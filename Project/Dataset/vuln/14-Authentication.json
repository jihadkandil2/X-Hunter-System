[
  {
    "Lab scenario": "Username enumeration via different responses",
    "Lab Description": "This lab is vulnerable to username enumeration and password brute-force attacks. It has an account with a predictable username and password, which can be found in the following wordlists:\nTo solve the lab, enumerate a valid username, brute-force this user's password, then access their account page.",
    "Vulnerability name": "Authentication"
  },
  {
    "Lab scenario": "2FA simple bypass",
    "Lab Description": "This lab's two-factor authentication can be bypassed. You have already obtained a valid username and password, but do not have access to the user's 2FA verification code. To solve the lab, access Carlos's account page.",
    "Vulnerability name": "Authentication",
    "lab level": "Easy",
    "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123', is2FAEnabled: true }]; app.post('/login', (req, res) => { const { username, password, code } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); if (user.is2FAEnabled && !code) return res.status(200).send('2FA code required'); res.send(`Welcome, ${username}!`); }); const PORT = 4000; app.listen(PORT, () => console.log(`2FA Bypass Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Password reset broken logic",
    "Lab Description": "This lab's password reset functionality is vulnerable. To solve the lab, reset Carlos's password then log in and access his \"My account\" page.",
    "Vulnerability name": "Authentication",
    "lab level": "Medium",
    "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'oldpassword' }]; app.post('/reset-password', (req, res) => { const { username } = req.body; const user = users.find(u => u.username === username); if (user) { res.send('Password reset link sent to your email'); } else { res.status(400).send('User not found'); } }); app.post('/set-new-password', (req, res) => { const { username, newPassword } = req.body; const user = users.find(u => u.username === username); if (user) { user.password = newPassword; res.send('Password changed successfully'); } else { res.status(400).send('User not found'); } }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.send(`Welcome, ${username}!`); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { res.send('Account details for carlos'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Password Reset Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Username enumeration via subtly different responses",
    "Lab Description": "This lab is subtly vulnerable to username enumeration and password brute-force attacks. It has an account with a predictable username and password, which can be found in the following wordlists:\nTo solve the lab, enumerate a valid username, brute-force this user's password, then access their account page.",
    "Vulnerability name": "Authentication",
    "lab level": "Medium",
    "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username); if (!user) { res.status(401).send('Invalid username'); return; } if (user.password !== password) { res.status(401).send('Invalid password'); return; } res.send(`Welcome, ${username}!`); }); app.get('/my-account', (req, res) => { res.send('Account details for carlos'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Username Enumeration Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Username enumeration via response timing",
    "Lab Description": "This lab is vulnerable to username enumeration using its response times. To solve the lab, enumerate a valid username, brute-force this user's password, then access their account page.",
    "Vulnerability name": "Authentication",
    "lab level": "Medium",
    "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username); if (!user) { setTimeout(() => res.status(401).send('Invalid username'), 1000); return; } if (user.password !== password) { res.status(401).send('Invalid password'); return; } res.send(`Welcome, ${username}!`); }); app.get('/my-account', (req, res) => { res.send('Account details for carlos'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Username Enumeration via Timing Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Broken brute-force protection, IP block",
    "Lab Description": "This lab is vulnerable due to a logic flaw in its password brute-force protection. To solve the lab, brute-force the victim's password, then log in and access their account page.",
    "Vulnerability name": "Authentication"
  },
  {
    "Lab scenario": "Username enumeration via account lock",
    "Lab Description": "This lab is vulnerable to username enumeration. It uses account locking, but this contains a logic flaw. To solve the lab, enumerate a valid username, brute-force this user's password, then access their account page.",
    "Vulnerability name": "Authentication",
    "lab level": "Medium",
    "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); let users = [{ username: 'carlos', password: 'securepassword', attempts: 0, locked: false }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username); if (!user) { return res.status(401).json({ error: 'Invalid credentials' }); } if (user.locked) { return res.status(403).json({ error: 'Account locked' }); } if (user.password === password) { user.attempts = 0; res.json({ message: 'Login successful' }); } else { user.attempts++; if (user.attempts >= 3) { user.locked = true; } res.status(401).json({ error: 'Invalid credentials' }); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Username Enumeration Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "2FA broken logic",
    "Lab Description": "This lab's two-factor authentication is vulnerable due to its flawed logic. To solve the lab, access Carlos's account page.\nYou also have access to the email server to receive your 2FA verification code.",
    "Vulnerability name": "Authentication",
    "lab level": "Medium",
    "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); let users = [{ username: 'carlos', password: 'securepassword', verified: false }]; let verificationCodes = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) { return res.status(401).json({ error: 'Invalid credentials' }); } verificationCodes[username] = '123456'; res.json({ message: '2FA code sent' }); }); app.post('/verify-2fa', (req, res) => { const { username, code } = req.body; if (verificationCodes[username] === code || !code) { users.find(u => u.username === username).verified = true; res.json({ message: '2FA verification bypassed' }); } else { res.status(403).json({ error: 'Invalid 2FA code' }); } }); const PORT = 4000; app.listen(PORT, () => console.log(`2FA Broken Logic Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Brute-forcing a stay-logged-in cookie",
    "Lab Description": "This lab allows users to stay logged in even after they close their browser session. The cookie used to provide this functionality is vulnerable to brute-forcing.\nTo solve the lab, brute-force Carlos's cookie to gain access to his My account page.",
    "Vulnerability name": "Authentication",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\nconst users = {\n  'carlos': { password: 'secure123', session: 'abcd1234' },\n  'admin': { password: 'admin123', session: 'xyz9876' }\n};\n\napp.get('/login', (req, res) => {\n  const { username, password } = req.query;\n  if (users[username] && users[username].password === password) {\n    res.cookie('session', users[username].session);\n    res.send('Logged in');\n  } else {\n    res.send('Invalid credentials');\n  }\n});\n\napp.get('/account', (req, res) => {\n  const session = req.cookies.session;\n  const user = Object.keys(users).find(u => users[u].session === session);\n  if (user) {\n    res.send(`Welcome ${user}`);\n  } else {\n    res.send('Access denied');\n  }\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
  },
  {
    "Lab scenario": "Offline password cracking",
    "Lab Description": "This lab stores the user's password hash in a cookie. The lab also contains an XSS vulnerability in the comment functionality. To solve the lab, obtain Carlos's stay-logged-in cookie and use it to crack his password. Then, log in as carlos and delete his account from the \"My account\" page.",
    "Vulnerability name": "Authentication",
    "lab level": "Hard",
    "src code": "const express=require('express'),sqlite3=require('sqlite3').verbose(),bodyParser=require('body-parser'),crypto=require('crypto'),app=express();app.use(bodyParser.json());app.use(bodyParser.urlencoded({extended:true}));const db=new sqlite3.Database(':memory:');db.serialize(()=>{db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password_hash TEXT)\");db.run(\"INSERT INTO users (username, password_hash) VALUES ('carlos', '5f4dcc3b5aa765d61d8327deb882cf99')\");});app.get('/comments',(req,res)=>{const comment=req.query.comment;res.send(`<p>${comment}</p>`);});app.get('/cookie',(req,res)=>{res.cookie('session','carlos_cookie_hash');res.send(\"Cookie set for Carlos.\");});app.post('/login',(req,res)=>{const{username,password}=req.body;if(!username||!password){return res.status(400).send(\"Username and password are required.\");}const hashedPassword=crypto.createHash('md5').update(password).digest('hex');const query=`SELECT * FROM users WHERE username='${username}' AND password_hash='${hashedPassword}'`;db.all(query,[],(err,rows)=>{if(err){res.status(500).send(\"Error occurred during login.\");}else if(rows.length>0){res.send(\"Login successful!\");}else{res.send(\"Invalid credentials.\");}});});const PORT=3000;app.listen(PORT,()=>console.log(`Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Password reset poisoning via middleware",
    "Lab Description": "This lab is vulnerable to password reset poisoning. The user carlos will carelessly click on any links in emails that he receives. To solve the lab, log in to Carlos's account. You can log in to your own account using the following credentials: wiener:peter. Any emails sent to this account can be read via the email client on the exploit server.",
    "Vulnerability name": "Authentication",
    "lab level": "medium",
    "src code": "const express=require('express'),bodyParser=require('body-parser'),app=express();app.use(bodyParser.json());const users={\"carlos\":{email:\"carlos@example.com\",password:\"securepassword\"},\"wiener\":{email:\"wiener@example.com\",password:\"peter\"}};app.post('/reset-password',(req,res)=>{const{email}=req.body;if(!email||!users[email.split('@')[0]]){return res.status(400).send(\"User not found.\");}const resetLink=`${req.headers.host}/reset?user=${email.split('@')[0]}`;console.log(\"Password reset link:\",resetLink);res.send(`Password reset link sent to ${email}: <a href=\"http://${resetLink}\">${resetLink}</a>`);});app.listen(3000,()=>console.log(\"Lab running on http://localhost:3000\"));"
  },
  {
    "Lab scenario": "Password brute-force via password change",
    "Lab Description": "This lab's password change functionality makes it vulnerable to brute-force attacks. To solve the lab, use the list of candidate passwords to brute-force Carlos's account and access his \"My account\" page.",
    "Vulnerability name": "Authentication",
    "lab level": "hard",
    "src code": "const express=require('express'),bodyParser=require('body-parser'),app=express();app.use(bodyParser.json());const users={\"carlos\":{password:\"securepassword\"},\"wiener\":{password:\"peter\"}};app.post('/change-password',(req,res)=>{const{username,oldPassword,newPassword}=req.body;if(!users[username]||users[username].password!==oldPassword){return res.status(401).send(\"Invalid credentials.\");}users[username].password=newPassword;console.log(`Password changed for ${username}`);res.send(\"Password changed successfully.\");});app.listen(3000,()=>console.log(\"Lab running on http://localhost:3000\"));"
  },
  {
    "Lab scenario": "Broken brute-force protection, multiple credentials per request",
    "Lab Description": "This lab is vulnerable due to a logic flaw in its brute-force protection. To solve the lab, brute-force Carlos's password, then access his account page.",
    "Vulnerability name": "Authentication",
    "lab level": "medium",
    "src code": "const express=require('express'),bodyParser=require('body-parser'),app=express();app.use(bodyParser.json());const users={'carlos':{password:'securepassword'},'wiener':{password:'peter'}};app.post('/login',(req,res)=>{const{credentials}=req.body;let success=false;credentials.forEach(({username,password})=>{if(users[username]&&users[username].password===password)success=true;});if(success)return res.send('Login successful!');else return res.status(401).send('Invalid credentials.');});app.listen(3000,()=>console.log('Lab running on http://localhost:3000'));"
  },
  {
    "Lab scenario": "2FA bypass using a brute-force attack",
    "Lab Description": "This lab's two-factor authentication is vulnerable to brute-forcing. You have already obtained a valid username and password, but do not have access to the user's 2FA verification code. To solve the lab, brute-force the 2FA code and access Carlos's account page.\nVictim's credentials: carlos:montoya",
    "Vulnerability name": "Authentication",
    "lab level": "hard",
    "src code": "const express=require('express'),bodyParser=require('body-parser'),app=express();app.use(bodyParser.json());const users={'carlos':{password:'montoya',otp:'0000'}};let attempts={};app.post('/login',(req,res)=>{const{username,password}=req.body;if(users[username]&&users[username].password===password)return res.json({message:'Enter 2FA code',user:username});else return res.status(401).send('Invalid credentials.');});app.post('/verify-2fa',(req,res)=>{const{username,otp}=req.body;if(!attempts[username])attempts[username]=0;attempts[username]++;if(users[username]&&users[username].otp===otp)return res.send('Login successful!');else return res.status(401).send('Invalid 2FA code.');});app.listen(3000,()=>console.log('Lab running on http://localhost:3000'));"
  }

  ,
  {"labs" : "Chat Gpt generated"},
  {"Lab scenario": "Weak password reset token",
    "Lab Description": "This lab's password reset functionality generates weak, predictable reset tokens. An attacker can enumerate tokens to reset another user's password and gain unauthorized access. To solve the lab, exploit the weak token mechanism to reset Carlos's password and access his account page.",
    "Vulnerability name": "Authentication",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst users = [{ username: 'carlos', email: 'carlos@example.com', password: 'securepassword' }];\nconst resetTokens = {}; // Store reset tokens temporarily\n\n// Request password reset\napp.post('/reset-password', (req, res) => {\n    const { email } = req.body;\n    const user = users.find(u => u.email === email);\n    if (!user) return res.status(400).send('User not found');\n    \n    // Weak token generation (predictable)\n    const token = Buffer.from(email).toString('hex').slice(0, 8); \n    resetTokens[token] = user.username;\n    res.send(`Password reset token: ${token}`);\n});\n\n// Reset password\napp.post('/change-password', (req, res) => {\n    const { token, newPassword } = req.body;\n    if (!resetTokens[token]) return res.status(400).send('Invalid token');\n    \n    const username = resetTokens[token];\n    const user = users.find(u => u.username === username);\n    user.password = newPassword;\n    delete resetTokens[token]; // Remove used token\n    res.send('Password reset successful');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Weak Password Reset Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Session fixation vulnerability via unrotated session tokens",
    "Lab Description": "This lab demonstrates a session fixation vulnerability. The application does not renew the session identifier upon successful login, leaving the session token predictable and fixed. An attacker can set a predetermined session ID and trick a victim into logging in with that token. To solve the lab, exploit this vulnerability by forcing the victim to use a known session token and then hijack their session to access their account.",
    "Vulnerability name": "Authentication",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Configure session without regenerating session ID on login\napp.use(session({\n    secret: 'supersecretkey',\n    resave: false,\n    saveUninitialized: true\n}));\n\n// Sample user database\nconst users = [{ username: 'carlos', password: 'password123' }];\n\n// Home/Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" required />\n            <input type=\"password\" name=\"password\" required />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\n// Login route\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        // Note: The session ID is NOT regenerated after login, leaving the token fixed\n        req.session.user = user.username;\n        res.send(`Welcome, ${user.username}. Your session id is ${req.sessionID}.`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Brute-force attack on an insecure login mechanism",
    "Lab Description": "This lab demonstrates a brute-force attack due to the absence of rate limiting. The application allows unlimited login attempts without restrictions, making it vulnerable to credential stuffing attacks. To solve the lab, use brute-force techniques to discover the credentials of Carlos and access his account.",
    "Vulnerability name": "Authentication",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Sample user database\nconst users = [{ username: 'carlos', password: 'securepassword' }];\n\n// Login route (no brute-force protection)\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        res.send(`Welcome, ${user.username}!`);\n    } else {\n        res.status(401).send('Invalid credentials');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Brute-Force Login Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Predictable 'Remember Me' token allows session hijacking",
    "Lab Description": "This lab demonstrates an authentication vulnerability in the 'Remember Me' functionality. The application generates a remember-me token using a weak, predictable algorithmâ€”specifically, an MD5 hash of the username. This allows an attacker to forge a valid token and hijack a victim's session. To solve the lab, generate a forged remember-me token for a victim (e.g., carlos), use it to access the victim's account page, and retrieve the flag.",
    "Vulnerability name": "Authentication",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Simple user database with insecure 'Remember Me' functionality\nconst users = [{ username: 'carlos', password: 'securepassword' }];\nconst tokens = {};\n\n// Login route - generates a predictable token if 'rememberMe' is enabled\napp.post('/login', (req, res) => {\n    const { username, password, rememberMe } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (!user) return res.status(401).send('Invalid credentials');\n    if (rememberMe) {\n        // Insecure token generation: MD5 of the username\n        const token = crypto.createHash('md5').update(username).digest('hex');\n        tokens[token] = username;\n        res.send(`Login successful. Your remember-me token is ${token}`);\n    } else {\n        res.send(`Login successful for ${username}`);\n    }\n});\n\n// Protected account route that checks for a remember-me token via query parameter\napp.get('/account', (req, res) => {\n    const token = req.query.token;\n    if (token && tokens[token]) {\n        res.send(`Welcome to your account, ${tokens[token]}! Flag: FLAG{remember_me_hijack_successful}`);\n    } else {\n        res.status(403).send('Access denied. Invalid or missing token.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Remember Me Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Default credentials bypass in login form",
    "Lab Description": "This lab demonstrates an authentication vulnerability caused by misconfigured default credentials. The login form fails to properly validate the username; if the username field is left empty, the application automatically assigns 'admin' as the username. To solve the lab, simply submit an empty username along with any password to gain access to the admin account page.",
    "Vulnerability name": "Authentication",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Home/Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method='POST' action='/login'>\n            <input type='text' name='username' placeholder='Username' />\n            <input type='password' name='password' placeholder='Password' />\n            <button type='submit'>Login</button>\n        </form>\n    `);\n});\n\n// Login route with default admin bypass\napp.post('/login', (req, res) => {\n    let { username, password } = req.body;\n    // If username is empty or only whitespace, default to 'admin'\n    if (!username || username.trim() === '') {\n        username = 'admin';\n    }\n    // For demonstration purposes, any password is accepted\n    res.send(`Welcome, ${username}!`);\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Default Credentials Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Login bypass due to missing password validation",
    "Lab Description": "This lab demonstrates an authentication vulnerability where the login form fails to enforce a proper password check. As a result, if a user submits a valid username with an empty password, the system logs them in. To solve the lab, log in as the target user by providing the correct username and leaving the password field empty.",
    "Vulnerability name": "Authentication",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Hard-coded user database\nconst users = [{ username: 'admin', password: 'supersecret' }];\n\n// Home/Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n            <input type=\"password\" name=\"password\" placeholder=\"Password\" />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\n// Login route with vulnerability: if password is empty, bypass check\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username);\n    // Vulnerability: if password is empty, allow login\n    if (user && (password === user.password || password === '')) {\n        res.send(`Welcome, ${username}!`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`No Password Check Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Login bypass via hidden parameter injection",
    "Lab Description": "This lab demonstrates an authentication vulnerability caused by a hidden parameter that bypasses password checks. The login form includes a hidden field named 'bypass' which, if set to '1', causes the server to skip the password validation and log in the user. To solve the lab, manipulate the login request to set the 'bypass' parameter to '1' and log in as the admin user.",
    "Vulnerability name": "Authentication",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Hard-coded user database\nconst users = [{ username: 'admin', password: 'admin123' }];\n\n// Home/Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n            <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n            <input type=\"hidden\" name=\"bypass\" value=\"0\" />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\n// Login route with vulnerability: if 'bypass' equals '1', skip password check\napp.post('/login', (req, res) => {\n    const { username, password, bypass } = req.body;\n    if (bypass === '1') {\n        res.send(`Welcome, ${username}! (Bypassed)`);\n        return;\n    }\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        res.send(`Welcome, ${username}!`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Hidden Parameter Bypass Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Login bypass via type coercion vulnerability",
    "Lab Description": "This lab demonstrates an authentication bypass due to improper type coercion in the login function. The server stores the password as a number and uses non-strict equality (==) for comparison, so a string like '0' is considered equal to 0. To solve the lab, exploit this vulnerability by logging in as the admin user using '0' as the password, and access the protected resource.",
    "Vulnerability name": "Authentication",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Sample user with password stored as a number\nconst users = [\n  { username: 'admin', password: 0 }  // The password is stored as 0\n];\n\napp.get('/', (req, res) => {\n    res.send(`\n      <h2>Login</h2>\n      <form method=\"POST\" action=\"/login\">\n          <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n          <input type=\"text\" name=\"password\" placeholder=\"Password\" required />\n          <button type=\"submit\">Login</button>\n      </form>\n    `);\n});\n\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username);\n    // Vulnerability: using non-strict equality (==) so '0' == 0 evaluates to true\n    if (user && password == user.password) {\n        res.send(`Welcome, ${username}! You have bypassed authentication using type coercion.`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Type Coercion Bypass Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Login bypass via HTTP parameter pollution",
    "Lab Description": "This lab demonstrates an authentication bypass caused by HTTP parameter pollution. The application processes multiple instances of the same parameter inconsistently. If an attacker submits multiple 'password' parameters in the login request, the server incorrectly validates the login. To solve the lab, send a login request with two password parameters and access the admin account.",
    "Vulnerability name": "Authentication",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Sample user database\nconst users = [{ username: 'admin', password: 'adminpass' }];\n\n// Home/Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n            <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\n// Vulnerable login route\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username);\n    \n    // Vulnerability: If multiple password parameters are provided, the server may not validate correctly\n    if (user && (Array.isArray(password) || password === user.password)) {\n        res.send(`Welcome, ${username}! (Authenticated via HTTP Parameter Pollution)`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`HTTP Parameter Pollution Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Bypassing multi-factor authentication using a race condition",
    "Lab Description": "This lab demonstrates an authentication bypass caused by a race condition in the multi-factor authentication (MFA) process. The application allows users to log in with a username and password and then requests a one-time code (OTP). However, due to an implementation flaw, the system does not properly validate session states when OTP requests are sent in parallel. An attacker can exploit this race condition to bypass MFA by submitting concurrent requests, allowing them to gain unauthorized access without providing the correct OTP. To solve the lab, exploit this issue to log in as the admin user without a valid OTP.",
    "Vulnerability name": "Authentication",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\n\napp.use(session({\n    secret: 'supersecretkey',\n    resave: false,\n    saveUninitialized: true\n}));\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst users = [{ username: 'admin', password: 'password123', otp: null }];\n\n// Step 1: Login with username & password\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        req.session.user = username;\n        user.otp = crypto.randomInt(100000, 999999).toString(); // Generate OTP\n        res.send('OTP required. Submit to /verify with the correct code.');\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\n// Step 2: Verify OTP (Vulnerable to race condition)\napp.post('/verify', (req, res) => {\n    const user = users.find(u => u.username === req.session.user);\n    if (!user) return res.status(401).send('Unauthorized');\n    \n    const { otp } = req.body;\n    if (otp === user.otp) {\n        req.session.authenticated = true;\n        res.send('Login successful!');\n    } else {\n        res.status(401).send('Invalid OTP');\n    }\n});\n\n// Step 3: Access the account (should be protected by MFA)\napp.get('/account', (req, res) => {\n    if (req.session.authenticated) {\n        res.send(`Welcome to your account, ${req.session.user}!`);\n    } else {\n        res.status(403).send('Access denied.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`MFA Race Condition Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Timing attack on naive password comparison",
    "Lab Description": "This lab demonstrates a timing attack vulnerability in the login functionality. The application compares the submitted password to the stored password using a naive, character-by-character comparison that introduces a fixed delay for each matching character. An attacker can exploit this predictable delay to infer the correct password one character at a time. To solve the lab, perform a timing attack to recover the target user's password and gain access to the account.",
    "Vulnerability name": "Authentication",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Simulated user database with one user\nconst users = [\n    { username: 'victim', password: 's3cr3t' }\n];\n\n// Naive slow compare function that introduces a fixed delay for each matching character\nfunction slowCompare(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    let result = true;\n    for (let i = 0; i < a.length; i++) {\n        // Introduce a 50ms delay for each character comparison\n        const start = Date.now();\n        while (Date.now() - start < 50) {}\n        if (a[i] !== b[i]) {\n            result = false;\n        }\n    }\n    return result;\n}\n\n// Home/Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required /><br>\n            <input type=\"text\" name=\"password\" placeholder=\"Password\" required /><br>\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\n// Login route that uses the slowCompare function\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username);\n    if (!user) return res.status(401).send('Invalid credentials');\n    if (slowCompare(user.password, password)) {\n        res.send(`Welcome, ${username}!`);\n    } else {\n        res.status(401).send('Invalid credentials');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Timing Attack Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Password reset token reuse vulnerability",
    "Lab Description": "This lab demonstrates an authentication vulnerability in the password reset process. The application generates a password reset token and sends it to the user's email, but fails to invalidate the token after a successful password reset. This allows an attacker to reuse an old token to reset the password of another user and gain unauthorized access. To solve the lab, reuse the previously generated token to change the target user's password and log in with the new credentials.",
    "Vulnerability name": "Authentication",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Sample user database\nlet users = [\n  { username: 'carlos', password: 'oldpassword', email: 'carlos@example.com' }\n];\n\n// Insecure storage for password reset tokens (tokens are not invalidated after use)\nlet resetTokens = {};\n\n// Endpoint to request a password reset\napp.post('/request-reset', (req, res) => {\n  const { email } = req.body;\n  const user = users.find(u => u.email === email);\n  if (!user) return res.status(400).send('User not found');\n  \n  // Generate an insecure and predictable token for demonstration purposes\n  const token = crypto.createHash('sha256').update(email).digest('hex').slice(0, 8);\n  resetTokens[token] = user.username;  // Token is stored but never invalidated\n  res.send(`Password reset token: ${token}`);\n});\n\n// Endpoint to reset the password\napp.post('/reset-password', (req, res) => {\n  const { token, newPassword } = req.body;\n  const username = resetTokens[token];\n  if (!username) return res.status(400).send('Invalid or expired token');\n  \n  const user = users.find(u => u.username === username);\n  if (!user) return res.status(400).send('User not found');\n\n  // Update the user's password\n  user.password = newPassword;\n  // Note: The token is not deleted after use, enabling token reuse\n  res.send('Password has been reset successfully');\n});\n\n// Login endpoint\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    res.send(`Welcome, ${username}!`);\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Insecure Password Reset Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Authentication Bypass via Weak Password Reset Validation",
    "Lab Description": "This lab's authentication system has a flawed password reset mechanism. The application does not properly validate ownership of the password reset token, allowing attackers to hijack the reset process for other users. To solve the lab, exploit this vulnerability to reset Carlos's password and log into his account. Steps: 1. Request a password reset token for your own account. 2. Intercept the token submission request and replace your email with Carlos's email address while keeping the valid token. 3. Set a new password for Carlos's account. 4. Authenticate as Carlos using the new password.",
    "Vulnerability name": "Authentication",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst users = [\n  { email: 'carlos@example.com', password: 'defaultPass' },\n  { email: 'attacker@example.com', password: 'hackMe' }\n];\n\nconst validTokens = new Map();\n\napp.post('/forgot-password', (req, res) => {\n  const { email } = req.body;\n  const user = users.find(u => u.email === email);\n  if (!user) return res.status(404).send('User not found');\n  \n  const token = Math.random().toString(36).slice(2, 10);\n  validTokens.set(email, token);\n  res.send(`Password reset token sent to ${email}: ${token}`);\n});\n\n// VULNERABLE ENDPOINT: Token is validated without checking email-token binding\napp.post('/reset-password', (req, res) => {\n  const { email, token, newPassword } = req.body;\n  \n  // Flaw: Only checks if token exists, not which user it belongs to\n  if (![...validTokens.values()].includes(token)) {\n    return res.status(401).send('Invalid token');\n  }\n  \n  const user = users.find(u => u.email === email);\n  if (!user) return res.status(404).send('User not found');\n  \n  user.password = newPassword;\n  validTokens.delete(email);\n  res.send('Password successfully reset');\n});\n\napp.post('/login', (req, res) => {\n  const { email, password } = req.body;\n  const user = users.find(u => u.email === email && u.password === password);\n  if (!user) return res.status(401).send('Invalid credentials');\n  res.send(`Logged in as ${email}`);\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Auth Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Credential Stuffing Attack",
  "Lab Description": "This lab is vulnerable to credential stuffing attacks. The login system does not properly rate-limit failed login attempts, allowing an attacker to repeatedly try different username and password combinations. To solve the lab, successfully log in to the admin account using a brute-force attack.",
  "Vulnerability name": "Authentication",
  "lab level": "Medium",
  "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'admin', password: 'admin123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); res.send('Welcome, ' + username + '!'); }); const PORT = 4000; app.listen(PORT, () => console.log('Credential Stuffing Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Exploit a weak password reset mechanism to access Carlos's account.",
  "Lab Description": "The application has a password reset feature that generates a reset token identical to the username provided in the request. This allows an attacker to reset any user's password by simply using their username as the token. To solve the lab, request a password reset for the user 'attacker' to observe the token, then use 'carlos' as the token to reset Carlos's password, and log in to his account with the new password.",
  "Vulnerability name": "Insecure Password Reset",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst session = require('express-session');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(session({ secret: 'weak_secret', resave: false, saveUninitialized: true }));\nlet users = { 'attacker': { password: 'attacker_pass' }, 'carlos': { password: 'carlos_pass' } };\napp.get('/login', (req, res) => res.send('<form method=\"post\"><input name=\"username\"><input name=\"password\" type=\"password\"><button type=\"submit\">Login</button></form>'));\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username].password === password) {\n    req.session.username = username;\n    res.send('Login successful');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/reset', (req, res) => res.send('<form method=\"post\"><input name=\"username\"><button type=\"submit\">Request reset</button></form>'));\napp.post('/reset', (req, res) => {\n  const { username } = req.body;\n  if (users[username]) {\n    const token = username;\n    res.send(`A reset link has been sent: <a href=\"/reset-password?token=${token}\">Reset password</a>`);\n  } else {\n    res.status(404).send('User not found');\n  }\n});\napp.get('/reset-password', (req, res) => {\n  const { token } = req.query;\n  if (!token) return res.status(400).send('Token required');\n  res.send(`<form method=\"post\"><input name=\"token\" type=\"hidden\" value=\"${token}\"><input name=\"new_password\" type=\"password\"><button type=\"submit\">Reset password</button></form>`);\n});\napp.post('/reset-password', (req, res) => {\n  const { token, new_password } = req.body;\n  if (users[token]) {\n    users[token].password = new_password;\n    res.send(`Password for ${token} has been reset.`);\n  } else {\n    res.status(400).send('Invalid token');\n  }\n});\napp.get('/account', (req, res) => {\n  if (req.session.username) {\n    res.send(`Welcome, ${req.session.username}!`);\n  } else {\n    res.status(401).send('Please log in');\n  }\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Insecure Password Reset Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Session Fixation Attack to Compromise Administrative Access",
  "Lab Description": "This lab contains an authentication vulnerability where the application does not regenerate session IDs after login, allowing session fixation. An attacker can force a user to authenticate with a known session ID and hijack their session. To solve the lab: 1. Obtain a valid session ID before authentication. 2. Trick Carlos (admin) into logging in with your pre-set session ID (simulated via CSRF/forced browsing). 3. Use the session ID to access the admin dashboard and delete all user data. The lab is solved when you execute the /admin/wipe endpoint as Carlos.",
  "Vulnerability name": "Authentication",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(bodyParser.json());\napp.use(cookieParser());\n\nconst sessions = new Map();\nconst users = [\n  { username: 'carlos', password: 's3cr3tAdm1n!', role: 'admin' },\n  { username: 'attacker', password: 'p@ssw0rd', role: 'user' }\n];\n\n// Generate initial session for demonstration\nconst initialSession = Math.random().toString(36).slice(2, 18);\nsessions.set(initialSession, { authenticated: false });\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  \n  if (!user) return res.status(401).send('Invalid credentials');\n  \n  // VULNERABILITY: Uses existing session ID if provided via cookie\n  const sessionId = req.cookies.sessionId || Math.random().toString(36).slice(2, 18);\n  \n  sessions.set(sessionId, {\n    authenticated: true,\n    username: user.username,\n    role: user.role\n  });\n  \n  res.cookie('sessionId', sessionId, { httpOnly: true });\n  res.send('Logged in successfully');\n});\n\napp.get('/admin/wipe', (req, res) => {\n  const sessionId = req.cookies.sessionId;\n  const session = sessions.get(sessionId);\n  \n  if (!session?.authenticated || session.role !== 'admin') {\n    return res.status(403).send('Admin access required');\n  }\n  \n  // Lab solution trigger\n  res.send('All data wiped by ' + session.username);\n});\n\napp.get('/profile', (req, res) => {\n  const sessionId = req.cookies.sessionId;\n  const session = sessions.get(sessionId);\n  \n  if (!session?.authenticated) {\n    return res.status(401).send('Not authenticated');\n  }\n  \n  res.send(`Welcome ${session.username} (${session.role})`);\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Hard Auth Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Exploit a lack of session timeout to access Alice's account after she logs out.",
  "Lab Description": "The application does not invalidate session IDs after a user logs out or after a period of inactivity, allowing an attacker to reuse an old session ID to access a user's account. To solve the lab, capture Alice's session ID after she logs in, wait for her to log out, then use the same session ID to access her account page.",
  "Vulnerability name": "Insecure Session Expiration",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst session = require('express-session');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(session({ secret: 'simple_secret', resave: false, saveUninitialized: true }));\nconst users = { 'alice': 'alice_pass', 'attacker': 'attacker_pass' };\napp.get('/login', (req, res) => res.send('<form method=\"post\"><input name=\"username\"><input name=\"password\" type=\"password\"><button type=\"submit\">Login</button></form>'));\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    req.session.username = username;\n    res.send('Logged in! <a href=\"/account\">Account</a> <a href=\"/logout\">Logout</a>');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/logout', (req, res) => {\n  req.session.username = null;\n  res.send('Logged out');\n});\napp.get('/account', (req, res) => {\n  if (req.session.username) {\n    res.send(`Welcome, ${req.session.username}!`);\n  } else {\n    res.status(401).send('Please log in');\n  }\n});\nconst PORT = 5000;\napp.listen(PORT, () => console.log(`Insecure Session Expiration Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Bypass Multi-Factor Authentication via Brute-Forceable TOTP",
  "Lab Description": "This lab implements weak Time-Based One-Time Password (TOTP) validation for multi-factor authentication. While the attacker has obtained Carlos's password, the MFA protection can be bypassed due to missing rate-limiting and code reuse prevention. To solve the lab: 1. Authenticate with Carlos's credentials (username: 'carlos', password: 'admin123'). 2. Brute-force the 6-digit TOTP code within 2 minutes of code validity. 3. Access the administrative panel at /admin to delete all records.",
  "Vulnerability name": "Authentication",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst speakeasy = require('speakeasy');\nconst app = express();\napp.use(bodyParser.json());\n\nconst users = [{\n  username: 'carlos',\n  password: 'admin123',\n  mfaSecret: speakeasy.generateSecret({ length: 20 }).base32,\n  isAdmin: true\n}];\n\nconst activeSessions = new Map();\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  \n  if (!user) return res.status(401).send('Invalid credentials');\n  \n  // Return MFA requirement but expose vulnerability trigger\n  res.status(202).json({\n    message: 'MFA required',\n    remainingAttempts: 'unlimited' // Critical flaw: No attempt counter\n  });\n});\n\napp.post('/verify', (req, res) => {\n  const { username, code } = req.body;\n  const user = users.find(u => u.username === username);\n  \n  // VULNERABILITY: No rate-limiting + accepts old codes within 120s window\n  const verified = speakeasy.totp.verify({\n    secret: user.mfaSecret,\n    encoding: 'base32',\n    token: code,\n    window: 4 // Allows codes from 2 minutes before/after\n  });\n\n  if (!verified) return res.status(401).send('Invalid MFA code');\n\n  // Critical flaw: Doesn't invalidate used codes\n  const sessionToken = Buffer.from(username + Date.now()).toString('base64');\n  activeSessions.set(sessionToken, user);\n  res.json({ token: sessionToken });\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  const session = activeSessions.get(token);\n  \n  if (!session?.isAdmin) return res.status(403).send('Admin access required');\n  res.send('Admin panel: <button onclick=\"fetch('/admin/wipe')\">WIPE DATA</button>');\n});\n\napp.post('/admin/wipe', (req, res) => {\n  // Lab solution validation\n  res.send('All critical data deleted - Lab solved');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`MFA Bypass Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Parameter Tampering Privilege Escalation",
  "Lab Description": "This lab is vulnerable to privilege escalation through parameter tampering. The application uses a 'role' parameter passed in the login request to determine user permissions. The backend blindly trusts this parameter, allowing an attacker to escalate their privileges to admin. To solve the lab, exploit the 'role' parameter in the login request.",
  "Vulnerability name": "Authentication",
  "lab level": "Medium",
  "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'user', password: 'password' }]; app.post('/login', (req, res) => { const { username, password, role } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); // Vulnerability: No validation or sanitization of the 'role' parameter if (role === 'admin') { res.send('Welcome, Admin! You can perform sensitive actions here.'); } else { res.send('Welcome, ' + username + '!'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Parameter Tampering Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Log into the system by exploiting unchanged default credentials.",
  "Lab Description": "The application is a simple web server with a login page. It was deployed with default credentials that were never changed: username 'admin' and password 'admin'. Your task is to log into the system using these default credentials. Once logged in, you will see a 'Welcome, admin!' message, indicating success.",
  "Vulnerability name": "Insecure Default Credentials",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Default credentials\nconst users = { 'admin': 'admin' };\n\n// Serve the login page\napp.get('/login', (req, res) => {\n  res.send(\"<form method='post'><input name='username' placeholder='Username'><input name='password' type='password' placeholder='Password'><button type='submit'>Login</button></form>\");\n});\n\n// Handle login attempts\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'admin' && password === 'admin') {\n    res.send('Welcome, admin!');\n  } else {\n    res.status(401).send('Login failed');\n  }\n});\n\nconst PORT = 7000;\napp.listen(PORT, () => console.log(`Insecure Default Credentials Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "JWT Algorithm Confusion to Gain Administrative Privileges",
  "Lab Description": "This lab uses JSON Web Tokens (JWT) for authentication but fails to validate the signing algorithm properly. The server exposes its public key, enabling attackers to exploit algorithm confusion. To solve the lab: 1. Obtain the server's public key from the exposed JWKS endpoint. 2. Forge an admin JWT by switching the algorithm from RS256 to HS256. 3. Access the /admin/export endpoint to download sensitive data. You start with valid low-privilege credentials (user: attacker, password: p@ssw0rd).",
  "Vulnerability name": "Authentication",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst jwt = require('jsonwebtoken');\nconst jwksClient = require('jwks-rsa');\nconst app = express();\napp.use(bodyParser.json());\n\n// Server's key pair\nconst privateKey = `-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC+8Zbn3NROZ/9L\n...[truncated]...\n3ZtC4x7SJ0miwIDAQAB\n-----END PRIVATE KEY-----`;\nconst publicKey = `-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvvGW59zUTmf/S0b4tAxs\n...[truncated]...\nNG0LjHtInSaLAgMBAAE=\n-----END PUBLIC KEY-----`;\n\nconst users = [\n  { username: 'attacker', password: 'p@ssw0rd', role: 'user' },\n  { username: 'carlos', password: 's3cr3t!', role: 'admin' }\n];\n\n// Vulnerable JWKS endpoint\ntapp.get('/.well-known/jwks.json', (req, res) => {\n  res.json({\n    keys: [{\n      kty: 'RSA',\n      kid: '1',\n      use: 'sig',\n      n: 'vrGW59zUTmf_S0b4tAxs...',\n      e: 'AQAB'\n    }]\n  });\n});\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (!user) return res.status(401).send('Invalid credentials');\n\n  // Generate JWT with vulnerable configuration\n  const token = jwt.sign(\n    { user: username, role: user.role },\n    privateKey,\n    { algorithm: 'RS256', expiresIn: '1h' }\n  );\n  res.json({ token });\n});\n\n// Vulnerable JWT verification middleware\nconst verifyToken = (req, res, next) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return res.status(401).send('Unauthorized');\n\n  // Critical flaw: No algorithm enforcement\n  jwt.verify(token, (header, callback) => {\n    jwksClient.getSigningKey(header.kid, (err, key) => {\n      callback(err, key?.publicKey || publicKey);\n    });\n  }, { algorithms: ['RS256', 'HS256'] }, (err, decoded) => {\n    if (err) return res.status(401).send('Invalid token');\n    req.user = decoded;\n    next();\n  });\n};\n\napp.get('/admin/export', verifyToken, (req, res) => {\n  if (req.user.role !== 'admin') return res.status(403).send('Admin required');\n  res.send('SECRET DATA: Credit card records of all users');\n});\n\napp.get('/profile', verifyToken, (req, res) => {\n  res.send(`Logged in as ${req.user.user} (${req.user.role})`);\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Predictable Authentication Tokens",
  "Lab Description": "This lab uses predictable authentication tokens in URLs. The tokens follow a simple pattern (e.g., 'user1-token', 'user2-token'), allowing an attacker to guess other users' tokens. To solve the lab, access another user's profile by modifying the token in the URL.",
  "Vulnerability name": "Authentication",
  "lab level": "Medium",
  "src code": "const express = require('express'); const app = express(); const users = { 'user1': { token: 'user1-token', data: 'User 1 data' }, 'user2': { token: 'user2-token', data: 'User 2 data' } }; app.get('/profile', (req, res) => { const token = req.query.token; const user = Object.keys(users).find(u => users[u].token === token); if (!user) return res.status(401).send('Unauthorized'); res.send('Welcome, ' + user + '! Data: ' + users[user].data); }); const PORT = 4000; app.listen(PORT, () => console.log('Predictable Token Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Exploit an insecure 'Remember Me' feature to access the admin account.",
  "Lab Description": "The application has a 'Remember Me' feature that stores the username in a cookie. When this cookie is present, the application automatically logs in the user as that username without further verification. To solve the lab, set the 'remember_user' cookie to 'admin' and visit the login page to be automatically logged in as admin, then access the account page to confirm.",
  "Vulnerability name": "Insecure Remember Me Functionality",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst session = require('express-session');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(cookieParser());\napp.use(session({ secret: 'simple_secret', resave: false, saveUninitialized: true }));\nconst users = { 'user': 'pass', 'admin': 'adminpass' };\napp.get('/login', (req, res) => {\n  if (req.cookies.remember_user && users[req.cookies.remember_user]) {\n    req.session.user = req.cookies.remember_user;\n    res.redirect('/account');\n  } else {\n    res.send('<form method=\"post\"><input name=\"username\"><input name=\"password\" type=\"password\"><input type=\"checkbox\" name=\"rememberMe\"> Remember Me<button type=\"submit\">Login</button></form>');\n  }\n});\napp.post('/login', (req, res) => {\n  const { username, password, rememberMe } = req.body;\n  if (users[username] && users[username] === password) {\n    req.session.user = username;\n    if (rememberMe) {\n      res.cookie('remember_user', username, { maxAge: 30 * 24 * 60 * 60 * 1000 });\n    }\n    res.redirect('/account');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/account', (req, res) => {\n  if (req.session.user) {\n    res.send(`Welcome, ${req.session.user}!`);\n  } else {\n    res.status(401).send('Please log in');\n  }\n});\napp.get('/logout', (req, res) => {\n  req.session.destroy();\n  res.clearCookie('remember_user');\n  res.send('Logged out');\n});\nconst PORT = 8000;\napp.listen(PORT, () => console.log(`Insecure Remember Me Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "OAuth Token Hijacking via Open Redirect and Missing State Parameter Validation",
  "Lab Description": "This lab contains a vulnerable OAuth 2.0 implementation where attackers can steal authorization codes through an open redirect vulnerability and gain full account access. The system fails to validate the 'state' parameter and allows arbitrary redirect URIs. To solve the lab: 1. Exploit the open redirect in /redirect endpoint to capture Carlos's authorization code. 2. Exchange the stolen code for an access token. 3. Use the token to access Carlos's private notes at /notes and delete the critical document. You start with a phishing page at http://attacker.com/callback.",
  "Vulnerability name": "Authentication",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\napp.use(bodyParser.json());\n\n// OAuth server configuration\nconst clients = [{\n  client_id: 'vulnerable-app',\n  client_secret: 's3cr3t',\n  redirect_uris: ['http://localhost:4000/callback']\n}];\n\nconst users = [{\n  id: 'carlos',\n  password: 'Winter2023!',\n  notes: ['SECRET: Nuclear launch codes = 000000']\n}];\n\nlet authCodes = new Map();\nlet accessTokens = new Map();\n\n// Vulnerable open redirect endpoint\napp.get('/redirect', (req, res) => {\n  const { url } = req.query;\n  res.redirect(decodeURIComponent(url)); // No validation of redirect targets\n});\n\n// OAuth authorization endpoint\napp.get('/authorize', (req, res) => {\n  const { client_id, redirect_uri, state } = req.query;\n  const client = clients.find(c => c.client_id === client_id);\n  \n  // Critical flaw: No redirect_uri validation\n  if (!client) return res.status(400).send('Invalid client');\n  \n  const code = crypto.randomBytes(16).toString('hex');\n  authCodes.set(code, { user: 'carlos', client_id });\n  \n  // Vulnerability: State parameter not validated/echoed\n  res.redirect(`${redirect_uri}?code=${code}`);\n});\n\n// OAuth token endpoint\napp.post('/token', (req, res) => {\n  const { client_id, client_secret, code } = req.body;\n  const client = clients.find(c => c.client_id === client_id);\n  \n  if (!client || client.client_secret !== client_secret) {\n    return res.status(401).send('Invalid client credentials');\n  }\n  \n  if (!authCodes.has(code)) return res.status(400).send('Invalid code');\n  \n  const token = crypto.randomBytes(24).toString('hex');\n  accessTokens.set(token, authCodes.get(code));\n  authCodes.delete(code);\n  \n  res.json({ access_token: token, token_type: 'Bearer' });\n});\n\n// Protected resource\napp.get('/notes', (req, res) => {\n  const authHeader = req.headers.authorization;\n  const token = authHeader?.split(' ')[1];\n  const session = accessTokens.get(token);\n  \n  if (!session) return res.status(401).send('Invalid token');\n  \n  const user = users.find(u => u.id === session.user);\n  res.json(user.notes);\n});\n\napp.delete('/notes', (req, res) => {\n  // Lab solution validation endpoint\n  res.send('Critical documents deleted - Lab solved');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`OAuth Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Horizontal Privilege Escalation via User ID Manipulation",
  "Lab Description": "This lab allows users to access other users' profiles by manipulating the user ID parameter in the URL. The application does not validate whether the authenticated user is authorized to access the requested profile. To solve the lab, access another user's profile by modifying the user ID in the profile URL.",
  "Vulnerability name": "Authentication",
  "lab level": "Medium",
  "src code": "const express = require('express'); const app = express(); const users = { 1: { id: 1, name: 'Alice', email: 'alice@example.com' }, 2: { id: 2, name: 'Bob', email: 'bob@example.com' } }; app.get('/profile/:userId', (req, res) => { const userId = parseInt(req.params.userId); const user = users[userId]; if (!user) return res.status(404).send('User not found'); res.json(user); }); const PORT = 4000; app.listen(PORT, () => console.log('Horizontal Privilege Escalation Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Exploit a weak password policy to guess a user's password.",
  "Lab Description": "The application enforces a weak password policy that allows very short and simple passwords (e.g., minimum 3 characters, no complexity requirements). Your task is to guess the password for the user 'user1' and log into their account. Hint: The password is a common three-letter word.",
  "Vulnerability name": "Weak Password Policy",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Simulated database with user credentials\nconst users = { 'user1': 'cat', 'admin': 'dog' };\n\n// Serve the login page\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\" placeholder=\"Username\"><input name=\"password\" type=\"password\" placeholder=\"Password\"><button type=\"submit\">Login</button></form>');\n});\n\n// Handle login attempts\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.send(`Welcome, ${username}!`);\n  } else {\n    res.status(401).send('Login failed');\n  }\n});\n\nconst PORT = 8000;\napp.listen(PORT, () => console.log(`Weak Password Policy Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "SAML Authentication Bypass via XML Comment Injection and Signature Wrapping",
  "Lab Description": "This lab implements a vulnerable SAML-based SSO system that improperly validates XML signatures and allows comment injection in assertions. Attackers can manipulate SAML responses to impersonate administrators. To solve the lab: 1. Capture a valid SAML response during login. 2. Inject XML comments to alter the NameID and attributes while preserving the valid signature. 3. Bypass signature validation to access the /internal/dashboard as an administrator and execute the system shutdown command.",
  "Vulnerability name": "Authentication",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst xmldom = require('xmldom');\nconst xpath = require('xpath');\nconst crypto = require('crypto');\nconst app = express();\napp.use(bodyParser.text({ type: '*/xml' }));\n\nconst trustedCertificate = `-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvZxTR6...\n-----END PUBLIC KEY-----`;\n\n// Simulated IdP metadata\nconst idpMetadata = {\n  issuer: 'https://saml-idp.example.com',\n  signingCert: trustedCertificate\n};\n\n// Vulnerable SAML validation\nconst validateSamlResponse = (samlResponse) => {\n  const doc = new xmldom.DOMParser().parseFromString(samlResponse);\n  \n  // Extract signature\n  const signature = xpath.select(\"//*[local-name()='Signature']\", doc)[0];\n  if (!signature) return false;\n  \n  // Verify signature cryptographically\n  const verifier = crypto.createVerify('RSA-SHA256');\n  const signedInfo = xpath.select(\".//*[local-name()='SignedInfo']\", signature)[0].toString();\n  verifier.update(signedInfo);\n  \n  const signatureValue = xpath.select(\".//*[local-name()='SignatureValue']\", signature)[0].textContent;\n  const validSig = verifier.verify(idpMetadata.signingCert, signatureValue, 'base64');\n  \n  // Critical flaw: Doesn't re-validate parsed data after signature check\n  return validSig;\n};\n\napp.post('/saml/acs', async (req, res) => {\n  try {\n    if (!validateSamlResponse(req.body)) return res.status(403).send('Invalid SAML response');\n    \n    // Vulnerable XML parsing with comment preservation\n    const parser = new xml2js.Parser({ preserveChildren: true, explicitChildren: true });\n    const result = await parser.parseStringPromise(req.body);\n    \n    // Extract NameID with comment injection vulnerability\n    const assertion = result['samlp:Response']['saml:Assertion'][0];\n    const nameId = assertion['saml:Subject'][0]['saml:NameID'][0];\n    \n    // Process attributes without proper validation\n    const attributes = assertion['saml:AttributeStatement'][0]['saml:Attribute'];\n    const roles = attributes.find(a => a.$.Name === 'roles')['saml:AttributeValue'];\n    \n    // Grant access based on manipulated values\n    if (roles.includes('admin')) {\n      res.send('Admin dashboard: <button onclick=\"fetch('/internal/shutdown')\">SHUTDOWN</button>');\n    } else {\n      res.status(403).send('Insufficient privileges');\n    }\n  } catch (error) {\n    res.status(500).send('SAML processing error');\n  }\n});\n\napp.post('/internal/shutdown', (req, res) => {\n  res.send('Critical systems halted - Lab solved');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`SAML Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Predictable Password Reset Tokens",
  "Lab Description": "This lab's password reset functionality uses predictable tokens that follow a simple pattern (e.g., 'user1-reset', 'user2-reset'). Attackers can guess other users' reset tokens to reset their passwords. To solve the lab, reset the password for the 'admin' account by guessing its reset token.",
  "Vulnerability name": "Authentication",
  "lab level": "Medium",
  "src code": "const express = require('express'); const app = express(); const users = { 'user1': { password: 'password1', resetToken: 'user1-reset' }, 'admin': { password: 'admin123', resetToken: 'admin-reset' } }; app.get('/reset-password/:token', (req, res) => { const token = req.params.token; const user = Object.keys(users).find(u => users[u].resetToken === token); if (!user) return res.status(404).send('Invalid reset token'); users[user].password = 'newPassword'; res.send('Password reset successful for ' + user); }); const PORT = 4000; app.listen(PORT, () => console.log('Predictable Reset Token Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Exploit hardcoded credentials to log in as an admin user.",
  "Lab Description": "The application contains hardcoded credentials embedded in its source code. Your task is to examine the code, identify the admin username and password, and use them to log in. Once successful, you'll see a welcome message confirming your access as an admin.",
  "Vulnerability name": "Hardcoded Credentials",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Hardcoded admin credentials\nconst ADMIN_USERNAME = 'admin';\nconst ADMIN_PASSWORD = 'secret123';\n\n// Serve the login page\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\" placeholder=\"Username\"><input name=\"password\" type=\"password\" placeholder=\"Password\"><button type=\"submit\">Login</button></form>');\n});\n\n// Handle login attempts\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === ADMIN_USERNAME && password === ADMIN_PASSWORD) {\n    res.send(`Welcome, ${username}! You have admin access.`);\n  } else {\n    res.status(401).send('Login failed: Incorrect username or password');\n  }\n});\n\nconst PORT = 9000;\napp.listen(PORT, () => console.log(`Hardcoded Credentials Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Predictable Session Tokens",
  "Lab Description": "This lab uses predictable session tokens derived from usernames. When a user logs in, the session token is set to 'user-<username>'. An attacker can guess other users' session tokens by knowing their usernames. To solve the lab, access another user's profile by modifying the session token in the cookie.",
  "Vulnerability name": "Authentication",
  "lab level": "Medium",
  "src code": "const express = require('express'); const app = express(); const users = [{ username: 'alice', password: 'password123' }, { username: 'bob', password: 'password456' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); // Set predictable session token res.cookie('session', 'user-' + user.username); res.send('Welcome, ' + username); }); app.get('/profile', (req, res) => { const session = req.cookies.session; if (!session) return res.status(401).send('Unauthorized'); const parts = session.split('-'); if (parts.length !== 2 || parts[0] !== 'user') return res.status(401).send('Invalid session'); const username = parts[1]; const user = users.find(u => u.username === username); if (!user) return res.status(401).send('Unauthorized'); res.send('Profile for ' + username); }); const PORT = 4000; app.listen(PORT, () => console.log('Predictable Session Tokens Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Exploit an insecure authentication mechanism by manipulating a cookie to bypass the login process.",
  "Lab Description": "The application uses a cookie named 'authenticated' to determine if a user is logged in. If the cookie is set to 'true', the application grants access to the protected area without checking the user's credentials. To solve the lab, use your browser's developer tools to set the 'authenticated' cookie to 'true' and then visit the '/account' page to gain access without logging in.",
  "Vulnerability name": "Authentication Bypass via Cookie Manipulation",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(cookieParser());\nconst users = { 'user': 'pass' };\napp.get('/login', (req, res) => {\n  res.send(\"<form method='post'><input name='username'><input name='password' type='password'><button type='submit'>Login</button></form>\");\n});\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.cookie('authenticated', 'true');\n    res.redirect('/account');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/account', (req, res) => {\n  if (req.cookies.authenticated === 'true') {\n    res.send('Welcome to your account!');\n  } else {\n    res.status(401).send('Please log in');\n  }\n});\nconst PORT = 10000;\napp.listen(PORT, () => console.log(`Authentication Bypass Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Bypass Session Termination via Stale Password Hash Validation",
  "Lab Description": "This lab's authentication system fails to invalidate existing sessions after password changes, allowing attackers to maintain persistent access using old credentials. To solve the lab: 1. Authenticate with Carlos's credentials (user: carlos, password: Summer2024). 2. Change Carlos's password while preserving your active session. 3. Use the original session cookie to access the /admin/export endpoint and download sensitive financial records. The system only validates sessions against initial password hashes, not current credentials.",
  "Vulnerability name": "Authentication",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\napp.use(bodyParser.json());\n\nconst users = [{\n  username: 'carlos',\n  passwordHash: crypto.createHash('sha256').update('Summer2024').digest('hex'),\n  isAdmin: true\n}];\n\nconst sessions = new Map();\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username);\n  \n  if (!user || user.passwordHash !== crypto.createHash('sha256').update(password).digest('hex')) {\n    return res.status(401).send('Invalid credentials');\n  }\n\n  const sessionId = crypto.randomBytes(16).toString('hex');\n  sessions.set(sessionId, {\n    username: user.username,\n    passwordHash: user.passwordHash // Storing password hash at time of login\n  });\n\n  res.cookie('session', sessionId, { httpOnly: true });\n  res.send('Logged in successfully');\n});\n\napp.post('/change-password', (req, res) => {\n  const sessionId = req.cookies.session;\n  const { newPassword } = req.body;\n  \n  if (!sessions.has(sessionId)) return res.status(401).send('Unauthorized');\n  \n  const user = users.find(u => u.username === sessions.get(sessionId).username);\n  user.passwordHash = crypto.createHash('sha256').update(newPassword).digest('hex');\n  \n  // Critical flaw: Doesn't update existing sessions' passwordHash\n  res.send('Password changed successfully');\n});\n\napp.get('/admin/export', (req, res) => {\n  const sessionId = req.cookies.session;\n  const session = sessions.get(sessionId);\n  \n  if (!session) return res.status(401).send('Unauthorized');\n  \n  const user = users.find(u => u.username === session.username);\n  \n  // Vulnerability: Only checks initial password hash, not current\n  if (session.passwordHash === user.passwordHash && user.isAdmin) {\n    res.send('ADMIN DATA: All financial records downloaded');\n  } else {\n    res.status(403).send('Admin access required');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Session Lab running on http://localhost:${PORT}`));"
},
{
  "lab_scenario": "Authentication bypass due to unsanitized login input",
  "lab_description": "This lab demonstrates a vulnerability where user input in the login form is concatenated directly into the SQL query, allowing injection that bypasses password verification.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Low",
  "src_code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'pass1')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = SELECT * FROM users WHERE username = '${username}' AND password = '${password}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (rows.length > 0) res.send('Login successful');\n    else res.send('Login failed');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Plaintext password storage vulnerability",
  "lab_description": "This lab shows an authentication system that stores passwords in plaintext, making it trivial for attackers to retrieve credentials if the database is compromised.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Low",
  "src_code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'admin123')\");\n});\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const query = SELECT * FROM users WHERE username = '${username}' AND password = '${password}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (rows.length > 0) res.send('Login successful');\n    else res.send('Login failed');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Missing password verification in login process",
  "lab_description": "This lab simulates a login endpoint where the system only checks for the existence of a username and ignores the password, allowing attackers to log in with any password.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Low",
  "src_code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'pass1')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  // Vulnerable: password is not verified\n  const query = SELECT * FROM users WHERE username = '${username}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (rows.length > 0) res.send('Login successful');\n    else res.send('Login failed');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Hardcoded credentials in source code",
  "lab_description": "This lab simulates an authentication system that uses hardcoded credentials embedded in the source code. An attacker can easily read these values to gain access.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Low",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\n// Hardcoded credentials\nconst ADMIN_USER = 'admin';\nconst ADMIN_PASS = 'admin123';\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === ADMIN_USER && password === ADMIN_PASS) {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Weak session token generation with predictable algorithm",
  "lab_description": "This lab demonstrates a vulnerability where session tokens are generated using a predictable algorithm, allowing attackers to guess valid tokens and hijack sessions.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Hard",
  "src_code": "const express = require('express');\nconst crypto = require('crypto');\nconst session = require('express-session');\n\nconst app = express();\napp.use(express.json());\n\napp.use(session({\n  secret: 'predictableSecret',\n  resave: false,\n  saveUninitialized: true\n}));\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username && password) {\n    // Predictable token using username and current time\n    const token = crypto.createHash('md5').update(username + Date.now().toString()).digest('hex');\n    req.session.token = token;\n    res.json({ token: token });\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.get('/profile', (req, res) => {\n  if (req.session.token) res.send(Profile accessed with token ${req.session.token});\n  else res.send('Not authenticated');\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Insecure JWT handling with weak secret",
  "lab_description": "This lab simulates a system that uses JSON Web Tokens for authentication but employs a weak secret and does not enforce proper verification, making it easy for attackers to forge tokens.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Hard",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst jwt = require('jsonwebtoken');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst SECRET = 'weaksecret';\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username && password) {\n    const token = jwt.sign({ username: username }, SECRET);\n    res.json({ token: token });\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.get('/protected', (req, res) => {\n  const token = req.headers.authorization;\n  try {\n    const payload = jwt.verify(token, SECRET);\n    res.send(Access granted for ${payload.username});\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Session fixation vulnerability in login process",
  "lab_description": "This lab demonstrates a vulnerability where the session ID is not regenerated upon login, allowing attackers to fix a session ID and hijack the session later.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Medium",
  "src_code": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\napp.use(session({ secret: 'secret', resave: false, saveUninitialized: true }));\n\napp.post('/login', (req, res) => {\n  req.session.user = req.body.username;\n  // Vulnerable: session ID remains unchanged after login\n  res.send('Login successful');\n});\n\napp.get('/profile', (req, res) => {\n  if (req.session.user) res.send(Welcome, ${req.session.user});\n  else res.send('Please log in');\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Bypass of admin override due to missing access checks",
  "lab_description": "This lab simulates an admin override function that lacks proper access control. Attackers can exploit this flaw to perform administrative actions without proper authorization.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Hard",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/adminOverride', (req, res) => {\n  const token = req.body.overrideToken;\n  // Vulnerable: token check is weak\n  if (token === 'override123') {\n    res.send('Admin override successful');\n  } else {\n    res.send('Access denied');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Authentication vulnerability due to predictable session IDs",
  "lab_description": "This lab shows a system that generates session IDs in a predictable manner, enabling attackers to guess and hijack sessions.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Hard",
  "src_code": "const express = require('express');\nconst session = require('express-session');\n\nconst app = express();\napp.use(express.json());\n\napp.use(session({\n  secret: 'predictableSecret',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: false }\n}));\n\napp.post('/login', (req, res) => {\n  req.session.user = req.body.username;\n  res.send('Login successful');\n});\n\napp.get('/dashboard', (req, res) => {\n  if (req.session.user) res.send(Welcome, ${req.session.user});\n  else res.send('Not authenticated');\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Token exchange vulnerability with improper validation",
  "lab_description": "This lab simulates a token exchange endpoint that fails to properly validate tokens, allowing attackers to exchange arbitrary tokens for access tokens.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Medium",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/tokenExchange', (req, res) => {\n  const token = req.body.token;\n  if (token === 'validToken') {\n    res.json({ newToken: 'newToken123' });\n  } else {\n    res.json({ newToken: token });\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Default credentials vulnerability in system configuration",
  "lab_description": "This lab simulates an authentication system using default credentials that have not been changed from the initial configuration, making it trivial to log in.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Low",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst DEFAULT_USER = 'defaultUser';\nconst DEFAULT_PASS = 'defaultPass';\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === DEFAULT_USER && password === DEFAULT_PASS) {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Misconfigured OAuth callback vulnerability",
  "lab_description": "This lab simulates an OAuth authentication flow where the callback URL is taken directly from user input without validation, allowing attackers to redirect users to malicious sites.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Hard",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/oauth/callback', (req, res) => {\n  const { token, callbackUrl } = req.body;\n  if (token === 'validToken') {\n    res.redirect(callbackUrl);\n  } else {\n    res.send('Invalid token');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Weak two-factor authentication implementation",
  "lab_description": "This lab simulates a two-factor authentication system where the one-time password (OTP) is not properly verified. Attackers can bypass the 2FA step by supplying any value.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Hard",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/2fa', (req, res) => {\n  const { username, password, otp } = req.body;\n  // Vulnerable: OTP is not verified properly\n  if (username === 'user1' && password === 'pass1') {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Insecure password reset without token validation",
  "lab_description": "This lab simulates a password reset feature where the reset token passed in the URL is not validated, allowing attackers to reset any user's password.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Hard",
  "src_code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, email TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (email, password) VALUES ('user@example.com', 'oldpass')\");\n});\n\napp.post('/resetPassword', (req, res) => {\n  const token = req.query.token;\n  const newPass = req.body.newPassword;\n  const query = UPDATE users SET password = '${newPass}' WHERE email = '${token}';\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Password reset successful');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Hardcoded API keys for authentication",
  "lab_description": "This lab demonstrates an authentication mechanism that uses hardcoded API keys, exposing them in the source code. Attackers can extract these keys and bypass authentication.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Low",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst API_KEY = 'hardcoded123';\n\napp.post('/apiAccess', (req, res) => {\n  const key = req.body.apiKey;\n  if (key === API_KEY) {\n    res.send('Access granted');\n  } else {\n    res.send('Access denied');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Insecure cookie settings in session management",
  "lab_description": "This lab simulates a session management vulnerability where session cookies are set without secure or HttpOnly flags, making them vulnerable to theft via XSS.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Medium",
  "src_code": "const express = require('express');\nconst session = require('express-session');\n\nconst app = express();\napp.use(express.json());\n\napp.use(session({\n  secret: 'insecureSecret',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: false, httpOnly: false }\n}));\n\napp.post('/login', (req, res) => {\n  if (req.body.username && req.body.password) {\n    req.session.user = req.body.username;\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.get('/profile', (req, res) => {\n  if (req.session.user) res.send(Welcome, ${req.session.user});\n  else res.send('Not logged in');\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Weak password strength enforcement in registration",
  "lab_description": "This lab simulates a registration process that fails to enforce strong password requirements, allowing users to set easily guessable passwords.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Low",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/register', (req, res) => {\n  const { username, password } = req.body;\n  // Vulnerable: No password complexity check\n  if (username && password) {\n    res.send('Registration successful');\n  } else {\n    res.send('Registration failed');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Open redirect in login flow enabling bypass",
  "lab_description": "This lab simulates a login flow where a redirect URL parameter is not validated. Attackers can manipulate this parameter to redirect users to a malicious site after authentication.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Medium",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/login', (req, res) => {\n  const { username, password, redirectUrl } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    res.redirect(redirectUrl);\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Unencrypted login over HTTP",
  "lab_description": "This lab simulates an authentication system that transmits credentials over plain HTTP, exposing them to network sniffing and interception by attackers.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Medium",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username && password) {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\n// Note: This server runs over HTTP\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "CSRF vulnerability in authentication",
  "lab_description": "This lab simulates a cross-site request forgery vulnerability in the login process where an attacker can force a login action from another site without the user's consent.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Hard",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Vulnerable: No CSRF protection\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Insecure password change without current password verification",
  "lab_description": "This lab simulates a password change functionality that does not require the user to input their current password. An attacker who hijacks the session can change the password without knowing the old one.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Hard",
  "src_code": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\napp.use(session({ secret: 'secret', resave: false, saveUninitialized: true }));\n\napp.post('/changePassword', (req, res) => {\n  if (req.session.user) {\n    res.send('Password changed successfully');\n  } else {\n    res.send('Not authenticated');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Insecure token refresh mechanism without validation",
  "lab_description": "This lab simulates a token refresh endpoint that accepts any refresh token and returns a new access token without proper validation, allowing attackers to bypass authentication.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Medium",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/refreshToken', (req, res) => {\n  const refreshToken = req.body.refreshToken;\n  if (refreshToken) {\n    res.json({ accessToken: 'newAccessToken123' });\n  } else {\n    res.status(400).send('Invalid refresh token');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Authentication bypass due to insufficient logging",
  "lab_description": "This lab simulates a scenario where the authentication process lacks sufficient logging, making it easier for attackers to perform brute-force attacks undetected.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Low",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Open redirect vulnerability in SSO callback",
  "lab_description": "This lab simulates an SSO authentication flow where the callback URL is directly taken from user input without validation, allowing attackers to redirect users to malicious sites.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Hard",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/sso/callback', (req, res) => {\n  const { token, redirectUrl } = req.body;\n  if (token === 'validToken') {\n    res.redirect(redirectUrl);\n  } else {\n    res.send('Invalid token');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Authentication vulnerability due to hardcoded default credentials",
  "lab_description": "This lab simulates a system that uses default credentials for authentication. These default credentials are well-known and allow attackers to gain access easily.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Low",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst DEFAULT_USER = 'defaultUser';\nconst DEFAULT_PASS = 'defaultPass';\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === DEFAULT_USER && password === DEFAULT_PASS) {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Authentication vulnerability in misconfigured token refresh",
  "lab_description": "This lab simulates a token refresh endpoint that fails to validate the refresh token properly, enabling attackers to obtain new access tokens using arbitrary tokens.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Medium",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/refresh', (req, res) => {\n  const token = req.body.refreshToken;\n  if (token) {\n    res.json({ accessToken: 'refreshedToken123' });\n  } else {\n    res.status(400).send('Invalid token');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Authentication bypass via insecure password change mechanism",
  "lab_description": "This lab simulates a password change feature that does not require verification of the current password, allowing attackers with an active session to change the password without knowing the old one.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Hard",
  "src_code": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\napp.use(session({ secret: 'secret', resave: false, saveUninitialized: true }));\n\napp.post('/changePassword', (req, res) => {\n  if (req.session.user) {\n    res.send('Password changed successfully');\n  } else {\n    res.send('Not authenticated');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Authentication vulnerability due to insecure cookie attributes",
  "lab_description": "This lab simulates a system that sets session cookies without secure attributes, making them vulnerable to theft via XSS. Attackers can steal these cookies and hijack sessions.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Medium",
  "src_code": "const express = require('express');\nconst session = require('express-session');\n\nconst app = express();\napp.use(express.json());\n\napp.use(session({\n  secret: 'insecureSecret',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: false, httpOnly: false }\n}));\n\napp.post('/login', (req, res) => {\n  req.session.user = req.body.username;\n  res.send('Login successful');\n});\n\napp.get('/dashboard', (req, res) => {\n  if (req.session.user) res.send(Welcome, ${req.session.user});\n  else res.send('Not authenticated');\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Authentication bypass via insecure token exchange",
  "lab_description": "This lab simulates a token exchange endpoint that returns a new token without proper validation of the provided token, allowing attackers to forge tokens.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Medium",
  "src_code": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/exchange', (req, res) => {\n  const providedToken = req.body.token;\n  if (providedToken === 'validToken') {\n    res.json({ token: 'newToken123' });\n  } else {\n    res.json({ token: providedToken });\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "lab_scenario": "Authentication vulnerability in session termination on logout",
  "lab_description": "This lab simulates a logout process where the session is not properly destroyed, allowing attackers to reuse the session ID after logout.",
  "vulnerability_name": "Authentication Vulnerability",
  "lab_level": "Hard",
  "src_code": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\napp.use(session({ secret: 'secret', resave: false, saveUninitialized: true }));\n\napp.post('/login', (req, res) => {\n  req.session.user = req.body.username;\n  res.send('Login successful');\n});\n\napp.post('/logout', (req, res) => {\n  // Vulnerable: session is not destroyed\n  res.send('Logged out');\n});\n\napp.get('/dashboard', (req, res) => {\n  if (req.session.user) res.send(Welcome, ${req.session.user});\n  else res.send('Please log in');\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
  "Lab scenario": "Weak Hash-Based Authentication Tokens",
  "Lab Description": "This lab uses weak hash-based authentication tokens generated with a static salt and MD5 hashing. The token format is MD5(username + 'secret123'). Attackers can compute valid tokens for other users if they know the salt. To solve the lab, compute the authentication token for the 'admin' user and access their profile.",
  "Vulnerability name": "Authentication",
  "lab level": "Medium",
  "src code": "const express = require('express'); const crypto = require('crypto'); const app = express(); const users = [{ username: 'user', password: 'password123' }, { username: 'admin', password: 'admin456' }]; const SALT = 'secret123'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = crypto.createHash('md5').update(user.username + SALT).digest('hex'); res.cookie('authToken', token); res.send('Welcome, ' + username); }); app.get('/profile', (req, res) => { const authToken = req.cookies.authToken; const user = users.find(u => crypto.createHash('md5').update(u.username + SALT).digest('hex') === authToken); if (!user) return res.status(401).send('Unauthorized'); res.send('Profile for ' + user.username); }); const PORT = 4000; app.listen(PORT, () => console.log('Weak Token Generation Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Bypass Session Termination via Stale Password Hash Validation",
  "Lab Description": "This lab's authentication system fails to invalidate existing sessions after password changes, allowing attackers to maintain persistent access using old credentials. To solve the lab: 1. Authenticate with Carlos's credentials (user: carlos, password: Summer2024). 2. Change Carlos's password while preserving your active session. 3. Use the original session cookie to access the /admin/export endpoint and download sensitive financial records. The system only validates sessions against initial password hashes, not current credentials.",
  "Vulnerability name": "Authentication",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\napp.use(bodyParser.json());\n\nconst users = [{\n  username: 'carlos',\n  passwordHash: crypto.createHash('sha256').update('Summer2024').digest('hex'),\n  isAdmin: true\n}];\n\nconst sessions = new Map();\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username);\n  \n  if (!user || user.passwordHash !== crypto.createHash('sha256').update(password).digest('hex')) {\n    return res.status(401).send('Invalid credentials');\n  }\n\n  const sessionId = crypto.randomBytes(16).toString('hex');\n  sessions.set(sessionId, {\n    username: user.username,\n    passwordHash: user.passwordHash // Storing password hash at time of login\n  });\n\n  res.cookie('session', sessionId, { httpOnly: true });\n  res.send('Logged in successfully');\n});\n\napp.post('/change-password', (req, res) => {\n  const sessionId = req.cookies.session;\n  const { newPassword } = req.body;\n  \n  if (!sessions.has(sessionId)) return res.status(401).send('Unauthorized');\n  \n  const user = users.find(u => u.username === sessions.get(sessionId).username);\n  user.passwordHash = crypto.createHash('sha256').update(newPassword).digest('hex');\n  \n  // Critical flaw: Doesn't update existing sessions' passwordHash\n  res.send('Password changed successfully');\n});\n\napp.get('/admin/export', (req, res) => {\n  const sessionId = req.cookies.session;\n  const session = sessions.get(sessionId);\n  \n  if (!session) return res.status(401).send('Unauthorized');\n  \n  const user = users.find(u => u.username === session.username);\n  \n  // Vulnerability: Only checks initial password hash, not current\n  if (session.passwordHash === user.passwordHash && user.isAdmin) {\n    res.send('ADMIN DATA: All financial records downloaded');\n  } else {\n    res.status(403).send('Admin access required');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Session Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Exploit a weak password reset mechanism to access the admin account.",
  "Lab Description": "The application features a password reset mechanism that generates a reset token identical to the username. This design flaw allows an attacker to reset any user's password simply by knowing their username and using it as the token. In this lab, there is an admin user with the username 'admin'. To solve the lab, follow these steps: 1. Request a password reset for the user 'attacker'. 2. Observe the reset link provided (e.g., '/reset?token=attacker'). 3. Modify the token in the URL to 'admin' (e.g., '/reset?token=admin'). 4. Reset the admin's password to a new value of your choice. 5. Log in as 'admin' using the new password to gain access. This lab demonstrates how predictable tokens can lead to unauthorized access, emphasizing the importance of secure token generation in authentication systems.",
  "Vulnerability name": "Insecure Password Reset Token",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nlet users = { 'attacker': 'attackerpass', 'admin': 'adminpass' };\n\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\" placeholder=\"Username\"><input name=\"password\" type=\"password\" placeholder=\"Password\"><button type=\"submit\">Login</button></form>');\n});\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.send(`Welcome, ${username}!`);\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/forgot', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\" placeholder=\"Username\"><button type=\"submit\">Request reset</button></form>');\n});\n\napp.post('/forgot', (req, res) => {\n  const { username } = req.body;\n  if (users[username]) {\n    const resetLink = `/reset?token=${username}`;\n    res.send(`Reset link: <a href=\"${resetLink}\">${resetLink}</a>`);\n  } else {\n    res.status(404).send('User not found');\n  }\n});\n\napp.get('/reset', (req, res) => {\n  const { token } = req.query;\n  if (!token || !users[token]) {\n    res.status(400).send('Invalid token');\n  } else {\n    res.send(`<form method=\"post\"><input name=\"token\" type=\"hidden\" value=\"${token}\"><input name=\"new_password\" type=\"password\" placeholder=\"New Password\"><button type=\"submit\">Reset password</button></form>`);\n  }\n});\n\napp.post('/reset', (req, res) => {\n  const { token, new_password } = req.body;\n  if (users[token]) {\n    users[token] = new_password;\n    res.send('Password reset successfully');\n  } else {\n    res.status(400).send('Invalid token');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Insecure Password Reset Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Bypass Certificate-Based Authentication via Forged Client-Side TLS Verification",
  "Lab Description": "This lab implements flawed certificate pinning where client certificate validation only checks the public key rather than full certificate chain. Attackers can forge certificates using extracted public keys to impersonate administrators. To solve the lab: 1. Obtain the server's pinned public key from /security.txt. 2. Generate a malicious certificate matching the public key. 3. Authenticate using the forged certificate to access the /audit/reports endpoint and delete all audit logs.",
  "Vulnerability name": "Authentication",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst fs = require('fs');\nconst spdy = require('spdy');\nconst app = express();\n\n// Server configuration\nconst pinnedPublicKey = fs.readFileSync('./pinned-key.pub', 'utf8');\nconst authorizedUsers = ['CN=admin'];\n\n// Vulnerable TLS middleware\napp.use((req, res, next) => {\n  const cert = req.socket.getPeerCertificate();\n  \n  if (!cert || !cert.raw) {\n    return res.status(401).send('Client certificate required');\n  }\n\n  // Critical flaw: Only compares public keys\n  const clientPublicKey = cert.publicKey.export({ type: 'spki', format: 'pem' });\n  if (clientPublicKey !== pinnedPublicKey) {\n    return res.status(403).send('Invalid certificate');\n  }\n\n  // Secondary flaw: Subject validation bypass\n  req.isAdmin = cert.subject.CN === 'admin';\n  next();\n});\n\napp.get('/audit/reports', (req, res) => {\n  if (!req.isAdmin) return res.status(403).send('Admin required');\n  res.send('AUDIT CONTROLS: <button onclick=\"fetch('/audit/purge')\">DELETE ALL</button>');\n});\n\napp.post('/audit/purge', (req, res) => {\n  res.send('All audit logs destroyed - Lab solved');\n});\n\n// Expose public key (simulate security misconfiguration)\napp.get('/security.txt', (req, res) => {\n  res.send(pinnedPublicKey);\n});\n\nspdy.createServer({\n  key: fs.readFileSync('./server.key'),\n  cert: fs.readFileSync('./server.crt'),\n  requestCert: true,\n  rejectUnauthorized: false // Critical: Accepts self-signed certs\n}, app).listen(4000, () => {\n  console.log(`Certificate Lab running on https://localhost:4000`);\n});"
},
{
  "Lab scenario": "Predictable Cookie-Based Session Hijacking",
  "Lab Description": "This lab uses a predictable cookie value derived from the username to authenticate users. The cookie format is 'user-<username>'. Attackers can impersonate other users by knowing their usernames and constructing the corresponding cookie value. To solve the lab, access another user's profile by manipulating the cookie value.",
  "Vulnerability name": "Authentication",
  "lab level": "Medium",
  "src code": "const express = require('express'); const app = express(); const users = [{ username: 'alice', password: 'password123' }, { username: 'bob', password: 'password456' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); // Set predictable cookie res.cookie('auth', 'user-' + user.username); res.send('Welcome, ' + username); }); app.get('/profile', (req, res) => { const authCookie = req.cookies.auth; if (!authCookie) return res.status(401).send('Unauthorized'); const parts = authCookie.split('-'); if (parts[0] !== 'user' || parts.length !== 2) return res.status(401).send('Invalid cookie'); const username = parts[1]; const user = users.find(u => u.username === username); if (!user) return res.status(401).send('Unauthorized'); res.send('Profile for ' + username); }); const PORT = 4000; app.listen(PORT, () => console.log('Predictable Cookie Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Exploit a web application with a weak password policy that allows users to set very short or predictable passwords, making them easy to guess.",
  "Lab Description": "The application has a login page where users can authenticate with a username and password. However, it enforces no minimum password length or complexity requirements. This allows an attacker to guess the password of a user by trying common or short passwords, such as '123' or 'password'. Your task is to: 1. Attempt to log in as the user 'admin' by guessing their password. 2. Use simple, common passwords (e.g., 'admin', '123', or 'pass') until you succeed. 3. Once logged in, access the protected '/dashboard' page to confirm the exploit. This lab demonstrates the importance of enforcing strong password policies (e.g., minimum length, mix of characters) to prevent attackers from easily guessing credentials. Hint: Try short or predictable passwords that someone might use if no rules are enforced.",
  "Vulnerability name": "Weak Password Policy",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst users = { 'admin': '123' }; // Weak password!\n\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\" placeholder=\"Username\"><br><input name=\"password\" type=\"password\" placeholder=\"Password\"><br><button type=\"submit\">Login</button></form>');\n});\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.send('Login successful! <a href=\"/dashboard\">Go to Dashboard</a>');\n  } else {\n    res.status(401).send('Invalid username or password');\n  }\n});\n\napp.get('/dashboard', (req, res) => {\n  res.send('Welcome to the Admin Dashboard!');\n});\n\nconst PORT = 5000;\napp.listen(PORT, () => console.log(`Weak Password Policy Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Bypass FIDO2 Authentication via Forged Attestation Statements",
  "Lab Description": "This lab's WebAuthn implementation fails to properly validate authenticator attestation data, allowing attackers to register malicious security keys as admin devices. To solve: 1. Intercept WebAuthn registration traffic. 2. Forge attestation statement using software emulated authenticator. 3. Bypass admin privilege checks by manipulating credential ID format. 4. Access /control-panel to disable security systems.",
  "Vulnerability name": "Authentication",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst { WebAuthn } = require('node-webauthn');\nconst app = express();\napp.use(bodyParser.json());\n\nconst webauthn = new WebAuthn({\n  rpName: 'Vulnerable Corp',\n  rpID: 'localhost',\n  origin: 'http://localhost:4000',\n  attestation: 'direct',\n  // Critical flaw: No attestation format validation\n  supportedAlgorithmIDs: [-7, -257]\n});\n\nconst users = [{\n  id: 'admin',\n  credentials: [],\n  role: 'user'\n}];\n\napp.post('/webauthn/register', async (req, res) => {\n  const options = webauthn.generateRegistrationOptions({\n    userID: 'attacker',\n    userName: 'attacker',\n    // Vulnerability: Accepts any authenticator type\n    authenticatorSelection: { userVerification: 'discouraged' }\n  });\n\n  req.session.challenge = options.challenge;\n  res.json(options);\n});\n\napp.post('/webauthn/register/complete', async (req, res) => {\n  const result = await webauthn.verifyRegistration({\n    credential: req.body,\n    expectedChallenge: req.session.challenge,\n    expectedOrigin: 'http://localhost:4000',\n    // Critical flaw: Disabled attestation verification\n    requireUserVerification: false\n  });\n\n  // Vulnerability: Privilege escalation via credential ID pattern\n  if (result.credentialID.toString('hex').startsWith('admin')) {\n    users[0].role = 'admin';\n  }\n\n  res.send('Registration successful');\n});\n\napp.get('/control-panel', (req, res) => {\n  if (users[0].role !== 'admin') return res.status(403).send('Access denied');\n  res.send('SECURITY CONTROLS: <button onclick=\"fetch('/shutdown')\">DISABLE ALL</button>');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`WebAuthn Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Steal OAuth Tokens through Promiscuous CORS Configuration",
  "Lab Description": "This lab's OAuth provider has insecure CORS settings allowing arbitrary origins to retrieve access tokens. Exploit: 1. Lure victim to malicious site loading cross-origin iframe. 2. Use XHR from attacker.com to /oauth/userinfo. 3. Exfiltrate tokens via DNS prefetch. 4. Access /api/admin to revoke all 2FA settings. The lab uses refresh_token grant with long-lived tokens.",
  "Vulnerability name": "Authentication",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst cors = require('cors');\nconst app = express();\n\napp.use(cors({\n  // Critical flaw: Reflects arbitrary origin with credentials\n  origin: (origin, callback) => callback(null, true),\n  credentials: true\n}));\n\nconst tokens = new Map();\ntokens.set('admin_token', { \n  user: 'admin',\n  scope: ['admin'],\n  expires: Date.now() + 31536000000 // 1 year expiration\n});\n\napp.get('/oauth/userinfo', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  const session = tokens.get(token);\n  \n  if (!session) return res.status(401).send('Invalid token');\n  res.json({\n    user: session.user,\n    scope: session.scope,\n    // Vulnerability: Returns sensitive metadata\n    security: { 2fa_enabled: false }\n  });\n});\n\napp.post('/api/admin/disable-2fa', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!tokens.get(token)?.scope.includes('admin')) {\n    return res.status(403).send('Admin required');\n  }\n  res.send('All 2FA disabled - Lab solved');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`CORS Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Exploit a weak password policy to guess a user's password.",
  "Lab Description": "The application enforces a weak password policy that allows very short and simple passwords (e.g., minimum 3 characters, no complexity requirements). Your task is to guess the password for the user 'user1' and log into their account. Hint: The password is a common three-letter word.",
  "Vulnerability name": "Weak Password Policy",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Simulated database with user credentials\nconst users = { 'user1': 'cat', 'admin': 'dog' };\n\n// Serve the login page\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\" placeholder=\"Username\"><input name=\"password\" type=\"password\" placeholder=\"Password\"><button type=\"submit\">Login</button></form>');\n});\n\n// Handle login attempts\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.send(`Welcome, ${username}!`);\n  } else {\n    res.status(401).send('Login failed');\n  }\n});\n\nconst PORT = 8000;\napp.listen(PORT, () => console.log(`Weak Password Policy Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Exploit hardcoded credentials to log in as an admin user.",
  "Lab Description": "The application contains hardcoded credentials embedded in its source code. Your task is to examine the code, identify the admin username and password, and use them to log in. Once successful, you'll see a welcome message confirming your access as an admin.",
  "Vulnerability name": "Hardcoded Credentials",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Hardcoded admin credentials\nconst ADMIN_USERNAME = 'admin';\nconst ADMIN_PASSWORD = 'secret123';\n\n// Serve the login page\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\" placeholder=\"Username\"><input name=\"password\" type=\"password\" placeholder=\"Password\"><button type=\"submit\">Login</button></form>');\n});\n\n// Handle login attempts\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === ADMIN_USERNAME && password === ADMIN_PASSWORD) {\n    res.send(`Welcome, ${username}! You have admin access.`);\n  } else {\n    res.status(401).send('Login failed: Incorrect username or password');\n  }\n});\n\nconst PORT = 9000;\napp.listen(PORT, () => console.log(`Hardcoded Credentials Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Unauthorized File Access via IDOR",
  "Lab Description": "This lab allows attackers to download sensitive files by manipulating the file ID parameter in the download endpoint. The application does not validate whether the user is authorized to access the requested file. To solve the lab, download a restricted file by guessing its ID.",
  "Vulnerability name": "Authentication",
  "lab level": "Medium",
  "src code": "const express = require('express'); const app = express(); const files = { 1: { id: 1, name: 'user1_file.txt', content: 'User 1 data' }, 2: { id: 2, name: 'admin_file.txt', content: 'Admin data' } }; app.get('/download/:fileId', (req, res) => { const fileId = parseInt(req.params.fileId); const file = files[fileId]; if (!file) return res.status(404).send('File not found'); res.send(file.content); }); const PORT = 4000; app.listen(PORT, () => console.log('IDOR File Download Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Session Reuse After Logout",
  "Lab Description": "This lab's logout functionality does not properly invalidate the session, allowing attackers to reuse the session cookie even after the user has logged out. To solve the lab, intercept the session cookie, force the user to log out, then use the same cookie to access their account.",
  "Vulnerability name": "Authentication",
  "lab level": "Medium",
  "src code": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); app.post('/login', (req, res) => { req.session.user = 'alice'; res.send('Logged in'); }); app.post('/logout', (req, res) => { // Vulnerability: Session not invalidated req.session.user = null; res.send('Logged out'); }); app.get('/profile', (req, res) => { if (req.session.user) res.send('Welcome, alice!'); else res.status(401).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log('Session Reuse Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Session ID Predictability via User Email",
  "Lab Description": "This lab generates session IDs using the user's email address (e.g., 'session-' + email). Attackers can impersonate users by knowing their email and constructing the corresponding session ID. To solve the lab, access another user's profile using their email-derived session ID.",
  "Vulnerability name": "Authentication",
  "lab level": "Medium",
  "src code": "const express = require('express'); const app = express(); const users = [{ email: 'user@example.com', password: 'password123' }, { email: 'admin@example.com', password: 'admin456' }]; app.post('/login', (req, res) => { const { email, password } = req.body; const user = users.find(u => u.email === email && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); res.cookie('session', 'session-' + user.email); res.send('Welcome!'); }); app.get('/profile', (req, res) => { const session = req.cookies.session; const user = users.find(u => 'session-' + u.email === session); if (!user) return res.status(401).send('Unauthorized'); res.send('Profile for ' + user.email); }); const PORT = 4000; app.listen(PORT, () => console.log('Predictable Session ID Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Unauthorized Email Update via API",
  "Lab Description": "This lab's API endpoint allows attackers to update any user's email by including the target user's ID in the request body. The backend does not validate authorization. To solve the lab, change another user's email using their ID.",
  "Vulnerability name": "Authentication",
  "lab level": "Medium",
  "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ id: 1, email: 'user@example.com' }, { id: 2, email: 'admin@example.com' }]; app.post('/update-email', (req, res) => { const { userId, newEmail } = req.body; const user = users.find(u => u.id === userId); if (!user) return res.status(404).send('User not found'); user.email = newEmail; res.send('Email updated to ' + newEmail); }); const PORT = 4000; app.listen(PORT, () => console.log('Missing Authorization Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Brute-Forceable Session IDs",
  "Lab Description": "This lab uses a weak random number generator (Math.random()) to create 4-digit session IDs. Attackers can brute-force all possible IDs (0000-9999) to hijack sessions. To solve the lab, iterate through session IDs to find an active one.",
  "Vulnerability name": "Authentication",
  "lab level": "Medium",
  "src code": "const express = require('express'); const app = express(); let sessionId = Math.floor(Math.random() * 9000) + 1000; // 4-digit ID app.get('/profile', (req, res) => { const userSession = req.query.session; if (userSession === sessionId.toString()) { res.send('Welcome! Active session: ' + sessionId); } else { res.status(401).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Weak Randomness Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Hijack SAML Flows via Assertion Consumer Service Manipulation",
  "Lab Description": "This lab's SAML IdP doesn't invalidate used assertions, allowing replay attacks. To solve: 1. Initiate SP-initiated SSO to capture SAMLRequest. 2. Modify `AssertionConsumerServiceURL` to attacker endpoint. 3. Replay assertion via original ACS URL. 4. Access /partner/data as federated admin.",
  "Vulnerability name": "Authentication",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst xmlCrypto = require('xml-crypto');\nconst xmldom = require('xmldom');\nconst xpath = require('xpath');\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/saml/acs', (req, res) => {\n  try {\n    const SAMLResponse = Buffer.from(req.body.SAMLResponse, 'base64').toString();\n    const doc = new xmldom.DOMParser().parseFromString(SAMLResponse);\n    \n    // Extract assertion with XPath\n    const select = xpath.useNamespaces({\n      saml: 'urn:oasis:names:tc:SAML:2.0:assertion',\n      ds: 'http://www.w3.org/2000/09/xmldsig#'\n    });\n    \n    const assertion = select('//saml:Assertion', doc)[0];\n    const signature = select('//ds:Signature', doc)[0];\n\n    // Verify signature\n    const verifier = new xmlCrypto.SignedXml({ signatureAlgorithm: 'rsa-sha256' });\n    verifier.loadSignature(signature.toString());\n    \n    if (!verifier.checkSignature(assertion.toString())) {\n      return res.status(403).send('Invalid signature');\n    }\n\n    // Vulnerability: No assertion replay prevention\n    res.redirect('/partner/data');\n  } catch (error) {\n    res.status(500).send('SAML processing error');\n  }\n});\n\napp.get('/partner/data', (req, res) => {\n  res.send('FEDERATED DATA: Cross-tenant customer records');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`SAML Replay Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Predict HMAC-Based One-Time Passwords via State Manipulation",
  "Lab Description": "This lab's 2FA system uses a flawed HMAC-SHA256 implementation where the nonce isn't properly randomized. Attackers can: 1. Capture two consecutive OTPs. 2. Reverse-engineer the HMAC key using length extension attacks. 3. Generate future OTPs to access /admin/backup. The nonce increments by 1 second but resets during password changes.",
  "Vulnerability name": "Authentication",
  "lab level": "Hard",
  "src code": "const crypto = require('crypto');\nconst express = require('express');\nconst app = express();\n\nlet hmacKey = crypto.randomBytes(32);\nlet nonce = Date.now();\n\napp.post('/2fa', (req, res) => {\n  const { code } = req.body;\n  const currentNonce = Math.floor(Date.now() / 1000);\n  \n  // Critical flaw: Reusable nonce window\n  const validCodes = [currentNonce - 1, currentNonce, currentNonce + 1]\n    .map(t => crypto.createHmac('sha256', hmacKey).update(t.toString()).digest('hex'));\n  \n  if (!validCodes.includes(code)) return res.status(401).send('Invalid code');\n  res.send('Admin dashboard unlocked');\n});\n\napp.post('/change-password', (req, res) => {\n  // Vulnerability: Resets nonce but preserves HMAC key\n  nonce = Date.now();\n  res.send('Password changed');\n});\n\napp.get('/admin/backup', (req, res) => {\n  res.send('SYSTEM BACKUP: Cryptographic keys archived');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`OTP Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Steal Identity Tokens via OpenID Connect Misconfiguration",
  "Lab Description": "This lab's OIDC implementation fetches JWKS keys from an attacker-controlled URL due to insecure `issuer` validation. Exploit: 1. Register a malicious OAuth client with `redirect_uri=http://attacker.com`. 2. Forge JWT with `iss` pointing to your server. 3. Capture the server's HTTP request to your JWKS endpoint containing privileged `kid` tokens. 4. Use leaked tokens to access /vault and decrypt secrets.",
  "Vulnerability name": "Authentication",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst axios = require('axios');\nconst app = express();\n\nconst clients = [{\n  client_id: 'legacy-app',\n  jwks_uri: 'https://metadata.google.com/.well-known/jwks.json' // Default trusted\n}];\n\napp.post('/oauth/token', async (req, res) => {\n  const { assertion } = req.body;\n  const decoded = jwt.decode(assertion, { complete: true });\n  \n  // Critical flaw: Blindly trusts JWT `iss` claim\n  const client = clients.find(c => c.client_id === decoded.payload.iss);\n  const jwks = (await axios.get(client.jwks_uri)).data;\n  \n  // Vulnerability: No host validation for JWKS_URI\n  const key = jwks.keys.find(k => k.kid === decoded.header.kid);\n  const verified = jwt.verify(assertion, pemKey(key), { algorithms: ['RS256'] });\n  \n  res.json({ access_token: 'leaked_system_token' });\n});\n\napp.get('/vault', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (token !== 'leaked_system_token') return res.status(403);\n  res.send('VAULT UNLOCKED: Root certificates extracted');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`OIDC Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Predictable Reset Tokens Using Timestamps",
  "Lab Description": "This lab generates password reset tokens using the current timestamp plus a fixed offset (e.g., 'token-' + (Date.now() + 10000)). Attackers can predict tokens by knowing when they were generated. To solve the lab, compute the reset token for the 'admin' account using the approximate timestamp.",
  "Vulnerability name": "Authentication",
  "lab level": "Medium",
  "src code": "const express = require('express'); const app = express(); const users = { 'admin': { password: 'admin123', resetToken: null } }; app.post('/request-reset', (req, res) => { const { username } = req.body; const user = users[username]; if (!user) return res.status(404).send('User not found'); const timestamp = Date.now(); user.resetToken = 'token-' + (timestamp + 10000); res.send('Reset token generated'); }); app.post('/reset-password', (req, res) => { const { username, token, newPassword } = req.body; const user = users[username]; if (!user || user.resetToken !== token) return res.status(401).send('Invalid token'); user.password = newPassword; user.resetToken = null; res.send('Password reset'); }); const PORT = 4000; app.listen(PORT, () => console.log('Timestamp Token Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Unauthorized Role Modification",
  "Lab Description": "This lab allows attackers to escalate privileges by modifying the 'role' parameter in API requests. The backend does not validate if the user is authorized to change roles. To solve the lab, change your role to 'admin' by tampering with the request.",
  "Vulnerability name": "Authentication",
  "lab level": "Medium",
  "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ id: 1, role: 'user' }, { id: 2, role: 'admin' }]; app.post('/update-role', (req, res) => { const { userId, newRole } = req.body; const user = users.find(u => u.id === userId); if (!user) return res.status(404).send('User not found'); user.role = newRole; res.send('Role updated to ' + newRole); }); const PORT = 4000; app.listen(PORT, () => console.log('Role Escalation Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Session ID Exposed in URL",
  "Lab Description": "This lab stores the session ID in the URL instead of a secure cookie. Attackers can steal session IDs from server logs or shared URLs. To solve the lab, intercept another user's session ID from their URL and access their profile.",
  "Vulnerability name": "Authentication",
  "lab level": "Medium",
  "src code": "const express = require('express'); const app = express(); let sessionId = 'abc123'; app.get('/profile', (req, res) => { const userSession = req.query.session; if (userSession === sessionId) { res.send('Welcome! Active session: ' + sessionId); } else { res.status(401).send('Unauthorized'); } }); app.get('/login', (req, res) => { res.send(`Logged in. Your session ID is: ${sessionId}`); }); const PORT = 4000; app.listen(PORT, () => console.log('URL Session ID Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Privilege Escalation via PAR Request URI Manipulation",
  "Lab Description": "This OAuth 2.1 implementation mishandles Pushed Authorization Request URIs, allowing attackers to: 1. Intercept `request_uri` during client registration. 2. Replace scopes with `admin:full`. 3. Force authorization server to process modified request. 4. Access SCIM API to create backdoor admin account.",
  "Vulnerability name": "Authentication",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst uuid = require('uuid');\nconst app = express();\n\nconst parRequests = new Map();\n\napp.post('/par', (req, res) => {\n  const { client_id, scope } = req.body;\n  const request_uri = `urn:ietf:params:oauth:request_uri:${uuid.v4()}`;\n  \n  // Critical flaw: No client-scope binding\n  parRequests.set(request_uri, {\n    client_id,\n    scope // Vulnerable: Attacker can override\n  });\n  \n  res.json({ request_uri, expires_in: 300 });\n});\n\napp.post('/authorize', (req, res) => {\n  const { request_uri } = req.body;\n  const request = parRequests.get(request_uri);\n  \n  // Vulnerability: Trusts unmodified PAR\n  if (request.scope.includes('admin:full')) {\n    res.redirect(`/scim/create-admin?client=${request.client_id}`);\n  } else {\n    res.send('Standard authorization granted');\n  }\n});\n\napp.post('/scim/create-admin', (req, res) => {\n  res.send('Backdoor admin created - Lab solved');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`PAR Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Bypass Facial Recognition via Stored Template Reuse",
  "Lab Description": "This lab's biometric authentication system stores facial recognition templates as static SHA-256 hashes. Attackers can: 1. Extract template hashes from insecure S3 bucket. 2. Replay admin's facial hash via API parameter. 3. Bypass liveness detection to access /biometric/safe. The system compares hashes without timestamp validation.",
  "Vulnerability name": "Authentication",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst crypto = require('crypto');\nconst app = express();\n\nconst facialHashes = {\n  admin: '8f434346648f6b96df89dda901c5176b10a6d83961dd3c1ac88b59b2dc327aa4'\n};\n\napp.post('/verify-biometric', (req, res) => {\n  const { image, hash } = req.body;\n  \n  // Critical flaw: Accepts precomputed hashes\n  const computedHash = hash || crypto.createHash('sha256').update(image).digest('hex');\n  \n  // Vulnerability: No anti-replay mechanism\n  if (Object.values(facialHashes).includes(computedHash)) {\n    res.send('Authentication successful');\n  } else {\n    res.status(403).send('Biometric mismatch');\n  }\n});\n\napp.get('/biometric/safe', (req, res) => {\n  res.send('BIOMETRIC VAULT: DNA profiles downloaded');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Biometric Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Exploit a weak password policy to guess a user's password.(Weak Password Policy)",
  "Lab Description": "The application allows users to set very short and simple passwords with no complexity requirements. Try logging in as 'admin' by guessing a common password like '123'. This demonstrates how weak password policies can lead to unauthorized access.",
  "Vulnerability name": "Authentication ",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\nconst users = { 'admin': '123' };\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\"><input name=\"password\" type=\"password\"><button type=\"submit\">Login</button></form>');\n});\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.send(`Welcome, ${username}!`);\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.listen(3001, () => console.log('Server running on port 3001'));"
},
{
  "Lab scenario": "Exploit insecure session management to reuse a session after logout. (Insecure Session Management)",
  "Lab Description": "The application fails to properly invalidate session cookies upon logout. Log in as 'user1', capture the session cookie, log out, then use the same cookie to access the account page again. This shows the importance of fully destroying sessions on logout.",
  "Vulnerability name": "Authentication ",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst session = require('express-session');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(session({ secret: 'secret', resave: false, saveUninitialized: true }));\nconst users = { 'user1': 'password' };\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\"><input name=\"password\" type=\"password\"><button type=\"submit\">Login</button></form>');\n});\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    req.session.username = username;\n    res.send('Logged in');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/account', (req, res) => {\n  if (req.session.username) {\n    res.send(`Welcome, ${req.session.username}!`);\n  } else {\n    res.status(401).send('Please log in');\n  }\n});\napp.get('/logout', (req, res) => {\n  req.session.username = null; // Not destroying the session\n  res.send('Logged out');\n});\napp.listen(3002, () => console.log('Server running on port 3002'));"
},
{
  "Lab scenario": "Exploit the lack of rate limiting to perform credential stuffing(Credential Stuffing)",
  "Lab Description": "The application does not limit the number of login attempts, allowing attackers to try multiple passwords for a known username. Try logging in as 'user1' with different passwords until you guess 'password123'. This highlights the need for rate limiting or account lockouts.",
  "Vulnerability name": "Authentication ",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\nconst users = { 'user1': 'password123' };\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\"><input name=\"password\" type=\"password\"><button type=\"submit\">Login</button></form>');\n});\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.send(`Welcome, ${username}!`);\n  } else {\n    res.send('Invalid credentials'); // No rate limiting\n  }\n});\napp.listen(3003, () => console.log('Server running on port 3003'));"
}

  
  
  
  ]