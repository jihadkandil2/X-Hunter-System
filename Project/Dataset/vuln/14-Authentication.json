[
  {
    "Lab scenario": "Username enumeration via different responses",
    "Lab Description": "This lab is vulnerable to username enumeration and password brute-force attacks. It has an account with a predictable username and password, which can be found in the following wordlists:\nTo solve the lab, enumerate a valid username, brute-force this user's password, then access their account page.",
    "Vulnerability name": "Authentication"
  },
  {
    "Lab scenario": "2FA simple bypass",
    "Lab Description": "This lab's two-factor authentication can be bypassed. You have already obtained a valid username and password, but do not have access to the user's 2FA verification code. To solve the lab, access Carlos's account page.",
    "Vulnerability name": "Authentication",
    "lab level": "Easy",
    "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123', is2FAEnabled: true }]; app.post('/login', (req, res) => { const { username, password, code } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); if (user.is2FAEnabled && !code) return res.status(200).send('2FA code required'); res.send(`Welcome, ${username}!`); }); const PORT = 4000; app.listen(PORT, () => console.log(`2FA Bypass Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Password reset broken logic",
    "Lab Description": "This lab's password reset functionality is vulnerable. To solve the lab, reset Carlos's password then log in and access his \"My account\" page.",
    "Vulnerability name": "Authentication",
    "lab level": "Medium",
    "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'oldpassword' }]; app.post('/reset-password', (req, res) => { const { username } = req.body; const user = users.find(u => u.username === username); if (user) { res.send('Password reset link sent to your email'); } else { res.status(400).send('User not found'); } }); app.post('/set-new-password', (req, res) => { const { username, newPassword } = req.body; const user = users.find(u => u.username === username); if (user) { user.password = newPassword; res.send('Password changed successfully'); } else { res.status(400).send('User not found'); } }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.send(`Welcome, ${username}!`); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { res.send('Account details for carlos'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Password Reset Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Username enumeration via subtly different responses",
    "Lab Description": "This lab is subtly vulnerable to username enumeration and password brute-force attacks. It has an account with a predictable username and password, which can be found in the following wordlists:\nTo solve the lab, enumerate a valid username, brute-force this user's password, then access their account page.",
    "Vulnerability name": "Authentication",
    "lab level": "Medium",
    "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username); if (!user) { res.status(401).send('Invalid username'); return; } if (user.password !== password) { res.status(401).send('Invalid password'); return; } res.send(`Welcome, ${username}!`); }); app.get('/my-account', (req, res) => { res.send('Account details for carlos'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Username Enumeration Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Username enumeration via response timing",
    "Lab Description": "This lab is vulnerable to username enumeration using its response times. To solve the lab, enumerate a valid username, brute-force this user's password, then access their account page.",
    "Vulnerability name": "Authentication",
    "lab level": "Medium",
    "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username); if (!user) { setTimeout(() => res.status(401).send('Invalid username'), 1000); return; } if (user.password !== password) { res.status(401).send('Invalid password'); return; } res.send(`Welcome, ${username}!`); }); app.get('/my-account', (req, res) => { res.send('Account details for carlos'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Username Enumeration via Timing Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Broken brute-force protection, IP block",
    "Lab Description": "This lab is vulnerable due to a logic flaw in its password brute-force protection. To solve the lab, brute-force the victim's password, then log in and access their account page.",
    "Vulnerability name": "Authentication"
  },
  {
    "Lab scenario": "Username enumeration via account lock",
    "Lab Description": "This lab is vulnerable to username enumeration. It uses account locking, but this contains a logic flaw. To solve the lab, enumerate a valid username, brute-force this user's password, then access their account page.",
    "Vulnerability name": "Authentication",
    "lab level": "Medium",
    "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); let users = [{ username: 'carlos', password: 'securepassword', attempts: 0, locked: false }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username); if (!user) { return res.status(401).json({ error: 'Invalid credentials' }); } if (user.locked) { return res.status(403).json({ error: 'Account locked' }); } if (user.password === password) { user.attempts = 0; res.json({ message: 'Login successful' }); } else { user.attempts++; if (user.attempts >= 3) { user.locked = true; } res.status(401).json({ error: 'Invalid credentials' }); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Username Enumeration Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "2FA broken logic",
    "Lab Description": "This lab's two-factor authentication is vulnerable due to its flawed logic. To solve the lab, access Carlos's account page.\nYou also have access to the email server to receive your 2FA verification code.",
    "Vulnerability name": "Authentication",
    "lab level": "Medium",
    "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); let users = [{ username: 'carlos', password: 'securepassword', verified: false }]; let verificationCodes = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) { return res.status(401).json({ error: 'Invalid credentials' }); } verificationCodes[username] = '123456'; res.json({ message: '2FA code sent' }); }); app.post('/verify-2fa', (req, res) => { const { username, code } = req.body; if (verificationCodes[username] === code || !code) { users.find(u => u.username === username).verified = true; res.json({ message: '2FA verification bypassed' }); } else { res.status(403).json({ error: 'Invalid 2FA code' }); } }); const PORT = 4000; app.listen(PORT, () => console.log(`2FA Broken Logic Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Brute-forcing a stay-logged-in cookie",
    "Lab Description": "This lab allows users to stay logged in even after they close their browser session. The cookie used to provide this functionality is vulnerable to brute-forcing.\nTo solve the lab, brute-force Carlos's cookie to gain access to his My account page.",
    "Vulnerability name": "Authentication",
    "lab level": "hard",
    "src code": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\nconst users = {\n  'carlos': { password: 'secure123', session: 'abcd1234' },\n  'admin': { password: 'admin123', session: 'xyz9876' }\n};\n\napp.get('/login', (req, res) => {\n  const { username, password } = req.query;\n  if (users[username] && users[username].password === password) {\n    res.cookie('session', users[username].session);\n    res.send('Logged in');\n  } else {\n    res.send('Invalid credentials');\n  }\n});\n\napp.get('/account', (req, res) => {\n  const session = req.cookies.session;\n  const user = Object.keys(users).find(u => users[u].session === session);\n  if (user) {\n    res.send(`Welcome ${user}`);\n  } else {\n    res.send('Access denied');\n  }\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
  },
  {
    "Lab scenario": "Offline password cracking",
    "Lab Description": "This lab stores the user's password hash in a cookie. The lab also contains an XSS vulnerability in the comment functionality. To solve the lab, obtain Carlos's stay-logged-in cookie and use it to crack his password. Then, log in as carlos and delete his account from the \"My account\" page.",
    "Vulnerability name": "Authentication",
    "lab level": "Hard",
    "src code": "const express=require('express'),sqlite3=require('sqlite3').verbose(),bodyParser=require('body-parser'),crypto=require('crypto'),app=express();app.use(bodyParser.json());app.use(bodyParser.urlencoded({extended:true}));const db=new sqlite3.Database(':memory:');db.serialize(()=>{db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password_hash TEXT)\");db.run(\"INSERT INTO users (username, password_hash) VALUES ('carlos', '5f4dcc3b5aa765d61d8327deb882cf99')\");});app.get('/comments',(req,res)=>{const comment=req.query.comment;res.send(`<p>${comment}</p>`);});app.get('/cookie',(req,res)=>{res.cookie('session','carlos_cookie_hash');res.send(\"Cookie set for Carlos.\");});app.post('/login',(req,res)=>{const{username,password}=req.body;if(!username||!password){return res.status(400).send(\"Username and password are required.\");}const hashedPassword=crypto.createHash('md5').update(password).digest('hex');const query=`SELECT * FROM users WHERE username='${username}' AND password_hash='${hashedPassword}'`;db.all(query,[],(err,rows)=>{if(err){res.status(500).send(\"Error occurred during login.\");}else if(rows.length>0){res.send(\"Login successful!\");}else{res.send(\"Invalid credentials.\");}});});const PORT=3000;app.listen(PORT,()=>console.log(`Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Password reset poisoning via middleware",
    "Lab Description": "This lab is vulnerable to password reset poisoning. The user carlos will carelessly click on any links in emails that he receives. To solve the lab, log in to Carlos's account. You can log in to your own account using the following credentials: wiener:peter. Any emails sent to this account can be read via the email client on the exploit server.",
    "Vulnerability name": "Authentication",
    "lab level": "medium",
    "src code": "const express=require('express'),bodyParser=require('body-parser'),app=express();app.use(bodyParser.json());const users={\"carlos\":{email:\"carlos@example.com\",password:\"securepassword\"},\"wiener\":{email:\"wiener@example.com\",password:\"peter\"}};app.post('/reset-password',(req,res)=>{const{email}=req.body;if(!email||!users[email.split('@')[0]]){return res.status(400).send(\"User not found.\");}const resetLink=`${req.headers.host}/reset?user=${email.split('@')[0]}`;console.log(\"Password reset link:\",resetLink);res.send(`Password reset link sent to ${email}: <a href=\"http://${resetLink}\">${resetLink}</a>`);});app.listen(3000,()=>console.log(\"Lab running on http://localhost:3000\"));"
  },
  {
    "Lab scenario": "Password brute-force via password change",
    "Lab Description": "This lab's password change functionality makes it vulnerable to brute-force attacks. To solve the lab, use the list of candidate passwords to brute-force Carlos's account and access his \"My account\" page.",
    "Vulnerability name": "Authentication",
    "lab level": "hard",
    "src code": "const express=require('express'),bodyParser=require('body-parser'),app=express();app.use(bodyParser.json());const users={\"carlos\":{password:\"securepassword\"},\"wiener\":{password:\"peter\"}};app.post('/change-password',(req,res)=>{const{username,oldPassword,newPassword}=req.body;if(!users[username]||users[username].password!==oldPassword){return res.status(401).send(\"Invalid credentials.\");}users[username].password=newPassword;console.log(`Password changed for ${username}`);res.send(\"Password changed successfully.\");});app.listen(3000,()=>console.log(\"Lab running on http://localhost:3000\"));"
  },
  {
    "Lab scenario": "Broken brute-force protection, multiple credentials per request",
    "Lab Description": "This lab is vulnerable due to a logic flaw in its brute-force protection. To solve the lab, brute-force Carlos's password, then access his account page.",
    "Vulnerability name": "Authentication",
    "lab level": "medium",
    "src code": "const express=require('express'),bodyParser=require('body-parser'),app=express();app.use(bodyParser.json());const users={'carlos':{password:'securepassword'},'wiener':{password:'peter'}};app.post('/login',(req,res)=>{const{credentials}=req.body;let success=false;credentials.forEach(({username,password})=>{if(users[username]&&users[username].password===password)success=true;});if(success)return res.send('Login successful!');else return res.status(401).send('Invalid credentials.');});app.listen(3000,()=>console.log('Lab running on http://localhost:3000'));"
  },
  {
    "Lab scenario": "2FA bypass using a brute-force attack",
    "Lab Description": "This lab's two-factor authentication is vulnerable to brute-forcing. You have already obtained a valid username and password, but do not have access to the user's 2FA verification code. To solve the lab, brute-force the 2FA code and access Carlos's account page.\nVictim's credentials: carlos:montoya",
    "Vulnerability name": "Authentication",
    "lab level": "hard",
    "src code": "const express=require('express'),bodyParser=require('body-parser'),app=express();app.use(bodyParser.json());const users={'carlos':{password:'montoya',otp:'0000'}};let attempts={};app.post('/login',(req,res)=>{const{username,password}=req.body;if(users[username]&&users[username].password===password)return res.json({message:'Enter 2FA code',user:username});else return res.status(401).send('Invalid credentials.');});app.post('/verify-2fa',(req,res)=>{const{username,otp}=req.body;if(!attempts[username])attempts[username]=0;attempts[username]++;if(users[username]&&users[username].otp===otp)return res.send('Login successful!');else return res.status(401).send('Invalid 2FA code.');});app.listen(3000,()=>console.log('Lab running on http://localhost:3000'));"
  }

  ,
  {"labs" : "Chat Gpt generated"},
  {"Lab scenario": "Weak password reset token",
    "Lab Description": "This lab's password reset functionality generates weak, predictable reset tokens. An attacker can enumerate tokens to reset another user's password and gain unauthorized access. To solve the lab, exploit the weak token mechanism to reset Carlos's password and access his account page.",
    "Vulnerability name": "Authentication",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst users = [{ username: 'carlos', email: 'carlos@example.com', password: 'securepassword' }];\nconst resetTokens = {}; // Store reset tokens temporarily\n\n// Request password reset\napp.post('/reset-password', (req, res) => {\n    const { email } = req.body;\n    const user = users.find(u => u.email === email);\n    if (!user) return res.status(400).send('User not found');\n    \n    // Weak token generation (predictable)\n    const token = Buffer.from(email).toString('hex').slice(0, 8); \n    resetTokens[token] = user.username;\n    res.send(`Password reset token: ${token}`);\n});\n\n// Reset password\napp.post('/change-password', (req, res) => {\n    const { token, newPassword } = req.body;\n    if (!resetTokens[token]) return res.status(400).send('Invalid token');\n    \n    const username = resetTokens[token];\n    const user = users.find(u => u.username === username);\n    user.password = newPassword;\n    delete resetTokens[token]; // Remove used token\n    res.send('Password reset successful');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Weak Password Reset Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Session fixation vulnerability via unrotated session tokens",
    "Lab Description": "This lab demonstrates a session fixation vulnerability. The application does not renew the session identifier upon successful login, leaving the session token predictable and fixed. An attacker can set a predetermined session ID and trick a victim into logging in with that token. To solve the lab, exploit this vulnerability by forcing the victim to use a known session token and then hijack their session to access their account.",
    "Vulnerability name": "Authentication",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Configure session without regenerating session ID on login\napp.use(session({\n    secret: 'supersecretkey',\n    resave: false,\n    saveUninitialized: true\n}));\n\n// Sample user database\nconst users = [{ username: 'carlos', password: 'password123' }];\n\n// Home/Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" required />\n            <input type=\"password\" name=\"password\" required />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\n// Login route\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        // Note: The session ID is NOT regenerated after login, leaving the token fixed\n        req.session.user = user.username;\n        res.send(`Welcome, ${user.username}. Your session id is ${req.sessionID}.`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Brute-force attack on an insecure login mechanism",
    "Lab Description": "This lab demonstrates a brute-force attack due to the absence of rate limiting. The application allows unlimited login attempts without restrictions, making it vulnerable to credential stuffing attacks. To solve the lab, use brute-force techniques to discover the credentials of Carlos and access his account.",
    "Vulnerability name": "Authentication",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Sample user database\nconst users = [{ username: 'carlos', password: 'securepassword' }];\n\n// Login route (no brute-force protection)\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        res.send(`Welcome, ${user.username}!`);\n    } else {\n        res.status(401).send('Invalid credentials');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Brute-Force Login Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Predictable 'Remember Me' token allows session hijacking",
    "Lab Description": "This lab demonstrates an authentication vulnerability in the 'Remember Me' functionality. The application generates a remember-me token using a weak, predictable algorithm—specifically, an MD5 hash of the username. This allows an attacker to forge a valid token and hijack a victim's session. To solve the lab, generate a forged remember-me token for a victim (e.g., carlos), use it to access the victim's account page, and retrieve the flag.",
    "Vulnerability name": "Authentication",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Simple user database with insecure 'Remember Me' functionality\nconst users = [{ username: 'carlos', password: 'securepassword' }];\nconst tokens = {};\n\n// Login route - generates a predictable token if 'rememberMe' is enabled\napp.post('/login', (req, res) => {\n    const { username, password, rememberMe } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (!user) return res.status(401).send('Invalid credentials');\n    if (rememberMe) {\n        // Insecure token generation: MD5 of the username\n        const token = crypto.createHash('md5').update(username).digest('hex');\n        tokens[token] = username;\n        res.send(`Login successful. Your remember-me token is ${token}`);\n    } else {\n        res.send(`Login successful for ${username}`);\n    }\n});\n\n// Protected account route that checks for a remember-me token via query parameter\napp.get('/account', (req, res) => {\n    const token = req.query.token;\n    if (token && tokens[token]) {\n        res.send(`Welcome to your account, ${tokens[token]}! Flag: FLAG{remember_me_hijack_successful}`);\n    } else {\n        res.status(403).send('Access denied. Invalid or missing token.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Remember Me Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Default credentials bypass in login form",
    "Lab Description": "This lab demonstrates an authentication vulnerability caused by misconfigured default credentials. The login form fails to properly validate the username; if the username field is left empty, the application automatically assigns 'admin' as the username. To solve the lab, simply submit an empty username along with any password to gain access to the admin account page.",
    "Vulnerability name": "Authentication",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Home/Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method='POST' action='/login'>\n            <input type='text' name='username' placeholder='Username' />\n            <input type='password' name='password' placeholder='Password' />\n            <button type='submit'>Login</button>\n        </form>\n    `);\n});\n\n// Login route with default admin bypass\napp.post('/login', (req, res) => {\n    let { username, password } = req.body;\n    // If username is empty or only whitespace, default to 'admin'\n    if (!username || username.trim() === '') {\n        username = 'admin';\n    }\n    // For demonstration purposes, any password is accepted\n    res.send(`Welcome, ${username}!`);\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Default Credentials Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Login bypass due to missing password validation",
    "Lab Description": "This lab demonstrates an authentication vulnerability where the login form fails to enforce a proper password check. As a result, if a user submits a valid username with an empty password, the system logs them in. To solve the lab, log in as the target user by providing the correct username and leaving the password field empty.",
    "Vulnerability name": "Authentication",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Hard-coded user database\nconst users = [{ username: 'admin', password: 'supersecret' }];\n\n// Home/Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n            <input type=\"password\" name=\"password\" placeholder=\"Password\" />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\n// Login route with vulnerability: if password is empty, bypass check\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username);\n    // Vulnerability: if password is empty, allow login\n    if (user && (password === user.password || password === '')) {\n        res.send(`Welcome, ${username}!`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`No Password Check Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Login bypass via hidden parameter injection",
    "Lab Description": "This lab demonstrates an authentication vulnerability caused by a hidden parameter that bypasses password checks. The login form includes a hidden field named 'bypass' which, if set to '1', causes the server to skip the password validation and log in the user. To solve the lab, manipulate the login request to set the 'bypass' parameter to '1' and log in as the admin user.",
    "Vulnerability name": "Authentication",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Hard-coded user database\nconst users = [{ username: 'admin', password: 'admin123' }];\n\n// Home/Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n            <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n            <input type=\"hidden\" name=\"bypass\" value=\"0\" />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\n// Login route with vulnerability: if 'bypass' equals '1', skip password check\napp.post('/login', (req, res) => {\n    const { username, password, bypass } = req.body;\n    if (bypass === '1') {\n        res.send(`Welcome, ${username}! (Bypassed)`);\n        return;\n    }\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        res.send(`Welcome, ${username}!`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Hidden Parameter Bypass Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Login bypass via type coercion vulnerability",
    "Lab Description": "This lab demonstrates an authentication bypass due to improper type coercion in the login function. The server stores the password as a number and uses non-strict equality (==) for comparison, so a string like '0' is considered equal to 0. To solve the lab, exploit this vulnerability by logging in as the admin user using '0' as the password, and access the protected resource.",
    "Vulnerability name": "Authentication",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Sample user with password stored as a number\nconst users = [\n  { username: 'admin', password: 0 }  // The password is stored as 0\n];\n\napp.get('/', (req, res) => {\n    res.send(`\n      <h2>Login</h2>\n      <form method=\"POST\" action=\"/login\">\n          <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n          <input type=\"text\" name=\"password\" placeholder=\"Password\" required />\n          <button type=\"submit\">Login</button>\n      </form>\n    `);\n});\n\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username);\n    // Vulnerability: using non-strict equality (==) so '0' == 0 evaluates to true\n    if (user && password == user.password) {\n        res.send(`Welcome, ${username}! You have bypassed authentication using type coercion.`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Type Coercion Bypass Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Login bypass via HTTP parameter pollution",
    "Lab Description": "This lab demonstrates an authentication bypass caused by HTTP parameter pollution. The application processes multiple instances of the same parameter inconsistently. If an attacker submits multiple 'password' parameters in the login request, the server incorrectly validates the login. To solve the lab, send a login request with two password parameters and access the admin account.",
    "Vulnerability name": "Authentication",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Sample user database\nconst users = [{ username: 'admin', password: 'adminpass' }];\n\n// Home/Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n            <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\n// Vulnerable login route\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username);\n    \n    // Vulnerability: If multiple password parameters are provided, the server may not validate correctly\n    if (user && (Array.isArray(password) || password === user.password)) {\n        res.send(`Welcome, ${username}! (Authenticated via HTTP Parameter Pollution)`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`HTTP Parameter Pollution Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Bypassing multi-factor authentication using a race condition",
    "Lab Description": "This lab demonstrates an authentication bypass caused by a race condition in the multi-factor authentication (MFA) process. The application allows users to log in with a username and password and then requests a one-time code (OTP). However, due to an implementation flaw, the system does not properly validate session states when OTP requests are sent in parallel. An attacker can exploit this race condition to bypass MFA by submitting concurrent requests, allowing them to gain unauthorized access without providing the correct OTP. To solve the lab, exploit this issue to log in as the admin user without a valid OTP.",
    "Vulnerability name": "Authentication",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\n\napp.use(session({\n    secret: 'supersecretkey',\n    resave: false,\n    saveUninitialized: true\n}));\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst users = [{ username: 'admin', password: 'password123', otp: null }];\n\n// Step 1: Login with username & password\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        req.session.user = username;\n        user.otp = crypto.randomInt(100000, 999999).toString(); // Generate OTP\n        res.send('OTP required. Submit to /verify with the correct code.');\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\n// Step 2: Verify OTP (Vulnerable to race condition)\napp.post('/verify', (req, res) => {\n    const user = users.find(u => u.username === req.session.user);\n    if (!user) return res.status(401).send('Unauthorized');\n    \n    const { otp } = req.body;\n    if (otp === user.otp) {\n        req.session.authenticated = true;\n        res.send('Login successful!');\n    } else {\n        res.status(401).send('Invalid OTP');\n    }\n});\n\n// Step 3: Access the account (should be protected by MFA)\napp.get('/account', (req, res) => {\n    if (req.session.authenticated) {\n        res.send(`Welcome to your account, ${req.session.user}!`);\n    } else {\n        res.status(403).send('Access denied.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`MFA Race Condition Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Timing attack on naive password comparison",
    "Lab Description": "This lab demonstrates a timing attack vulnerability in the login functionality. The application compares the submitted password to the stored password using a naive, character-by-character comparison that introduces a fixed delay for each matching character. An attacker can exploit this predictable delay to infer the correct password one character at a time. To solve the lab, perform a timing attack to recover the target user's password and gain access to the account.",
    "Vulnerability name": "Authentication",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Simulated user database with one user\nconst users = [\n    { username: 'victim', password: 's3cr3t' }\n];\n\n// Naive slow compare function that introduces a fixed delay for each matching character\nfunction slowCompare(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    let result = true;\n    for (let i = 0; i < a.length; i++) {\n        // Introduce a 50ms delay for each character comparison\n        const start = Date.now();\n        while (Date.now() - start < 50) {}\n        if (a[i] !== b[i]) {\n            result = false;\n        }\n    }\n    return result;\n}\n\n// Home/Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required /><br>\n            <input type=\"text\" name=\"password\" placeholder=\"Password\" required /><br>\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\n// Login route that uses the slowCompare function\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username);\n    if (!user) return res.status(401).send('Invalid credentials');\n    if (slowCompare(user.password, password)) {\n        res.send(`Welcome, ${username}!`);\n    } else {\n        res.status(401).send('Invalid credentials');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Timing Attack Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Password reset token reuse vulnerability",
    "Lab Description": "This lab demonstrates an authentication vulnerability in the password reset process. The application generates a password reset token and sends it to the user's email, but fails to invalidate the token after a successful password reset. This allows an attacker to reuse an old token to reset the password of another user and gain unauthorized access. To solve the lab, reuse the previously generated token to change the target user's password and log in with the new credentials.",
    "Vulnerability name": "Authentication",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Sample user database\nlet users = [\n  { username: 'carlos', password: 'oldpassword', email: 'carlos@example.com' }\n];\n\n// Insecure storage for password reset tokens (tokens are not invalidated after use)\nlet resetTokens = {};\n\n// Endpoint to request a password reset\napp.post('/request-reset', (req, res) => {\n  const { email } = req.body;\n  const user = users.find(u => u.email === email);\n  if (!user) return res.status(400).send('User not found');\n  \n  // Generate an insecure and predictable token for demonstration purposes\n  const token = crypto.createHash('sha256').update(email).digest('hex').slice(0, 8);\n  resetTokens[token] = user.username;  // Token is stored but never invalidated\n  res.send(`Password reset token: ${token}`);\n});\n\n// Endpoint to reset the password\napp.post('/reset-password', (req, res) => {\n  const { token, newPassword } = req.body;\n  const username = resetTokens[token];\n  if (!username) return res.status(400).send('Invalid or expired token');\n  \n  const user = users.find(u => u.username === username);\n  if (!user) return res.status(400).send('User not found');\n\n  // Update the user's password\n  user.password = newPassword;\n  // Note: The token is not deleted after use, enabling token reuse\n  res.send('Password has been reset successfully');\n});\n\n// Login endpoint\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    res.send(`Welcome, ${username}!`);\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Insecure Password Reset Lab running on http://localhost:${PORT}`));"
  },
  {
    "Lab scenario": "Authentication Bypass via Weak Password Reset Validation",
    "Lab Description": "This lab's authentication system has a flawed password reset mechanism. The application does not properly validate ownership of the password reset token, allowing attackers to hijack the reset process for other users. To solve the lab, exploit this vulnerability to reset Carlos's password and log into his account. Steps: 1. Request a password reset token for your own account. 2. Intercept the token submission request and replace your email with Carlos's email address while keeping the valid token. 3. Set a new password for Carlos's account. 4. Authenticate as Carlos using the new password.",
    "Vulnerability name": "Authentication",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst users = [\n  { email: 'carlos@example.com', password: 'defaultPass' },\n  { email: 'attacker@example.com', password: 'hackMe' }\n];\n\nconst validTokens = new Map();\n\napp.post('/forgot-password', (req, res) => {\n  const { email } = req.body;\n  const user = users.find(u => u.email === email);\n  if (!user) return res.status(404).send('User not found');\n  \n  const token = Math.random().toString(36).slice(2, 10);\n  validTokens.set(email, token);\n  res.send(`Password reset token sent to ${email}: ${token}`);\n});\n\n// VULNERABLE ENDPOINT: Token is validated without checking email-token binding\napp.post('/reset-password', (req, res) => {\n  const { email, token, newPassword } = req.body;\n  \n  // Flaw: Only checks if token exists, not which user it belongs to\n  if (![...validTokens.values()].includes(token)) {\n    return res.status(401).send('Invalid token');\n  }\n  \n  const user = users.find(u => u.email === email);\n  if (!user) return res.status(404).send('User not found');\n  \n  user.password = newPassword;\n  validTokens.delete(email);\n  res.send('Password successfully reset');\n});\n\napp.post('/login', (req, res) => {\n  const { email, password } = req.body;\n  const user = users.find(u => u.email === email && u.password === password);\n  if (!user) return res.status(401).send('Invalid credentials');\n  res.send(`Logged in as ${email}`);\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Auth Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Credential Stuffing Attack",
  "Lab Description": "This lab is vulnerable to credential stuffing attacks. The login system does not properly rate-limit failed login attempts, allowing an attacker to repeatedly try different username and password combinations. To solve the lab, successfully log in to the admin account using a brute-force attack.",
  "Vulnerability name": "Authentication",
  "lab level": "Medium",
  "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'admin', password: 'admin123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); res.send('Welcome, ' + username + '!'); }); const PORT = 4000; app.listen(PORT, () => console.log('Credential Stuffing Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Exploit a weak password reset mechanism to access Carlos's account.",
  "Lab Description": "The application has a password reset feature that generates a reset token identical to the username provided in the request. This allows an attacker to reset any user's password by simply using their username as the token. To solve the lab, request a password reset for the user 'attacker' to observe the token, then use 'carlos' as the token to reset Carlos's password, and log in to his account with the new password.",
  "Vulnerability name": "Insecure Password Reset",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst session = require('express-session');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(session({ secret: 'weak_secret', resave: false, saveUninitialized: true }));\nlet users = { 'attacker': { password: 'attacker_pass' }, 'carlos': { password: 'carlos_pass' } };\napp.get('/login', (req, res) => res.send('<form method=\"post\"><input name=\"username\"><input name=\"password\" type=\"password\"><button type=\"submit\">Login</button></form>'));\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username].password === password) {\n    req.session.username = username;\n    res.send('Login successful');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/reset', (req, res) => res.send('<form method=\"post\"><input name=\"username\"><button type=\"submit\">Request reset</button></form>'));\napp.post('/reset', (req, res) => {\n  const { username } = req.body;\n  if (users[username]) {\n    const token = username;\n    res.send(`A reset link has been sent: <a href=\"/reset-password?token=${token}\">Reset password</a>`);\n  } else {\n    res.status(404).send('User not found');\n  }\n});\napp.get('/reset-password', (req, res) => {\n  const { token } = req.query;\n  if (!token) return res.status(400).send('Token required');\n  res.send(`<form method=\"post\"><input name=\"token\" type=\"hidden\" value=\"${token}\"><input name=\"new_password\" type=\"password\"><button type=\"submit\">Reset password</button></form>`);\n});\napp.post('/reset-password', (req, res) => {\n  const { token, new_password } = req.body;\n  if (users[token]) {\n    users[token].password = new_password;\n    res.send(`Password for ${token} has been reset.`);\n  } else {\n    res.status(400).send('Invalid token');\n  }\n});\napp.get('/account', (req, res) => {\n  if (req.session.username) {\n    res.send(`Welcome, ${req.session.username}!`);\n  } else {\n    res.status(401).send('Please log in');\n  }\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Insecure Password Reset Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Session Fixation Attack to Compromise Administrative Access",
  "Lab Description": "This lab contains an authentication vulnerability where the application does not regenerate session IDs after login, allowing session fixation. An attacker can force a user to authenticate with a known session ID and hijack their session. To solve the lab: 1. Obtain a valid session ID before authentication. 2. Trick Carlos (admin) into logging in with your pre-set session ID (simulated via CSRF/forced browsing). 3. Use the session ID to access the admin dashboard and delete all user data. The lab is solved when you execute the /admin/wipe endpoint as Carlos.",
  "Vulnerability name": "Authentication",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(bodyParser.json());\napp.use(cookieParser());\n\nconst sessions = new Map();\nconst users = [\n  { username: 'carlos', password: 's3cr3tAdm1n!', role: 'admin' },\n  { username: 'attacker', password: 'p@ssw0rd', role: 'user' }\n];\n\n// Generate initial session for demonstration\nconst initialSession = Math.random().toString(36).slice(2, 18);\nsessions.set(initialSession, { authenticated: false });\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  \n  if (!user) return res.status(401).send('Invalid credentials');\n  \n  // VULNERABILITY: Uses existing session ID if provided via cookie\n  const sessionId = req.cookies.sessionId || Math.random().toString(36).slice(2, 18);\n  \n  sessions.set(sessionId, {\n    authenticated: true,\n    username: user.username,\n    role: user.role\n  });\n  \n  res.cookie('sessionId', sessionId, { httpOnly: true });\n  res.send('Logged in successfully');\n});\n\napp.get('/admin/wipe', (req, res) => {\n  const sessionId = req.cookies.sessionId;\n  const session = sessions.get(sessionId);\n  \n  if (!session?.authenticated || session.role !== 'admin') {\n    return res.status(403).send('Admin access required');\n  }\n  \n  // Lab solution trigger\n  res.send('All data wiped by ' + session.username);\n});\n\napp.get('/profile', (req, res) => {\n  const sessionId = req.cookies.sessionId;\n  const session = sessions.get(sessionId);\n  \n  if (!session?.authenticated) {\n    return res.status(401).send('Not authenticated');\n  }\n  \n  res.send(`Welcome ${session.username} (${session.role})`);\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Hard Auth Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Exploit a lack of session timeout to access Alice's account after she logs out.",
  "Lab Description": "The application does not invalidate session IDs after a user logs out or after a period of inactivity, allowing an attacker to reuse an old session ID to access a user's account. To solve the lab, capture Alice's session ID after she logs in, wait for her to log out, then use the same session ID to access her account page.",
  "Vulnerability name": "Insecure Session Expiration",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst session = require('express-session');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(session({ secret: 'simple_secret', resave: false, saveUninitialized: true }));\nconst users = { 'alice': 'alice_pass', 'attacker': 'attacker_pass' };\napp.get('/login', (req, res) => res.send('<form method=\"post\"><input name=\"username\"><input name=\"password\" type=\"password\"><button type=\"submit\">Login</button></form>'));\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    req.session.username = username;\n    res.send('Logged in! <a href=\"/account\">Account</a> <a href=\"/logout\">Logout</a>');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/logout', (req, res) => {\n  req.session.username = null;\n  res.send('Logged out');\n});\napp.get('/account', (req, res) => {\n  if (req.session.username) {\n    res.send(`Welcome, ${req.session.username}!`);\n  } else {\n    res.status(401).send('Please log in');\n  }\n});\nconst PORT = 5000;\napp.listen(PORT, () => console.log(`Insecure Session Expiration Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Bypass Multi-Factor Authentication via Brute-Forceable TOTP",
  "Lab Description": "This lab implements weak Time-Based One-Time Password (TOTP) validation for multi-factor authentication. While the attacker has obtained Carlos's password, the MFA protection can be bypassed due to missing rate-limiting and code reuse prevention. To solve the lab: 1. Authenticate with Carlos's credentials (username: 'carlos', password: 'admin123'). 2. Brute-force the 6-digit TOTP code within 2 minutes of code validity. 3. Access the administrative panel at /admin to delete all records.",
  "Vulnerability name": "Authentication",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst speakeasy = require('speakeasy');\nconst app = express();\napp.use(bodyParser.json());\n\nconst users = [{\n  username: 'carlos',\n  password: 'admin123',\n  mfaSecret: speakeasy.generateSecret({ length: 20 }).base32,\n  isAdmin: true\n}];\n\nconst activeSessions = new Map();\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  \n  if (!user) return res.status(401).send('Invalid credentials');\n  \n  // Return MFA requirement but expose vulnerability trigger\n  res.status(202).json({\n    message: 'MFA required',\n    remainingAttempts: 'unlimited' // Critical flaw: No attempt counter\n  });\n});\n\napp.post('/verify', (req, res) => {\n  const { username, code } = req.body;\n  const user = users.find(u => u.username === username);\n  \n  // VULNERABILITY: No rate-limiting + accepts old codes within 120s window\n  const verified = speakeasy.totp.verify({\n    secret: user.mfaSecret,\n    encoding: 'base32',\n    token: code,\n    window: 4 // Allows codes from 2 minutes before/after\n  });\n\n  if (!verified) return res.status(401).send('Invalid MFA code');\n\n  // Critical flaw: Doesn't invalidate used codes\n  const sessionToken = Buffer.from(username + Date.now()).toString('base64');\n  activeSessions.set(sessionToken, user);\n  res.json({ token: sessionToken });\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  const session = activeSessions.get(token);\n  \n  if (!session?.isAdmin) return res.status(403).send('Admin access required');\n  res.send('Admin panel: <button onclick=\"fetch('/admin/wipe')\">WIPE DATA</button>');\n});\n\napp.post('/admin/wipe', (req, res) => {\n  // Lab solution validation\n  res.send('All critical data deleted - Lab solved');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`MFA Bypass Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Parameter Tampering Privilege Escalation",
  "Lab Description": "This lab is vulnerable to privilege escalation through parameter tampering. The application uses a 'role' parameter passed in the login request to determine user permissions. The backend blindly trusts this parameter, allowing an attacker to escalate their privileges to admin. To solve the lab, exploit the 'role' parameter in the login request.",
  "Vulnerability name": "Authentication",
  "lab level": "Medium",
  "src code": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'user', password: 'password' }]; app.post('/login', (req, res) => { const { username, password, role } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); // Vulnerability: No validation or sanitization of the 'role' parameter if (role === 'admin') { res.send('Welcome, Admin! You can perform sensitive actions here.'); } else { res.send('Welcome, ' + username + '!'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Parameter Tampering Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Log into the system by exploiting unchanged default credentials.",
  "Lab Description": "The application is a simple web server with a login page. It was deployed with default credentials that were never changed: username 'admin' and password 'admin'. Your task is to log into the system using these default credentials. Once logged in, you will see a 'Welcome, admin!' message, indicating success.",
  "Vulnerability name": "Insecure Default Credentials",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Default credentials\nconst users = { 'admin': 'admin' };\n\n// Serve the login page\napp.get('/login', (req, res) => {\n  res.send(\"<form method='post'><input name='username' placeholder='Username'><input name='password' type='password' placeholder='Password'><button type='submit'>Login</button></form>\");\n});\n\n// Handle login attempts\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'admin' && password === 'admin') {\n    res.send('Welcome, admin!');\n  } else {\n    res.status(401).send('Login failed');\n  }\n});\n\nconst PORT = 7000;\napp.listen(PORT, () => console.log(`Insecure Default Credentials Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "JWT Algorithm Confusion to Gain Administrative Privileges",
  "Lab Description": "This lab uses JSON Web Tokens (JWT) for authentication but fails to validate the signing algorithm properly. The server exposes its public key, enabling attackers to exploit algorithm confusion. To solve the lab: 1. Obtain the server's public key from the exposed JWKS endpoint. 2. Forge an admin JWT by switching the algorithm from RS256 to HS256. 3. Access the /admin/export endpoint to download sensitive data. You start with valid low-privilege credentials (user: attacker, password: p@ssw0rd).",
  "Vulnerability name": "Authentication",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst jwt = require('jsonwebtoken');\nconst jwksClient = require('jwks-rsa');\nconst app = express();\napp.use(bodyParser.json());\n\n// Server's key pair\nconst privateKey = `-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC+8Zbn3NROZ/9L\n...[truncated]...\n3ZtC4x7SJ0miwIDAQAB\n-----END PRIVATE KEY-----`;\nconst publicKey = `-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvvGW59zUTmf/S0b4tAxs\n...[truncated]...\nNG0LjHtInSaLAgMBAAE=\n-----END PUBLIC KEY-----`;\n\nconst users = [\n  { username: 'attacker', password: 'p@ssw0rd', role: 'user' },\n  { username: 'carlos', password: 's3cr3t!', role: 'admin' }\n];\n\n// Vulnerable JWKS endpoint\ntapp.get('/.well-known/jwks.json', (req, res) => {\n  res.json({\n    keys: [{\n      kty: 'RSA',\n      kid: '1',\n      use: 'sig',\n      n: 'vrGW59zUTmf_S0b4tAxs...',\n      e: 'AQAB'\n    }]\n  });\n});\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (!user) return res.status(401).send('Invalid credentials');\n\n  // Generate JWT with vulnerable configuration\n  const token = jwt.sign(\n    { user: username, role: user.role },\n    privateKey,\n    { algorithm: 'RS256', expiresIn: '1h' }\n  );\n  res.json({ token });\n});\n\n// Vulnerable JWT verification middleware\nconst verifyToken = (req, res, next) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return res.status(401).send('Unauthorized');\n\n  // Critical flaw: No algorithm enforcement\n  jwt.verify(token, (header, callback) => {\n    jwksClient.getSigningKey(header.kid, (err, key) => {\n      callback(err, key?.publicKey || publicKey);\n    });\n  }, { algorithms: ['RS256', 'HS256'] }, (err, decoded) => {\n    if (err) return res.status(401).send('Invalid token');\n    req.user = decoded;\n    next();\n  });\n};\n\napp.get('/admin/export', verifyToken, (req, res) => {\n  if (req.user.role !== 'admin') return res.status(403).send('Admin required');\n  res.send('SECRET DATA: Credit card records of all users');\n});\n\napp.get('/profile', verifyToken, (req, res) => {\n  res.send(`Logged in as ${req.user.user} (${req.user.role})`);\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Predictable Authentication Tokens",
  "Lab Description": "This lab uses predictable authentication tokens in URLs. The tokens follow a simple pattern (e.g., 'user1-token', 'user2-token'), allowing an attacker to guess other users' tokens. To solve the lab, access another user's profile by modifying the token in the URL.",
  "Vulnerability name": "Authentication",
  "lab level": "Medium",
  "src code": "const express = require('express'); const app = express(); const users = { 'user1': { token: 'user1-token', data: 'User 1 data' }, 'user2': { token: 'user2-token', data: 'User 2 data' } }; app.get('/profile', (req, res) => { const token = req.query.token; const user = Object.keys(users).find(u => users[u].token === token); if (!user) return res.status(401).send('Unauthorized'); res.send('Welcome, ' + user + '! Data: ' + users[user].data); }); const PORT = 4000; app.listen(PORT, () => console.log('Predictable Token Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Exploit an insecure 'Remember Me' feature to access the admin account.",
  "Lab Description": "The application has a 'Remember Me' feature that stores the username in a cookie. When this cookie is present, the application automatically logs in the user as that username without further verification. To solve the lab, set the 'remember_user' cookie to 'admin' and visit the login page to be automatically logged in as admin, then access the account page to confirm.",
  "Vulnerability name": "Insecure Remember Me Functionality",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst session = require('express-session');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(cookieParser());\napp.use(session({ secret: 'simple_secret', resave: false, saveUninitialized: true }));\nconst users = { 'user': 'pass', 'admin': 'adminpass' };\napp.get('/login', (req, res) => {\n  if (req.cookies.remember_user && users[req.cookies.remember_user]) {\n    req.session.user = req.cookies.remember_user;\n    res.redirect('/account');\n  } else {\n    res.send('<form method=\"post\"><input name=\"username\"><input name=\"password\" type=\"password\"><input type=\"checkbox\" name=\"rememberMe\"> Remember Me<button type=\"submit\">Login</button></form>');\n  }\n});\napp.post('/login', (req, res) => {\n  const { username, password, rememberMe } = req.body;\n  if (users[username] && users[username] === password) {\n    req.session.user = username;\n    if (rememberMe) {\n      res.cookie('remember_user', username, { maxAge: 30 * 24 * 60 * 60 * 1000 });\n    }\n    res.redirect('/account');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/account', (req, res) => {\n  if (req.session.user) {\n    res.send(`Welcome, ${req.session.user}!`);\n  } else {\n    res.status(401).send('Please log in');\n  }\n});\napp.get('/logout', (req, res) => {\n  req.session.destroy();\n  res.clearCookie('remember_user');\n  res.send('Logged out');\n});\nconst PORT = 8000;\napp.listen(PORT, () => console.log(`Insecure Remember Me Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "OAuth Token Hijacking via Open Redirect and Missing State Parameter Validation",
  "Lab Description": "This lab contains a vulnerable OAuth 2.0 implementation where attackers can steal authorization codes through an open redirect vulnerability and gain full account access. The system fails to validate the 'state' parameter and allows arbitrary redirect URIs. To solve the lab: 1. Exploit the open redirect in /redirect endpoint to capture Carlos's authorization code. 2. Exchange the stolen code for an access token. 3. Use the token to access Carlos's private notes at /notes and delete the critical document. You start with a phishing page at http://attacker.com/callback.",
  "Vulnerability name": "Authentication",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\napp.use(bodyParser.json());\n\n// OAuth server configuration\nconst clients = [{\n  client_id: 'vulnerable-app',\n  client_secret: 's3cr3t',\n  redirect_uris: ['http://localhost:4000/callback']\n}];\n\nconst users = [{\n  id: 'carlos',\n  password: 'Winter2023!',\n  notes: ['SECRET: Nuclear launch codes = 000000']\n}];\n\nlet authCodes = new Map();\nlet accessTokens = new Map();\n\n// Vulnerable open redirect endpoint\napp.get('/redirect', (req, res) => {\n  const { url } = req.query;\n  res.redirect(decodeURIComponent(url)); // No validation of redirect targets\n});\n\n// OAuth authorization endpoint\napp.get('/authorize', (req, res) => {\n  const { client_id, redirect_uri, state } = req.query;\n  const client = clients.find(c => c.client_id === client_id);\n  \n  // Critical flaw: No redirect_uri validation\n  if (!client) return res.status(400).send('Invalid client');\n  \n  const code = crypto.randomBytes(16).toString('hex');\n  authCodes.set(code, { user: 'carlos', client_id });\n  \n  // Vulnerability: State parameter not validated/echoed\n  res.redirect(`${redirect_uri}?code=${code}`);\n});\n\n// OAuth token endpoint\napp.post('/token', (req, res) => {\n  const { client_id, client_secret, code } = req.body;\n  const client = clients.find(c => c.client_id === client_id);\n  \n  if (!client || client.client_secret !== client_secret) {\n    return res.status(401).send('Invalid client credentials');\n  }\n  \n  if (!authCodes.has(code)) return res.status(400).send('Invalid code');\n  \n  const token = crypto.randomBytes(24).toString('hex');\n  accessTokens.set(token, authCodes.get(code));\n  authCodes.delete(code);\n  \n  res.json({ access_token: token, token_type: 'Bearer' });\n});\n\n// Protected resource\napp.get('/notes', (req, res) => {\n  const authHeader = req.headers.authorization;\n  const token = authHeader?.split(' ')[1];\n  const session = accessTokens.get(token);\n  \n  if (!session) return res.status(401).send('Invalid token');\n  \n  const user = users.find(u => u.id === session.user);\n  res.json(user.notes);\n});\n\napp.delete('/notes', (req, res) => {\n  // Lab solution validation endpoint\n  res.send('Critical documents deleted - Lab solved');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`OAuth Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Horizontal Privilege Escalation via User ID Manipulation",
  "Lab Description": "This lab allows users to access other users' profiles by manipulating the user ID parameter in the URL. The application does not validate whether the authenticated user is authorized to access the requested profile. To solve the lab, access another user's profile by modifying the user ID in the profile URL.",
  "Vulnerability name": "Authentication",
  "lab level": "Medium",
  "src code": "const express = require('express'); const app = express(); const users = { 1: { id: 1, name: 'Alice', email: 'alice@example.com' }, 2: { id: 2, name: 'Bob', email: 'bob@example.com' } }; app.get('/profile/:userId', (req, res) => { const userId = parseInt(req.params.userId); const user = users[userId]; if (!user) return res.status(404).send('User not found'); res.json(user); }); const PORT = 4000; app.listen(PORT, () => console.log('Horizontal Privilege Escalation Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Exploit a weak password policy to guess a user's password.",
  "Lab Description": "The application enforces a weak password policy that allows very short and simple passwords (e.g., minimum 3 characters, no complexity requirements). Your task is to guess the password for the user 'user1' and log into their account. Hint: The password is a common three-letter word.",
  "Vulnerability name": "Weak Password Policy",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Simulated database with user credentials\nconst users = { 'user1': 'cat', 'admin': 'dog' };\n\n// Serve the login page\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\" placeholder=\"Username\"><input name=\"password\" type=\"password\" placeholder=\"Password\"><button type=\"submit\">Login</button></form>');\n});\n\n// Handle login attempts\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.send(`Welcome, ${username}!`);\n  } else {\n    res.status(401).send('Login failed');\n  }\n});\n\nconst PORT = 8000;\napp.listen(PORT, () => console.log(`Weak Password Policy Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "SAML Authentication Bypass via XML Comment Injection and Signature Wrapping",
  "Lab Description": "This lab implements a vulnerable SAML-based SSO system that improperly validates XML signatures and allows comment injection in assertions. Attackers can manipulate SAML responses to impersonate administrators. To solve the lab: 1. Capture a valid SAML response during login. 2. Inject XML comments to alter the NameID and attributes while preserving the valid signature. 3. Bypass signature validation to access the /internal/dashboard as an administrator and execute the system shutdown command.",
  "Vulnerability name": "Authentication",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst xmldom = require('xmldom');\nconst xpath = require('xpath');\nconst crypto = require('crypto');\nconst app = express();\napp.use(bodyParser.text({ type: '*/xml' }));\n\nconst trustedCertificate = `-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvZxTR6...\n-----END PUBLIC KEY-----`;\n\n// Simulated IdP metadata\nconst idpMetadata = {\n  issuer: 'https://saml-idp.example.com',\n  signingCert: trustedCertificate\n};\n\n// Vulnerable SAML validation\nconst validateSamlResponse = (samlResponse) => {\n  const doc = new xmldom.DOMParser().parseFromString(samlResponse);\n  \n  // Extract signature\n  const signature = xpath.select(\"//*[local-name()='Signature']\", doc)[0];\n  if (!signature) return false;\n  \n  // Verify signature cryptographically\n  const verifier = crypto.createVerify('RSA-SHA256');\n  const signedInfo = xpath.select(\".//*[local-name()='SignedInfo']\", signature)[0].toString();\n  verifier.update(signedInfo);\n  \n  const signatureValue = xpath.select(\".//*[local-name()='SignatureValue']\", signature)[0].textContent;\n  const validSig = verifier.verify(idpMetadata.signingCert, signatureValue, 'base64');\n  \n  // Critical flaw: Doesn't re-validate parsed data after signature check\n  return validSig;\n};\n\napp.post('/saml/acs', async (req, res) => {\n  try {\n    if (!validateSamlResponse(req.body)) return res.status(403).send('Invalid SAML response');\n    \n    // Vulnerable XML parsing with comment preservation\n    const parser = new xml2js.Parser({ preserveChildren: true, explicitChildren: true });\n    const result = await parser.parseStringPromise(req.body);\n    \n    // Extract NameID with comment injection vulnerability\n    const assertion = result['samlp:Response']['saml:Assertion'][0];\n    const nameId = assertion['saml:Subject'][0]['saml:NameID'][0];\n    \n    // Process attributes without proper validation\n    const attributes = assertion['saml:AttributeStatement'][0]['saml:Attribute'];\n    const roles = attributes.find(a => a.$.Name === 'roles')['saml:AttributeValue'];\n    \n    // Grant access based on manipulated values\n    if (roles.includes('admin')) {\n      res.send('Admin dashboard: <button onclick=\"fetch('/internal/shutdown')\">SHUTDOWN</button>');\n    } else {\n      res.status(403).send('Insufficient privileges');\n    }\n  } catch (error) {\n    res.status(500).send('SAML processing error');\n  }\n});\n\napp.post('/internal/shutdown', (req, res) => {\n  res.send('Critical systems halted - Lab solved');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`SAML Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Predictable Password Reset Tokens",
  "Lab Description": "This lab's password reset functionality uses predictable tokens that follow a simple pattern (e.g., 'user1-reset', 'user2-reset'). Attackers can guess other users' reset tokens to reset their passwords. To solve the lab, reset the password for the 'admin' account by guessing its reset token.",
  "Vulnerability name": "Authentication",
  "lab level": "Medium",
  "src code": "const express = require('express'); const app = express(); const users = { 'user1': { password: 'password1', resetToken: 'user1-reset' }, 'admin': { password: 'admin123', resetToken: 'admin-reset' } }; app.get('/reset-password/:token', (req, res) => { const token = req.params.token; const user = Object.keys(users).find(u => users[u].resetToken === token); if (!user) return res.status(404).send('Invalid reset token'); users[user].password = 'newPassword'; res.send('Password reset successful for ' + user); }); const PORT = 4000; app.listen(PORT, () => console.log('Predictable Reset Token Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Exploit hardcoded credentials to log in as an admin user.",
  "Lab Description": "The application contains hardcoded credentials embedded in its source code. Your task is to examine the code, identify the admin username and password, and use them to log in. Once successful, you'll see a welcome message confirming your access as an admin.",
  "Vulnerability name": "Hardcoded Credentials",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Hardcoded admin credentials\nconst ADMIN_USERNAME = 'admin';\nconst ADMIN_PASSWORD = 'secret123';\n\n// Serve the login page\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\" placeholder=\"Username\"><input name=\"password\" type=\"password\" placeholder=\"Password\"><button type=\"submit\">Login</button></form>');\n});\n\n// Handle login attempts\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === ADMIN_USERNAME && password === ADMIN_PASSWORD) {\n    res.send(`Welcome, ${username}! You have admin access.`);\n  } else {\n    res.status(401).send('Login failed: Incorrect username or password');\n  }\n});\n\nconst PORT = 9000;\napp.listen(PORT, () => console.log(`Hardcoded Credentials Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Predictable Session Tokens",
  "Lab Description": "This lab uses predictable session tokens derived from usernames. When a user logs in, the session token is set to 'user-<username>'. An attacker can guess other users' session tokens by knowing their usernames. To solve the lab, access another user's profile by modifying the session token in the cookie.",
  "Vulnerability name": "Authentication",
  "lab level": "Medium",
  "src code": "const express = require('express'); const app = express(); const users = [{ username: 'alice', password: 'password123' }, { username: 'bob', password: 'password456' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); // Set predictable session token res.cookie('session', 'user-' + user.username); res.send('Welcome, ' + username); }); app.get('/profile', (req, res) => { const session = req.cookies.session; if (!session) return res.status(401).send('Unauthorized'); const parts = session.split('-'); if (parts.length !== 2 || parts[0] !== 'user') return res.status(401).send('Invalid session'); const username = parts[1]; const user = users.find(u => u.username === username); if (!user) return res.status(401).send('Unauthorized'); res.send('Profile for ' + username); }); const PORT = 4000; app.listen(PORT, () => console.log('Predictable Session Tokens Lab running on http://localhost:' + PORT));"
},
{
  "Lab scenario": "Exploit an insecure authentication mechanism by manipulating a cookie to bypass the login process.",
  "Lab Description": "The application uses a cookie named 'authenticated' to determine if a user is logged in. If the cookie is set to 'true', the application grants access to the protected area without checking the user's credentials. To solve the lab, use your browser's developer tools to set the 'authenticated' cookie to 'true' and then visit the '/account' page to gain access without logging in.",
  "Vulnerability name": "Authentication Bypass via Cookie Manipulation",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(cookieParser());\nconst users = { 'user': 'pass' };\napp.get('/login', (req, res) => {\n  res.send(\"<form method='post'><input name='username'><input name='password' type='password'><button type='submit'>Login</button></form>\");\n});\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.cookie('authenticated', 'true');\n    res.redirect('/account');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/account', (req, res) => {\n  if (req.cookies.authenticated === 'true') {\n    res.send('Welcome to your account!');\n  } else {\n    res.status(401).send('Please log in');\n  }\n});\nconst PORT = 10000;\napp.listen(PORT, () => console.log(`Authentication Bypass Lab running on http://localhost:${PORT}`));"
},
{
  "Lab scenario": "Bypass Session Termination via Stale Password Hash Validation",
  "Lab Description": "This lab's authentication system fails to invalidate existing sessions after password changes, allowing attackers to maintain persistent access using old credentials. To solve the lab: 1. Authenticate with Carlos's credentials (user: carlos, password: Summer2024). 2. Change Carlos's password while preserving your active session. 3. Use the original session cookie to access the /admin/export endpoint and download sensitive financial records. The system only validates sessions against initial password hashes, not current credentials.",
  "Vulnerability name": "Authentication",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\napp.use(bodyParser.json());\n\nconst users = [{\n  username: 'carlos',\n  passwordHash: crypto.createHash('sha256').update('Summer2024').digest('hex'),\n  isAdmin: true\n}];\n\nconst sessions = new Map();\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username);\n  \n  if (!user || user.passwordHash !== crypto.createHash('sha256').update(password).digest('hex')) {\n    return res.status(401).send('Invalid credentials');\n  }\n\n  const sessionId = crypto.randomBytes(16).toString('hex');\n  sessions.set(sessionId, {\n    username: user.username,\n    passwordHash: user.passwordHash // Storing password hash at time of login\n  });\n\n  res.cookie('session', sessionId, { httpOnly: true });\n  res.send('Logged in successfully');\n});\n\napp.post('/change-password', (req, res) => {\n  const sessionId = req.cookies.session;\n  const { newPassword } = req.body;\n  \n  if (!sessions.has(sessionId)) return res.status(401).send('Unauthorized');\n  \n  const user = users.find(u => u.username === sessions.get(sessionId).username);\n  user.passwordHash = crypto.createHash('sha256').update(newPassword).digest('hex');\n  \n  // Critical flaw: Doesn't update existing sessions' passwordHash\n  res.send('Password changed successfully');\n});\n\napp.get('/admin/export', (req, res) => {\n  const sessionId = req.cookies.session;\n  const session = sessions.get(sessionId);\n  \n  if (!session) return res.status(401).send('Unauthorized');\n  \n  const user = users.find(u => u.username === session.username);\n  \n  // Vulnerability: Only checks initial password hash, not current\n  if (session.passwordHash === user.passwordHash && user.isAdmin) {\n    res.send('ADMIN DATA: All financial records downloaded');\n  } else {\n    res.status(403).send('Admin access required');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Session Lab running on http://localhost:${PORT}`));"
}

  
  
  
  
  
  
  
  
  
  

  ]