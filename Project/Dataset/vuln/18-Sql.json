[
  {
    "Lab scenario": "SQL injection vulnerability in WHERE clause allowing retrieval of hidden data",
  "Lab Description": "This lab contains a SQL injection vulnerability in the product category filter. When the user selects a category, the application carries out a SQL query like the following:\nSELECT * FROM products WHERE category = 'Gifts' AND released = 1\nTo solve the lab, perform a SQL injection attack that causes the application to display one or more unreleased products.",
  "Vulnerability name": "SQL injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\n// Create an in-memory SQLite database\nconst db = new sqlite3.Database(':memory:');\n\n// Create products table with released flag\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, category TEXT, released INTEGER)\");\n  db.run(\"INSERT INTO products (name, category, released) VALUES ('Teddy Bear', 'Gifts', 1)\");\n  db.run(\"INSERT INTO products (name, category, released) VALUES ('Secret Item', 'Gifts', 0)\");\n  db.run(\"INSERT INTO products (name, category, released) VALUES ('Tech Gadget', 'Electronics', 1)\");\n});\n\napp.get('/', (req, res) => {\n  res.send(`\n    <h1>Product Search</h1>\n    <form method=\"GET\" action=\"/products\">\n      <label for=\"category\">Category:</label>\n      <input type=\"text\" id=\"category\" name=\"category\" value=\"Gifts\">\n      <button type=\"submit\">Show Products</button>\n    </form>\n  `);\n});\n\n// Vulnerable product route\napp.get('/products', (req, res) => {\n  const category = req.query.category;\n  const query = `SELECT * FROM products WHERE category = '${category}' AND released = 1`;\n\n  console.log(\"Executing query:\", query);\n  \n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error fetching products\");\n    } else {\n      res.send(`\n        <h2>Products in ${category}</h2>\n        <ul>\n          ${rows.map(p => `<li>${p.name}</li>`).join('')}\n        </ul>\n      `);\n    }\n  });\n});\n\n// Start server\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
  },
  {
    "Lab scenario": "SQL injection in login form allowing authentication bypass",
  "Lab Description": "This lab contains a SQL injection vulnerability in the login functionality. The application constructs a SQL query using unsanitized user inputs, allowing attackers to bypass authentication.\nTo solve the lab, exploit the SQL injection vulnerability to log in as the administrator without a valid password.",
  "Vulnerability name": "SQL injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Create an in-memory SQLite database\nconst db = new sqlite3.Database(':memory:');\n\n// Create a table and populate it with sample user data\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user', 'user123')\");\n});\n\n// Serve the login form\napp.get('/', (req, res) => {\n  res.send(`\n    <h1>Login</h1>\n    <form method=\"POST\" action=\"/login\">\n      <label for=\"username\">Username:</label>\n      <input type=\"text\" id=\"username\" name=\"username\"><br><br>\n      <label for=\"password\">Password:</label>\n      <input type=\"password\" id=\"password\" name=\"password\"><br><br>\n      <button type=\"submit\">Login</button>\n    </form>\n  `);\n});\n\n// Vulnerable login route\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n\n  // Vulnerable query: directly using user inputs without sanitization\n  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  console.log(\"Executing query:\", query);\n\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred during login.\");\n    } else if (rows.length > 0) {\n      res.send(`Welcome, ${rows[0].username}!`);\n    } else {\n      res.send(\"Invalid credentials.\");\n    }\n  });\n});\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running at http://localhost:${PORT}`);\n});"
  },
  {
    "Lab scenario": "SQL injection attack, querying the database type and version on Oracle",
    "Lab Description": "This lab contains a SQL injection vulnerability in the product category filter. You can use a UNION attack to retrieve the results from an injected query.\nTo solve the lab, display the database version string.",
    "Vulnerability name": "SQL injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\n// Create an in-memory SQLite database\nconst db = new sqlite3.Database(':memory:');\n\n// Create a table and populate it with sample data\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, category TEXT, released INTEGER)\");\n  db.run(\"INSERT INTO products (name, category, released) VALUES ('Teddy Bear', 'Gifts', 1)\");\n  db.run(\"INSERT INTO products (name, category, released) VALUES ('Unreleased Puzzle', 'Gifts', 0)\");\n  db.run(\"INSERT INTO products (name, category, released) VALUES ('Smartphone', 'Electronics', 1)\");\n});\n\napp.get('/', (req, res) => {\n  res.send(`\n    <form method=\"GET\" action=\"/products\">\n      <label for=\"category\">Category:</label>\n      <input type=\"text\" id=\"category\" name=\"category\">\n      <button type=\"submit\">Search</button>\n    </form>\n  `);\n});\n\n// Vulnerable route\napp.get('/products', (req, res) => {\n  const category = req.query.category; // Directly using user input without sanitization // vulnerability is here \n  const query = `SELECT * FROM products WHERE category = '${category}' AND released = 1`;\n\n  console.log(\"Executing query:\", query);\n  \n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error executing query.\");\n    } else {\n      res.send(`\n        <h2>Products</h2>\n        <ul>\n          ${rows.map(row => `<li>${row.name}</li>`).join('')}\n        </ul>\n      `);\n    }\n  });\n});\n\n// Simulate database information retrieval for UNION-based injection\napp.get('/database-info', (req, res) => {\n  // Static response to simulate UNION attack\n  const simulatedResponse = [\n    { version: 'SQLite 3.32.3' },\n    { version: 'Oracle 19c' }\n  ];\n  res.json(simulatedResponse);\n});\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Server is running on http://localhost:${PORT}`);\n});"
  },
  {
    "Lab scenario": "SQL injection attack, listing the database contents on Oracle",
    "Lab Description": "This lab contains a SQL injection vulnerability in the product category filter. The results from the query are returned in the application's response so you can use a UNION attack to retrieve data from other tables.\nThe application has a login function, and the database contains a table that holds usernames and passwords. You need to determine the name of this table and the columns it contains, then retrieve the contents of the table to obtain the username and password of all users.\nTo solve the lab, log in as the administrator user.",
    "Vulnerability name": "SQL injection",
    "lab level": "Medium",
    "src code":"const express = require('express');\nconst sqlite3 = require('sqlite3').verbose(); // Simulating Oracle-like database\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Create an in-memory SQLite database\nconst db = new sqlite3.Database(':memory:');\n\n// Create tables and populate them with sample data\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'user123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user2', 'user456')\");\n\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, category TEXT)\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product 1', 'Gifts')\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product 2', 'Electronics')\");\n});\n\n// Root route for instructions\napp.get('/', (req, res) => {\n  res.send(`\n    <h1>SQL Injection Lab - Oracle</h1>\n    <p>This lab demonstrates SQL Injection vulnerability allowing enumeration and extraction of database contents.</p>\n    <ul>\n      <li><a href=\"/products?category=Gifts\">View Products in 'Gifts' Category</a></li>\n      <li>Inject queries to enumerate database schema and retrieve user credentials.</li>\n    </ul>\n  `);\n});\n\n// Vulnerable products route\napp.get('/products', (req, res) => {\n  const category = req.query.category || '';\n  const query = `SELECT * FROM products WHERE category = '${category}'`;\n  console.log(\"Executing query:\", query);\n\n  if (category.includes(\"UNION\")) {\n    if (category.includes(\"sqlite_master\")) {\n      res.send(`\n        <h2>Database Schema</h2>\n        <ul>\n          <li>users: id, username, password</li>\n          <li>products: id, name, category</li>\n        </ul>\n      `);\n    } else if (category.includes(\"users\")) {\n      res.send(`\n        <h2>User Credentials</h2>\n        <ul>\n          <li>administrator: admin123</li>\n          <li>user1: user123</li>\n          <li>user2: user456</li>\n        </ul>\n      `);\n    } else {\n      res.send(\"Invalid UNION query.\");\n    }\n  } else {\n    db.all(query, [], (err, rows) => {\n      if (err) {\n        console.error(\"Error executing query:\", err.message);\n        res.status(500).send(\"Error occurred.\");\n      } else {\n        res.send(`\n          <h2>Products</h2>\n          <ul>\n            ${rows.map(row => `<li>${row.name}</li>`).join('')}\n          </ul>\n        `);\n      }\n    });\n  }\n});\n\n// Vulnerable login route\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n\n  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  console.log(\"Executing query:\", query);\n\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred during login.\");\n    } else if (rows.length > 0) {\n      res.send(`Welcome, ${rows[0].username}!`);\n    } else {\n      res.send(\"Invalid credentials.\");\n    }\n  });\n});\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
  },
  {
    "Lab scenario": "SQL injection UNION attack, determining the number of columns returned by the query",
    "Lab Description": "This lab contains a SQL injection vulnerability in the product category filter. The results from the query are returned in the application's response, so you can use a UNION attack to retrieve data from other tables. The first step of such an attack is to determine the number of columns that are being returned by the query. You will then use this technique in subsequent labs to construct the full attack.\nTo solve the lab, determine the number of columns returned by the query by performing a SQL injection UNION attack that returns an additional row containing null values.",
    "Vulnerability name": "SQL injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Create an in-memory SQLite database\nconst db = new sqlite3.Database(':memory:');\n\n// Create a table and populate it with sample data\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, category TEXT)\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product 1', 'Gifts')\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product 2', 'Electronics')\");\n});\n\n// Root route for instructions\napp.get('/', (req, res) => {\n  res.send(`\n    <h1>SQL Injection Lab - Determine Columns</h1>\n    <p>This lab demonstrates SQL Injection vulnerability for determining the number of columns.</p>\n    <ul>\n      <li><a href=\"/products?category=Gifts\">View Products in 'Gifts' Category</a></li>\n      <li>Inject queries to determine the number of columns returned.</li>\n    </ul>\n  `);\n});\n\n// Vulnerable route for products\napp.get('/products', (req, res) => {\n  const category = req.query.category || '';\n  const query = `SELECT * FROM products WHERE category = '${category}'`;\n  console.log(\"Executing query:\", query);\n\n  if (category.includes(\"UNION\")) {\n    res.send(`\n      <h2>Column Count</h2>\n      <p>The query returns 2 columns: id, name.</p>\n    `);\n  } else {\n    db.all(query, [], (err, rows) => {\n      if (err) {\n        console.error(\"Error executing query:\", err.message);\n        res.status(500).send(\"Error occurred.\");\n      } else {\n        res.send(`\n          <h2>Products</h2>\n          <ul>\n            ${rows.map(row => `<li>${row.name}</li>`).join('')}\n          </ul>\n        `);\n      }\n    });\n  }\n});\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});" 
  },
  {
    "Lab scenario": "SQL injection UNION attack, finding a column containing text",
    "Lab Description": "This lab contains a SQL injection vulnerability in the product category filter. The results from the query are returned in the application's response, so you can use a UNION attack to retrieve data from other tables. To construct such an attack, you first need to determine the number of columns returned by the query. You can do this using a technique you learned in a previous lab. The next step is to identify a column that is compatible with string data.\nThe lab will provide a random value that you need to make appear within the query results. To solve the lab, perform a SQL injection UNION attack that returns an additional row containing the value provided. This technique helps you determine which columns are compatible with string data.",
    "Vulnerability name": "SQL injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Create an in-memory SQLite database\nconst db = new sqlite3.Database(':memory:');\n\n// Create a table and populate it with sample data\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, category TEXT)\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product 1', 'Gifts')\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product 2', 'Electronics')\");\n});\n\n// Root route for instructions\napp.get('/', (req, res) => {\n  res.send(`\n    <h1>SQL Injection Lab - Find Text-Compatible Column</h1>\n    <p>This lab demonstrates SQL Injection vulnerability to identify string-compatible columns using UNION attacks.</p>\n    <ul>\n      <li><a href=\"/products?category=Gifts\">View Products in 'Gifts' Category</a></li>\n      <li>Try SQL Injection by modifying the 'category' parameter in the URL.</li>\n      <li>Example: <code>?category=Gifts' UNION SELECT NULL, 'test' -- </code></li>\n    </ul>\n  `);\n});\n\n// Vulnerable products route\napp.get('/products', (req, res) => {\n  const category = req.query.category || '';\n  const query = `SELECT * FROM products WHERE category = '${category}'`; // Vulnerable query\n  console.log(\"Executing query:\", query);\n\n  // Handle UNION injection detection\n  if (category.includes(\"UNION\")) {\n    const testValue = \"test_string\"; // Simulated test value to inject\n    if (category.includes(\"NULL, 'test_string'\")) {\n      res.send(`\n        <h2>Column Compatibility</h2>\n        <p>The second column ('name') is compatible with string data.</p>\n      `);\n    } else {\n      res.send(`\n        <h2>Invalid Injection</h2>\n        <p>Ensure your UNION attack is formatted correctly.</p>\n      `);\n    }\n  } else {\n    // Normal query execution\n    db.all(query, [], (err, rows) => {\n      if (err) {\n        console.error(\"Error executing query:\", err.message);\n        res.status(500).send(\"Error occurred.\");\n      } else {\n        res.send(`\n          <h2>Products</h2>\n          <ul>\n            ${rows.map(row => `<li>${row.name}</li>`).join('')}\n          </ul>\n        `);\n      }\n    });\n  }\n});\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
  },
  {
    "Lab scenario": "SQL injection UNION attack, retrieving data from other tables",
    "Lab Description": "This lab contains a SQL injection vulnerability in the product category filter. The results from the query are returned in the application's response, so you can use a UNION attack to retrieve data from other tables. To construct such an attack, you need to combine some of the techniques you learned in previous labs.\nThe database contains a different table called users, with columns called username and password.\nTo solve the lab, perform a SQL injection UNION attack that retrieves all usernames and passwords, and use the information to log in as the administrator user.",
    "Vulnerability name": "SQL injection",
    "Lab Level":"Hard",
     "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Create an in-memory SQLite database\nconst db = new sqlite3.Database(':memory:');\n\n// Create tables and populate them with sample data\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'password1')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user2', 'password2')\");\n\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, category TEXT)\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product A', 'Gifts')\");\n  db.run(\"INSERT INTO products (name, category) VALUES ('Product B', 'Electronics')\");\n});\n\n// Root route with instructions\napp.get('/', (req, res) => {\n  res.send(`\n    <h1>SQL Injection Lab - Retrieving Data from Other Tables</h1>\n    <p>This lab demonstrates an SQL Injection vulnerability that allows attackers to retrieve data from other tables.</p>\n    <ul>\n      <li><a href=\"/products?category=Gifts\">View Products in 'Gifts' Category</a></li>\n      <li>Try SQL Injection by modifying the 'category' parameter in the URL.</li>\n      <li>Example: <code>?category=Gifts' UNION SELECT username, password FROM users -- </code></li>\n    </ul>\n  `);\n});\n\n// Vulnerable products route\napp.get('/products', (req, res) => {\n  const category = req.query.category || '';\n  const query = `SELECT name, category FROM products WHERE category = '${category}'`; // Vulnerable query\n  console.log(\"Executing query:\", query);\n\n  if (category.includes(\"UNION\")) {\n    if (category.includes(\"users\")) {\n      res.send(`\n        <h2>User Credentials</h2>\n        <ul>\n          <li>administrator: admin123</li>\n          <li>user1: password1</li>\n          <li>user2: password2</li>\n        </ul>\n      `);\n    } else {\n      res.send(\"Invalid UNION query.\");\n    }\n  } else {\n    db.all(query, [], (err, rows) => {\n      if (err) {\n        console.error(\"Error executing query:\", err.message);\n        res.status(500).send(\"Error occurred.\");\n      } else {\n        res.send(`\n          <h2>Products</h2>\n          <ul>\n            ${rows.map(row => `<li>${row.name}</li>`).join('')}\n          </ul>\n        `);\n      }\n    });\n  }\n});\n\n// Vulnerable login route\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n\n  // Vulnerable query: directly using user inputs without sanitization\n  const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n  console.log(\"Executing query:\", query);\n\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred during login.\");\n    } else if (rows.length > 0) {\n      res.send(`Welcome, ${rows[0].username}!\");\n    } else {\n      res.send(\"Invalid credentials.\");\n    }\n  });\n});\n\n// Start the server\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
  },
  {
  "Lab scenario": "Blind SQL injection with conditional responses",
  "Lab Description": "This lab contains a blind SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs a SQL query containing the value of the submitted cookie.\nThe results of the SQL query are not returned, and no error messages are displayed. But the application includes a Welcome back message in the page if the query returns any rows.\nThe database contains a different table called users, with columns called username and password. You need to exploit the blind SQL injection vulnerability to find out the password of the administrator user.\nTo solve the lab, log in as the administrator user.",
  "Vulnerability name": "SQL injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(cookieParser());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'password1')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user2', 'password2')\");\n});\n\napp.get('/', (req, res) => {\n  const trackingId = req.cookies.tracking || '';\n\n  const query = `SELECT CASE WHEN EXISTS (SELECT 1 FROM users WHERE username='administrator' AND password LIKE '${trackingId}%') THEN 1 ELSE 0 END AS result`;\n  console.log(\"Executing query:\", query);\n\n  db.get(query, [], (err, row) => {\n    if (err) {\n      console.error(\"SQL Error:\", err.message);\n      return res.status(500).send(\"Internal Server Error\");\n    }\n    \n    if (row && row.result === 1) {\n      res.send('<h1>Welcome back!</h1>');\n    } else {\n      res.send('<h1>Welcome to our site</h1>');\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
  
  },
  {
    "Lab scenario": "Blind SQL injection with conditional errors",
    "Lab Description": "This lab contains a blind SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs a SQL query containing the value of the submitted cookie.\nThe results of the SQL query are not returned, and the application does not respond any differently based on whether the query returns any rows. If the SQL query causes an error, then the application returns a custom error message.\nThe database contains a different table called users, with columns called username and password. You need to exploit the blind SQL injection vulnerability to find out the password of the administrator user.\nTo solve the lab, log in as the administrator user.",
    "Vulnerability name": "SQL injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(cookieParser());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run('CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)');\n  db.run('INSERT INTO users (username, password) VALUES (\"administrator\", \"admin123\")');\n  db.run('INSERT INTO users (username, password) VALUES (\"user1\", \"password1\")');\n  db.run('INSERT INTO users (username, password) VALUES (\"user2\", \"password2\")');\n});\n\napp.get('/', (req, res) => {\n  const trackingId = req.cookies.tracking || '';\n\n  // Vulnerable SQL query using the cookie value\n  const query = `SELECT CASE WHEN EXISTS (SELECT 1 FROM users WHERE username='administrator' AND password LIKE '${trackingId}%') THEN 1 ELSE 0 END AS result`;\n  console.log('Executing query:', query);\n\n  db.get(query, [], (err, row) => {\n    if (err) {\n      console.error('SQL Error:', err.message);\n      return res.status(500).send('Internal Server Error');\n    }\n    \n    if (row && row.result === 1) {\n      res.send('<h1>Welcome back!</h1>');\n    } else {\n      res.send('<h1>Welcome to our site</h1>');\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
    
  },
  {
    "Lab scenario": "Visible error-based SQL injection",
    "Lab Description": "This lab contains a SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs a SQL query containing the value of the submitted cookie. The results of the SQL query are not returned.\nThe database contains a different table called users, with columns called username and password. To solve the lab, find a way to leak the password for the administrator user, then log in to their account.",
    "Vulnerability name": "SQL injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(cookieParser());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run('CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)');\n  db.run('INSERT INTO users (username, password) VALUES (\"administrator\", \"admin123\")');\n  db.run('INSERT INTO users (username, password) VALUES (\"user1\", \"password1\")');\n  db.run('INSERT INTO users (username, password) VALUES (\"user2\", \"password2\")');\n});\n\napp.get('/', (req, res) => {\n  const trackingId = req.cookies.tracking || '';\n  \n  // Vulnerable SQL query using the cookie value\n  const query = `SELECT * FROM users WHERE username='administrator' AND password LIKE '${trackingId}%'`;\n  console.log('Executing query:', query);\n\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(err.message); // Visible SQL error\n    } else {\n      res.send('<h1>Welcome to our site</h1>');\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
    
  },
  {
    "Lab scenario": "Blind SQL injection with time delays",
    "Lab Description": "This lab contains a blind SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs a SQL query containing the value of the submitted cookie.\nThe results of the SQL query are not returned, and the application does not respond any differently based on whether the query returns any rows or causes an error. However, since the query is executed synchronously, it is possible to trigger conditional time delays to infer information.\nTo solve the lab, exploit the SQL injection vulnerability to cause a 10 second delay.",
    "Vulnerability name": "SQL injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst cookieParser = require('cookie-parser');\nconst app = express();\napp.use(cookieParser());\nconst db = new sqlite3.Database(':memory:');\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'password1')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user2', 'password2')\");\n});\napp.get('/', (req, res) => {\n  const trackingId = req.cookies.tracking || '';\n  const query = `SELECT CASE WHEN (1=1) THEN randomblob(1000000000) ELSE NULL END FROM users WHERE username='administrator' AND password LIKE '${trackingId}%'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) {\n      res.status(500).send(\"Internal Server Error\");\n    } else {\n      res.send('<h1>Welcome to our site</h1>');\n    }\n  });\n});\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
     
  },
  {
    "Lab scenario": "Blind SQL injection with time delays and information retrieval",
    "Lab Description": "This lab contains a blind SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs a SQL query containing the value of the submitted cookie.\nThe results of the SQL query are not returned, and the application does not respond any differently based on whether the query returns any rows or causes an error. However, since the query is executed synchronously, it is possible to trigger conditional time delays to infer information.\nThe database contains a different table called users, with columns called username and password. You need to exploit the blind SQL injection vulnerability to find out the password of the administrator user.\nTo solve the lab, log in as the administrator user.",
    "Vulnerability name": "SQL injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst cookieParser = require('cookie-parser');\n\nconst app = express();\napp.use(cookieParser());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'password1')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user2', 'password2')\");\n});\n\napp.get('/', (req, res) => {\n  const trackingId = req.cookies.tracking || '';\n  const query = `SELECT CASE WHEN (1=1) THEN randomblob(100000000) ELSE NULL END FROM users WHERE username='administrator' AND password LIKE '${trackingId}%'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) {\n      res.status(500).send(\"Internal Server Error\");\n    } else {\n      res.send('<h1>Welcome to our site</h1>');\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
    
  },
  {
    "Lab scenario": "Blind SQL injection with out-of-band interaction",
  "Lab Description": "This lab contains a blind SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs a SQL query containing the value of the submitted cookie.\nThe SQL query is executed asynchronously and has no effect on the application's response. However, you can trigger out-of-band interactions with an external domain.\nTo solve the lab, exploit the SQL injection vulnerability to cause a DNS lookup to Burp Collaborator.",
  "Vulnerability name": "SQL injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst cookieParser = require('cookie-parser');\nconst dns = require('dns');\n\nconst app = express();\napp.use(cookieParser());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'password1')\");\n});\n\napp.get('/', (req, res) => {\n  const trackingId = req.cookies.trackingId || '1';\n  const query = `SELECT username FROM users WHERE id = ${trackingId}`;\n  db.get(query, (err, row) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else if (row) {\n      res.send(`Welcome, ${row.username}!`);\n    } else {\n      res.send(\"User not found.\");\n    }\n  });\n});\n\napp.get('/dns', (req, res) => {\n  const trackingId = req.cookies.trackingId || '1';\n  const domain = 'example.com'; // Replace with Burp Collaborator domain\n  dns.lookup(trackingId + '.' + domain, (err, address, family) => {\n    if (err) {\n      res.status(500).send(\"DNS lookup failed.\");\n    } else {\n      res.send(`DNS lookup successful: ${address}`);\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
  
  },
  {
    "Lab scenario": "Blind SQL injection with out-of-band data exfiltration",
    "Lab Description": "This lab contains a blind SQL injection vulnerability. The application uses a tracking cookie for analytics, and performs a SQL query containing the value of the submitted cookie.\nThe SQL query is executed asynchronously and has no effect on the application's response. However, you can trigger out-of-band interactions with an external domain.\nThe database contains a different table called users, with columns called username and password. You need to exploit the blind SQL injection vulnerability to find out the password of the administrator user.\nTo solve the lab, log in as the administrator user.",
    "Vulnerability name": "SQL injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst cookieParser = require('cookie-parser');\nconst dns = require('dns');\n\nconst app = express();\napp.use(cookieParser());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'password1')\");\n});\n\napp.get('/', (req, res) => {\n  const trackingId = req.cookies.trackingId || '1';\n  const query = `SELECT username FROM users WHERE id = ${trackingId}`;\n  db.get(query, (err, row) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else if (row) {\n      res.send(`Welcome, ${row.username}!`);\n    } else {\n      res.send(\"User not found.\");\n    }\n  });\n});\n\napp.get('/dns', (req, res) => {\n  const trackingId = req.cookies.trackingId || '1';\n  const domain = 'example.com'; // Replace with Burp Collaborator domain\n  dns.lookup(trackingId + '.' + domain, (err, address, family) => {\n    if (err) {\n      res.status(500).send(\"DNS lookup failed.\");\n    } else {\n      res.send(`DNS lookup successful: ${address}`);\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});" 
  },
  {
    "Lab scenario": "SQL injection with filter bypass via XML encoding",
    "Lab Description": "This lab contains a SQL injection vulnerability in its stock check feature. The results from the query are returned in the application's response, so you can use a UNION attack to retrieve data from other tables.\nThe database contains a users table, which contains the usernames and passwords of registered users. To solve the lab, perform a SQL injection attack to retrieve the admin user's credentials, then log in to their account.",
    "Vulnerability name": "SQL injection",
     "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\n\nconst app = express();\napp.use(bodyParser.text({ type: 'application/xml' }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'password1')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user2', 'password2')\");\n\n  db.run(\"CREATE TABLE stock (id INTEGER PRIMARY KEY, product TEXT, quantity INTEGER)\");\n  db.run(\"INSERT INTO stock (product, quantity) VALUES ('Laptop', 10)\");\n  db.run(\"INSERT INTO stock (product, quantity) VALUES ('Phone', 20)\");\n});\n\napp.post('/stock', (req, res) => {\n  xml2js.parseString(req.body, (err, result) => {\n    if (err) {\n      res.status(400).send(\"Invalid XML\");\n      return;\n    }\n    const product = result.stock.product[0];\n    const query = `SELECT product, quantity FROM stock WHERE product = '${product}'`;\n    console.log(\"Executing query:\", query);\n\n    db.all(query, [], (err, rows) => {\n      if (err) {\n        res.status(500).send(\"Error occurred.\");\n      } else {\n        res.json(rows);\n      }\n    });\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(`Lab running on http://localhost:${PORT}`);\n});"
  },
  {
    "Lab scenario": "SQL injection in search filter with parameter manipulation",
    "Lab Description": "This lab simulates a search endpoint where user-provided filters are concatenated into a query. The lack of proper sanitization allows attackers to manipulate parameters to retrieve unauthorized data.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE items (id INTEGER PRIMARY KEY, name TEXT, price REAL)\");\n  db.run(\"INSERT INTO items (name, price) VALUES ('Book', 10.99)\");\n});\n\napp.get('/filter', (req, res) => {\n  const filter = req.query.filter;\n  const query = SELECT * FROM items WHERE name = '${filter}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection with dynamic sorting vulnerability",
    "Lab Description": "This lab exposes a vulnerability where the sort column in a query is dynamically constructed from user input without proper validation. Attackers can inject arbitrary SQL into the ORDER BY clause.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price REAL)\");\n  db.run(\"INSERT INTO products (name, price) VALUES ('Phone', 699)\");\n});\n\napp.get('/sort', (req, res) => {\n  const sortBy = req.query.sortBy;\n  const query = SELECT * FROM products ORDER BY ${sortBy};\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in report generation with unsanitized date inputs",
    "Lab Description": "This lab simulates a reporting system where date parameters are not validated. Attackers can inject malicious SQL in the date fields to manipulate report queries.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE reports (id INTEGER PRIMARY KEY, report_date TEXT, content TEXT)\");\n  db.run(\"INSERT INTO reports (report_date, content) VALUES ('2023-01-01', 'Initial Report')\");\n});\n\napp.post('/report', (req, res) => {\n  const date = req.body.date;\n  const query = SELECT * FROM reports WHERE report_date = '${date}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in file download endpoint",
    "Lab Description": "This lab demonstrates a vulnerability in a file download feature where user input is directly appended to the SQL query. Attackers can modify the query to download unintended files.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE files (id INTEGER PRIMARY KEY, filename TEXT, content TEXT)\");\n  db.run(\"INSERT INTO files (filename, content) VALUES ('secret.txt', 'Top secret file content')\");\n});\n\napp.get('/download', (req, res) => {\n  const file = req.query.file;\n  const query = SELECT content FROM files WHERE filename = '${file}';\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (row) res.send(row.content);\n    else res.send('File not found');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in data export functionality",
    "Lab Description": "This lab simulates a data export module where user inputs are concatenated into an SQL query, allowing attackers to modify the export query and extract additional data.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE exportData (id INTEGER PRIMARY KEY, info TEXT)\");\n  db.run(\"INSERT INTO exportData (info) VALUES ('Sensitive Export Data')\");\n});\n\napp.post('/export', (req, res) => {\n  const filter = req.body.filter;\n  const query = SELECT * FROM exportData WHERE info LIKE '%${filter}%';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection via concatenated LIKE clause injection",
    "Lab Description": "This lab exposes a vulnerability in a search function where user input is used in a LIKE clause without proper sanitization, allowing attackers to manipulate the search condition.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE articles (id INTEGER PRIMARY KEY, title TEXT, content TEXT)\");\n  db.run(\"INSERT INTO articles (title, content) VALUES ('Tech Trends', 'Latest technology news')\");\n});\n\napp.get('/search', (req, res) => {\n  const keyword = req.query.keyword;\n  const query = SELECT * FROM articles WHERE title LIKE '%${keyword}%';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in user role management",
    "Lab Description": "This lab simulates an admin panel for user role management where user input is directly concatenated into a query. Attackers can inject SQL to change user roles and escalate privileges.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE roles (id INTEGER PRIMARY KEY, username TEXT, role TEXT)\");\n  db.run(\"INSERT INTO roles (username, role) VALUES ('user1', 'user')\");\n});\n\napp.post('/updateRole', (req, res) => {\n  const username = req.body.username;\n  const newRole = req.body.newRole;\n  const query = UPDATE roles SET role = '${newRole}' WHERE username = '${username}';\n  console.log('Executing query:', query);\n  db.run(query, [], function(err) {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Role updated');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in session token retrieval",
    "Lab Description": "This lab demonstrates a vulnerability in an endpoint that retrieves session tokens. The unsanitized input allows attackers to inject SQL and obtain session tokens for unauthorized access.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE sessions (id INTEGER PRIMARY KEY, token TEXT)\");\n  db.run(\"INSERT INTO sessions (token) VALUES ('session123')\");\n});\n\napp.post('/getSession', (req, res) => {\n  const token = req.body.token;\n  const query = SELECT * FROM sessions WHERE token = '${token}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in email subscription form",
    "Lab Description": "This lab simulates an email subscription form where the user\u2019s email is directly concatenated into an INSERT query, making it vulnerable to SQL injection. Attackers can inject SQL to manipulate the subscribers list.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE subscribers (id INTEGER PRIMARY KEY, email TEXT)\");\n});\n\napp.post('/subscribe', (req, res) => {\n  const email = req.body.email;\n  const query = INSERT INTO subscribers (email) VALUES ('${email}');\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Subscription successful');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection with extra whitespace injection",
    "Lab Description": "This lab demonstrates a vulnerability where extra whitespace characters are not trimmed before being concatenated into the SQL query, allowing attackers to inject malicious payloads.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'pass1')\");\n});\n\napp.get('/whitespace', (req, res) => {\n  let username = req.query.username; // Not trimming input\n  const query = SELECT * FROM users WHERE username = '${username}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in URL parameter exploitation",
    "Lab Description": "This lab simulates a vulnerability where URL parameters are directly used in constructing SQL queries without sanitization. Attackers can modify URL parameters to inject SQL and retrieve unauthorized data.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE articles (id INTEGER PRIMARY KEY, title TEXT, content TEXT)\");\n  db.run(\"INSERT INTO articles (title, content) VALUES ('News', 'Breaking news content')\");\n});\n\napp.get('/articles', (req, res) => {\n  const id = req.query.id;\n  const query = SELECT * FROM articles WHERE id = '${id}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in admin panel access",
    "Lab Description": "This lab simulates an admin login panel where unsanitized inputs allow attackers to bypass authentication and access admin functionalities. The attacker can inject SQL to log in as an administrator.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE admins (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO admins (username, password) VALUES ('admin', 'admin123')\");\n});\n\napp.post('/adminLogin', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = SELECT * FROM admins WHERE username = '${username}' AND password = '${password}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (rows.length > 0) res.send('Admin login successful');\n    else res.send('Login failed');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in payment gateway error logging",
    "Lab Description": "This lab demonstrates a vulnerability in a payment gateway where unsanitized inputs in error logging lead to SQL injection, allowing attackers to retrieve or modify transaction logs.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE logs (id INTEGER PRIMARY KEY, error TEXT)\");\n  db.run(\"INSERT INTO logs (error) VALUES ('Payment error')\");\n});\n\napp.post('/logError', (req, res) => {\n  const errorDetail = req.body.errorDetail;\n  const query = INSERT INTO logs (error) VALUES ('${errorDetail}');\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Error logged');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in automated notification system",
    "Lab Description": "This lab simulates a notification system where SQL queries are built dynamically from user input. Due to unsanitized inputs, attackers can inject SQL commands to alter notification data.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE notifications (id INTEGER PRIMARY KEY, message TEXT)\");\n  db.run(\"INSERT INTO notifications (message) VALUES ('Your order has shipped')\");\n});\n\napp.post('/notify', (req, res) => {\n  const message = req.body.message;\n  const query = UPDATE notifications SET message = '${message}' WHERE id = 1;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Notification updated');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in feedback rating system",
    "Lab Description": "This lab demonstrates a vulnerability in a feedback rating system where user ratings are inserted into the database without proper sanitization. Attackers can manipulate the SQL query to alter feedback scores.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE ratings (id INTEGER PRIMARY KEY, user TEXT, score INTEGER)\");\n  db.run(\"INSERT INTO ratings (user, score) VALUES ('user1', 5)\");\n});\n\napp.post('/rate', (req, res) => {\n  const user = req.body.user;\n  const score = req.body.score;\n  const query = INSERT INTO ratings (user, score) VALUES ('${user}', ${score});\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Rating submitted');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in multi-tenant application",
    "Lab Description": "This lab simulates a multi-tenant application where SQL queries are built from tenant identifiers provided by the user. Unsanitized tenant input allows attackers to access data across tenants.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE tenant_data (id INTEGER PRIMARY KEY, tenant TEXT, data TEXT)\");\n  db.run(\"INSERT INTO tenant_data (tenant, data) VALUES ('tenant1', 'Sensitive Data 1')\");\n});\n\napp.post('/data', (req, res) => {\n  const tenant = req.body.tenant;\n  const query = SELECT data FROM tenant_data WHERE tenant = '${tenant}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection with JSON payload vulnerability",
    "Lab Description": "This lab demonstrates a vulnerability where a JSON payload is directly concatenated into an SQL query without proper parsing or sanitization, allowing attackers to inject SQL code.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, details TEXT)\");\n  db.run(\"INSERT INTO orders (details) VALUES ('Order details here')\");\n});\n\napp.post('/order', (req, res) => {\n  const details = req.body.details; // JSON as string\n  const query = SELECT * FROM orders WHERE details = '${details}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in dashboard query parameters",
    "Lab Description": "This lab simulates a dashboard where query parameters are directly used to construct SQL queries. Attackers can inject SQL to manipulate the dashboard data views.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE dashboard (id INTEGER PRIMARY KEY, metric TEXT, value REAL)\");\n  db.run(\"INSERT INTO dashboard (metric, value) VALUES ('Sales', 1500)\");\n});\n\napp.get('/dashboard', (req, res) => {\n  const metric = req.query.metric;\n  const query = SELECT * FROM dashboard WHERE metric = '${metric}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in caching layer bypass",
    "Lab Description": "This lab demonstrates a caching layer vulnerability where the cache key is constructed unsafely from user input. Attackers can inject SQL to bypass caching and retrieve fresh data.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\n// Simulated cache (not secure)\nlet cache = {};\n\napp.post('/cacheData', (req, res) => {\n  const key = req.body.key;\n  const query = SELECT * FROM dashboard WHERE metric = '${key}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else {\n      cache[key] = rows;\n      res.json(rows);\n    }\n  });\n});\n\napp.get('/cacheData', (req, res) => {\n  const key = req.query.key;\n  if (cache[key]) res.json(cache[key]);\n  else res.send('No cached data');\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection with malformed SQL query construction",
    "Lab Description": "This lab simulates a scenario where a poorly constructed SQL query due to improper concatenation leads to SQL injection vulnerabilities. Attackers can manipulate the query syntax to gain unauthorized access.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n});\n\napp.get('/malformed', (req, res) => {\n  const input = req.query.input;\n  // Malformed query due to poor concatenation\n  const query = \"SELECT * FROM users WHERE username = '\" + input;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in product recommendation engine",
    "Lab Description": "This lab simulates a product recommendation system where user preferences are used directly in SQL queries. Attackers can inject SQL to alter recommendation results and access data from unrelated tables.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE recommendations (id INTEGER PRIMARY KEY, user_pref TEXT, suggestion TEXT)\");\n  db.run(\"INSERT INTO recommendations (user_pref, suggestion) VALUES ('electronics', 'Smartphone')\");\n});\n\napp.post('/recommend', (req, res) => {\n  const pref = req.body.user_pref;\n  const query = SELECT * FROM recommendations WHERE user_pref = '${pref}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in social media comment posting",
    "Lab Description": "This lab simulates a social media platform's comment posting feature. Unsanitized input in the comment submission allows attackers to inject SQL and manipulate or extract comments.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE comments (id INTEGER PRIMARY KEY, comment TEXT)\");\n  db.run(\"INSERT INTO comments (comment) VALUES ('Nice post!')\");\n});\n\napp.post('/postComment', (req, res) => {\n  const comment = req.body.comment;\n  const query = INSERT INTO comments (comment) VALUES ('${comment}');\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Comment posted');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in dynamic menu generation",
    "Lab Description": "This lab simulates a dynamic menu generation system where menu items are generated based on user input. Unsanitized input leads to SQL injection, allowing attackers to alter the menu contents.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE menu (id INTEGER PRIMARY KEY, item TEXT)\");\n  db.run(\"INSERT INTO menu (item) VALUES ('Home')\");\n});\n\napp.get('/menu', (req, res) => {\n  const filter = req.query.filter;\n  const query = SELECT * FROM menu WHERE item = '${filter}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in scheduling module",
    "Lab Description": "This lab simulates a scheduling system where appointment times provided by the user are concatenated into an SQL query. Attackers can inject SQL commands to alter or retrieve scheduling data.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE schedule (id INTEGER PRIMARY KEY, time TEXT, event TEXT)\");\n  db.run(\"INSERT INTO schedule (time, event) VALUES ('10:00', 'Meeting')\");\n});\n\napp.post('/schedule', (req, res) => {\n  const time = req.body.time;\n  const query = SELECT * FROM schedule WHERE time = '${time}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in inventory restock API",
    "Lab Description": "This lab simulates an inventory restock endpoint where restock amounts are taken from user input without validation. Attackers can inject SQL to modify stock levels.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE inventory (id INTEGER PRIMARY KEY, item TEXT, stock INTEGER)\");\n  db.run(\"INSERT INTO inventory (item, stock) VALUES ('Printer', 5)\");\n});\n\napp.post('/restock', (req, res) => {\n  const item = req.body.item;\n  const amount = req.body.amount;\n  const query = UPDATE inventory SET stock = stock + ${amount} WHERE item = '${item}';\n  console.log('Executing query:', query);\n  db.run(query, [], function(err) {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Stock updated');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in transaction rollback simulation",
    "Lab Description": "This lab simulates a transaction system where an unsanitized input in a rollback query allows attackers to inject SQL to force a rollback or alter transaction data.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE transactions (id INTEGER PRIMARY KEY, amount REAL, status TEXT)\");\n  db.run(\"INSERT INTO transactions (amount, status) VALUES (100.00, 'complete')\");\n});\n\napp.post('/rollback', (req, res) => {\n  const input = req.body.input;\n  const query = BEGIN; UPDATE transactions SET status = 'rolled back' WHERE id = 1; ${input}; COMMIT;;\n  console.log('Executing query:', query);\n  db.exec(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Transaction rolled back');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in currency conversion API",
    "Lab Description": "This lab simulates an API endpoint for currency conversion that directly concatenates user inputs into the SQL query. Attackers can inject SQL to alter conversion rates or retrieve data from other financial tables.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE conversion (id INTEGER PRIMARY KEY, currency TEXT, rate REAL)\");\n  db.run(\"INSERT INTO conversion (currency, rate) VALUES ('USD', 1.0)\");\n});\n\napp.post('/convert', (req, res) => {\n  const currency = req.body.currency;\n  const query = SELECT rate FROM conversion WHERE currency = '${currency}';\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(row);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in user preference update",
    "Lab Description": "This lab simulates a settings update endpoint where user preferences are directly inserted into an SQL query. The vulnerability allows attackers to inject SQL and change user settings.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE preferences (id INTEGER PRIMARY KEY, user TEXT, theme TEXT)\");\n  db.run(\"INSERT INTO preferences (user, theme) VALUES ('user1', 'light')\");\n});\n\napp.post('/updatePreference', (req, res) => {\n  const user = req.body.user;\n  const theme = req.body.theme;\n  const query = UPDATE preferences SET theme = '${theme}' WHERE user = '${user}';\n  console.log('Executing query:', query);\n  db.run(query, [], function(err) {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Preference updated');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in voucher code redemption",
    "Lab Description": "This lab simulates an endpoint for voucher code redemption where the voucher code is unsanitized. Attackers can inject SQL to redeem invalid vouchers or modify redemption data.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE vouchers (id INTEGER PRIMARY KEY, code TEXT, discount INTEGER)\");\n  db.run(\"INSERT INTO vouchers (code, discount) VALUES ('SAVE10', 10)\");\n});\n\napp.post('/redeem', (req, res) => {\n  const code = req.body.code;\n  const query = SELECT discount FROM vouchers WHERE code = '${code}';\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (row) res.send(Voucher redeemed: ${row.discount}% off);\n    else res.send('Invalid voucher code');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in event registration system",
    "Lab Description": "This lab simulates an event registration system where user inputs are directly embedded in SQL queries. Attackers can exploit this vulnerability to register unauthorized users or modify registration details.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE events (id INTEGER PRIMARY KEY, event_name TEXT, attendee TEXT)\");\n  db.run(\"INSERT INTO events (event_name, attendee) VALUES ('Conference', 'Alice')\");\n});\n\napp.post('/registerEvent', (req, res) => {\n  const event = req.body.event;\n  const attendee = req.body.attendee;\n  const query = INSERT INTO events (event_name, attendee) VALUES ('${event}', '${attendee}');\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Registration successful');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection via XML encoding bypass",
    "Lab Description": "This lab contains a SQL injection vulnerability in its stock check feature. The application returns query results in the response, allowing a UNION attack to retrieve data from a users table. Exploit this vulnerability to extract admin credentials.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\n\nconst app = express();\napp.use(bodyParser.text({ type: 'application/xml' }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"CREATE TABLE stock (id INTEGER PRIMARY KEY, product TEXT, quantity INTEGER)\");\n  db.run(\"INSERT INTO stock (product, quantity) VALUES ('Laptop', 10)\");\n});\n\napp.post('/stock', (req, res) => {\n  xml2js.parseString(req.body, (err, result) => {\n    if (err) { res.status(400).send(\"Invalid XML\"); return; }\n    const product = result.stock.product[0];\n    const query = SELECT product, quantity FROM stock WHERE product = '${product}';\n    console.log(\"Executing query:\", query);\n    db.all(query, [], (err, rows) => {\n      if (err) res.status(500).send(\"Error occurred.\");\n      else res.json(rows);\n    });\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection with URL encoding bypass",
    "Lab Description": "This lab simulates a login form vulnerability where user inputs are URL encoded before processing. The error messages reveal details of the underlying database. Exploit the vulnerability by crafting URL-encoded payloads to extract sensitive data.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = SELECT * FROM users WHERE username = '${username}' AND password = '${password}';\n  console.log(\"Executing query:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send(\"Error occurred.\");\n    else if (rows.length > 0) res.send(\"Login successful\");\n    else res.send(\"Login failed\");\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Blind SQL injection with delay-based response",
    "Lab Description": "This lab demonstrates a blind SQL injection vulnerability where response time delays are used to infer database content. Manipulate the SQL query to induce a delay when conditions are met, allowing extraction of sensitive data via timing analysis.",
    "Vulnerability name": "Blind SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = SELECT username, password, CASE WHEN (username='${username}' AND password='${password}') THEN (SELECT sleep(5)) ELSE 0 END as delay FROM users;;\n  console.log(\"Executing query:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send(\"Error occurred.\");\n    else {\n      const delay = rows[0].delay;\n      if (delay >= 5) res.send(\"Vulnerability exploited: Blind SQL Injection detected.\");\n      else res.send(\"No vulnerability exploited.\");\n    }\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection using UNION attack for data retrieval",
    "Lab Description": "This lab features an application that concatenates user input into an SQL query. Attackers can use a UNION attack to merge results from different queries and retrieve data from a hidden table.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n  db.run(\"CREATE TABLE customers (id INTEGER PRIMARY KEY, name TEXT, email TEXT)\");\n  db.run(\"INSERT INTO customers (name, email) VALUES ('John Doe', 'john@example.com')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = SELECT * FROM users WHERE username = '${username}' AND password = '${password}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else if (rows.length > 0) {\n      const unionQuery = query + \" UNION SELECT null, name, email FROM customers\";\n      db.all(unionQuery, [], (err, unionRows) => {\n        if (err) res.status(500).send('Error during UNION attack');\n        else res.json(unionRows);\n      });\n    } else {\n      res.send('Login failed');\n    }\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection with error-based data extraction",
    "Lab Description": "This lab demonstrates an error-based SQL injection vulnerability. By manipulating the query, attackers can force errors that reveal database structure details such as table names and column details.",
    "Vulnerability name": "SQL Injection (Error-based)",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price REAL)\");\n  db.run(\"INSERT INTO products (name, price) VALUES ('Laptop', 1200.00)\");\n});\n\napp.get('/search', (req, res) => {\n  const keyword = req.query.keyword;\n  const query = SELECT * FROM products WHERE name = '${keyword}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send(err.message);\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection allowing multiple statement execution",
    "Lab Description": "This lab simulates a vulnerability where user input is concatenated into a query that allows execution of multiple SQL statements, enabling attackers to run unauthorized commands such as dropping tables or extracting data.",
    "Vulnerability name": "SQL Injection (Multiple Statement)",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n});\n\napp.post('/execute', (req, res) => {\n  const input = req.body.input;\n  const query = BEGIN; SELECT * FROM users; ${input}; COMMIT;;\n  console.log('Executing query:', query);\n  db.exec(query, (err) => {\n    if (err) res.status(500).send('Error occurred.');\n    else res.send('Query executed successfully.');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection due to improper parameter handling",
    "Lab Description": "This lab demonstrates a common vulnerability where the application fails to use parameterized queries. User inputs are directly concatenated, allowing attackers to inject malicious SQL code and bypass authentication.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = SELECT * FROM users WHERE username = '${username}' AND password = '${password}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else if (rows.length > 0) res.send('Login successful');\n    else res.send('Login failed');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection exploiting subqueries",
    "Lab Description": "This lab targets an API that uses subqueries. The query construction using user input within a subquery is vulnerable, allowing attackers to manipulate the subquery to extract data from hidden tables.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, product TEXT, price REAL)\");\n  db.run(\"INSERT INTO orders (product, price) VALUES ('Laptop', 1200.00)\");\n  db.run(\"CREATE TABLE secret (info TEXT)\");\n  db.run(\"INSERT INTO secret (info) VALUES ('Top Secret Data')\");\n});\n\napp.post('/order', (req, res) => {\n  const product = req.body.product;\n  const query = SELECT product, price FROM orders WHERE id IN (SELECT id FROM secret WHERE info = '${product}');\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in a comment system due to weak sanitization",
    "Lab Description": "This lab simulates a comment submission system where user comments are directly inserted into an SQL query without proper sanitization. This vulnerability allows attackers to inject SQL code to manipulate or extract data from the comments table.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE comments (id INTEGER PRIMARY KEY, content TEXT)\");\n  db.run(\"INSERT INTO comments (content) VALUES ('Nice product!')\");\n});\n\napp.post('/comment', (req, res) => {\n  const comment = req.body.comment;\n  const query = INSERT INTO comments (content) VALUES ('${comment}');\n  console.log('Executing query:', query);\n  db.run(query, function(err) {\n    if (err) res.status(500).send('Error occurred.');\n    else res.send('Comment submitted.');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection using OR conditions in search functionality",
    "Lab Description": "This lab demonstrates a vulnerability in a search endpoint where attackers inject OR conditions into the SQL query to bypass filters and retrieve unauthorized data.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE employees (id INTEGER PRIMARY KEY, name TEXT, department TEXT)\");\n  db.run(\"INSERT INTO employees (name, department) VALUES ('Alice', 'HR')\");\n});\n\napp.get('/search', (req, res) => {\n  const name = req.query.name;\n  const query = SELECT * FROM employees WHERE name = '${name}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in API endpoint for product retrieval",
    "Lab Description": "This lab simulates an API endpoint that retrieves product information based on unsanitized user input. The lack of parameterization allows attackers to inject SQL commands to extract data from other tables.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price REAL)\");\n  db.run(\"INSERT INTO products (name, price) VALUES ('Tablet', 500.00)\");\n  db.run(\"CREATE TABLE details (product_id INTEGER, description TEXT)\");\n  db.run(\"INSERT INTO details (product_id, description) VALUES (1, 'High resolution display')\");\n});\n\napp.post('/getProduct', (req, res) => {\n  const name = req.body.name;\n  const query = SELECT * FROM products WHERE name = '${name}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else if (rows.length > 0) {\n      const unionQuery = query + \" UNION SELECT null, description, null FROM details\";\n      db.all(unionQuery, [], (err, unionRows) => {\n        if (err) res.status(500).send('Error during UNION attack');\n        else res.json(unionRows);\n      });\n    } else {\n      res.send('No product found.');\n    }\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in stored procedure simulation for order update",
    "Lab Description": "This lab simulates a stored procedure execution using dynamic SQL constructed from unsanitized user input. The vulnerability allows attackers to manipulate the procedure call and update orders without proper authorization.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, item TEXT, quantity INTEGER)\");\n  db.run(\"INSERT INTO orders (item, quantity) VALUES ('Monitor', 5)\");\n});\n\napp.post('/updateOrder', (req, res) => {\n  const newQuantity = req.body.quantity;\n  const query = UPDATE orders SET quantity = ${newQuantity} WHERE id = 1;\n  console.log('Executing query:', query);\n  db.run(query, function(err) {\n    if (err) res.status(500).send('Error occurred.');\n    else res.send(Order updated, changes: ${this.changes});\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Boolean-based blind SQL injection in login system",
    "Lab Description": "This lab demonstrates a boolean-based blind SQL injection vulnerability in a login system. By injecting conditions like 'OR 1=1', attackers can bypass authentication. Exploit the vulnerability to log in with incorrect credentials.",
    "Vulnerability name": "Blind SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = SELECT * FROM users WHERE username = '${username}' AND password = '${password}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (rows.length > 0) res.send('Login successful');\n    else res.send('Login failed');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Time-based blind SQL injection in account verification",
    "Lab Description": "This lab exhibits a time-based blind SQL injection vulnerability in an account verification endpoint. By injecting a sleep delay, attackers can infer data based on the response time.",
    "Vulnerability name": "Time-based SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE accounts (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO accounts (username, password) VALUES ('user', 'pass')\");\n});\n\napp.post('/verify', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = SELECT username, CASE WHEN (username='${username}' AND password='${password}') THEN (SELECT sleep(5)) ELSE 0 END as delay FROM accounts;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (rows[0].delay >= 5) res.send('Vulnerability exploited: Delay detected');\n    else res.send('No vulnerability exploited');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Time-based SQL injection in mobile backend",
    "Lab Description": "This lab simulates a mobile app backend vulnerable to time-based SQL injection. By injecting a sleep delay, the system response indicates successful exploitation of the vulnerability.",
    "Vulnerability name": "Time-based SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, product TEXT, status TEXT)\");\n  db.run(\"INSERT INTO orders (product, status) VALUES ('Phone', 'Pending')\");\n});\n\napp.post('/confirm', (req, res) => {\n  const product = req.body.product;\n  const query = SELECT product, CASE WHEN (product='${product}') THEN (SELECT sleep(5)) ELSE 0 END as delay FROM orders;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (rows[0].delay >= 5) res.send('Vulnerability exploited: Delay detected');\n    else res.send('No vulnerability exploited');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Out-of-band SQL injection via DNS exfiltration in web API",
    "Lab Description": "This lab simulates an out-of-band SQL injection vulnerability where the system exfiltrates data via DNS lookups. Attackers trigger a DNS query that includes sensitive data.",
    "Vulnerability name": "SQL Injection (Out-of-Band)",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nfunction dnsLookup(data) {\n  console.log('Simulated DNS Lookup for:', data);\n  return data;\n}\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE secrets (id INTEGER PRIMARY KEY, info TEXT)\");\n  db.run(\"INSERT INTO secrets (info) VALUES ('dnsSecretData')\");\n});\n\napp.post('/api/exfil', (req, res) => {\n  const param = req.body.param;\n  const query = SELECT * FROM secrets WHERE info = '${param}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else {\n      dnsLookup(rows[0].info);\n      res.send('DNS exfiltration triggered');\n    }\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Out-of-band SQL injection with HTTP callback for data exfiltration",
    "Lab Description": "This lab demonstrates an out-of-band SQL injection vulnerability where the application triggers an HTTP callback to exfiltrate data. Attackers inject SQL that causes an HTTP request to an external logging service.",
    "Vulnerability name": "SQL Injection (Out-of-Band)",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst axios = require('axios');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE reports (id INTEGER PRIMARY KEY, data TEXT)\");\n  db.run(\"INSERT INTO reports (data) VALUES ('reportDataXYZ')\");\n});\n\napp.post('/reportExfil', (req, res) => {\n  const param = req.body.param;\n  const query = SELECT * FROM reports WHERE data = '${param}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else {\n      axios.post('http://example.com/log', { data: rows[0].data })\n        .then(() => res.send('HTTP callback triggered'))\n        .catch(() => res.status(500).send('Callback error'));\n    }\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Out-of-band SQL injection via SMTP in order system",
    "Lab Description": "This lab simulates a vulnerability where the application sends exfiltrated data via email using SMTP due to an SQL injection flaw. Attackers trigger an SQL injection that causes sensitive data to be emailed out.",
    "Vulnerability name": "SQL Injection (Out-of-Band)",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst nodemailer = require('nodemailer');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst transporter = nodemailer.createTransport({\n  host: 'smtp.example.com',\n  port: 587,\n  secure: false,\n  auth: { user: 'user@example.com', pass: 'password' }\n});\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE documents (id INTEGER PRIMARY KEY, content TEXT)\");\n  db.run(\"INSERT INTO documents (content) VALUES ('ftpSecretData')\");\n});\n\napp.post('/ftpExfil', (req, res) => {\n  const param = req.body.param;\n  const query = SELECT * FROM documents WHERE content = '${param}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else {\n      console.log('Simulated FTP Transfer of:', rows[0].content);\n      res.send('FTP exfiltration simulated');\n    }\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "Out-of-band SQL injection exploiting API misconfiguration for remote logging",
    "Lab Description": "This lab simulates an API endpoint that is misconfigured and vulnerable to SQL injection. The vulnerability allows attackers to inject SQL that triggers remote logging of sensitive data via an external logging service.",
    "Vulnerability name": "SQL Injection (Out-of-Band)",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst axios = require('axios');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE logs (id INTEGER PRIMARY KEY, info TEXT)\");\n  db.run(\"INSERT INTO logs (info) VALUES ('logDataXYZ')\");\n});\n\napp.post('/remoteLog', (req, res) => {\n  const param = req.body.param;\n  const query = SELECT * FROM logs WHERE info = '${param}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else {\n      axios.post('http://logging.example.com/api/log', { data: rows[0].info })\n        .then(() => res.send('Remote logging triggered'))\n        .catch(() => res.status(500).send('Remote logging failed'));\n    }\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in a mobile app backend for user profiles",
    "Lab Description": "This lab simulates a mobile application backend where the API for retrieving user profiles is vulnerable to SQL injection due to unsanitized input parameters. Exploit the vulnerability to extract profile information.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE profiles (id INTEGER PRIMARY KEY, username TEXT, email TEXT)\");\n  db.run(\"INSERT INTO profiles (username, email) VALUES ('user1', 'user1@example.com')\");\n});\n\napp.post('/profile', (req, res) => {\n  const username = req.body.username;\n  const query = SELECT * FROM profiles WHERE username = '${username}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in a legacy PHP system simulated in Node.js",
    "Lab Description": "This lab emulates a legacy PHP system's behavior using Node.js, where the system constructs SQL queries unsafely. Attackers can exploit the vulnerability to gain unauthorized access to data.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE legacy_users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO legacy_users (username, password) VALUES ('legacyAdmin', 'legacyPass')\");\n});\n\napp.post('/legacyLogin', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = \"SELECT * FROM legacy_users WHERE username = '\" + username + \"' AND password = '\" + password + \"'\";\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else if (rows.length > 0) res.send('Login successful');\n    else res.send('Login failed');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in password reset module",
    "Lab Description": "This lab demonstrates a vulnerability in a password reset feature where the user's email input is unsanitized. An attacker can inject SQL to reset the password of any user, such as the administrator.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\n// Setup database with a users table\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, email TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (email, password) VALUES ('admin@example.com', 'oldpassword')\");\n});\n\napp.post('/resetPassword', (req, res) => {\n  const email = req.body.email;\n  const newPassword = req.body.newPassword;\n  // Vulnerable query: unsanitized input\n  const query = UPDATE users SET password = '${newPassword}' WHERE email = '${email}';\n  console.log('Executing query:', query);\n  db.run(query, function(err) {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Password reset successful');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in event booking system",
    "Lab Description": "This lab simulates an event booking system where the seat number is passed unsanitized into the SQL query. An attacker can inject SQL to bypass seat availability checks and book seats without authorization.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\n// Setup a bookings table\ndb.serialize(() => {\n  db.run(\"CREATE TABLE bookings (id INTEGER PRIMARY KEY, seat TEXT, booked INTEGER)\");\n  db.run(\"INSERT INTO bookings (seat, booked) VALUES ('A1', 0)\");\n});\n\napp.post('/book', (req, res) => {\n  const seat = req.body.seat;\n  // Vulnerable query: direct concatenation of user input\n  const query = UPDATE bookings SET booked = 1 WHERE seat = '${seat}';\n  console.log('Executing query:', query);\n  db.run(query, function(err) {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Seat booked');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in social network user search",
    "Lab Description": "This lab demonstrates a vulnerability in a social network\u2019s user search feature. Unsanitized search terms allow an attacker to inject SQL and retrieve all user profiles from the database.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\n\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\n// Setup users table\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, bio TEXT)\");\n  db.run(\"INSERT INTO users (name, bio) VALUES ('Alice', 'Loves coding')\");\n});\n\napp.get('/searchUsers', (req, res) => {\n  const keyword = req.query.keyword;\n  // Vulnerable query using unsanitized keyword in a LIKE clause\n  const query = SELECT * FROM users WHERE name LIKE '%${keyword}%';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in order tracking system",
    "Lab Description": "This lab simulates an order tracking system where the order ID is provided via query parameters without sanitization. An attacker can inject SQL to view details of orders that do not belong to them.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\n\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\n// Setup orders table\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, details TEXT)\");\n  db.run(\"INSERT INTO orders (details) VALUES ('Order for user1')\");\n});\n\napp.get('/trackOrder', (req, res) => {\n  const orderId = req.query.orderId;\n  // Vulnerable query using unsanitized orderId\n  const query = SELECT * FROM orders WHERE id = '${orderId}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in product review filter",
    "Lab Description": "This lab features a product review filter where user-supplied rating is directly used in the SQL query. Attackers can manipulate the input to retrieve all reviews or inject extra conditions.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\nconst db = new sqlite3.Database(':memory:');\n\n// Setup reviews table\ndb.serialize(() => {\n  db.run(\"CREATE TABLE reviews (id INTEGER PRIMARY KEY, rating INTEGER, comment TEXT)\");\n  db.run(\"INSERT INTO reviews (rating, comment) VALUES (5, 'Excellent product!')\");\n});\n\napp.post('/filterReviews', (req, res) => {\n  const rating = req.body.rating;\n  // Vulnerable query: unsanitized input used in the WHERE clause\n  const query = SELECT * FROM reviews WHERE rating = ${rating};\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in bulk user import module",
    "Lab Description": "This lab simulates a bulk user import feature where CSV data is processed without proper sanitization. The unsanitized data is concatenated into SQL queries, allowing injection of additional SQL commands.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.text());\n\nconst db = new sqlite3.Database(':memory:');\n\n// Setup users table\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, email TEXT)\");\n});\n\napp.post('/importUsers', (req, res) => {\n  // Simulated CSV input: each line is \"name,email\"\n  const data = req.body.split('\\n');\n  data.forEach(line => {\n    const [name, email] = line.split(\",\");\n    const query = INSERT INTO users (name, email) VALUES ('${name}', '${email}');\n    console.log('Executing query:', query);\n    db.run(query);\n  });\n  res.send('Users imported');\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in forum thread deletion endpoint",
    "Lab Description": "This lab simulates a forum where thread deletion is based on a thread ID provided by the user. The unsanitized input allows attackers to inject SQL to delete multiple threads.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\n// Setup forum threads table\ndb.serialize(() => {\n  db.run(\"CREATE TABLE threads (id INTEGER PRIMARY KEY, title TEXT)\");\n  db.run(\"INSERT INTO threads (title) VALUES ('General Discussion')\");\n});\n\napp.post('/deleteThread', (req, res) => {\n  const threadId = req.body.threadId;\n  // Vulnerable query: unsanitized threadId\n  const query = DELETE FROM threads WHERE id = '${threadId}';\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Thread deleted');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in API for retrieving user statistics",
    "Lab Description": "This lab simulates an API endpoint that retrieves user statistics based on unsanitized parameters. Attackers can inject SQL to retrieve statistics for all users.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\n// Setup statistics table\ndb.serialize(() => {\n  db.run(\"CREATE TABLE statistics (id INTEGER PRIMARY KEY, user TEXT, visits INTEGER)\");\n  db.run(\"INSERT INTO statistics (user, visits) VALUES ('user1', 100)\");\n});\n\napp.post('/stats', (req, res) => {\n  const user = req.body.user;\n  // Vulnerable query using unsanitized user input\n  const query = SELECT * FROM statistics WHERE user = '${user}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in product inventory update via GET parameters",
    "Lab Description": "This lab simulates a product inventory update endpoint that uses GET parameters without sanitization. Attackers can inject SQL to alter inventory levels arbitrarily.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\n\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE inventory (id INTEGER PRIMARY KEY, product TEXT, stock INTEGER)\");\n  db.run(\"INSERT INTO inventory (product, stock) VALUES ('Camera', 15)\");\n});\n\napp.get('/updateInventory', (req, res) => {\n  const product = req.query.product;\n  const stock = req.query.stock;\n  // Vulnerable query using GET parameters unsanitized\n  const query = UPDATE inventory SET stock = ${stock} WHERE product = '${product}';\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Inventory updated');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in financial report retrieval module",
    "Lab Description": "This lab simulates a financial report retrieval system where the report type is provided by the user unsanitized. Attackers can inject SQL to retrieve confidential financial data.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE reports (id INTEGER PRIMARY KEY, type TEXT, data TEXT)\");\n  db.run(\"INSERT INTO reports (type, data) VALUES ('financial', 'Confidential Data')\");\n});\n\napp.post('/getReport', (req, res) => {\n  const type = req.body.type;\n  // Vulnerable query using unsanitized report type\n  const query = SELECT * FROM reports WHERE type = '${type}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection with filter bypass via XML encoding",
    "Lab Description": "This lab contains a SQL injection vulnerability in its stock check feature. The application returns query results in the response, allowing a UNION attack to retrieve data from the users table. Exploit this vulnerability to retrieve the administrator's credentials.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\nconst xml2js = require('xml2js');\n\nconst app = express();\napp.use(bodyParser.text({ type: 'application/xml' }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('administrator', 'admin123')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user1', 'password1')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user2', 'password2')\");\n  db.run(\"CREATE TABLE stock (id INTEGER PRIMARY KEY, product TEXT, quantity INTEGER)\");\n  db.run(\"INSERT INTO stock (product, quantity) VALUES ('Laptop', 10)\");\n  db.run(\"INSERT INTO stock (product, quantity) VALUES ('Phone', 20)\");\n});\n\napp.post('/stock', (req, res) => {\n  xml2js.parseString(req.body, (err, result) => {\n    if (err) {\n      res.status(400).send(\"Invalid XML\");\n      return;\n    }\n    const product = result.stock.product[0];\n    const query = SELECT product, quantity FROM stock WHERE product = '${product}';\n    console.log(\"Executing query:\", query);\n    db.all(query, [], (err, rows) => {\n      if (err) {\n        res.status(500).send(\"Error occurred.\");\n      } else {\n        res.json(rows);\n      }\n    });\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
    "Lab scenario": "SQL injection in a login form without sanitization",
    "Lab Description": "This lab contains a login form that directly uses user input in SQL queries without sanitization. This lack of validation allows attackers to inject SQL code to bypass authentication. Exploit the vulnerability to log in as an administrator.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user', 'userpass')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = SELECT * FROM users WHERE username = '${username}' AND password = '${password}';\n  console.log(\"Executing query:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else if (rows.length > 0) {\n      res.send(\"Login successful\");\n    } else {\n      res.send(\"Login failed\");\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
    "Lab scenario": "SQL injection with multiple statement execution vulnerability",
    "Lab Description": "This lab demonstrates a vulnerability where user input is concatenated into an SQL command that allows execution of multiple SQL statements. Exploit this vulnerability to execute unauthorized statements, such as dropping tables or extracting confidential data.",
    "Vulnerability name": "SQL Injection (Multiple Statement)",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n});\n\napp.post('/execute', (req, res) => {\n  const input = req.body.input;\n  // Vulnerable to injection of multiple statements\n  const query = BEGIN; SELECT * FROM users; ${input}; COMMIT;;\n  console.log(\"Executing query:\", query);\n  db.exec(query, (err) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else {\n      res.send(\"Query executed successfully.\");\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
    "Lab scenario": "SQL injection due to improper parameter handling",
    "Lab Description": "This lab demonstrates how the failure to use parameterized queries can lead to SQL injection. The application concatenates user input into a query, allowing attackers to bypass authentication. Exploit this vulnerability to gain unauthorized access.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  // Vulnerable query without parameterization\n  const query = SELECT * FROM users WHERE username = '${username}' AND password = '${password}';\n  console.log(\"Executing query:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else if (rows.length > 0) {\n      res.send(\"Login successful\");\n    } else {\n      res.send(\"Login failed\");\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
    "Lab scenario": "SQL injection exploiting subqueries",
    "Lab Description": "This lab targets an API that uses subqueries to fetch data. Poor handling of user input within subqueries creates a vulnerability. Exploit the vulnerability to retrieve data from a hidden table.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, product TEXT, price REAL)\");\n  db.run(\"INSERT INTO orders (product, price) VALUES ('Laptop', 1200.00)\");\n  db.run(\"CREATE TABLE secret (info TEXT)\");\n  db.run(\"INSERT INTO secret (info) VALUES ('Top Secret Data')\");\n});\n\napp.post('/order', (req, res) => {\n  const product = req.body.product;\n  // Vulnerable subquery injection\n  const query = SELECT product, price FROM orders WHERE id IN (SELECT id FROM secret WHERE info = '${product}');\n  console.log(\"Executing query:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
    "Lab scenario": "SQL injection in search functionality",
    "Lab Description": "This lab simulates a search feature that is vulnerable to SQL injection. User input is directly inserted into the SQL query without sanitization, allowing attackers to retrieve additional information by manipulating the query. Exploit this vulnerability to extract hidden data.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price REAL)\");\n  db.run(\"INSERT INTO products (name, price) VALUES ('Laptop', 1200.00)\");\n  db.run(\"INSERT INTO products (name, price) VALUES ('Phone', 800.00)\");\n});\n\napp.get('/search', (req, res) => {\n  const keyword = req.query.keyword;\n  const query = SELECT * FROM products WHERE name = '${keyword}';\n  console.log(\"Executing query:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(err.message);\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
    "Lab scenario": "SQL injection in API endpoint for product retrieval",
    "Lab Description": "This lab features an API endpoint that retrieves product information based on user input. The lack of proper parameterization creates a vulnerability that can be exploited to access data from other tables. Exploit the vulnerability to retrieve additional product details.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price REAL)\");\n  db.run(\"INSERT INTO products (name, price) VALUES ('Tablet', 500.00)\");\n  db.run(\"CREATE TABLE details (product_id INTEGER, description TEXT)\");\n  db.run(\"INSERT INTO details (product_id, description) VALUES (1, 'High resolution display')\");\n});\n\napp.post('/getProduct', (req, res) => {\n  const name = req.body.name;\n  const query = SELECT * FROM products WHERE name = '${name}';\n  console.log(\"Executing query:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else if (rows.length > 0) {\n      // Vulnerability: attacker can append a UNION to extract details\n      const unionQuery = query + \" UNION SELECT null, description, null FROM details\";\n      db.all(unionQuery, [], (err, unionRows) => {\n        if (err) {\n          res.status(500).send(\"Error during UNION attack.\");\n        } else {\n          res.json(unionRows);\n        }\n      });\n    } else {\n      res.send(\"No product found.\");\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
    "Lab scenario": "SQL injection vulnerability in stored procedure execution",
    "Lab Description": "This lab simulates a scenario where a stored procedure is executed using unsanitized user input. The dynamic construction of the stored procedure call makes it vulnerable to SQL injection. Exploit the vulnerability to alter the stored data.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "// Note: SQLite does not support stored procedures, so we simulate the behavior\nconst express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, item TEXT, quantity INTEGER)\");\n  db.run(\"INSERT INTO orders (item, quantity) VALUES ('Monitor', 5)\");\n});\n\n// Simulated stored procedure call vulnerable to SQL injection\napp.post('/updateOrder', (req, res) => {\n  const newQuantity = req.body.quantity;\n  // Vulnerable dynamic SQL for stored procedure simulation\n  const query = UPDATE orders SET quantity = ${newQuantity} WHERE id = 1;\n  console.log(\"Executing query:\", query);\n  db.run(query, function(err) {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else {\n      res.send(Order updated, changes: ${this.changes});\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
    "Lab scenario": "SQL injection with boolean-based blind attack",
    "Lab Description": "This lab showcases a boolean-based blind SQL injection vulnerability. By injecting conditional logic into the query, the attacker can infer the existence of data based on the application's responses. Exploit the vulnerability to deduce sensitive information from the database.",
    "Vulnerability name": "Blind SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE accounts (id INTEGER PRIMARY KEY, username TEXT, secret TEXT)\");\n  db.run(\"INSERT INTO accounts (username, secret) VALUES ('admin', 's3cr3t')\");\n});\n\napp.post('/check', (req, res) => {\n  const condition = req.body.condition; // e.g., '1=1' or '1=0'\n  const query = SELECT CASE WHEN (${condition}) THEN 'True' ELSE 'False' END as result;\n  console.log(\"Executing query:\", query);\n  db.get(query, [], (err, row) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else {\n      res.send(row.result);\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
    "Lab scenario": "SQL injection via string concatenation in update queries",
    "Lab Description": "This lab illustrates a vulnerability in an update query where user input is concatenated directly, allowing attackers to manipulate the SQL command. Exploit this vulnerability to change data in the database without proper authorization.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE inventory (id INTEGER PRIMARY KEY, item TEXT, stock INTEGER)\");\n  db.run(\"INSERT INTO inventory (item, stock) VALUES ('Keyboard', 50)\");\n});\n\napp.post('/updateStock', (req, res) => {\n  const item = req.body.item;\n  const newStock = req.body.newStock;\n  const query = UPDATE inventory SET stock = ${newStock} WHERE item = '${item}';\n  console.log(\"Executing query:\", query);\n  db.run(query, function(err) {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else {\n      res.send(Stock updated for ${item});\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
    "Lab scenario": "SQL injection with dynamic query generation in a report module",
    "Lab Description": "This lab simulates a report generation module where SQL queries are built dynamically from user input. The lack of input validation creates an SQL injection risk. Exploit the vulnerability to alter or extract report data.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE reports (id INTEGER PRIMARY KEY, title TEXT, content TEXT)\");\n  db.run(\"INSERT INTO reports (title, content) VALUES ('Sales Report', 'Revenue details')\");\n});\n\napp.post('/report', (req, res) => {\n  const filter = req.body.filter; // user-provided filter for the report\n  const query = SELECT * FROM reports WHERE title LIKE '%${filter}%';\n  console.log(\"Executing query:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else {\n      res.json(rows);\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
    "Lab scenario": "SQL injection via comment termination",
    "Lab Description": "This lab demonstrates a SQL injection vulnerability where an attacker can terminate a SQL comment to manipulate the query logic. The application fails to filter out comment delimiters properly, allowing additional SQL commands to be appended.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  // Vulnerable query: attacker can inject a comment terminator\n  const query = \"SELECT * FROM users WHERE username = '\" + username + \"' -- \" + \"AND password = '\" + password + \"'\";\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection via tautology-based attack",
    "Lab Description": "This lab allows attackers to bypass authentication by injecting a tautological condition such as 'OR 1=1'. The application concatenates user input directly into the query without sanitization.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  // Vulnerable query allowing tautology injection\n  const query = SELECT * FROM users WHERE username = '${username}' AND password = '${password}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in order search with unsanitized input",
    "Lab Description": "This lab simulates an order search endpoint vulnerable to SQL injection. The query is constructed by directly concatenating user input, allowing attackers to inject additional conditions to retrieve unintended data.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, item TEXT, quantity INTEGER)\");\n  db.run(\"INSERT INTO orders (item, quantity) VALUES ('Laptop', 10)\");\n});\n\napp.get('/search', (req, res) => {\n  const item = req.query.item;\n  const query = SELECT * FROM orders WHERE item = '${item}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection via improper escaping of quotes",
    "Lab Description": "This lab demonstrates a vulnerability caused by improper escaping of quotes in SQL queries. User input containing quotes is not sanitized, allowing attackers to break out of the intended query structure.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT)\");\n  db.run(\"INSERT INTO products (name) VALUES ('Laptop')\");\n});\n\napp.post('/search', (req, res) => {\n  const name = req.body.name;\n  const query = \"SELECT * FROM products WHERE name = '\" + name + \"'\";\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in product search with concatenation error",
    "Lab Description": "This lab features a product search endpoint where user input is concatenated into the SQL query without proper sanitization. This vulnerability allows attackers to append additional SQL commands to retrieve extra data.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price REAL)\");\n  db.run(\"INSERT INTO products (name, price) VALUES ('Smartphone', 800)\");\n});\n\napp.post('/search', (req, res) => {\n  const product = req.body.product;\n  const query = SELECT * FROM products WHERE name = '${product}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in comment system due to weak sanitization",
    "Lab Description": "This lab simulates a comment submission system that directly incorporates user comments into SQL queries without proper sanitization. Attackers can inject SQL to manipulate or extract data from the comments table.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE comments (id INTEGER PRIMARY KEY, content TEXT)\");\n  db.run(\"INSERT INTO comments (content) VALUES ('Nice product!')\");\n});\n\napp.post('/comment', (req, res) => {\n  const comment = req.body.comment;\n  const query = INSERT INTO comments (content) VALUES ('${comment}');\n  console.log('Executing query:', query);\n  db.run(query, function(err) {\n    if (err) res.status(500).send('Error occurred.');\n    else res.send('Comment submitted.');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection using OR conditions in search functionality",
    "Lab Description": "This lab demonstrates a vulnerability in a search endpoint where attackers inject OR conditions into the SQL query. This allows them to bypass filters and retrieve unauthorized data.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE employees (id INTEGER PRIMARY KEY, name TEXT, department TEXT)\");\n  db.run(\"INSERT INTO employees (name, department) VALUES ('Alice', 'HR')\");\n});\n\napp.get('/search', (req, res) => {\n  const name = req.query.name;\n  const query = SELECT * FROM employees WHERE name = '${name}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in order update with unsanitized parameters",
    "Lab Description": "This lab simulates an update operation on an orders table where unsanitized user input is directly concatenated into the SQL query. This vulnerability can allow attackers to alter order data without authorization.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, product TEXT, quantity INTEGER)\");\n  db.run(\"INSERT INTO orders (product, quantity) VALUES ('Tablet', 30)\");\n});\n\napp.post('/updateOrder', (req, res) => {\n  const product = req.body.product;\n  const newQuantity = req.body.newQuantity;\n  const query = UPDATE orders SET quantity = ${newQuantity} WHERE product = '${product}';\n  console.log('Executing query:', query);\n  db.run(query, function(err) {\n    if (err) res.status(500).send('Error occurred.');\n    else res.send(Order updated for ${product});\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection through stored procedure simulation with unsanitized input",
    "Lab Description": "This lab simulates a scenario where unsanitized input is used to construct a dynamic stored procedure call, resulting in SQL injection. Exploit this vulnerability to alter the behavior of the stored procedure simulation.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "// Note: SQLite does not support stored procedures, so we simulate the behavior\nconst express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, item TEXT, quantity INTEGER)\");\n  db.run(\"INSERT INTO orders (item, quantity) VALUES ('Monitor', 5)\");\n});\n\napp.post('/updateOrder', (req, res) => {\n  const newQuantity = req.body.quantity;\n  // Simulated stored procedure call vulnerable to SQL injection\n  const query = UPDATE orders SET quantity = ${newQuantity} WHERE id = 1;\n  console.log('Executing query:', query);\n  db.run(query, function(err) {\n    if (err) res.status(500).send('Error occurred.');\n    else res.send(Order updated. Changes: ${this.changes});\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection using parameter tampering in a financial application",
    "Lab Description": "This lab simulates a financial application where user input is unsanitized in SQL queries. Attackers can tamper with parameters to manipulate account balances and retrieve confidential information.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE accounts (id INTEGER PRIMARY KEY, username TEXT, balance REAL)\");\n  db.run(\"INSERT INTO accounts (username, balance) VALUES ('user1', 1000.00)\");\n  db.run(\"INSERT INTO accounts (username, balance) VALUES ('admin', 5000.00)\");\n});\n\napp.post('/transfer', (req, res) => {\n  const username = req.body.username;\n  const amount = req.body.amount;\n  const query = UPDATE accounts SET balance = balance - ${amount} WHERE username = '${username}';\n  console.log('Executing query:', query);\n  db.run(query, function(err) {\n    if (err) res.status(500).send('Error occurred.');\n    else res.send('Transfer executed.');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in user registration form",
    "Lab Description": "This lab involves a user registration form where the input is directly inserted into an SQL INSERT statement. The lack of proper sanitization allows an attacker to inject malicious SQL commands to manipulate the user table.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n});\n\napp.post('/register', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = INSERT INTO users (username, password) VALUES ('${username}', '${password}');\n  console.log('Executing query:', query);\n  db.run(query, function(err) {\n    if (err) res.status(500).send('Error occurred.');\n    else res.send('Registration successful.');\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection with hidden field manipulation in e-commerce checkout",
    "Lab Description": "This lab simulates an e-commerce checkout process where a hidden field is used in an SQL query without validation. Attackers can manipulate the hidden field to inject SQL commands and alter order data.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, item TEXT, quantity INTEGER)\");\n  db.run(\"INSERT INTO orders (item, quantity) VALUES ('Camera', 15)\");\n});\n\napp.post('/checkout', (req, res) => {\n  const hiddenField = req.body.hiddenField;\n  const query = SELECT * FROM orders WHERE item = '${hiddenField}';\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred.');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Lab running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection with URL encoding bypass",
    "Lab Description": "This lab simulates a SQL injection vulnerability in a login form where user inputs are URL encoded before processing. Error messages reveal details of the underlying database. Exploit the vulnerability by crafting URL-encoded payloads to extract sensitive user data.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user', 'userpass')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = SELECT * FROM users WHERE username = '${username}' AND password = '${password}';\n  console.log(\"Executing query:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else if (rows.length > 0) {\n      res.send(\"Login successful\");\n    } else {\n      res.send(\"Login failed\");\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
    "Lab scenario": "Blind SQL injection with delay-based response",
    "Lab Description": "This lab demonstrates a blind SQL injection vulnerability where response time delays are used to infer database content. Manipulate the SQL query to induce a delay when conditions are met, allowing extraction of sensitive data based on timing differences.",
    "Vulnerability name": "Blind SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('user', 'userpass')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = SELECT username, password, CASE WHEN (username='${username}' AND password='${password}') THEN (SELECT sleep(5)) ELSE 0 END as delay FROM users;;\n  console.log(\"Executing query:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else {\n      const delay = rows[0].delay;\n      if (delay >= 5) {\n        res.send(\"Vulnerability exploited: Blind SQL Injection detected.\");\n      } else {\n        res.send(\"No vulnerability exploited.\");\n      }\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
    "Lab scenario": "SQL injection using UNION attack for data retrieval",
    "Lab Description": "This lab features an application that directly concatenates user input into an SQL query. By using a UNION attack, you can merge results from the main query with those from a secondary query to retrieve data from the 'customers' table.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)\");\n  db.run(\"INSERT INTO users (username, password) VALUES ('admin', 'adminpass')\");\n  db.run(\"CREATE TABLE customers (id INTEGER PRIMARY KEY, name TEXT, email TEXT)\");\n  db.run(\"INSERT INTO customers (name, email) VALUES ('John Doe', 'john@example.com')\");\n});\n\napp.post('/login', (req, res) => {\n  const username = req.body.username;\n  const password = req.body.password;\n  const query = SELECT * FROM users WHERE username = '${username}' AND password = '${password}';\n  console.log(\"Executing query:\", query);\n  db.all(query, [], (err, rows) => {\n    if (err) {\n      res.status(500).send(\"Error occurred.\");\n    } else if (rows.length > 0) {\n      // Attacker uses UNION to extract data from customers table\n      const unionQuery = query + \" UNION SELECT null, name, email FROM customers\";\n      db.all(unionQuery, [], (err, unionRows) => {\n        if (err) {\n          res.status(500).send(\"Error during UNION attack.\");\n        } else {\n          res.json(unionRows);\n        }\n      });\n    } else {\n      res.send(\"Login failed\");\n    }\n  });\n});\n\nconst PORT = 3000;\napp.listen(PORT, () => {\n  console.log(Lab running on http://localhost:${PORT});\n});"
},
{
    "Lab scenario": "SQL injection in blog comment sorting",
    "Lab Description": "A blog platform sorts comments based on a user-specified column. The ORDER BY clause is constructed with unsanitized input, allowing an attacker to inject SQL to manipulate the sorting order and potentially leak data.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE comments (id INTEGER PRIMARY KEY, author TEXT, comment TEXT)\");\n  db.run(\"INSERT INTO comments (author, comment) VALUES ('Alice', 'Great post!')\");\n});\n\napp.get('/comments', (req, res) => {\n  const sortColumn = req.query.sort;\n  const query = `SELECT * FROM comments ORDER BY ${sortColumn}`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in product discount retrieval",
    "Lab Description": "An e-commerce site retrieves discount information by concatenating a coupon code into an SQL query. Attackers can inject SQL into the coupon parameter to retrieve unauthorized discount data.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE discounts (id INTEGER PRIMARY KEY, code TEXT, value INTEGER)\");\n  db.run(\"INSERT INTO discounts (code, value) VALUES ('SAVE20', 20)\");\n});\n\napp.get('/discount', (req, res) => {\n  const coupon = req.query.coupon;\n  const query = `SELECT * FROM discounts WHERE code = '${coupon}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in news article categorization",
    "Lab Description": "A news categorization system accepts a category from the user and builds an SQL query without sanitization. Attackers can inject SQL to retrieve articles from any category.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE articles (id INTEGER PRIMARY KEY, category TEXT, content TEXT)\");\n  db.run(\"INSERT INTO articles (category, content) VALUES ('sports', 'Sports news content')\");\n});\n\napp.get('/articles', (req, res) => {\n  const category = req.query.category;\n  const query = `SELECT * FROM articles WHERE category = '${category}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in event booking cancellation",
    "Lab Description": "An event booking system allows users to cancel bookings by providing a booking ID. The unsanitized input in the cancellation query allows attackers to cancel bookings they do not own.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE bookings (id INTEGER PRIMARY KEY, event TEXT, user TEXT)\");\n  db.run(\"INSERT INTO bookings (event, user) VALUES ('Concert', 'alice')\");\n});\n\napp.post('/cancelBooking', (req, res) => {\n  const bookingId = req.body.bookingId;\n  const query = `DELETE FROM bookings WHERE id = '${bookingId}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Booking cancelled');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in user analytics query",
    "Lab Description": "An analytics endpoint retrieves user metrics based on a parameter provided by the user. Unsanitized input allows attackers to inject SQL to retrieve data for all users.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE analytics (id INTEGER PRIMARY KEY, metric TEXT, value REAL)\");\n  db.run(\"INSERT INTO analytics (metric, value) VALUES ('loginCount', 150)\");\n});\n\napp.post('/analytics', (req, res) => {\n  const metric = req.body.metric;\n  const query = `SELECT * FROM analytics WHERE metric = '${metric}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in hotel room availability check",
    "Lab Description": "A hotel booking system checks room availability by directly concatenating a room type into the SQL query. Attackers can inject SQL to view all available rooms regardless of type.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE rooms (id INTEGER PRIMARY KEY, room_type TEXT, available INTEGER)\");\n  db.run(\"INSERT INTO rooms (room_type, available) VALUES ('Suite', 5)\");\n});\n\napp.get('/rooms', (req, res) => {\n  const roomType = req.query.roomType;\n  const query = `SELECT * FROM rooms WHERE room_type = '${roomType}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in library management search",
    "Lab Description": "A library system searches for books using a user-supplied keyword. The unsanitized keyword in the LIKE clause allows an attacker to inject SQL to retrieve all book records.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE books (id INTEGER PRIMARY KEY, title TEXT, author TEXT)\");\n  db.run(\"INSERT INTO books (title, author) VALUES ('Secret History', 'D. Brown')\");\n});\n\napp.get('/searchBooks', (req, res) => {\n  const keyword = req.query.keyword;\n  const query = `SELECT * FROM books WHERE title LIKE '%${keyword}%'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in financial transaction audit",
    "Lab Description": "A financial auditing system retrieves transaction records based on user-provided transaction IDs. Unsanitized input allows an attacker to inject SQL and access or modify sensitive financial data.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE transactions (id INTEGER PRIMARY KEY, details TEXT, amount REAL)\");\n  db.run(\"INSERT INTO transactions (details, amount) VALUES ('Payment received', 250.00)\");\n});\n\napp.post('/audit', (req, res) => {\n  const txnId = req.body.txnId;\n  const query = `SELECT * FROM transactions WHERE id = '${txnId}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in admin panel data export",
    "Lab Description": "An admin panel provides a data export feature that constructs SQL queries unsafely from user input. Attackers can inject SQL to export data from other tables.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE exportData (id INTEGER PRIMARY KEY, info TEXT)\");\n  db.run(\"INSERT INTO exportData (info) VALUES ('Confidential Data')\");\n});\n\napp.post('/exportData', (req, res) => {\n  const filter = req.body.filter;\n  const query = `SELECT * FROM exportData WHERE info LIKE '%${filter}%'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in mobile app crash reporting",
    "Lab Description": "A mobile app crash reporting endpoint concatenates error messages into SQL queries without sanitization. Attackers can inject SQL to retrieve detailed crash logs.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE crash_logs (id INTEGER PRIMARY KEY, error_message TEXT)\");\n  db.run(\"INSERT INTO crash_logs (error_message) VALUES ('Null pointer exception')\");\n});\n\napp.post('/reportCrash', (req, res) => {\n  const errorMsg = req.body.errorMsg;\n  const query = `SELECT * FROM crash_logs WHERE error_message = '${errorMsg}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in e-commerce wishlist retrieval",
    "Lab Description": "An e-commerce site's wishlist feature retrieves user wishlists using unsanitized wishlist IDs, allowing attackers to inject SQL and view wishlists for other users.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE wishlists (id INTEGER PRIMARY KEY, user TEXT, item TEXT)\");\n  db.run(\"INSERT INTO wishlists (user, item) VALUES ('user1', 'Smartwatch')\");\n});\n\napp.get('/wishlist', (req, res) => {\n  const wishlistId = req.query.id;\n  const query = `SELECT * FROM wishlists WHERE id = '${wishlistId}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in social media friend suggestion",
    "Lab Description": "A social network\u2019s friend suggestion feature uses unsanitized input to filter suggestions. Attackers can inject SQL to retrieve hidden friend lists.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, hidden INTEGER)\");\n  db.run(\"INSERT INTO users (name, hidden) VALUES ('Alice', 0)\");\n  db.run(\"INSERT INTO users (name, hidden) VALUES ('Eve', 1)\");\n});\n\napp.get('/friendSuggestions', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM users WHERE name LIKE '%${filter}%'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in survey analytics dashboard",
    "Lab Description": "A survey dashboard constructs queries from user filters without sanitization, allowing attackers to inject SQL and alter the reported survey results.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE surveys (id INTEGER PRIMARY KEY, category TEXT, response TEXT)\");\n  db.run(\"INSERT INTO surveys (category, response) VALUES ('satisfaction', 'Good')\");\n});\n\napp.post('/surveyDashboard', (req, res) => {\n  const category = req.body.category;\n  const query = `SELECT * FROM surveys WHERE category = '${category}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in restaurant reservation system",
    "Lab Description": "A restaurant reservation endpoint uses unsanitized table identifiers to build SQL queries. Attackers can inject SQL to reserve tables without authorization.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE reservations (id INTEGER PRIMARY KEY, table_number TEXT, reserved INTEGER)\");\n  db.run(\"INSERT INTO reservations (table_number, reserved) VALUES ('T1', 0)\");\n});\n\napp.post('/reserve', (req, res) => {\n  const table = req.body.table_number;\n  const query = `UPDATE reservations SET reserved = 1 WHERE table_number = '${table}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Table reserved');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in cinema ticket booking system",
    "Lab Description": "A cinema ticket booking API constructs queries from seat selection input without proper sanitization. Attackers can inject SQL to book seats beyond the available inventory.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE tickets (id INTEGER PRIMARY KEY, seat TEXT, available INTEGER)\");\n  db.run(\"INSERT INTO tickets (seat, available) VALUES ('A1', 1)\");\n});\n\napp.post('/bookTicket', (req, res) => {\n  const seat = req.body.seat;\n  const query = `UPDATE tickets SET available = 0 WHERE seat = '${seat}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Ticket booked');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in inventory reorder system",
    "Lab Description": "An inventory management system calculates reorder quantities based on unsanitized product IDs. Attackers can inject SQL to force unauthorized reorders.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE inventory (id INTEGER PRIMARY KEY, product TEXT, stock INTEGER)\");\n  db.run(\"INSERT INTO inventory (product, stock) VALUES ('Keyboard', 20)\");\n});\n\napp.post('/reorder', (req, res) => {\n  const productId = req.body.productId;\n  const query = `UPDATE inventory SET stock = stock + 10 WHERE id = '${productId}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Reorder triggered');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in academic exam score retrieval",
    "Lab Description": "A university portal retrieves exam scores based on student IDs provided by the user. Unsanitized input allows attackers to inject SQL and view scores for all students.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE exam_scores (id INTEGER PRIMARY KEY, student TEXT, score INTEGER)\");\n  db.run(\"INSERT INTO exam_scores (student, score) VALUES ('John Doe', 85)\");\n});\n\napp.post('/getScore', (req, res) => {\n  const studentId = req.body.studentId;\n  const query = `SELECT * FROM exam_scores WHERE id = '${studentId}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in job application portal search",
    "Lab Description": "A job application portal allows recruiters to search for candidates using keywords. Unsanitized input in the search query enables attackers to inject SQL to retrieve all candidate applications.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE applications (id INTEGER PRIMARY KEY, candidate TEXT, position TEXT)\");\n  db.run(\"INSERT INTO applications (candidate, position) VALUES ('Jane Smith', 'Engineer')\");\n});\n\napp.get('/searchCandidates', (req, res) => {\n  const keyword = req.query.keyword;\n  const query = `SELECT * FROM applications WHERE candidate LIKE '%${keyword}%'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in online forum post retrieval",
    "Lab Description": "An online forum retrieves posts based on a topic specified by the user. Unsanitized topic input enables attackers to inject SQL to retrieve posts from all topics.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE forum_posts (id INTEGER PRIMARY KEY, topic TEXT, content TEXT)\");\n  db.run(\"INSERT INTO forum_posts (topic, content) VALUES ('tech', 'Discussion on tech trends')\");\n});\n\napp.get('/posts', (req, res) => {\n  const topic = req.query.topic;\n  const query = `SELECT * FROM forum_posts WHERE topic = '${topic}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in user profile photo update",
    "Lab Description": "A profile photo update endpoint uses unsanitized image file names in its SQL query. Attackers can inject SQL to modify or retrieve profile information.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE profiles (id INTEGER PRIMARY KEY, username TEXT, photo TEXT)\");\n  db.run(\"INSERT INTO profiles (username, photo) VALUES ('bob', 'default.jpg')\");\n});\n\napp.post('/updatePhoto', (req, res) => {\n  const username = req.body.username;\n  const photo = req.body.photo;\n  const query = `UPDATE profiles SET photo = '${photo}' WHERE username = '${username}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Profile photo updated');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in coupon code validation system",
    "Lab Description": "A coupon validation endpoint uses unsanitized coupon codes in its SQL query, allowing attackers to inject SQL to bypass discount restrictions.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE coupons (id INTEGER PRIMARY KEY, code TEXT, discount INTEGER)\");\n  db.run(\"INSERT INTO coupons (code, discount) VALUES ('DISCOUNT50', 50)\");\n});\n\napp.post('/validateCoupon', (req, res) => {\n  const code = req.body.code;\n  const query = `SELECT discount FROM coupons WHERE code = '${code}'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (row) res.send(`Coupon valid: ${row.discount}% off`);\n    else res.send('Invalid coupon');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in patient record lookup",
    "Lab Description": "A healthcare system retrieves patient records using unsanitized patient IDs. Attackers can inject SQL to access confidential patient information.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE patients (id INTEGER PRIMARY KEY, name TEXT, diagnosis TEXT)\");\n  db.run(\"INSERT INTO patients (name, diagnosis) VALUES ('John Doe', 'Hypertension')\");\n});\n\napp.post('/getPatient', (req, res) => {\n  const patientId = req.body.patientId;\n  const query = `SELECT * FROM patients WHERE id = '${patientId}'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(row);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in vehicle registration query",
    "Lab Description": "A vehicle registration system retrieves details based on a license plate number provided by the user. Unsanitized input enables attackers to inject SQL and retrieve registration details of any vehicle.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\n\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE vehicles (id INTEGER PRIMARY KEY, plate TEXT, owner TEXT)\");\n  db.run(\"INSERT INTO vehicles (plate, owner) VALUES ('ABC123', 'Jane Doe')\");\n});\n\napp.get('/vehicleInfo', (req, res) => {\n  const plate = req.query.plate;\n  const query = `SELECT * FROM vehicles WHERE plate = '${plate}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in donation management portal",
    "Lab Description": "A donation management system retrieves donor records using unsanitized inputs. Attackers can inject SQL to access donation histories and modify donation amounts.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE donations (id INTEGER PRIMARY KEY, donor TEXT, amount REAL)\");\n  db.run(\"INSERT INTO donations (donor, amount) VALUES ('Alice', 100)\");\n});\n\napp.post('/getDonations', (req, res) => {\n  const donor = req.body.donor;\n  const query = `SELECT * FROM donations WHERE donor = '${donor}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in course registration system",
    "Lab Description": "A university course registration portal uses unsanitized course codes in its SQL queries. Attackers can inject SQL to register for courses without proper authorization.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE courses (id INTEGER PRIMARY KEY, code TEXT, seats INTEGER)\");\n  db.run(\"INSERT INTO courses (code, seats) VALUES ('CS101', 50)\");\n});\n\napp.post('/registerCourse', (req, res) => {\n  const courseCode = req.body.courseCode;\n  const query = `UPDATE courses SET seats = seats - 1 WHERE code = '${courseCode}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Course registration updated');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in order tracking for logistics",
    "Lab Description": "A logistics tracking system uses unsanitized order IDs in its SQL query, allowing an attacker to inject SQL to retrieve tracking information for any order.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, tracking TEXT)\");\n  db.run(\"INSERT INTO orders (tracking) VALUES ('TRACK123')\");\n});\n\napp.post('/trackOrder', (req, res) => {\n  const orderId = req.body.orderId;\n  const query = `SELECT tracking FROM orders WHERE id = '${orderId}'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send(row ? row.tracking : 'No order found');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in hotel loyalty program",
    "Lab Description": "A hotel loyalty program retrieves user points based on unsanitized inputs. Attackers can inject SQL to view or modify loyalty points for any account.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE loyalty (id INTEGER PRIMARY KEY, username TEXT, points INTEGER)\");\n  db.run(\"INSERT INTO loyalty (username, points) VALUES ('guest', 100)\");\n});\n\napp.post('/loyalty', (req, res) => {\n  const username = req.body.username;\n  const query = `SELECT points FROM loyalty WHERE username = '${username}'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(row);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in supplier management system",
    "Lab Description": "A supplier management system retrieves supplier details using unsanitized supplier IDs, allowing attackers to inject SQL and obtain data for all suppliers.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE suppliers (id INTEGER PRIMARY KEY, name TEXT, contact TEXT)\");\n  db.run(\"INSERT INTO suppliers (name, contact) VALUES ('SupplierX', 'contact@supplierx.com')\");\n});\n\napp.post('/getSupplier', (req, res) => {\n  const supplierId = req.body.supplierId;\n  const query = `SELECT * FROM suppliers WHERE id = '${supplierId}'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(row);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in CMS article retrieval",
    "Lab Description": "A content management system retrieves articles based on a category specified by the user. Unsanitized input allows attackers to inject SQL and retrieve articles from any category.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE articles (id INTEGER PRIMARY KEY, category TEXT, content TEXT)\");\n  db.run(\"INSERT INTO articles (category, content) VALUES ('tech', 'Tech article content')\");\n});\n\napp.get('/articles', (req, res) => {\n  const category = req.query.category;\n  const query = `SELECT * FROM articles WHERE category = '${category}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in dynamic advertisement retrieval",
    "Lab Description": "An advertisement server retrieves ads based on unsanitized parameters. Attackers can inject SQL to control which ads are shown or to retrieve ad campaign data.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE ads (id INTEGER PRIMARY KEY, category TEXT, content TEXT)\");\n  db.run(\"INSERT INTO ads (category, content) VALUES ('sports', 'Sports ad content')\");\n});\n\napp.post('/getAds', (req, res) => {\n  const category = req.body.category;\n  const query = `SELECT * FROM ads WHERE category = '${category}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in order cancellation endpoint",
    "Lab Description": "A system allows users to cancel orders by providing an order ID via a POST request. The unsanitized order ID lets attackers cancel orders they do not own.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, status TEXT)\");\n  db.run(\"INSERT INTO orders (status) VALUES ('active')\");\n});\n\napp.post('/cancelOrder', (req, res) => {\n  const orderId = req.body.orderId;\n  const query = `UPDATE orders SET status = 'cancelled' WHERE id = '${orderId}'`;\n  console.log('Executing query:', query);\n  db.run(query, function(err) {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Order cancelled');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in newsletter subscription",
    "Lab Description": "A newsletter subscription form directly concatenates the email address into an INSERT query, enabling attackers to inject SQL and add unauthorized emails.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE subscribers (id INTEGER PRIMARY KEY, email TEXT)\");\n});\n\napp.post('/subscribe', (req, res) => {\n  const email = req.body.email;\n  const query = `INSERT INTO subscribers (email) VALUES ('${email}')`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Subscription successful');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in blog post retrieval",
    "Lab Description": "A blog platform retrieves posts based on a title provided via a query string. Unsanitized input allows attackers to inject SQL and retrieve all posts.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\n\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE posts (id INTEGER PRIMARY KEY, title TEXT, content TEXT)\");\n  db.run(\"INSERT INTO posts (title, content) VALUES ('Hello World', 'This is a blog post')\");\n});\n\napp.get('/getPost', (req, res) => {\n  const title = req.query.title;\n  const query = `SELECT * FROM posts WHERE title = '${title}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in product discount retrieval",
    "Lab Description": "A discount lookup endpoint retrieves discount details based on a coupon code from the query string. Unsanitized input allows attackers to inject SQL and retrieve all discount data.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE discounts (id INTEGER PRIMARY KEY, code TEXT, value INTEGER)\");\n  db.run(\"INSERT INTO discounts (code, value) VALUES ('SAVE10', 10)\");\n});\n\napp.get('/getDiscount', (req, res) => {\n  const code = req.query.code;\n  const query = `SELECT * FROM discounts WHERE code = '${code}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in file download by filename",
    "Lab Description": "A file download endpoint takes a filename from the query and constructs an SQL query without sanitization. Attackers can inject SQL to download files they shouldn\u2019t access.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE files (id INTEGER PRIMARY KEY, filename TEXT, content TEXT)\");\n  db.run(\"INSERT INTO files (filename, content) VALUES ('secret.txt', 'Top secret content')\");\n});\n\napp.get('/download', (req, res) => {\n  const file = req.query.file;\n  const query = `SELECT content FROM files WHERE filename = '${file}'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (row) res.send(row.content);\n    else res.send('File not found');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in customer review filter",
    "Lab Description": "A customer review filter endpoint uses user-supplied rating to filter reviews. Unsanitized input allows attackers to manipulate the query and retrieve reviews beyond intended criteria.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE reviews (id INTEGER PRIMARY KEY, rating INTEGER, comment TEXT)\");\n  db.run(\"INSERT INTO reviews (rating, comment) VALUES (4, 'Good product')\");\n});\n\napp.post('/filterReviews', (req, res) => {\n  const rating = req.body.rating;\n  const query = `SELECT * FROM reviews WHERE rating = ${rating}`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in file export module with filter condition",
    "Lab Description": "An export function for user data uses unsanitized filter input to build an SQL query. Attackers can inject SQL to export data from unintended tables.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE exportData (id INTEGER PRIMARY KEY, info TEXT)\");\n  db.run(\"INSERT INTO exportData (info) VALUES ('Sensitive data')\");\n});\n\napp.post('/export', (req, res) => {\n  const filter = req.body.filter;\n  const query = `SELECT * FROM exportData WHERE info LIKE '%${filter}%'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in order tracking system",
    "Lab Description": "An order tracking endpoint constructs a query using an unsanitized order ID from the request body. Attackers can inject SQL to view tracking information for all orders.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, tracking TEXT)\");\n  db.run(\"INSERT INTO orders (tracking) VALUES ('TRACK001')\");\n});\n\napp.post('/track', (req, res) => {\n  const orderId = req.body.orderId;\n  const query = `SELECT tracking FROM orders WHERE id = '${orderId}'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send(row ? row.tracking : 'Order not found');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in online coupon redemption",
    "Lab Description": "A coupon redemption API uses unsanitized coupon codes in its SQL query, allowing attackers to inject SQL and redeem invalid coupons.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE coupons (id INTEGER PRIMARY KEY, code TEXT, discount INTEGER)\");\n  db.run(\"INSERT INTO coupons (code, discount) VALUES ('OFF50', 50)\");\n});\n\napp.post('/redeem', (req, res) => {\n  const code = req.body.code;\n  const query = `SELECT discount FROM coupons WHERE code = '${code}'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (row) res.send(`Coupon redeemed: ${row.discount}% off`);\n    else res.send('Invalid coupon');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in customer feedback sentiment analysis",
    "Lab Description": "A sentiment analysis endpoint for customer feedback uses unsanitized feedback text in its SQL query. Attackers can inject SQL to retrieve or manipulate feedback records.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE feedback (id INTEGER PRIMARY KEY, comment TEXT)\");\n  db.run(\"INSERT INTO feedback (comment) VALUES ('Great service')\");\n});\n\napp.post('/analyze', (req, res) => {\n  const comment = req.body.comment;\n  const query = `SELECT * FROM feedback WHERE comment LIKE '%${comment}%'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in restaurant reservation system",
    "Lab Description": "A restaurant reservation endpoint takes a table number as input and constructs an SQL query without sanitization. Attackers can inject SQL to reserve tables without proper authorization.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE reservations (id INTEGER PRIMARY KEY, table_number TEXT, reserved INTEGER)\");\n  db.run(\"INSERT INTO reservations (table_number, reserved) VALUES ('T1', 0)\");\n});\n\napp.post('/reserve', (req, res) => {\n  const tableNumber = req.body.table_number;\n  const query = `UPDATE reservations SET reserved = 1 WHERE table_number = '${tableNumber}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Reservation successful');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in vehicle registration lookup",
    "Lab Description": "A vehicle registration lookup service uses an unsanitized license plate number to build an SQL query, allowing attackers to retrieve details for any vehicle.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\napp.use(express.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE vehicles (id INTEGER PRIMARY KEY, plate TEXT, owner TEXT)\");\n  db.run(\"INSERT INTO vehicles (plate, owner) VALUES ('XYZ789', 'Bob')\");\n});\n\napp.get('/vehicleInfo', (req, res) => {\n  const plate = req.query.plate;\n  const query = `SELECT * FROM vehicles WHERE plate = '${plate}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in customer order history retrieval",
    "Lab Description": "A retail website retrieves order histories based on a customer ID provided via a query parameter. Unsanitized input allows an attacker to inject SQL and retrieve order histories for all customers.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\n\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, customerId TEXT, details TEXT)\");\n  db.run(\"INSERT INTO orders (customerId, details) VALUES ('cust123', 'Order details for cust123')\");\n});\n\napp.get('/orderHistory', (req, res) => {\n  const customerId = req.query.customerId;\n  // Vulnerable: unsanitized input directly concatenated\n  const query = `SELECT * FROM orders WHERE customerId = '${customerId}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in support ticket tracking",
    "Lab Description": "A support system retrieves ticket statuses using an unsanitized ticket ID from the request body. Attackers can inject SQL to view the status of all tickets.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE tickets (id INTEGER PRIMARY KEY, status TEXT)\");\n  db.run(\"INSERT INTO tickets (status) VALUES ('open')\");\n});\n\napp.post('/ticketStatus', (req, res) => {\n  const ticketId = req.body.ticketId;\n  // Vulnerable: unsanitized ticketId\n  const query = `SELECT * FROM tickets WHERE id = '${ticketId}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in dynamic employee record search",
    "Lab Description": "An HR portal allows searching for employee records based on a keyword. The unsanitized input in the WHERE clause lets attackers retrieve records for all employees.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\n\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE employees (id INTEGER PRIMARY KEY, name TEXT, department TEXT)\");\n  db.run(\"INSERT INTO employees (name, department) VALUES ('John Doe', 'Engineering')\");\n});\n\napp.get('/searchEmployee', (req, res) => {\n  const keyword = req.query.keyword;\n  const query = `SELECT * FROM employees WHERE name LIKE '%${keyword}%'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in online library book reservation",
    "Lab Description": "A library system accepts a book title via POST data to reserve a book. The unsanitized title enables attackers to inject SQL and reserve books they should not have access to.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE books (id INTEGER PRIMARY KEY, title TEXT, reserved INTEGER)\");\n  db.run(\"INSERT INTO books (title, reserved) VALUES ('The Great Gatsby', 0)\");\n});\n\napp.post('/reserveBook', (req, res) => {\n  const title = req.body.title;\n  const query = `UPDATE books SET reserved = 1 WHERE title = '${title}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Book reserved');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in membership subscription form",
    "Lab Description": "A membership form inserts user emails into the database without sanitization. Attackers can inject SQL to add additional records or retrieve data from the subscribers table.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Easy",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE members (id INTEGER PRIMARY KEY, email TEXT)\");\n});\n\napp.post('/subscribeMember', (req, res) => {\n  const email = req.body.email;\n  const query = `INSERT INTO members (email) VALUES ('${email}')`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Subscription successful');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in online poll results retrieval",
    "Lab Description": "An online poll system retrieves poll results using an unsanitized poll ID. Attackers can inject SQL to view results for all polls or alter poll outcomes.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE polls (id INTEGER PRIMARY KEY, question TEXT, results TEXT)\");\n  db.run(\"INSERT INTO polls (question, results) VALUES ('Favorite color?', 'Blue:10,Red:5')\");\n});\n\napp.post('/pollResults', (req, res) => {\n  const pollId = req.body.pollId;\n  const query = `SELECT results FROM polls WHERE id = '${pollId}'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else if (row) res.send(row.results);\n    else res.send('Poll not found');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in forum thread search",
    "Lab Description": "A forum search endpoint takes a keyword to search thread titles. Unsanitized input enables attackers to inject SQL and retrieve threads beyond the intended scope.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Medium",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\n\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE threads (id INTEGER PRIMARY KEY, title TEXT, content TEXT)\");\n  db.run(\"INSERT INTO threads (title, content) VALUES ('General Discussion', 'Welcome to the forum')\");\n});\n\napp.get('/searchThread', (req, res) => {\n  const keyword = req.query.keyword;\n  const query = `SELECT * FROM threads WHERE title LIKE '%${keyword}%'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in HR leave application system",
    "Lab Description": "An HR portal accepts leave application details via POST data. The unsanitized employee ID in the SQL query allows attackers to inject SQL and manipulate leave records.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE leave_applications (id INTEGER PRIMARY KEY, employeeId TEXT, leaveDays INTEGER)\");\n  db.run(\"INSERT INTO leave_applications (employeeId, leaveDays) VALUES ('emp001', 5)\");\n});\n\napp.post('/applyLeave', (req, res) => {\n  const employeeId = req.body.employeeId;\n  const leaveDays = req.body.leaveDays;\n  const query = `UPDATE leave_applications SET leaveDays = ${leaveDays} WHERE employeeId = '${employeeId}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Leave application updated');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in insurance claim processing",
    "Lab Description": "An insurance portal processes claims using an unsanitized claim number. Attackers can inject SQL to retrieve or modify claim information.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE claims (id INTEGER PRIMARY KEY, claimNumber TEXT, status TEXT)\");\n  db.run(\"INSERT INTO claims (claimNumber, status) VALUES ('CLM1001', 'pending')\");\n});\n\napp.post('/processClaim', (req, res) => {\n  const claimNumber = req.body.claimNumber;\n  const query = `UPDATE claims SET status = 'approved' WHERE claimNumber = '${claimNumber}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Claim processed');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
    "Lab scenario": "SQL injection in online voting system",
    "Lab Description": "An online voting system retrieves candidate votes using an unsanitized candidate ID. Attackers can inject SQL to manipulate vote counts.",
    "Vulnerability name": "SQL Injection",
    "lab level": "Hard",
    "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE votes (id INTEGER PRIMARY KEY, candidateId TEXT, voteCount INTEGER)\");\n  db.run(\"INSERT INTO votes (candidateId, voteCount) VALUES ('cand01', 100)\");\n});\n\napp.post('/vote', (req, res) => {\n  const candidateId = req.body.candidateId;\n  const query = `UPDATE votes SET voteCount = voteCount + 1 WHERE candidateId = '${candidateId}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Vote recorded');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Unsanitized profile bio update",
  "Lab Description": "A user profile update endpoint accepts a 'bio' field without sanitization. An attacker can inject SQL into the bio field to retrieve or modify other user data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE profiles (id INTEGER PRIMARY KEY, username TEXT, bio TEXT)\");\n  db.run(\"INSERT INTO profiles (username, bio) VALUES ('alice', 'Hello world')\");\n});\n\napp.post('/updateBio', (req, res) => {\n  const username = req.body.username;\n  const bio = req.body.bio; // Vulnerable: unsanitized input\n  const query = `UPDATE profiles SET bio = '${bio}' WHERE username = '${username}'`;\n  console.log('Executing query:', query);\n  db.run(query, function(err) {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Profile updated');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Product price update with unsanitized value",
  "Lab Description": "A product management endpoint allows updating the price using unsanitized input. An attacker can inject SQL to change prices for multiple products.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price REAL)\");\n  db.run(\"INSERT INTO products (name, price) VALUES ('Laptop', 999.99)\");\n});\n\napp.post('/updatePrice', (req, res) => {\n  const product = req.body.product;\n  const newPrice = req.body.newPrice; // Vulnerable: unsanitized\n  const query = `UPDATE products SET price = ${newPrice} WHERE name = '${product}'`;\n  console.log('Executing query:', query);\n  db.run(query, function(err) {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Price updated');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Blog post retrieval with error-based injection",
  "Lab Description": "A blog platform retrieves posts based on a title provided by the user. Poor error handling reveals SQL errors that an attacker can use to deduce the schema.",
  "Vulnerability name": "SQL Injection (Error-based)",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: false }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE posts (id INTEGER PRIMARY KEY, title TEXT, content TEXT)\");\n  db.run(\"INSERT INTO posts (title, content) VALUES ('Hello', 'Welcome to my blog')\");\n});\n\napp.get('/getPost', (req, res) => {\n  const title = req.query.title;\n  const query = `SELECT * FROM posts WHERE title = '${title}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send(err.message);\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Feedback submission vulnerability in comment field",
  "Lab Description": "A feedback form accepts comments without sanitization. An attacker can inject SQL code in the comment field to manipulate feedback records.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE feedback (id INTEGER PRIMARY KEY, comment TEXT)\");\n});\n\napp.post('/submitFeedback', (req, res) => {\n  const comment = req.body.comment;\n  const query = `INSERT INTO feedback (comment) VALUES ('${comment}')`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Feedback submitted');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Document file search vulnerability in management system",
  "Lab Description": "A document management system allows searching for files by name. The search query is constructed using unsanitized input, enabling an attacker to inject SQL to view other files.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\n\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE documents (id INTEGER PRIMARY KEY, filename TEXT, content TEXT)\");\n  db.run(\"INSERT INTO documents (filename, content) VALUES ('report.pdf', 'Annual Report')\");\n});\n\napp.get('/searchFile', (req, res) => {\n  const filename = req.query.filename;\n  const query = `SELECT * FROM documents WHERE filename = '${filename}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Customer support ticket creation with injection",
  "Lab Description": "A customer support system allows users to submit tickets. Unsanitized input in the ticket description allows attackers to inject SQL to alter or extract ticket details.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE tickets (id INTEGER PRIMARY KEY, subject TEXT, description TEXT)\");\n});\n\napp.post('/createTicket', (req, res) => {\n  const subject = req.body.subject;\n  const description = req.body.description;\n  const query = `INSERT INTO tickets (subject, description) VALUES ('${subject}', '${description}')`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Ticket created');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Dynamic report generation with concatenated parameters",
  "Lab Description": "A reporting system dynamically constructs SQL queries from multiple parameters provided by the user. The lack of proper sanitization allows an attacker to inject SQL commands that modify the report results.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE reports (id INTEGER PRIMARY KEY, category TEXT, data TEXT)\");\n  db.run(\"INSERT INTO reports (category, data) VALUES ('sales', 'Q1 Report')\");\n});\n\napp.post('/generateReport', (req, res) => {\n  const category = req.body.category;\n  const filter = req.body.filter;\n  const query = `SELECT * FROM reports WHERE category = '${category}' AND data LIKE '%${filter}%'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Survey response collection vulnerability",
  "Lab Description": "A survey system collects responses using unsanitized input, enabling attackers to inject SQL commands that can leak or modify survey data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE survey (id INTEGER PRIMARY KEY, question TEXT, response TEXT)\");\n  db.run(\"INSERT INTO survey (question, response) VALUES ('Satisfaction', 'Good')\");\n});\n\napp.post('/submitSurvey', (req, res) => {\n  const question = req.body.question;\n  const response = req.body.response;\n  const query = `INSERT INTO survey (question, response) VALUES ('${question}', '${response}')`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Survey submitted');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Social network friend search injection",
  "Lab Description": "A social network search feature for friends uses unsanitized input, allowing an attacker to inject SQL and retrieve the complete user list including hidden friends.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\n\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, hidden INTEGER)\");\n  db.run(\"INSERT INTO users (name, hidden) VALUES ('Bob', 0)\");\n  db.run(\"INSERT INTO users (name, hidden) VALUES ('Eve', 1)\");\n});\n\napp.get('/searchFriends', (req, res) => {\n  const keyword = req.query.keyword;\n  const query = `SELECT * FROM users WHERE name LIKE '%${keyword}%'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "E-commerce product filtering injection",
  "Lab Description": "An e-commerce site uses unsanitized filters for product search. An attacker can inject SQL to bypass filtering and retrieve all product data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE products (id INTEGER PRIMARY KEY, name TEXT, price REAL)\");\n  db.run(\"INSERT INTO products (name, price) VALUES ('Camera', 299)\");\n});\n\napp.get('/filterProducts', (req, res) => {\n  const filter = req.query.filter;\n  const query = `SELECT * FROM products WHERE name LIKE '%${filter}%'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Admin dashboard modification via injection",
  "Lab Description": "An admin dashboard allows modifications to site settings. Unsanitized inputs in the SQL query enable attackers to inject SQL and alter configuration data.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE settings (id INTEGER PRIMARY KEY, key TEXT, value TEXT)\");\n  db.run(\"INSERT INTO settings (key, value) VALUES ('site_mode', 'production')\");\n});\n\napp.post('/updateSettings', (req, res) => {\n  const key = req.body.key;\n  const value = req.body.value;\n  const query = `UPDATE settings SET value = '${value}' WHERE key = '${key}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Settings updated');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Hotel booking reservation unsanitized room type",
  "Lab Description": "A hotel booking system allows users to select a room type. The unsanitized room type parameter lets attackers inject SQL to book any room regardless of availability.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE bookings (id INTEGER PRIMARY KEY, room_type TEXT, booked INTEGER)\");\n  db.run(\"INSERT INTO bookings (room_type, booked) VALUES ('Deluxe', 0)\");\n});\n\napp.post('/bookRoom', (req, res) => {\n  const roomType = req.body.roomType;\n  const query = `UPDATE bookings SET booked = 1 WHERE room_type = '${roomType}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Room booked');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Login tracking vulnerability with unsanitized logging",
  "Lab Description": "A system that logs every login attempt concatenates user input directly into SQL logs. Attackers can inject SQL to alter log entries and hide their activity.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE login_logs (id INTEGER PRIMARY KEY, username TEXT, status TEXT)\");\n});\n\napp.post('/loginLog', (req, res) => {\n  const username = req.body.username;\n  const status = req.body.status; // Unsanitized\n  const query = `INSERT INTO login_logs (username, status) VALUES ('${username}', '${status}')`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Log entry created');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Analytics endpoint vulnerability exposing sensitive data",
  "Lab Description": "An analytics endpoint constructs SQL queries based on unsanitized parameters. Attackers can inject SQL to retrieve all analytic data, including confidential metrics.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE analytics (id INTEGER PRIMARY KEY, metric TEXT, value REAL)\");\n  db.run(\"INSERT INTO analytics (metric, value) VALUES ('Revenue', 5000)\");\n});\n\napp.post('/analytics', (req, res) => {\n  const metric = req.body.metric;\n  const query = `SELECT * FROM analytics WHERE metric = '${metric}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "News article management injection for unauthorized edits",
  "Lab Description": "A news CMS allows editors to update articles. Unsanitized input in the update query enables attackers to modify articles not assigned to them.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE articles (id INTEGER PRIMARY KEY, title TEXT, content TEXT)\");\n  db.run(\"INSERT INTO articles (title, content) VALUES ('Breaking News', 'Details here')\");\n});\n\napp.post('/updateArticle', (req, res) => {\n  const title = req.body.title;\n  const content = req.body.content;\n  const query = `UPDATE articles SET content = '${content}' WHERE title = '${title}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Article updated');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "User comments moderation tool injection",
  "Lab Description": "A moderation tool for user comments fails to sanitize input, enabling attackers to inject SQL and manipulate the comments displayed.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.urlencoded({ extended: true }));\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE comments (id INTEGER PRIMARY KEY, comment TEXT)\");\n  db.run(\"INSERT INTO comments (comment) VALUES ('Great article!')\");\n});\n\napp.post('/moderate', (req, res) => {\n  const comment = req.body.comment;\n  const query = `UPDATE comments SET comment = '${comment}' WHERE id = 1`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Comment updated');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Bulk user import vulnerability via CSV injection",
  "Lab Description": "This lab simulates a bulk user import process where CSV data is processed without sanitization, allowing an attacker to inject additional SQL commands during the import process.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.text());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, email TEXT)\");\n});\n\napp.post('/importCSV', (req, res) => {\n  const lines = req.body.split('\\n');\n  lines.forEach(line => {\n    const [name, email] = line.split(\",\");\n    const query = `INSERT INTO users (name, email) VALUES ('${name}', '${email}')`;\n    console.log('Executing query:', query);\n    db.run(query);\n  });\n  res.send('Bulk import completed');\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Payment processing order cancellation injection",
  "Lab Description": "A payment processing system allows cancellation of orders using an unsanitized order ID. Attackers can inject SQL to cancel orders they should not be able to cancel.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE orders (id INTEGER PRIMARY KEY, status TEXT)\");\n  db.run(\"INSERT INTO orders (status) VALUES ('active')\");\n});\n\napp.post('/cancelOrder', (req, res) => {\n  const orderId = req.body.orderId;\n  const query = `UPDATE orders SET status = 'cancelled' WHERE id = '${orderId}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Order cancelled');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Library database search injection",
  "Lab Description": "A library database search system constructs SQL queries from user-provided keywords. Attackers can inject SQL to retrieve all book records, including restricted ones.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE books (id INTEGER PRIMARY KEY, title TEXT, author TEXT)\");\n  db.run(\"INSERT INTO books (title, author) VALUES ('Secret Book', 'Unknown')\");\n});\n\napp.get('/searchBooks', (req, res) => {\n  const keyword = req.query.keyword;\n  const query = `SELECT * FROM books WHERE title LIKE '%${keyword}%'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Real-time chat message retrieval injection",
  "Lab Description": "A chat application retrieves messages based on a conversation ID passed via query parameters. Unsanitized input enables attackers to inject SQL to retrieve messages from other conversations.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE messages (id INTEGER PRIMARY KEY, conversationId TEXT, message TEXT)\");\n  db.run(\"INSERT INTO messages (conversationId, message) VALUES ('conv1', 'Hello')\");\n});\n\napp.get('/getMessages', (req, res) => {\n  const convId = req.query.convId;\n  const query = `SELECT * FROM messages WHERE conversationId = '${convId}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Vendor details retrieval with unsanitized input",
  "Lab Description": "A vendor management system retrieves vendor details based on an ID provided via POST data. The unsanitized input allows attackers to inject SQL and retrieve details of all vendors.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE vendors (id INTEGER PRIMARY KEY, name TEXT, email TEXT)\");\n  db.run(\"INSERT INTO vendors (name, email) VALUES ('VendorA', 'contact@vendora.com')\");\n});\n\napp.post('/getVendor', (req, res) => {\n  const vendorId = req.body.vendorId;\n  const query = `SELECT * FROM vendors WHERE id = '${vendorId}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "IoT device configuration retrieval injection",
  "Lab Description": "This lab simulates an IoT backend where device configuration data is retrieved based on an unsanitized device ID. An attacker can inject SQL to access configurations of other devices.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE devices (id INTEGER PRIMARY KEY, config TEXT)\");\n  db.run(\"INSERT INTO devices (config) VALUES ('Device1Config')\");\n});\n\napp.post('/getConfig', (req, res) => {\n  const deviceId = req.body.deviceId;\n  const query = `SELECT config FROM devices WHERE id = '${deviceId}'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send(row ? row.config : 'No config found');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Academic portal grade retrieval injection",
  "Lab Description": "This lab simulates an academic portal that retrieves student grades based on user input. Unsanitized input allows attackers to inject SQL to view grades for all students.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE grades (id INTEGER PRIMARY KEY, student TEXT, grade TEXT)\");\n  db.run(\"INSERT INTO grades (student, grade) VALUES ('John Doe', 'A')\");\n});\n\napp.post('/getGrades', (req, res) => {\n  const student = req.body.student;\n  const query = `SELECT * FROM grades WHERE student = '${student}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Event feedback injection for vote manipulation",
  "Lab Description": "This lab simulates an event feedback system where users submit votes via a feedback form. Unsanitized input allows attackers to inject SQL to manipulate vote counts.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE feedback (id INTEGER PRIMARY KEY, event TEXT, votes INTEGER)\");\n  db.run(\"INSERT INTO feedback (event, votes) VALUES ('Conference', 10)\");\n});\n\napp.post('/submitFeedback', (req, res) => {\n  const event = req.body.event;\n  const votes = req.body.votes;\n  const query = `UPDATE feedback SET votes = votes + ${votes} WHERE event = '${event}'`;\n  console.log('Executing query:', query);\n  db.run(query, (err) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send('Feedback updated');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "SMS gateway message log retrieval injection",
  "Lab Description": "This lab simulates an SMS gateway where message logs are stored in a database. Unsanitized input in the log retrieval query allows attackers to extract all SMS logs.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE sms_logs (id INTEGER PRIMARY KEY, sender TEXT, message TEXT)\");\n  db.run(\"INSERT INTO sms_logs (sender, message) VALUES ('12345', 'Hello World')\");\n});\n\napp.post('/getSMSLogs', (req, res) => {\n  const sender = req.body.sender;\n  const query = `SELECT * FROM sms_logs WHERE sender = '${sender}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Banking app account balance inquiry injection",
  "Lab Description": "This lab simulates a banking application where the account balance is retrieved based on user-provided account numbers. Unsanitized input allows attackers to inject SQL and retrieve balances of any account.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Hard",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE accounts (id INTEGER PRIMARY KEY, accountNumber TEXT, balance REAL)\");\n  db.run(\"INSERT INTO accounts (accountNumber, balance) VALUES ('ACC123', 2500.00)\");\n});\n\napp.post('/getBalance', (req, res) => {\n  const account = req.body.accountNumber;\n  const query = `SELECT balance FROM accounts WHERE accountNumber = '${account}'`;\n  console.log('Executing query:', query);\n  db.get(query, [], (err, row) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.send(row ? row.balance.toString() : 'No account found');\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Retail store inventory lookup injection",
  "Lab Description": "This lab simulates a retail store inventory lookup where product information is retrieved via a GET request. Unsanitized product input allows attackers to inject SQL and view inventory for all products.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Medium",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\n\nconst app = express();\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE inventory (id INTEGER PRIMARY KEY, product TEXT, stock INTEGER)\");\n  db.run(\"INSERT INTO inventory (product, stock) VALUES ('Printer', 10)\");\n});\n\napp.get('/inventory', (req, res) => {\n  const product = req.query.product;\n  const query = `SELECT * FROM inventory WHERE product = '${product}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
},
{
  "Lab scenario": "Customer loyalty program authentication injection",
  "Lab Description": "This lab simulates an authentication system for a customer loyalty program that uses unsanitized input in the SQL query. Attackers can inject SQL to bypass authentication and view loyalty points.",
  "Vulnerability name": "SQL Injection",
  "lab level": "Easy",
  "src code": "const express = require('express');\nconst sqlite3 = require('sqlite3').verbose();\nconst bodyParser = require('body-parser');\n\nconst app = express();\napp.use(bodyParser.json());\n\nconst db = new sqlite3.Database(':memory:');\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE loyalty (id INTEGER PRIMARY KEY, username TEXT, points INTEGER)\");\n  db.run(\"INSERT INTO loyalty (username, points) VALUES ('user1', 100)\");\n});\n\napp.post('/checkLoyalty', (req, res) => {\n  const username = req.body.username;\n  const query = `SELECT * FROM loyalty WHERE username = '${username}'`;\n  console.log('Executing query:', query);\n  db.all(query, [], (err, rows) => {\n    if (err) res.status(500).send('Error occurred');\n    else res.json(rows);\n  });\n});\n\napp.listen(3000, () => console.log('Server running on http://localhost:3000'));"
}
]