[
    {
        "Lab scenario": "Web shell upload via race condition",
        "Lab Description": "This lab contains a vulnerable image upload function. Although it performs robust validation on any files that are uploaded, it is possible to bypass this validation entirely by exploiting a race condition in the way it processes them.\nTo solve the lab, upload a basic PHP web shell, then use it to exfiltrate the contents of the file /home/carlos/secret. Submit this secret using the button provided in the lab banner.\nYou can log in to your own account using the following credentials: wiener:peter",
        "Vulnerability name": "File upload vulnerabilities"
    },
    {
        "Lab scenario": "Remote code execution via web shell upload",
        "Lab Description": "This lab contains a vulnerable image upload function. It doesn't perform any validation on the files users upload before storing them on the server's filesystem.\nTo solve the lab, upload a basic PHP web shell and use it to exfiltrate the contents of the file /home/carlos/secret. Submit this secret using the button provided in the lab banner.\nYou can log in to your own account using the following credentials: wiener:peter",
        "Vulnerability name": "File upload vulnerabilities"
    },
    {
        "this lab not tested":"##################################",
        "Lab scenario": "Web shell upload via Content-Type restriction bypass",
        "Lab Description": "This lab contains a vulnerable image upload function. It attempts to prevent users from uploading unexpected file types, but relies on checking user-controllable input to verify this.\nTo solve the lab, upload a basic PHP web shell and use it to exfiltrate the contents of the file /home/carlos/secret. Submit this secret using the button provided in the lab banner.\nYou can log in to your own account using the following credentials: wiener:peter",
        "Vulnerability name": "File upload vulnerabilities",
         "src code": "const express = require('express');\nconst session = require('express-session');\nconst multer = require('multer');\nconst path = require('path');\nconst fs = require('fs');\nconst { exec } = require('child_process');\n\nconst app = express();\nconst port = 3000;\n\n// Configure session\napp.use(session({\n    secret: 'supersecretkey',\n    resave: false,\n    saveUninitialized: true\n}));\n\n// Parse URL-encoded bodies (for login)\napp.use(express.urlencoded({ extended: true }));\n\n// Setup multer for file uploads (store files in the uploads folder)\nconst uploadDir = path.join(__dirname, 'uploads');\nif (!fs.existsSync(uploadDir)) {\n    fs.mkdirSync(uploadDir);\n}\nconst storage = multer.diskStorage({\n    destination: (req, file, cb) => cb(null, uploadDir),\n    filename: (req, file, cb) => cb(null, file.originalname)\n});\nconst upload = multer({ storage: storage });\n\n// Home / Login route\napp.get('/', (req, res) => {\n    if (!req.session.loggedIn) {\n        res.send(`\n            <h2>Login</h2>\n            <form method=\"POST\" action=\"/login\">\n                <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n                <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n                <button type=\"submit\">Login</button>\n            </form>\n        `);\n    } else {\n        res.redirect('/upload');\n    }\n});\n\n// Login route\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    if (username === 'wiener' && password === 'peter') {\n        req.session.loggedIn = true;\n        res.redirect('/upload');\n    } else {\n        res.send('Invalid credentials.');\n    }\n});\n\n// Upload page\napp.get('/upload', (req, res) => {\n    if (!req.session.loggedIn) return res.redirect('/');\n    res.send(`\n        <h2>Upload File</h2>\n        <form method=\"POST\" action=\"/upload\" enctype=\"multipart/form-data\">\n            <input type=\"file\" name=\"file\" required />\n            <button type=\"submit\">Upload</button>\n        </form>\n        <p>Note: This upload function checks only the MIME type provided by the client. It accepts files only if the MIME type is exactly \"image/png\". Since the MIME type is userâ€‘controllable, an attacker can bypass this check and upload a PHP web shell.</p>\n    `);\n});\n\n// Handle file upload with vulnerable Content-Type check\napp.post('/upload', upload.single('file'), (req, res) => {\n    if (!req.session.loggedIn) return res.redirect('/');\n    if (req.file.mimetype !== 'image/png') {\n         return res.send('File type not allowed.');\n    }\n    res.send(`\n       File uploaded successfully as ${req.file.originalname}.<br>\n       <a href=\"/uploads/${encodeURIComponent(req.file.originalname)}\">Access Uploaded File</a><br>\n       <a href=\"/exec?file=${encodeURIComponent(req.file.originalname)}&cmd=cat%20secret.txt\">Execute Shell</a>\n    `);\n});\n\n// Serve static files from the uploads directory\napp.use('/uploads', express.static(uploadDir));\n\n// Vulnerable execution endpoint\napp.get('/exec', (req, res) => {\n    if (!req.session.loggedIn) return res.redirect('/');\n    const file = req.query.file;\n    const cmd = req.query.cmd || '';\n    if (!file) return res.send('Missing file parameter.');\n    const filePath = path.join(uploadDir, file);\n    if (!fs.existsSync(filePath)) return res.send('File not found.');\n    \n    if (file.toLowerCase().includes('.php')) {\n         const phpPath = 'C:\\\\php-8.4.4-nts-Win32-vs17-x64\\\\php.exe';\n         const command = `\"${phpPath}\" \"${filePath}\" \"${cmd}\"`;\n         exec(command, (error, stdout, stderr) => {\n              if (error) {\n                   return res.send(`Error executing shell: ${error.message}`);\n              }\n              res.send(`<pre>${stdout || stderr}</pre>`);\n         });\n    } else {\n         res.send('Uploaded file is not a PHP shell.');\n    }\n});\n\n// Secret endpoint\napp.get('/secret', (req, res) => {\n    const secretFile = path.join(__dirname, 'secret.txt');\n    if (!fs.existsSync(secretFile)) {\n        fs.writeFileSync(secretFile, 'SuperSecretData123', 'utf8');\n    }\n    const secret = fs.readFileSync(secretFile, 'utf8');\n    res.send(`<pre>${secret}</pre>`);\n});\n\napp.listen(port, () => {\n    console.log(`Server running on http://localhost:${port}`);\n});",
         "lab level": "Medium"
    },
    {
        "this lab not tested":"##################################",
        "Lab scenario": "Web shell upload via path traversal",
        "Lab Description": "This lab contains a vulnerable image upload function. The server is configured to prevent execution of user-supplied files, but this restriction can be bypassed by exploiting a secondary vulnerability.\nTo solve the lab, upload a basic PHP web shell and use it to exfiltrate the contents of the file /home/carlos/secret. Submit this secret using the button provided in the lab banner.\nYou can log in to your own account using the following credentials: wiener:peter",
        "Vulnerability name": "File upload vulnerabilities",
         "src code": "const express = require('express');\nconst session = require('express-session');\nconst multer = require('multer');\nconst path = require('path');\nconst fs = require('fs');\nconst { exec } = require('child_process');\n\nconst app = express();\nconst port = 3000;\n\n// Define the safe directory (where files are normally executed)\nconst safeDir = path.join(__dirname, 'safe');\nif (!fs.existsSync(safeDir)) {\n    fs.mkdirSync(safeDir);\n}\n\n// Configure session\napp.use(session({\n    secret: 'supersecretkey',\n    resave: false,\n    saveUninitialized: true\n}));\n\n// Parse URL-encoded bodies (for login form)\napp.use(express.urlencoded({ extended: true }));\n\n// Setup multer for file uploads (store files in the uploads folder)\nconst uploadDir = path.join(__dirname, 'uploads');\nif (!fs.existsSync(uploadDir)) {\n    fs.mkdirSync(uploadDir);\n}\nconst storage = multer.diskStorage({\n    destination: function(req, file, cb) {\n        cb(null, uploadDir);\n    },\n    filename: function(req, file, cb) {\n        cb(null, file.originalname);\n    }\n});\nconst upload = multer({ storage: storage });\n\n// Home / Login route\napp.get('/', (req, res) => {\n    if (!req.session.loggedIn) {\n        res.send(`\n            <h2>Login</h2>\n            <form method=\"POST\" action=\"/login\">\n                <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n                <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n                <button type=\"submit\">Login</button>\n            </form>\n        `);\n    } else {\n        res.redirect('/upload');\n    }\n});\n\n// Login route\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    if (username === 'wiener' && password === 'peter') {\n        req.session.loggedIn = true;\n        res.redirect('/upload');\n    } else {\n        res.send('Invalid credentials.');\n    }\n});\n\n// Upload page\napp.get('/upload', (req, res) => {\n    if (!req.session.loggedIn) return res.redirect('/');\n    res.send(`\n        <h2>Upload File</h2>\n        <form method=\"POST\" action=\"/upload\" enctype=\"multipart/form-data\">\n            <input type=\"file\" name=\"file\" required />\n            <button type=\"submit\">Upload</button>\n        </form>\n        <p>Note: The upload function blacklists dangerous file extensions based only on the last extension. This defense can be bypassed (for example, by renaming a PHP shell to shell.php.jpg). The server is configured to execute files only from a safe directory, but a path traversal vulnerability in the execution endpoint allows execution of files from other directories.</p>\n    `);\n});\n\n// Handle file upload\napp.post('/upload', upload.single('file'), (req, res) => {\n    if (!req.session.loggedIn) return res.redirect('/');\n    const filename = req.file.originalname;\n    // Blacklist check: reject files whose last extension is dangerous\n    const dangerousExtensions = ['phtml', 'php3', 'php4', 'php5', 'phps'];\n    let ext = path.extname(filename).toLowerCase().slice(1);\n    if (dangerousExtensions.includes(ext)) {\n        return res.send('File type not allowed.');\n    }\n    res.send(`File uploaded successfully as ${filename}.<br>\n        <a href=\"/uploads/${encodeURIComponent(filename)}\">Access Uploaded File</a><br>\n        <a href=\"/exec?file=${encodeURIComponent(filename)}&cmd=type%20secret.txt\">Execute Shell</a>\n    `);\n});\n\n// Serve static files from the uploads directory\napp.use('/uploads', express.static(uploadDir));\n\n// Vulnerable execution endpoint (with path traversal)\n// This endpoint copies the uploaded file into the safe directory with a .php extension and executes it using the PHP interpreter.\napp.get('/exec', (req, res) => {\n    if (!req.session.loggedIn) return res.redirect('/');\n    const fileParam = req.query.file; // e.g., shell.php.jpg or path traversal payload\n    const cmd = req.query.cmd || '';\n    if (!fileParam) return res.send('Missing file parameter.');\n\n    // Resolve the original file path in uploads\n    const filePath = path.join(uploadDir, fileParam);\n    if (!fs.existsSync(filePath)) return res.send('File not found.');\n\n    // Copy the file into the safe directory as shell_temp.php\n    const safeFilePath = path.join(safeDir, 'shell_temp.php');\n    try {\n        fs.copyFileSync(filePath, safeFilePath);\n    } catch (err) {\n        return res.send('Error copying file to safe directory: ' + err.toString());\n    }\n\n    // Define full path to php.exe (adjust if necessary)\n    const phpPath = 'C:\\php-8.4.4-nts-Win32-vs17-x64\\php.exe';\n    const command = `\"${phpPath}\" \"${safeFilePath}\" \"${cmd}\"`;\n    exec(command, (error, stdout, stderr) => {\n        if (error) {\n            return res.send(`Error executing shell: ${error.message}`);\n        }\n        res.send(`<pre>${stdout || stderr}</pre>`);\n    });\n});\n\n// Secret endpoint (simulates /home/carlos/secret)\napp.get('/secret', (req, res) => {\n    const secretFile = path.join(__dirname, 'secret.txt');\n    if (!fs.existsSync(secretFile)) {\n        fs.writeFileSync(secretFile, 'SuperSecretData123', 'utf8');\n    }\n    const secret = fs.readFileSync(secretFile, 'utf8');\n    res.send(`<pre>${secret}</pre>`);\n});\n\napp.listen(port, () => {\n    console.log(`Server running on http://localhost:${port}`);\n});",
        "lab level": "Medium"
    },
    {
        "Lab scenario": "Web shell upload via extension blacklist bypass",
        "Lab Description": "This lab contains a vulnerable image upload function. Certain file extensions are blacklisted, but this defense can be bypassed due to a fundamental flaw in the configuration of this blacklist.\nTo solve the lab, upload a basic PHP web shell, then use it to exfiltrate the contents of the file /home/carlos/secret. Submit this secret using the button provided in the lab banner.\nYou can log in to your own account using the following credentials: wiener:peter",
        "Vulnerability name": "File upload vulnerabilities",
         "src code": "const express = require('express');\nconst session = require('express-session');\nconst multer = require('multer');\nconst path = require('path');\nconst fs = require('fs');\n\nconst app = express();\nconst port = 3000;\n\n// Session setup\napp.use(session({\n    secret: 'supersecretkey',\n    resave: false,\n    saveUninitialized: true\n}));\n\n// Parse URL-encoded bodies (for login form)\napp.use(express.urlencoded({ extended: true }));\n\n// Setup multer for file uploads\nconst uploadDir = path.join(__dirname, 'uploads');\nif (!fs.existsSync(uploadDir)) {\n    fs.mkdirSync(uploadDir);\n}\nconst storage = multer.diskStorage({\n    destination: function(req, file, cb) {\n        cb(null, uploadDir);\n    },\n    filename: function(req, file, cb) {\n        cb(null, file.originalname);\n    }\n});\nconst upload = multer({ storage: storage });\n\n// Home/Login route\napp.get('/', (req, res) => {\n    if (!req.session.loggedIn) {\n        res.send(`\n            <h2>Login</h2>\n            <form method=\"POST\" action=\"/login\">\n                <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n                <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n                <button type=\"submit\">Login</button>\n            </form>\n        `);\n    } else {\n        res.redirect('/upload');\n    }\n});\n\n// Login route\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    if (username === 'wiener' && password === 'peter') {\n        req.session.loggedIn = true;\n        res.redirect('/upload');\n    } else {\n        res.send('Invalid credentials.');\n    }\n});\n\n// Upload page\napp.get('/upload', (req, res) => {\n    if (!req.session.loggedIn) return res.redirect('/');\n    res.send(`\n        <h2>Upload File</h2>\n        <form method=\"POST\" action=\"/upload\" enctype=\"multipart/form-data\">\n            <input type=\"file\" name=\"file\" required />\n            <button type=\"submit\">Upload</button>\n        </form>\n        <p>Note: This upload function blacklists dangerous file extensions based only on the last extension. This defense can be bypassed (for example, by renaming a dangerous file to shell.js.jpg and then renaming it to a .js file upon execution). In this lab, upload a JavaScript web shell.</p>\n    `);\n});\n\n// Handle file upload\napp.post('/upload', upload.single('file'), (req, res) => {\n    if (!req.session.loggedIn) return res.redirect('/');\n    const filename = req.file.originalname;\n    // Blacklist check: reject files with these dangerous extensions (based on the last extension)\n    const dangerousExtensions = ['php', 'phtml', 'php3', 'php4', 'php5', 'phps'];\n    let ext = path.extname(filename).toLowerCase().slice(1);\n    if (dangerousExtensions.includes(ext)) {\n        return res.send('File type not allowed.');\n    }\n    res.send(`File uploaded successfully as ${filename}.<br>\n        <a href=\"/uploads/${encodeURIComponent(filename)}\">Access Uploaded File</a><br>\n        <a href=\"/exec?file=${encodeURIComponent(filename)}&cmd=read\">Execute Shell</a>\n    `);\n});\n\n// Serve static files from the uploads directory\napp.use('/uploads', express.static(uploadDir));\n\n// Vulnerable execution endpoint (JS Shell Only)\napp.get('/exec', (req, res) => {\n    if (!req.session.loggedIn) return res.redirect('/');\n    const file = req.query.file;\n    const cmd = req.query.cmd || '';\n    if (!file) return res.send('Missing file parameter.');\n    const filePath = path.join(uploadDir, file);\n    if (!fs.existsSync(filePath)) return res.send('File not found.');\n    \n    // Only support JavaScript shell files\n    if (path.extname(file).toLowerCase() !== '.js') {\n        return res.send('Unsupported shell file type. Only JavaScript shells are supported.');\n    }\n    \n    try {\n        // Clear Node's require cache so we can re-run the uploaded shell file\n        delete require.cache[require.resolve(filePath)];\n        const shell = require(filePath);\n        if (typeof shell !== 'function') return res.send('Uploaded JS shell is invalid.');\n        // Call the shell function with the provided command\n        shell(cmd, (output) => {\n            res.send(`<pre>${output}</pre>`);\n        });\n    } catch (err) {\n        res.send('Error executing JS shell: ' + err.toString());\n    }\n});\n\n// Secret endpoint: simulates the secret file located at /home/carlos/secret\napp.get('/secret', (req, res) => {\n    const secretFile = path.join(__dirname, 'secret.txt');\n    if (!fs.existsSync(secretFile)) {\n        fs.writeFileSync(secretFile, 'SuperSecretData123', 'utf8');\n    }\n    const secret = fs.readFileSync(secretFile, 'utf8');\n    res.send(`<pre>${secret}</pre>`);\n});\n\napp.listen(port, () => {\n    console.log(`Server running on http://localhost:${port}`);\n});",
        "lab level": "Medium"
    },
    {
        "Lab scenario": "Web shell upload via obfuscated file extension",
        "Lab Description": "This lab contains a vulnerable image upload function. Certain file extensions are blacklisted, but this defense can be bypassed using a classic obfuscation technique.\nTo solve the lab, upload a basic PHP web shell, then use it to exfiltrate the contents of the file /home/carlos/secret. Submit this secret using the button provided in the lab banner.\nYou can log in to your own account using the following credentials: wiener:peter",
        "Vulnerability name": "File upload vulnerabilities",
        "src code": "const express = require('express');\nconst session = require('express-session');\nconst multer = require('multer');\nconst path = require('path');\nconst fs = require('fs');\n\nconst app = express();\nconst port = 3000;\n\n// Session setup\napp.use(session({\n    secret: 'supersecretkey',\n    resave: false,\n    saveUninitialized: true\n}));\n\n// Parse URL-encoded bodies (for login form)\napp.use(express.urlencoded({ extended: true }));\n\n// Setup multer for file uploads\nconst uploadDir = path.join(__dirname, 'uploads');\nif (!fs.existsSync(uploadDir)) {\n    fs.mkdirSync(uploadDir);\n}\nconst storage = multer.diskStorage({\n    destination: function(req, file, cb) {\n        cb(null, uploadDir);\n    },\n    filename: function(req, file, cb) {\n        cb(null, file.originalname);\n    }\n});\nconst upload = multer({ storage: storage });\n\n// Home/Login route\napp.get('/', (req, res) => {\n    if (!req.session.loggedIn) {\n        res.send(`\n            <h2>Login</h2>\n            <form method=\"POST\" action=\"/login\">\n                <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n                <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n                <button type=\"submit\">Login</button>\n            </form>\n        `);\n    } else {\n        res.redirect('/upload');\n    }\n});\n\n// Login route\napp.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    if (username === 'wiener' && password === 'peter') {\n        req.session.loggedIn = true;\n        res.redirect('/upload');\n    } else {\n        res.send('Invalid credentials.');\n    }\n});\n\n// Upload page\napp.get('/upload', (req, res) => {\n    if (!req.session.loggedIn) return res.redirect('/');\n    res.send(`\n        <h2>Upload File</h2>\n        <form method=\"POST\" action=\"/upload\" enctype=\"multipart/form-data\">\n            <input type=\"file\" name=\"file\" required />\n            <button type=\"submit\">Upload</button>\n        </form>\n        <p>Note: This upload function blacklists dangerous file extensions, but can be bypassed using obfuscation techniques.</p>\n    `);\n});\n\n// Handle file upload\napp.post('/upload', upload.single('file'), (req, res) => {\n    if (!req.session.loggedIn) return res.redirect('/');\n    const filename = req.file.originalname;\n    // Blacklist check: reject files with these dangerous extensions (based on the last extension)\n    const dangerousExtensions = ['php', 'phtml', 'php3', 'php4', 'php5', 'phps'];\n    let ext = path.extname(filename).toLowerCase().slice(1); // Remove the dot\n    if (dangerousExtensions.includes(ext)) {\n        return res.send('File type not allowed.');\n    }\n    res.send(`File uploaded successfully as ${filename}.<br>\n        <a href=\"/uploads/${encodeURIComponent(filename)}\">Access Uploaded File</a><br>\n        <a href=\"/exec?file=${encodeURIComponent(filename)}&cmd=read\">Execute Shell</a>\n    `);\n});\n\n// Serve static files from the uploads directory\napp.use('/uploads', express.static(uploadDir));\n\n// Vulnerable execution endpoint (JS Shell Only)\napp.get('/exec', (req, res) => {\n    if (!req.session.loggedIn) return res.redirect('/');\n    const file = req.query.file;\n    const cmd = req.query.cmd;\n    if (!file) return res.send('Missing file parameter.');\n    const filePath = path.join(uploadDir, file);\n    if (!fs.existsSync(filePath)) return res.send('File not found.');\n    \n    // Only support JavaScript shell files (ignore other types)\n    const ext = path.extname(file).toLowerCase();\n    if (ext !== '.js') {\n        return res.send('Unsupported shell file type. Only .js files are supported.');\n    }\n    \n    try {\n        // Clear Node's require cache so we can re-run the uploaded shell file\n        delete require.cache[require.resolve(filePath)];\n        const shell = require(filePath);\n        if (typeof shell !== 'function') return res.send('Uploaded JS shell is invalid.');\n        // Call the shell function with the provided command\n        shell(cmd, (output) => {\n            res.send(`<pre>${output}</pre>`);\n        });\n    } catch (err) {\n        res.send('Error executing JS shell: ' + err.toString());\n    }\n});\n\n// Secret endpoint: simulates the secret file located at /home/carlos/secret\napp.get('/secret', (req, res) => {\n    const secretFile = path.join(__dirname, 'secret.txt');\n    if (!fs.existsSync(secretFile)) {\n        fs.writeFileSync(secretFile, 'SuperSecretData123', 'utf8');\n    }\n    const secret = fs.readFileSync(secretFile, 'utf8');\n    res.send(`<pre>${secret}</pre>`);\n});\n\napp.listen(port, () => {\n    console.log(`Server running on http://localhost:${port}`);\n});",
  "lab level": "Medium"
    },
    {
        "Lab scenario": "Remote code execution via polyglot web shell upload",
        "Lab Description": "This lab contains a vulnerable image upload function. Although it checks the contents of the file to verify that it is a genuine image, it is still possible to upload and execute server-side code.\nTo solve the lab, upload a basic PHP web shell, then use it to exfiltrate the contents of the file /home/carlos/secret. Submit this secret using the button provided in the lab banner.\nYou can log in to your own account using the following credentials: wiener:peter",
        "Vulnerability name": "File upload vulnerabilities",
        "src code": "const express = require('express');\nconst session = require('express-session');\nconst multer = require('multer');\nconst path = require('path');\nconst fs = require('fs');\n\nconst app = express();\nconst port = 3000;\n\n// Session setup\napp.use(session({\n  secret: 'supersecretkey',\n  resave: false,\n  saveUninitialized: true\n}));\n\n// Parse URL-encoded bodies (for login form)\napp.use(express.urlencoded({ extended: true }));\n\n// Setup multer for file uploads\nconst uploadDir = path.join(__dirname, 'uploads');\nif (!fs.existsSync(uploadDir)) {\n  fs.mkdirSync(uploadDir);\n}\nconst storage = multer.diskStorage({\n  destination: function (req, file, cb) {\n    cb(null, uploadDir);\n  },\n  filename: function (req, file, cb) {\n    cb(null, file.originalname);\n  }\n});\nconst upload = multer({ storage: storage });\n\n// ----- ROUTES -----\n\n// Home / Login page\napp.get('/', (req, res) => {\n  if (!req.session.loggedIn) {\n    res.send(`\n      <h2>Login</h2>\n      <form method=\"POST\" action=\"/login\">\n        <input type=\"text\" name=\"username\" placeholder=\"Username\" required />\n        <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n        <button type=\"submit\">Login</button>\n      </form>\n    `);\n  } else {\n    res.redirect('/upload');\n  }\n});\n\n// Login route\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  // Credentials: wiener / peter\n  if (username === 'wiener' && password === 'peter') {\n    req.session.loggedIn = true;\n    res.redirect('/upload');\n  } else {\n    res.send('Invalid credentials.');\n  }\n});\n\n// Upload page (requires login)\napp.get('/upload', (req, res) => {\n  if (!req.session.loggedIn) return res.redirect('/');\n  res.send(`\n    <h2>Upload File</h2>\n    <form action=\"/upload\" method=\"POST\" enctype=\"multipart/form-data\">\n      <input type=\"file\" name=\"file\" required />\n      <button type=\"submit\">Upload</button>\n    </form>\n    <p>Note: Only image files (or .js files) are allowed. The check is very weak!</p>\n  `);\n});\n\n// Handle file upload\napp.post('/upload', upload.single('file'), (req, res) => {\n  if (!req.session.loggedIn) return res.redirect('/');\n  // Naively check file extension to simulate a weak image check.\n  const ext = path.extname(req.file.originalname).toLowerCase();\n  // Allow image types and .js (for our web shell)\n  if (!['.jpg', '.jpeg', '.png', '.gif', '.js'].includes(ext)) {\n    return res.send('File type not allowed.');\n  }\n  res.send(`File uploaded successfully as ${req.file.originalname}.<br>\n    <a href=\"/uploads/${req.file.originalname}\">Access Uploaded File</a>\n    <br><a href=\"/shell?file=${encodeURIComponent(req.file.originalname)}&cmd=read\">Execute Shell</a>\n  `);\n});\n\n// Serve static files from uploads directory\napp.use('/uploads', express.static(uploadDir));\n\n// Vulnerable shell execution endpoint\n// If a .js file is uploaded, we \"execute\" it by requiring it.\n// The uploaded shell must export a function that accepts a command and a callback.\napp.get('/shell', (req, res) => {\n  if (!req.session.loggedIn) return res.redirect('/');\n  const file = req.query.file;\n  const cmd = req.query.cmd;\n  if (!file || !cmd) return res.send('Missing file or cmd parameter.');\n  const filePath = path.join(uploadDir, file);\n  if (!fs.existsSync(filePath)) return res.send('Shell file not found.');\n  if (path.extname(file) !== '.js') return res.send('Invalid shell file.');\n\n  try {\n    // Clear Node's require cache so we can re-run our uploaded shell file\n    delete require.cache[require.resolve(filePath)];\n    const shell = require(filePath);\n    if (typeof shell !== 'function') return res.send('Uploaded shell is invalid.');\n    // Call the shell function with the command.\n    shell(cmd, (output) => {\n      res.send(`<pre>${output}</pre>`);\n    });\n  } catch (err) {\n    res.send('Error executing shell: ' + err.toString());\n  }\n});\n\n// Updated secret endpoint: Create a default secret.txt if it doesn't exist\napp.get('/secret', (req, res) => {\n  const secretFile = path.join(__dirname, 'secret.txt');\n  if (!fs.existsSync(secretFile)) {\n    // Create secret.txt with a default secret\n    fs.writeFileSync(secretFile, 'SuperSecretData123', 'utf8');\n  }\n  const secret = fs.readFileSync(secretFile, 'utf8');\n  res.send(`<pre>${secret}</pre>`);\n});\n\napp.listen(port, () => {\n  console.log(`Server running on http://localhost:${port}`);\n});",
        "lab level": "Medium"
    }
      
]